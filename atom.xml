<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鱼与前端🐟</title>
  
  <subtitle>摸鱼和工作不可得兼~</subtitle>
  <link href="https://zlinni.github.io/atom.xml" rel="self"/>
  
  <link href="https://zlinni.github.io/"/>
  <updated>2022-09-04T08:12:27.661Z</updated>
  <id>https://zlinni.github.io/</id>
  
  <author>
    <name>Zlinni</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自问自答八股文</title>
    <link href="https://zlinni.github.io/posts/4161554500/"/>
    <id>https://zlinni.github.io/posts/4161554500/</id>
    <published>2022-08-24T11:07:36.000Z</published>
    <updated>2022-09-04T08:12:27.661Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="js-有多少种数据类型"><a href="#js-有多少种数据类型" class="headerlink" title="js 有多少种数据类型"></a>js 有多少种数据类型</h2><p>7+1 USONB undefined string symbol object null number boolean bigint</p><h2 id="栈和堆的概念-什么是堆空间共享-如何改变引用地址"><a href="#栈和堆的概念-什么是堆空间共享-如何改变引用地址" class="headerlink" title="栈和堆的概念 什么是堆空间共享 如何改变引用地址"></a>栈和堆的概念 什么是堆空间共享 如何改变引用地址</h2><p>栈中存放基本数据类型，栈内的数据大小固定，体积较小，会被频繁使用，拷贝或者引用的时候会创建一份相同的复制</p><p>堆存放引用类型，堆内的数据大小不定，占据空间大。当一个引用类型被创建的时候，其属性会被放在堆空间中，指针放在栈中，当被引用的时候，先从栈找到对应的指针，指向堆空间的地址，获取属性。</p><p>堆空间共享指的是 多个引用指向同一个地址。</p><p>引用地址可以使用 bind call apply 去改变。</p><p>栈和堆的存在是为了维持 js 的内存平衡</p><h2 id="闭包是怎么存储的"><a href="#闭包是怎么存储的" class="headerlink" title="闭包是怎么存储的"></a>闭包是怎么存储的</h2><p>闭包被创建的时候，会创建一个 closure 对象到堆中，用于保存闭包中的变量，这就是为什么闭包可以常驻在内存的原因。且会导致内存泄漏。</p><h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><p>内存泄漏指的是堆内存中的变量由于某种原因无法及时释放造成系统资源的浪费，甚至导致系统崩溃。</p><p>怎么解决内存泄漏：<br>销毁闭包的变量，比如使用 clearTimeout 消除 settimeout 的 id 等</p><h2 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h2><p>闭包的本质是当前作用域中存在指向父级作用域的引用。</p><p>所以闭包并不一定表现为返回一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun3;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  fun3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br><span class="line">fun3();</span><br></pre></td></tr></table></figure><p>可以看出其中输出的结果还是 2 因为在给 fun3 赋值的时候，fun3 就可以访问到 window fun1 和本身的作用域，然后由下往上查找 找到了 fun1 中的 2 输出 2</p><h2 id="如何解决循环输出问题"><a href="#如何解决循环输出问题" class="headerlink" title="如何解决循环输出问题"></a>如何解决循环输出问题</h2><p>let IIFE 注入变量 定时器第三个参数传入变量</p><h2 id="undefined-和-null-的理解"><a href="#undefined-和-null-的理解" class="headerlink" title="undefined 和 null 的理解"></a>undefined 和 null 的理解</h2><p>undefined 和 null 一般用于对变量赋初始值。需要注意的是 undefined 在 js 中并不是一个保留字，所以 undefined 可以作为变量名，那么要如何获取安全的 undefined 呢？可以使用 void<br>null 代表空对象，但不是真的空对象</p><h2 id="什么是-BigInt-用途是什么-怎么实现一个-BigInt-的运算"><a href="#什么是-BigInt-用途是什么-怎么实现一个-BigInt-的运算" class="headerlink" title="什么是 BigInt 用途是什么 怎么实现一个 BigInt 的运算"></a>什么是 BigInt 用途是什么 怎么实现一个 BigInt 的运算</h2><p>js 只支持 2 的 53 次方的数字，大于这个范围会四舍五入，表现在最后一位数不对，BigInt 是数字+n 或者使用 BigInt 构造函数传入数字格式的字符串就可以生成。</p><p>注意 bigint 并不是 number 所以不等于 number 类型</p><p>bigint 可以用在比如发送请求之前将请求的数字包装成 bigint 类型发送，常用一些库函数。</p><p>bigint 之间的运算使用位运算</p><p>leetcode</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</span></span><br><span class="line"><span class="string">最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</span></span><br><span class="line"><span class="string">你可以假设除了整数 0 之外，这个整数不会以零开头。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">示例 1:</span></span><br><span class="line"><span class="string">输入: [1,2,3]</span></span><br><span class="line"><span class="string">输出: [1,2,4]</span></span><br><span class="line"><span class="string">解释: 输入数组表示数字 123。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">示例 2:</span></span><br><span class="line"><span class="string">输入: [4,3,2,1]</span></span><br><span class="line"><span class="string">输出: [4,3,2,2]</span></span><br><span class="line"><span class="string">解释: 输入数组表示数字 4321。`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plusOne = <span class="function">(<span class="params">digits</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">BigInt</span>(digits.join(<span class="string">&quot;&quot;</span>)) + <span class="number">1n</span>).toString().split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1+0.2!==0.3?"></a>0.1+0.2!==0.3?</h2><p>刚刚说了只支持到 2 的五十三次方，而由于小数计算机是识别不了的，要转二进制，所以 0.1 其实相当于一个无限循环的二进制数<code>0.0001100110011001100...</code>，而考虑到内存的原因，到某一位就被四舍五入了，导致结果计算出来不是 0.3 而是一个近似值。</p><p>解决方法：<br>使用 toFixed 或者变成整数再除以对应的倍数</p><h2 id="0-2-0-3-0-5？"><a href="#0-2-0-3-0-5？" class="headerlink" title="0.2+0.3===0.5？"></a>0.2+0.3===0.5？</h2><p>因为后面转二进制都是 0 所以刚好是 0.5</p><h2 id="那既然-0-1-不是-0-1-了，为什么在console-log-0-1-的时候还是-0-1-呢"><a href="#那既然-0-1-不是-0-1-了，为什么在console-log-0-1-的时候还是-0-1-呢" class="headerlink" title="那既然 0.1 不是 0.1 了，为什么在console.log(0.1)的时候还是 0.1 呢?"></a>那既然 0.1 不是 0.1 了，为什么在<code>console.log(0.1)</code>的时候还是 0.1 呢?</h2><p>在 console.log 的时候会二进制转换为十进制，十进制再会转为字符串的形式，在转换的过程中发生了取近似值，所以打印出来的是一个近似值的字符串</p><h2 id="js-有多少种判断数据的方式-分别是什么"><a href="#js-有多少种判断数据的方式-分别是什么" class="headerlink" title="js 有多少种判断数据的方式 分别是什么"></a>js 有多少种判断数据的方式 分别是什么</h2><p>4 typeof instanceof constructor Object.prototype.toStirng().call()</p><h2 id="为什么-typeof-null-是-object"><a href="#为什么-typeof-null-是-object" class="headerlink" title="为什么 typeof null 是 object"></a>为什么 typeof null 是 object</h2><p>typeof 的原理就是通过类型的地址判断，对于 null 和 object 来说，地址开头的前几位都是 0 所以判断相同</p><p>注意 typeof 是可以判断 function 的</p><h2 id="instanceof-的原理-为什么-instanceof-无法判断-null-和-undefined-手写-instanceof"><a href="#instanceof-的原理-为什么-instanceof-无法判断-null-和-undefined-手写-instanceof" class="headerlink" title="instanceof 的原理 为什么 instanceof 无法判断 null 和 undefined 手写 instanceof"></a>instanceof 的原理 为什么 instanceof 无法判断 null 和 undefined 手写 instanceof</h2><p>instanceof 是通过原型链判断的，相当于是在判断该变量是否是某个类的实例。</p><p>null 和 undefined 没有构造函数 也就是他没有对应的原型</p><p>手写 instanceof</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myInstanceof = <span class="function">(<span class="params">example, classFn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(example);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="built_in">Object</span>.getPrototypeOf(classFn)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototypeOf(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用-constructor-检测有什么缺点？"><a href="#使用-constructor-检测有什么缺点？" class="headerlink" title="使用 constructor 检测有什么缺点？"></a>使用 constructor 检测有什么缺点？</h2><p>constructor 是构造函数，会指向原型。使用 constructor 的时候，相当于判断该变量的构造函数是否指向对应的原型。</p><p>但由于原型是可以改变的，所以原型指向改变之后，原本的构造函数就会指向新的原型，所以会判断失误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Fn.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fn();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor === Fn); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Object-prototype-toString-call-为什么要用-prototype，为什么要用-call，以及他能判断什么类型，如何封装一个判断类型的函数"><a href="#Object-prototype-toString-call-为什么要用-prototype，为什么要用-call，以及他能判断什么类型，如何封装一个判断类型的函数" class="headerlink" title="Object.prototype.toString().call 为什么要用 prototype，为什么要用 call，以及他能判断什么类型，如何封装一个判断类型的函数"></a>Object.prototype.toString().call 为什么要用 prototype，为什么要用 call，以及他能判断什么类型，如何封装一个判断类型的函数</h2><p>类似于 Number，String,Array 上面都重写了 toString 方法.而它们最终指向的 Object 上有共同的方法，所以要使用 prototype 去找 Object 上的方法，使用 call 是为了改变 this 的指向。他能判断所有的类型，以及一些特殊的比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>); <span class="comment">//&quot;[object HTMLDocument]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>); <span class="comment">//&quot;[object Window]&quot;</span></span><br></pre></td></tr></table></figure><p>封装一个判断类型函数的思路就是，基本类型除了 null 使用 typeof 判断，非基本类型使用该方法判断</p><h2 id="对象是怎么转原始类型的，可以自己设置转换规则吗"><a href="#对象是怎么转原始类型的，可以自己设置转换规则吗" class="headerlink" title="对象是怎么转原始类型的，可以自己设置转换规则吗"></a>对象是怎么转原始类型的，可以自己设置转换规则吗</h2><p>对象中有 toPrimitive 方法，该方法优先级是 valueOf，到 toString，能转到原始类型就转</p><p>自己设置转换规则的话 使用<code>Symobol.toPrimitive</code>就可以自定义规则了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">toStirng</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>+a <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>常考：[1,2,3]转原始类型</p><h2 id="的隐式转换"><a href="#的隐式转换" class="headerlink" title="==的隐式转换"></a>==的隐式转换</h2><ol><li>其中一个是<code>null</code>或者<code>undefined</code> 另外一个也要是 否则为 false</li><li>其中一个是<code>string/number</code> 转 number</li><li>boolean 转 number</li><li>object 转原始 （注意！！！两个 obj 比较的是地址值）</li><li>NaN 和任何值都不相等 包括他自己</li></ol><p>常考</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意这里a又可以等于1、2、3</span></span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>常见坑:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小坑</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="literal">false</span> <span class="comment">// -&gt; true  这里false先被转为0，&quot;0&quot;也会转为0，所以为true</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="string">&quot;&quot;</span> <span class="comment">// -&gt; false 两个都是字符串类型，直接比较</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// -&gt; true 空字符串直接转为0</span></span><br><span class="line"><span class="literal">false</span> == [] <span class="comment">// -&gt; true false先转为0；[]空数组转为&#x27;&#x27;，之后ToNumber操作转为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大坑</span></span><br><span class="line">[] == ![] <span class="comment">// -&gt; true []  这里![]先被强制转换为false，变成[]与fasle的比较，之后fasle-&gt;0；[]-&gt;&#x27;&#x27;-&gt;0，所以为true。</span></span><br><span class="line"><span class="number">2</span>==[<span class="number">2</span>] <span class="comment">// -&gt; true [2]-&gt;&#x27;2&#x27;-&gt;2 所以为true</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span>==[<span class="literal">null</span>] <span class="comment">// true [null]-&gt;&#x27;&#x27;</span></span><br><span class="line"><span class="number">0</span>==<span class="string">&#x27;\n&#x27;</span> <span class="comment">// -&gt; true &#x27;\n&#x27;-&gt;&#x27;&#x27;-&gt;0</span></span><br><span class="line"><span class="string">&#x27;true&#x27;</span>==<span class="literal">true</span> <span class="comment">// -&gt; false true-&gt;0;&#x27;true&#x27;-&gt;NaN，所以为false</span></span><br></pre></td></tr></table></figure></p><h2 id="的隐式转换-1"><a href="#的隐式转换-1" class="headerlink" title="+的隐式转换"></a>+的隐式转换</h2><ol><li>其中一个是字符串，另外的是基本类型则转 string，引用类型转原始(存在优先级)</li><li>其中一个是数字，另外的是基本类型则转 number，引用类型转原始(存在优先级)</li><li>如果一个是字符串一个是数字则拼接</li></ol><h2 id="isNaN和Number-isNaN的区别"><a href="#isNaN和Number-isNaN的区别" class="headerlink" title="isNaN和Number.isNaN的区别"></a><code>isNaN</code>和<code>Number.isNaN</code>的区别</h2><p>前者是 ES6 之前的全局方法，判断的方式是先把传进来的内容使用 Number 进行转换，然后再判断是否为 NaN，后者更方便一点，首先判断传进来的内容是否为数值类型，非数值直接返回 NaN，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">true</span>); <span class="comment">// false 布尔值true会转为非0值</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">false</span>); <span class="comment">// false 布尔值false会转换成0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">null</span>); <span class="comment">// false  null会转为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// strings</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;37&quot;</span>); <span class="comment">// false: 可以被转换成数值37</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;37.37&quot;</span>); <span class="comment">// false: 可以被转换成数值37.37</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;37,5&quot;</span>); <span class="comment">// true &quot;37,5&quot;不能转换为数值</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;123ABC&quot;</span>); <span class="comment">// true：parseInt(&quot;123ABC&quot;) = 123, 但是Number(&quot;123ABC&quot;) = NaN</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// false: 空字符串被转换成0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot; &quot;</span>); <span class="comment">// false: 包含空格的字符串被转换成0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// false 会转换成当前的时间</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().toString()); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>([]); <span class="comment">// false []转换成0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="built_in">String</span>()); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="built_in">Array</span>()); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;Infinity&quot;</span>); <span class="comment">// false：&quot;Infinity&quot;转换为Infinity</span></span><br><span class="line"><span class="built_in">isNaN</span>(-<span class="number">0.1</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(x) == <span class="built_in">isNaN</span>(<span class="built_in">Number</span>(x)); <span class="comment">// 不论x为何值 都返回true 哪怕x = undefined</span></span><br><span class="line"><span class="comment">// 因为isNaN(undefined) = true 且 Number(undefined) = NaN 使得isNaN(NaN) = true</span></span><br><span class="line"><span class="built_in">isNaN</span>() == <span class="built_in">isNaN</span>(<span class="built_in">Number</span>()); <span class="comment">// false, because isNaN() = true and Number() = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下全部返回true</span></span><br><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;); <span class="comment">// 空对象执行toString方法 结果是&#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">String</span>); <span class="comment">//</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Array</span>); <span class="comment">//</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;blabla&quot;</span>); <span class="comment">// &quot;blabla&quot;不能转换成数值</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;-blabla&quot;</span>); <span class="comment">//</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">0</span> / <span class="number">0</span>); <span class="comment">//</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;0/0&quot;</span>); <span class="comment">// &quot;0/0&quot;不能转换成数字</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">Infinity</span> / <span class="literal">Infinity</span>); <span class="comment">//</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">//</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">undefined</span>); <span class="comment">//</span></span><br><span class="line"><span class="built_in">isNaN</span>();</span><br></pre></td></tr></table></figure><h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a><code>Object.is</code></h2><p>用法和<code>===</code>基本一致 不同在于</p><ol><li>0 和+0 是一样的 但是 0 和-0 是不一样的</li><li>NaN 与 NaN 为 true</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="number">0</span>, -<span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">0</span>, +<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="number">0</span> / <span class="number">0</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数为什么不能和-this-结合"><a href="#箭头函数为什么不能和-this-结合" class="headerlink" title="箭头函数为什么不能和 this 结合"></a>箭头函数为什么不能和 this 结合</h2><p>因为箭头函数的指向在定义函数的时候就已经指定好了，所以不能和 this 结合</p><p>因为 this 是固定的了，所以也不能去改变<br>比如使用 call/bind/apply<br>那么进一步说，new 也不能用在箭头函数实例化，因为 new 的原理其实也是把 this 指向给到新的实例</p><p>并且 也没有 arguments，(为什么) 但是可以访问别人的 arguments</p><h2 id="this-有多少种指向"><a href="#this-有多少种指向" class="headerlink" title="this 有多少种指向"></a>this 有多少种指向</h2><p>5 种</p><p>在浏览器中 全局范围的 this 指向 window(控制台)<br>在函数中 this 指向最后调用它的对象<br>在构造函数中指向实例<br><code>call/apply/bind</code>中指向被强绑定的对象<br>箭头函数，声明的时候就固定，是静态的</p><h2 id="call-apply-bind三者区别"><a href="#call-apply-bind三者区别" class="headerlink" title="call/apply/bind三者区别"></a><code>call/apply/bind</code>三者区别</h2><p>共同点 都能改变 this 指向<br>call 和 apply 区别在于传参，一个是字符串，一个是数组<br>bind 的话 会生成一个函数或者是生成一个新的对象(当传入 null)的时候</p><h2 id="三者手写"><a href="#三者手写" class="headerlink" title="三者手写"></a>三者手写</h2><h2 id="如何实现柯里化"><a href="#如何实现柯里化" class="headerlink" title="如何实现柯里化"></a>如何实现柯里化</h2><h2 id="如何给类数组添加-push-方法"><a href="#如何给类数组添加-push-方法" class="headerlink" title="如何给类数组添加 push 方法"></a>如何给类数组添加 push 方法</h2><p>其实就是用 bind 改变 push 方法的 this 指向 就可以了</p><h2 id="什么时候要使用到-bind"><a href="#什么时候要使用到-bind" class="headerlink" title="什么时候要使用到 bind"></a>什么时候要使用到 bind</h2><p>防止 this 指向到不正确的对象/永久绑定 this 指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">nickname</span>: <span class="string">&quot;jojo&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">eatWatermelon</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.nickname + <span class="string">&quot; 吃西瓜&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.eatWatermelon(); <span class="comment">//jojo吃西瓜</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eatWatermelon = person.eatWatermelon;</span><br><span class="line">eatWatermelon(); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>this 的指向变成了 eatWatermelon() 执行时所在作用域的 this。也就是 window，所以找不到</p><p>解决方法: 使用 bind 永久绑定 this 指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eatWatermelon = person.eatWatermelon.bind(person);</span><br><span class="line">eatWatermelon(); <span class="comment">//jojo吃西瓜</span></span><br></pre></td></tr></table></figure><p>预置函数参数<br>eg2 预置函数参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addSix = add.bind(<span class="literal">null</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">const</span> addSixThenAddFour = addSix.bind(<span class="literal">null</span>, <span class="number">4</span>);</span><br><span class="line">addSixThenAddFour(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line">addSixThenAddFour(<span class="number">7</span>);</span><br><span class="line"><span class="comment">// 17</span></span><br></pre></td></tr></table></figure><h2 id="什么是变量提升"><a href="#什么是变量提升" class="headerlink" title="什么是变量提升"></a>什么是变量提升</h2><p>var 声明变量的时候 var 变量会提升到作用域顶部为 undefined，然后在对应的位置重新赋值</p><p>这里还涉及函数提升 函数提升优于变量提升</p><p>常考的：在函数中输出函数的名字 误导性极强</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="string">&quot;jojo&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line">b(); <span class="comment">//jojo</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//[Function: b]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b = <span class="string">&quot;jojo&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line">b(); <span class="comment">//jojo</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//jojo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="keyword">var</span> b = <span class="string">&quot;jojo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">b(); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//[Function: b]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  b = <span class="string">&quot;jojo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">b(); <span class="comment">// [Function: b]</span></span><br><span class="line"><span class="built_in">console</span>.log(b)(</span><br><span class="line">  <span class="comment">// jojo</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// case5 这里涉及的是闭包的知识，闭包会将函数名存储进去，无法修改</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    b = <span class="string">&quot;jojo&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">//[Function: b]</span></span><br><span class="line">  &#125;</span><br><span class="line">)();</span><br></pre></td></tr></table></figure><h2 id="什么是暂时性死区"><a href="#什么是暂时性死区" class="headerlink" title="什么是暂时性死区"></a>什么是暂时性死区</h2><p>let const 声明的变量在声明前就被调用 产生暂时性死区 表现为 Reference Error</p><h2 id="js-执行环境有哪些"><a href="#js-执行环境有哪些" class="headerlink" title="js 执行环境有哪些"></a>js 执行环境有哪些</h2><p>全局执行环境和函数执行环境</p><h2 id="js-执行上下文有哪几种"><a href="#js-执行上下文有哪几种" class="headerlink" title="js 执行上下文有哪几种"></a>js 执行上下文有哪几种</h2><p>全局上下文 函数上下文 eval 上下文</p><h2 id="执行上下文中有哪些重要属性"><a href="#执行上下文中有哪些重要属性" class="headerlink" title="执行上下文中有哪些重要属性"></a>执行上下文中有哪些重要属性</h2><ul><li>变量对象（VO),包含变量，函数声明和函数的形参，该属性只能在全局上下文中访问。</li><li>作用域链，js 采用词法作用域链，也就是说变量的作用域是在定义的时候决定了。</li><li><code>this</code></li></ul><h2 id="js-代码执行的过程"><a href="#js-代码执行的过程" class="headerlink" title="js 代码执行的过程"></a>js 代码执行的过程</h2><ul><li>先创建全局执行上下文 global EC</li><li>全局执行上下文 caller 逐行 自上而下执行。遇到函数的时候，函数执行上下文 callee 会被 push 到执行栈顶层</li><li>执行上下文被激活后，成为 active EC 开始执行函数中的代码，caller 被挂起</li><li>函数执行完后 callee 被 pop 出执行栈 控制权还给 caller 继续执行</li></ul><h2 id="作用域和作用域链的理解"><a href="#作用域和作用域链的理解" class="headerlink" title="作用域和作用域链的理解"></a>作用域和作用域链的理解</h2><ul><li>作用域：作用域就是定义变量的区域，他有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找</li><li>作用域链：作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数</li></ul><div class="note primary flat"><p>作用域链本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象</p></div><ul><li>当我们查找一个变量的时候，如果在当前执行环境中没有找到，我们可以沿着作用域链向后查找</li><li>作用域链的创建过程和执行上下文的建立有关。</li></ul><div class="note primary flat"><p>作用域可以理解为变量的可访问性 总共分为三种类型 分别为：</p></div><ul><li>全局作用域</li><li>函数作用域</li><li>块级作用域</li></ul><h2 id="new-的原理以及实现"><a href="#new-的原理以及实现" class="headerlink" title="new 的原理以及实现"></a>new 的原理以及实现</h2><ul><li>创建一个空对象</li><li>将对象连接到构造函数原型</li><li>改变构造函数的 this 指向为新的对象并获取执行构造获取结果</li><li>判断结果是否返回了一个对象<br>如果是 那么返回该对象 否则 使用连接的新对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fn <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">    <span class="keyword">let</span> res = fn.call(obj, ...args); <span class="comment">//改变了this指向的同时获取到构造的结果</span></span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? res : obj;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="proto-prototype-constructor三者关系"><a href="#proto-prototype-constructor三者关系" class="headerlink" title="__proto__,prototype,constructor三者关系"></a><code>__proto__,prototype,constructor</code>三者关系</h2><p><code>__proto__</code>是隐式原型，用于实例去访问其原型对象，但是不规范，一般使用<code>getPrototypeOf</code>去访问</p><p><code>constructor</code>是构造函数，用于创建对象，以及给新对象设置原型对象(相当于设置了一个指针指向 prototype)。存放于<code>constructor.prototype</code>属性中。</p><p><code>prototype</code>是对象，通常叫他原型对象，存在于构造函数中，是他的一个属性。</p><p>常考的东西：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链</span></span><br><span class="line"><span class="built_in">console</span>.log(test.__proto__ === <span class="built_in">Array</span>.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(test.constructor === <span class="built_in">Array</span>); <span class="comment">//实例的构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.constructor === <span class="built_in">Array</span>); <span class="comment">//构造函数自身有原型属性去访问原型，原型又可以通过construtor属性去访问构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.constructor === <span class="built_in">Array</span>); <span class="comment">//原型链 找到原型上的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.__proto__ === <span class="built_in">Function</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的原型的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure><p>对于实例来说 有两个属性 <code>__proto__</code>和<code>constructor</code>分别可以去访问原型和构造函数<br>对于构造函数来说 有两个属性<code>__proto__</code>和<code>prototype</code>分别可以去访问构造函数的原型和原型<br>对于原型来说 有两个属性 <code>__proto__</code>和<code>constructor</code>分别可以去访问原型的原型和构造函数</p><h2 id="如何获取对象的原型"><a href="#如何获取对象的原型" class="headerlink" title="如何获取对象的原型"></a>如何获取对象的原型</h2><ul><li><code>p.__proto__</code></li><li><code>p.constructor.prototype</code></li><li><code>Object.getPrototypeOf(p)</code></li></ul><h2 id="原型链本质"><a href="#原型链本质" class="headerlink" title="原型链本质"></a>原型链本质</h2><p>对象可以通过<code>__proto__</code>来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了原型链。本质上就是链表结构，<code>__proto__</code>算是链表的指针，指向下一个位置</p><h2 id="说说你知道的-js-继承方式，为什么要继承"><a href="#说说你知道的-js-继承方式，为什么要继承" class="headerlink" title="说说你知道的 js 继承方式，为什么要继承"></a>说说你知道的 js 继承方式，为什么要继承</h2><p>继承的目的是为了 让子类拥有父类的属性和方法，属性放在构造函数中，方法挂载在原型中</p><p>组合继承，寄生组合继承，Class 继承</p><p>代码参见手写</p><h2 id="组合继承有什么问题？"><a href="#组合继承有什么问题？" class="headerlink" title="组合继承有什么问题？"></a>组合继承有什么问题？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">//缺点 使得prototype上面有了不必要的属性</span></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>组合继承让实例的原型继承了不应该继承的东西，因为他是在子类构造函数里用了一次 call 执行父类构造函数 然后在外面链接父类原型的时候(链接原型的目的是为了继承父类的方法，而继承父类方法的方式可以是使用 new) 使用了 new 方法，new 方法又会执行一遍构造函数，于是子类原型上面也有了父类原型的一些属性</p><p>而 call 的时候已经继承过了一次属性到子类构造函数中，造成了属性冗余</p><h2 id="寄生组合继承怎么解决组合继承的问题？又有什么缺点？"><a href="#寄生组合继承怎么解决组合继承的问题？又有什么缺点？" class="headerlink" title="寄生组合继承怎么解决组合继承的问题？又有什么缺点？"></a>寄生组合继承怎么解决组合继承的问题？又有什么缺点？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="comment">// 第二次调用SuperType()</span></span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="comment">// 构建原型链</span></span><br><span class="line"><span class="comment">// 第一次调用SuperType()</span></span><br><span class="line"><span class="comment">//   SubType.prototype = new SuperType();</span></span><br><span class="line"><span class="comment">// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType</span></span><br><span class="line">SubType.prototype = <span class="built_in">Object</span>.create(SuperType.prototype, &#123;</span><br><span class="line">  <span class="attr">constructor</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: SubType,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// SubType.prototype.__proto__ = SuperType.prototype; //或者这么使用</span></span><br></pre></td></tr></table></figure><p>我们知道。组合继承的问题在于给子类添加父类方法的时候又调用了一遍父类的构造函数使得子类原型上面多了很多无关的属性。</p><p>寄生组合继承的解决方法有两种，一种是采用 api<code>Object.create(子类,constructor)</code>去重写子类的原型的 constructor 属性为子类自身的构造函数</p><p>或者直接把子类的原型链接到父类原型上面。这样子类调用方法的时候找不到就去父类找，属于原型链的方法。</p><p>缺点：缺点在于不能调用父类静态方法。</p><h2 id="什么是-class-继承"><a href="#什么是-class-继承" class="headerlink" title="什么是 class 继承"></a>什么是 class 继承</h2><p>class 其实也是一个函数，使用方法是，子类采用 extends 关键字继承父类，然后在子类的构造函数中，采用 super 继承父类的属性。</p><h2 id="事件流的三个阶段是什么"><a href="#事件流的三个阶段是什么" class="headerlink" title="事件流的三个阶段是什么"></a>事件流的三个阶段是什么</h2><p>捕获 目标 冒泡</p><h2 id="preventDefault与stopPropagation的区别"><a href="#preventDefault与stopPropagation的区别" class="headerlink" title="preventDefault与stopPropagation的区别"></a><code>preventDefault</code>与<code>stopPropagation</code>的区别</h2><p>前者是阻止默认事件 比如表单提交<br>后者是阻止冒泡</p><h2 id="onClick-和-addEventListener-的区别"><a href="#onClick-和-addEventListener-的区别" class="headerlink" title="onClick 和 addEventListener 的区别"></a>onClick 和 addEventListener 的区别</h2><p>前者不需要销毁 后者需要<br>前者阻止冒泡需要 stopPropagation，后者在第三个参数决定是否需要冒泡 默认 false 是冒泡</p><h2 id="Promise-是什么，解决了什么问题"><a href="#Promise-是什么，解决了什么问题" class="headerlink" title="Promise 是什么，解决了什么问题"></a>Promise 是什么，解决了什么问题</h2><p>Promise 是一种状态机，状态有 fulfilled,rejected,pending。状态只能由 fulfilled 向其他两个转换，一旦转换就不能再改变。</p><p>Promise 解决了回调地狱的问题，回调地狱指的是回调函数里面又嵌套回调函数，导致代码缩进非常难看，可读性差，Promise 链式调用可以帮我们解决这个痛点。</p><p>而实际上 async await 更方便一点点</p><h2 id="Promise-中直接-return-一个-error-对象会发生什么"><a href="#Promise-中直接-return-一个-error-对象会发生什么" class="headerlink" title="Promise 中直接 return 一个 error 对象会发生什么"></a>Promise 中直接 return 一个 error 对象会发生什么</h2><p>在 promise 中，任何的 return 都视为成功的回调。不写的话默认<code>return Promise.resolve(undefined)</code> return 一个 error 对象也是会进入成功回调的</p><h2 id="new-Promise-需要注意什么"><a href="#new-Promise-需要注意什么" class="headerlink" title="new Promise 需要注意什么"></a>new Promise 需要注意什么</h2><p>new Promise 会先执行构造器的内容，常考在异步任务中</p><h2 id="Promise-all-race-any-allSettled-具体实现"><a href="#Promise-all-race-any-allSettled-具体实现" class="headerlink" title="Promise.all race any allSettled 具体实现"></a>Promise.all race any allSettled 具体实现</h2><p>参考手写代码<br>all 的话 传入可迭代对象，一般是数组，如果其中的有一个失败则进入失败回调，全都成功才算成功<br>race 传参相同，以第一个改变状态的任务为最终结果<br>any 传参相同 全部失败算失败 全部成功算成功<br>allSettled 传参相同，不会因为一个失败就停止，会返回全部任务的最终状态</p><h2 id="Promise-实现-fetch-请求的-abort"><a href="#Promise-实现-fetch-请求的-abort" class="headerlink" title="Promise 实现 fetch 请求的 abort"></a>Promise 实现 fetch 请求的 abort</h2><h2 id="如果实现异步请求并发限制"><a href="#如果实现异步请求并发限制" class="headerlink" title="如果实现异步请求并发限制"></a>如果实现异步请求并发限制</h2><p>all 方法可以保证，promise 数组中所有的 promis 对象都达到 resolve 的状态才执行 then 的回调。</p><p>此时如果数组内有几十万个 promise，那么就会在一瞬间发出几十万跳请求，导致内存溢出。</p><p>所以需要 promiseall 进行并发限制。每一个时刻并发执行的 promise 数量是固定的。最终执行结果和原来的保持一致。</p><h2 id="race-方法的用途"><a href="#race-方法的用途" class="headerlink" title="race 方法的用途"></a>race 方法的用途</h2><p>实现一个超时停止请求</p><h2 id="Promise-finally-的用法"><a href="#Promise-finally-的用法" class="headerlink" title="Promise finally 的用法"></a>Promise finally 的用法</h2><p>不论最后状态如何都会去执行，一般用做中间件，因为无论状态如何都会走 finally，这样就可以用作过度。</p><h2 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h2><p>并行是指多个事件在同一时间点执行<br>并发指的是多个事件在同一时间段执行，但是多个指令进程被快速的交替进行，因此在宏观上长得和并行差不多，但是微观上不一样</p><h2 id="all-方法是并发的还是并行的。"><a href="#all-方法是并发的还是并行的。" class="headerlink" title="all 方法是并发的还是并行的。"></a>all 方法是并发的还是并行的。</h2><p>并发的，不过<code>promise.all().then()</code>结果中数组的顺序和<code>Promise.all()</code>接收到的数组顺序一致</p><h2 id="generator-怎么使用"><a href="#generator-怎么使用" class="headerlink" title="generator 怎么使用"></a>generator 怎么使用</h2><ul><li>有一个*符号的标识符 在函数名称前</li><li>有一个关键字 yield 用于实现分段执行，当 generator 函数遇到 yield 的时候会暂停并抛出其之后的表达式</li><li>有一个关键字 next 表示归还代码的控制权（这一步非常重要，能否理解他决定能否做 async 和 await 的异步题</li></ul><p>手写 genertor</p><h2 id="js-事件循环是什么"><a href="#js-事件循环是什么" class="headerlink" title="js 事件循环是什么"></a>js 事件循环是什么</h2><p>js 的任务分为同步任务和异步任务，异步任务中分为宏任务和微任务。代码由上而下执行，遇到函数调用将函数压入执行栈，先执行同步任务，如果在同步任务中发现了异步事件，先将其挂起，继续执行执行栈中的其他任务。<br>当同步事件执行完之后，将异步事件的回调加入到异步的任务队列中等待执行。<br>异步任务队列分为，微任务队列和宏任务队列。<br>优先执行微任务队列，然后执行宏任务队列。<br>然后重复以上操作</p><h2 id="process-nextTick-是什么"><a href="#process-nextTick-是什么" class="headerlink" title="process.nextTick 是什么"></a>process.nextTick 是什么</h2><p>是 node 中的一个 api，他指定的异步任务总是发生于所有异步任务之前</p><h2 id="js-为什么是单线程"><a href="#js-为什么是单线程" class="headerlink" title="js 为什么是单线程"></a>js 为什么是单线程</h2><p>考虑到用户视角始终只有一个的原因，如果 js 是多线程的话。其中一个线程创建了 DOM 节点，另外一个线程销毁了 DOM 节点。此时浏览器的视图应该以什么为准呢？因为这样的原因，js 在一开始设计上就是单线程的。</p><h2 id="js-怎么开启多线程"><a href="#js-怎么开启多线程" class="headerlink" title="js 怎么开启多线程"></a>js 怎么开启多线程</h2><p>浏览器的线程主要包括 js 引擎，界面渲染线程，事件触发线程，http 请求线程。</p><p>对于 js 来说，他是单线程的，所以一旦有一个任务花费了大量的时间就会造成阻塞。为了解决这个问题，js 提供了一个 worker 类 。</p><p>使用这个 worker 类，会向浏览器申请一个新的线程，用于编写耗时代码。且主线程可以和子线程连线，这样就实现了线程之间数据的传递</p><p>不过需要注意的一点是，尽量只把耗时的操作交给 worker，其他的操作交给主线程，因为所有 js 里面集成的对象都在主线程中。worker 访问会报错</p><h2 id="对-async-和-await-的理解"><a href="#对-async-和-await-的理解" class="headerlink" title="对 async 和 await 的理解"></a>对 async 和 await 的理解</h2><p>本质是 generator 的语法糖，async 用于产生一个 promise，await 需要保证顶部是 async。</p><p>await 和 next 的作用是一样的，他会暂时返还代码的控制权，也就是会跳出当前任务到外面继续执行同步任务等。</p><p>他还会保留堆栈中的东西，假如在 await 这一步操作了变量，他会保留变量的值，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + (<span class="keyword">await</span> <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>, a); <span class="comment">// -&gt; &#x27;2&#x27; 10 //回到awiat之后的内容，保留了堆栈 所以a还是0，0+10= 10</span></span><br><span class="line">  a = (<span class="keyword">await</span> <span class="number">10</span>) + a;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;3&quot;</span>, a); <span class="comment">// -&gt; &#x27;3&#x27; 20</span></span><br><span class="line">&#125;;</span><br><span class="line">b(); <span class="comment">//执行b但是遇到await 跳出</span></span><br><span class="line">a++;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>, a); <span class="comment">// -&gt; &#x27;1&#x27; 1 //跳出后执行同步</span></span><br></pre></td></tr></table></figure><h2 id="async-await-对比-promise-的优势"><a href="#async-await-对比-promise-的优势" class="headerlink" title="async/await 对比 promise 的优势"></a>async/await 对比 promise 的优势</h2><p>优势在于处理 then 的链式调用，能更清晰的写出代码。<br>但是缺点在于 await 会阻塞线程，可能导致性能问题。</p><h2 id="async-await-如何捕获异常"><a href="#async-await-如何捕获异常" class="headerlink" title="async/await 如何捕获异常"></a>async/await 如何捕获异常</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最近流行的 await-to-js，这种方式可能更为优雅</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">5</span>) &#123;</span><br><span class="line">      resolve(<span class="string">&quot;small&quot;</span> + num);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      reject(<span class="string">&quot;big&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to函数来执行一下a()， to函数返回的是一个Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">to</span>(<span class="params">P</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> P.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="literal">null</span>, data];</span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [err, <span class="literal">undefined</span>]; <span class="comment">// 因为没有主动抛出异常，所以后续.then是fullfilled的状态</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> b1 = <span class="keyword">await</span> to(a(<span class="number">8</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(b1); <span class="comment">// [ &#x27;big8&#x27;, undefined ]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> b2 = <span class="keyword">await</span> to(a(<span class="number">3</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(b2); <span class="comment">// [ null, &#x27;small3&#x27; ]</span></span><br><span class="line">&#125;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure><h2 id="setTimeout-和-setInterval-和-requestAnimationFrame-各有什么特点"><a href="#setTimeout-和-setInterval-和-requestAnimationFrame-各有什么特点" class="headerlink" title="setTimeout 和 setInterval 和 requestAnimationFrame 各有什么特点"></a>setTimeout 和 setInterval 和 requestAnimationFrame 各有什么特点</h2><p>正常的屏幕刷新率是 60hz，相当于 16.7ms 执行一次，我们为了达到这样的效果，要设置更新时间为 1000/60。但是 settimeout 和 setInterval 始终是基于 js 引擎的，也就不可避免遇到阻塞，就造成了并不是每一次循环都是相同的时间间隔</p><p>requestAnimationFrame 是基于 GUI 引擎的，他的刷新时间是和系统的刷新率同步的，如果是 60HZ 那么就是 16.7ms 执行一次。这样就能防止掉帧行为。且由于 setTimeout 实现的动画，在浏览器隐藏或者最小化的时候仍然在处于激活状态(虽然已经有浏览器对定时器做了优化)，而 requestAnimationFrame 在页面未激活的情况下会停止。节约了 CPU 开销</p><h2 id="什么是垃圾回收机制"><a href="#什么是垃圾回收机制" class="headerlink" title="什么是垃圾回收机制?"></a>什么是垃圾回收机制?</h2><h2 id="遍历对象有几种方法"><a href="#遍历对象有几种方法" class="headerlink" title="遍历对象有几种方法"></a>遍历对象有几种方法</h2><p>7 种<br>forin<br><code>Object.keys()、Object.values()、Object.entries()</code><br><code>Object.getOwnPropertyNames()</code><br><code>Object.getOwnPropertySymbols()</code><br><code>Reflect.ownKeys()</code></p><h2 id="什么方法只返回对象本身的属性"><a href="#什么方法只返回对象本身的属性" class="headerlink" title="什么方法只返回对象本身的属性"></a>什么方法只返回对象本身的属性</h2><p><code>Object.keys()、Object.values()、Object.entries()</code><br><code>Object.getOwnPropertyNames()</code><br><code>Object.getOwnPropertySymbols()</code><br><code>Reflect.ownKeys()</code></p><h2 id="什么方法能返回不可枚举的属性"><a href="#什么方法能返回不可枚举的属性" class="headerlink" title="什么方法能返回不可枚举的属性"></a>什么方法能返回不可枚举的属性</h2><p>forin<br><code>Object.getOwnPropertySymbols()</code><br><code>Reflect.ownKeys()</code></p><h2 id="面向对象的思想包括"><a href="#面向对象的思想包括" class="headerlink" title="面向对象的思想包括"></a>面向对象的思想包括</h2><p>继承 封装 多态 抽象</p><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><h2 id="JSON-parse-JSON-stringfy-有什么问题"><a href="#JSON-parse-JSON-stringfy-有什么问题" class="headerlink" title="JSON.parse(JSON.stringfy())有什么问题"></a>JSON.parse(JSON.stringfy())有什么问题</h2><p>缺点：不能拷贝<code>undefined function 正则 Error对象</code></p><h2 id="深拷贝实现细节-如何判断一个对象是正则对象"><a href="#深拷贝实现细节-如何判断一个对象是正则对象" class="headerlink" title="深拷贝实现细节 如何判断一个对象是正则对象"></a>深拷贝实现细节 如何判断一个对象是正则对象</h2><h2 id="深拷贝实现细节-如何判断一个对象是-Date-对象"><a href="#深拷贝实现细节-如何判断一个对象是-Date-对象" class="headerlink" title="深拷贝实现细节 如何判断一个对象是 Date 对象"></a>深拷贝实现细节 如何判断一个对象是 Date 对象</h2><h2 id="map-和-object-的区别"><a href="#map-和-object-的区别" class="headerlink" title="map 和 object 的区别"></a>map 和 object 的区别</h2><p>访问：map 通过 getkey 访问 object 直接点或者括号<br>赋值 map 通过 set 赋值 或者直接数组嵌套数组赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> showContents = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;title&quot;</span>, <span class="string">&quot;标题&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;tags&quot;</span>, <span class="string">&quot;标签&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;categories&quot;</span>, <span class="string">&quot;目录&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;date&quot;</span>, <span class="string">&quot;创建日期&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;updateTime&quot;</span>, <span class="string">&quot;最后更新日期&quot;</span>],</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>删除 map 通过 delete 去删除 删成功 true 反之 false，不存在也是 false<br>但 obj 的话 删除不存在的属性也返回 true<br>大小：map 通过 size 访问元素个数，obj 需要通过<code>Object.keys</code>的转换才能将其转换为数组，再通过数组的<code>length</code>方法去获得或者使用<code>Reflect.ownKeys(obj)</code>也可以获取到 keys 的集合</p><p>迭代：map 有迭代器，可以直接遍历。obj 没有，但可以通过 forin 不过是无序的</p><h2 id="常用正则表达式有哪些"><a href="#常用正则表达式有哪些" class="headerlink" title="常用正则表达式有哪些"></a>常用正则表达式有哪些</h2><h2 id="对-json-的理解"><a href="#对-json-的理解" class="headerlink" title="对 json 的理解"></a>对 json 的理解</h2><p>JSON 是一种结构化数据，它是一种数据格式<br>json 必须用<code>&#123;&#125;</code>包裹，内部只能双引号。没有分号<br>方法：<br><code>JSON.stringify()</code>; 把 js 对象序列化为 json 字符串</p><p><code>JSON.parse()</code>; 把 json 字符串解析为原生 js 值</p><h2 id="js-脚本延迟加载的方式有哪些"><a href="#js-脚本延迟加载的方式有哪些" class="headerlink" title="js 脚本延迟加载的方式有哪些"></a>js 脚本延迟加载的方式有哪些</h2><p>1:defer 属性,async 属性<br>2:动态创建 DOM 方式<br>3:使用 jQuery 的 getScript 方法<br>4:使用 setTimeout 延迟方法<br>5:让 JS 最后加载 放到页面底部</p><h2 id="Unicode，UTF-8，UTF-16，UTF-32-的区别"><a href="#Unicode，UTF-8，UTF-16，UTF-32-的区别" class="headerlink" title="Unicode，UTF-8，UTF-16，UTF-32 的区别"></a>Unicode，UTF-8，UTF-16，UTF-32 的区别</h2><h2 id="常见位运算符及其运算规则"><a href="#常见位运算符及其运算规则" class="headerlink" title="常见位运算符及其运算规则"></a>常见位运算符及其运算规则</h2><h2 id="什么是-DOM-和-BOM"><a href="#什么是-DOM-和-BOM" class="headerlink" title="什么是 DOM 和 BOM"></a>什么是 DOM 和 BOM</h2><h2 id="类数组如何转换成数组"><a href="#类数组如何转换成数组" class="headerlink" title="类数组如何转换成数组"></a>类数组如何转换成数组</h2><p>a. 使用Array.from()<br>b. 使用Array.prototype.slice.call()<br>c. 使用Array.prototype.forEach()进行属性遍历并组成新的数组</p><h2 id="对-ajax-的理解-实现一个-ajax"><a href="#对-ajax-的理解-实现一个-ajax" class="headerlink" title="对 ajax 的理解 实现一个 ajax"></a>对 ajax 的理解 实现一个 ajax</h2><h2 id="什么是尾调用，有什么好处"><a href="#什么是尾调用，有什么好处" class="headerlink" title="什么是尾调用，有什么好处"></a>什么是尾调用，有什么好处</h2><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是返回调用另一个函数的执行结果。</p><p>注意 结尾返回另外一个函数之后没别的操作才叫尾调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> g(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面代码中:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> y = g(x);</span><br><span class="line"> <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//情况2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> g(x) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//情况3 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"> g(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。<br>情况二也属于调用后还有操作，即使写在一行内。<br>情况三等价于return undefined<br>属于尾调用的示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> g(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b(x)</span><br></pre></td></tr></table></figure><br>尾调用不一定出现在函数尾部，只要是最后一步操作即可。上面代码中，函数g和b都属于尾调用，因为它们都是函数f的最后一步操作。</p><p>尾调用的情况下，执行栈中只有当前调用函数，取代了外层函数，这就是尾调用的优化。<br>链接:<a href="https://blog.csdn.net/weixin_45374451/article/details/106495588?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-106495588-blog-123396329.pc_relevant_multi_platform_whitelistv6&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-106495588-blog-123396329.pc_relevant_multi_platform_whitelistv6&amp;utm_relevant_index=2">尾调用</a></p><h2 id="CJS-ES"><a href="#CJS-ES" class="headerlink" title="CJS ES"></a>CJS ES</h2><p>这里的知识可以联系 bundless</p><p>cjs 是 node 的格式 es 是现代浏览器支持的格式<br>cjs 是运行时 因为他基于 node 传递的是值的拷贝<br>es 是编译时 传递的是值的引用</p><p>es支持tree shaking</p><p>bundless 的过程其实就是把 cjs 转 es 的过程</p><h2 id="动态类型语言和静态类型语言的区别"><a href="#动态类型语言和静态类型语言的区别" class="headerlink" title="动态类型语言和静态类型语言的区别"></a>动态类型语言和静态类型语言的区别</h2><p>通常我们所说的动态语言、静态语言是指动态类型语言和静态类型语言。</p><p>动态类型语言：动态类型语言是指在运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。Python 和 Ruby 就是一种典型的动态类型语言，其他的各种脚本语言如 VBScript 也多少属于动态类型语言。</p><p>静态类型语言：静态类型语言与动态类型语言刚好相反，它的数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表，其他的静态类型语言还有 C#、JAVA 等。</p><p>对于动态语言与静态语言的区分，套用一句流行的话就是：StaTIc typing when possible， dynamictyping when needed。</p><h2 id="强类型语言和弱类型语言的区别"><a href="#强类型语言和弱类型语言的区别" class="headerlink" title="强类型语言和弱类型语言的区别"></a>强类型语言和弱类型语言的区别</h2><p>强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量 a，那么程序根本不可能将 a 当作字符串类型处理。强类型定义语言是类型安全的语言。</p><p>弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反， 一个变量可以赋不同数据类型的值。</p><p>强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。另外，“这门语言是不是动态语言”与“这门语言是否类型安全”之间是完全没有联系的！</p><p>例如：Python 是动态语言，是强类型定义语言（类型安全的语言）; VBScript 是动态语言，是弱类型定义语言（类型不安全的语言）;JAVA 是静态语言，是强类型定义语言（类型安全的语言）。</p><h2 id="解释性语言和编译型语言的区别"><a href="#解释性语言和编译型语言的区别" class="headerlink" title="解释性语言和编译型语言的区别"></a>解释性语言和编译型语言的区别</h2><p>编译型语言：编译型语言在执行之前要先经过编译过程，编译成为一个可执行的机器语言的文件，比如 exe。因为翻译只做一遍，以后都不需要翻译，所以执行效率高。</p><p>解释型语言：解释性语言编写的程序不进行预先编译，以文本方式存储程序代码。执行时才翻译执行。程序每执行一次就要翻译一遍。</p><h2 id="fetch，实现一个-fetch"><a href="#fetch，实现一个-fetch" class="headerlink" title="fetch，实现一个 fetch"></a>fetch，实现一个 fetch</h2><h2 id="escape，encodeURL，encodeURIComponent-的区别"><a href="#escape，encodeURL，encodeURIComponent-的区别" class="headerlink" title="escape，encodeURL，encodeURIComponent 的区别"></a>escape，encodeURL，encodeURIComponent 的区别</h2><h2 id="defer-和-async-的区别"><a href="#defer-和-async-的区别" class="headerlink" title="defer 和 async 的区别"></a>defer 和 async 的区别</h2><h2 id="什么是同源-同域"><a href="#什么是同源-同域" class="headerlink" title="什么是同源/同域"></a>什么是同源/同域</h2><p>协议 域名 端口 三者相同才算同源<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220904085319.png" alt=""></p><h2 id="实现数组去重"><a href="#实现数组去重" class="headerlink" title="实现数组去重"></a>实现数组去重</h2><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="介绍一下-http1-3"><a href="#介绍一下-http1-3" class="headerlink" title="介绍一下 http1-3"></a>介绍一下 http1-3</h2><p>http1 是 0.9 的下一个版本，这个版本中他可以传输任何形式的内容不限于文本，还加入了 post 和 head 请求，且加入了更多标识信息的手段，比如 header 头部和响应码，以及对于资源提供了缓存。算是一个大更新，不过缺点也存在，也就是这个版本不支持断点续传，且没有传递主机名 hostname(大概是身份识别的一个影响)，最重要的是服务器发送完响应就关闭了 TCP 连接，导致每次请求都要重新建立连接,我们知道 TCP 三次握手的成本是比较高的，不过他有一个缓解的方法，就是设置<code>Connection:keep-alive</code>让服务端先不要关闭 TCP 连接。从而达到了类似 TCP 复用的目的(这里经常忘记断点续传，因为这个内容确实不熟悉)</p><p>在 1.1 的时候，引入了长连接，默认 TCP 不去关闭，可以被多个请求复用。且支持断点续传。这个版本还新增了并发连接，管道机制，增加了 PUTDELETEOPTIONSPATCH 等方法，允许响应数据分块，有利于传输大文件，强制要求 host 头，让主机托管成为可能。不过也因为引入了长连接，带来了跨越两个版本的问题，队头阻塞，而且 1.1 版本中越来越多的头字段也暴露了引入 header 的问题，无状态。以及明文传输导致的数据安全性问题。</p><p>在 2.0 之前有个叫 spdy 的协议，是改进版本的 1.1,提出了多路复用的方案，通过多个请求 stream 共享一个 TCP 连接的方式，解决了 http 队头阻塞的问题。还设置了请求优先级，重要的请求优先响应() 压缩了 header 并且加密传输和服务端推送</p><p>2.0 就是基于 spdy 协议的，通过多路复用和流解决了队头阻塞的问题，使用了 hpack 算法解决了头部过大的问题。2.0 协议的特点是二进制分针，头部压缩，多路复用和服务端推送，流。</p><p>不过 2.0 尚未解决 TCP 阻塞的问题，这个问题根本上是传输层的问题，要想改变这个历史已久的协议要同时改变其他硬件厂商和网络厂商的设备，是不太可能的。于是 3.0 面向 UDP 协议做了新的调整。也就是 QUIC 协议</p><p>3.0 的 QUIC 协议要求严格加密</p><h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><h2 id="为什么-ConnectionKeepalive-不能根本解决问题"><a href="#为什么-ConnectionKeepalive-不能根本解决问题" class="headerlink" title="为什么 ConnectionKeepalive 不能根本解决问题"></a>为什么 ConnectionKeepalive 不能根本解决问题</h2><p>头部字段不是标准的，不同浏览器实现起来可能不一样，所以不能从根本上解决问题</p><h2 id="并发并行"><a href="#并发并行" class="headerlink" title="并发并行"></a>并发并行</h2><p>并发指的是多个事件在同一时间段执行<br>并行是指多个事件在同一时间点执行</p><h2 id="什么是主机托管"><a href="#什么是主机托管" class="headerlink" title="什么是主机托管"></a>什么是主机托管</h2><h2 id="什么是无状态"><a href="#什么是无状态" class="headerlink" title="什么是无状态"></a>什么是无状态</h2><p>无状态指的是对于请求头没有记忆能力。于是 2.0 提出的 hpack 解决了这个问题</p><h2 id="http1-之前还有别的版本吗"><a href="#http1-之前还有别的版本吗" class="headerlink" title="http1 之前还有别的版本吗"></a>http1 之前还有别的版本吗</h2><p>0.9 为了传输 HTML(文本)诞生，而且只能发 GET 请求，请求报文只有一行，没有标识信息，服务器发完就关闭了 TCP</p><h2 id="讲一下-HTTP-的请求报文"><a href="#讲一下-HTTP-的请求报文" class="headerlink" title="讲一下 HTTP 的请求报文"></a>讲一下 HTTP 的请求报文</h2><p>由三部分组成<br>请求行 请求头 请求体<br>请求行由请求方法 URL 协议版本组成<br>请求头<br>空行(注意)<br>请求体</p><h2 id="请求方法-什么是幂等-什么是不幂等"><a href="#请求方法-什么是幂等-什么是不幂等" class="headerlink" title="请求方法 什么是幂等 什么是不幂等"></a>请求方法 什么是幂等 什么是不幂等</h2><p>GET POST HEAD DELETE PATCH OPTION PUT</p><h2 id="常见的请求头？"><a href="#常见的请求头？" class="headerlink" title="常见的请求头？"></a>常见的请求头？</h2><p>Referer<br>Cookie<br>Connection<br>Content-Length<br>Accept-language<br>…</p><h2 id="怎么进行断点续传"><a href="#怎么进行断点续传" class="headerlink" title="怎么进行断点续传"></a>怎么进行断点续传</h2><h2 id="前端如何设置缓存"><a href="#前端如何设置缓存" class="headerlink" title="前端如何设置缓存"></a>前端如何设置缓存</h2><h2 id="缓存中的-Etag-和-Expires-是什么区别"><a href="#缓存中的-Etag-和-Expires-是什么区别" class="headerlink" title="缓存中的 Etag 和 Expires 是什么区别"></a>缓存中的 Etag 和 Expires 是什么区别</h2><h2 id="缓存新鲜度是怎么计算的"><a href="#缓存新鲜度是怎么计算的" class="headerlink" title="缓存新鲜度是怎么计算的"></a>缓存新鲜度是怎么计算的</h2><h2 id="有什么响应码"><a href="#有什么响应码" class="headerlink" title="有什么响应码"></a>有什么响应码</h2><h2 id="TCP-和-UDP-什么区别"><a href="#TCP-和-UDP-什么区别" class="headerlink" title="TCP 和 UDP 什么区别"></a>TCP 和 UDP 什么区别</h2><h2 id="TCP-连接的过程"><a href="#TCP-连接的过程" class="headerlink" title="TCP 连接的过程"></a>TCP 连接的过程</h2><h2 id="说一下-1-1-的管道机制"><a href="#说一下-1-1-的管道机制" class="headerlink" title="说一下 1.1 的管道机制"></a>说一下 1.1 的管道机制</h2><h2 id="如何进行大文件传输"><a href="#如何进行大文件传输" class="headerlink" title="如何进行大文件传输"></a>如何进行大文件传输</h2><p>前端：文件名转 md5，文件切片，上传完后合并</p><h2 id="为什么-1，1-强制要求-host-头"><a href="#为什么-1，1-强制要求-host-头" class="headerlink" title="为什么 1，1 强制要求 host 头"></a>为什么 1，1 强制要求 host 头</h2><h2 id="什么是-TCP-阻塞-什么是-HTTP-阻塞-怎么解决"><a href="#什么是-TCP-阻塞-什么是-HTTP-阻塞-怎么解决" class="headerlink" title="什么是 TCP 阻塞 什么是 HTTP 阻塞 怎么解决"></a>什么是 TCP 阻塞 什么是 HTTP 阻塞 怎么解决</h2><p>TCP 阻塞是指当一个 TCP 的分节丢失的时候，因为 TCP 本身是可靠传输，所以他的后续分节会一直被接收端保存，直到丢失的这一个分节传输到接收端为止。</p><p>这样的可靠传输能保证数据的完整性，但是却影响了后续分节的传输。比如发三个图片第一个图片的分节丢失，也影响到后面的两个图片数据传输。</p><p>HTTP 队头阻塞是指 1.1 协议中的管道传输，由于管道传输的性质是可以多个请求同时发送但是要求响应顺序一致，所以导致了 http 阻塞。</p><p>解决 HTTP 阻塞靠的是 2.0 中多路复用和流的概念，多路复用有点类似于管道，不过他使得同多个请求共享同一个 TCP 连接，在这个连接中他会将报文拆分成二进制帧发送，服务器接收到乱序的帧重新组合成为对应的报文，所以就不存在先后的问题，也就解决了 HTTP 的队头阻塞</p><p>解决 TCP 阻塞靠的是 QUIC 协议，因为 TCP 阻塞本质上是传输层的问题，在改变协议困难的情况下(现在绝大部分硬件厂商网络运营商都是这样的协议)为了解决这个问题，从另外一个协议下手，也就是 UDP。UDP 不管顺序，丢包方面也有 QUIC 对应的方法去处理(多路复用，有多个独立的逻辑数据流)从而解决 TCP 阻塞的问题</p><h2 id="http1-1-是怎么解决队头阻塞-实际上是缓解"><a href="#http1-1-是怎么解决队头阻塞-实际上是缓解" class="headerlink" title="http1.1 是怎么解决队头阻塞(实际上是缓解)"></a>http1.1 是怎么解决队头阻塞(实际上是缓解)</h2><p>使用了域名分片的技术<br>一个域名拥有 6 个 TCP 连接，有多级域名的时候能吧更多的资源分配出来。<br>引起别的问题：因为 TCP 连接要经过 dns，三次握手，慢启动等操作。所以对于服务器来说连接太多容易造成网络拥挤</p><h2 id="http2-0-有什么新特性"><a href="#http2-0-有什么新特性" class="headerlink" title="http2.0 有什么新特性"></a>http2.0 有什么新特性</h2><p>二进制分帧，多路复用，头部压缩，服务端推送，流</p><h2 id="Hpack-算法原理"><a href="#Hpack-算法原理" class="headerlink" title="Hpack 算法原理"></a>Hpack 算法原理</h2><p>哈希表 传索引 哈夫曼收集整数和</p><h2 id="2-0-之前是怎么分帧的"><a href="#2-0-之前是怎么分帧的" class="headerlink" title="2.0 之前是怎么分帧的"></a>2.0 之前是怎么分帧的</h2><h2 id="二进制分帧是怎么实现优先级和流量控制的"><a href="#二进制分帧是怎么实现优先级和流量控制的" class="headerlink" title="二进制分帧是怎么实现优先级和流量控制的"></a>二进制分帧是怎么实现优先级和流量控制的</h2><h2 id="什么是多路复用"><a href="#什么是多路复用" class="headerlink" title="什么是多路复用"></a>什么是多路复用</h2><h2 id="怎么进行服务端推送"><a href="#怎么进行服务端推送" class="headerlink" title="怎么进行服务端推送"></a>怎么进行服务端推送</h2><h2 id="2-0-有什么问题"><a href="#2-0-有什么问题" class="headerlink" title="2.0 有什么问题"></a>2.0 有什么问题</h2><h2 id="http3-0-有什么新特性"><a href="#http3-0-有什么新特性" class="headerlink" title="http3.0 有什么新特性"></a>http3.0 有什么新特性</h2><h2 id="QUIC-有安全问题吗"><a href="#QUIC-有安全问题吗" class="headerlink" title="QUIC 有安全问题吗"></a>QUIC 有安全问题吗</h2><h2 id="UDP-丢失数据包的问题在-QUIC-中是怎么解决的"><a href="#UDP-丢失数据包的问题在-QUIC-中是怎么解决的" class="headerlink" title="UDP 丢失数据包的问题在 QUIC 中是怎么解决的"></a>UDP 丢失数据包的问题在 QUIC 中是怎么解决的</h2><h2 id="说一下-TLS"><a href="#说一下-TLS" class="headerlink" title="说一下 TLS"></a>说一下 TLS</h2><h2 id="RTT-是什么意思"><a href="#RTT-是什么意思" class="headerlink" title="RTT 是什么意思"></a>RTT 是什么意思</h2><h2 id="TLS1-3-有什么问题吗"><a href="#TLS1-3-有什么问题吗" class="headerlink" title="TLS1.3 有什么问题吗"></a>TLS1.3 有什么问题吗</h2><h2 id="QUIC-是如何确立一个连接的"><a href="#QUIC-是如何确立一个连接的" class="headerlink" title="QUIC 是如何确立一个连接的"></a>QUIC 是如何确立一个连接的</h2><h2 id="说一下-HTTP1-3-分别使用了多少个-RTT"><a href="#说一下-HTTP1-3-分别使用了多少个-RTT" class="headerlink" title="说一下 HTTP1-3 分别使用了多少个 RTT"></a>说一下 HTTP1-3 分别使用了多少个 RTT</h2><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="v-if-v-show"><a href="#v-if-v-show" class="headerlink" title="v-if v-show"></a>v-if v-show</h2><h2 id="vue2-为什么不能监听数组"><a href="#vue2-为什么不能监听数组" class="headerlink" title="vue2 为什么不能监听数组"></a>vue2 为什么不能监听数组</h2><p>其实是可以监听的，原因在于<code>Object.defineProperty</code>这个 api 上，他是可以暴力监听数组中的所有元素的，以 index 的形式。但是如果数组内部有百万个元素，每次监听都要发生改变，这样就会造成很大的性能问题了。所以选择不去监听。Vue3 中使用了 Proxy，直接劫持整个数组对象，就没这个问题了。</p><h2 id="使用过-Object-defineProperty-吗"><a href="#使用过-Object-defineProperty-吗" class="headerlink" title="使用过 Object.defineProperty 吗"></a>使用过 Object.defineProperty 吗</h2><h2 id="nextTick-的原理"><a href="#nextTick-的原理" class="headerlink" title="nextTick 的原理"></a>nextTick 的原理</h2><h2 id="vue3-在响应式上做了什么优化"><a href="#vue3-在响应式上做了什么优化" class="headerlink" title="vue3 在响应式上做了什么优化"></a>vue3 在响应式上做了什么优化</h2><h2 id="为什么-Proxy-中需要-Reflect"><a href="#为什么-Proxy-中需要-Reflect" class="headerlink" title="为什么 Proxy 中需要 Reflect"></a>为什么 Proxy 中需要 Reflect</h2><h2 id="Proxy-的-get-的三个参数的意义-为什么需要-receiver"><a href="#Proxy-的-get-的三个参数的意义-为什么需要-receiver" class="headerlink" title="Proxy 的 get 的三个参数的意义/为什么需要 receiver"></a>Proxy 的 get 的三个参数的意义/为什么需要 receiver</h2><h2 id="MVC-和-MVVM-的区别"><a href="#MVC-和-MVVM-的区别" class="headerlink" title="MVC 和 MVVM 的区别"></a>MVC 和 MVVM 的区别</h2><h2 id="为什么-data-是一个函数"><a href="#为什么-data-是一个函数" class="headerlink" title="为什么 data 是一个函数"></a>为什么 data 是一个函数</h2><h2 id="Vue-组件通讯有那些方式？"><a href="#Vue-组件通讯有那些方式？" class="headerlink" title="Vue 组件通讯有那些方式？"></a>Vue 组件通讯有那些方式？</h2><h2 id="Vue-的生命周期方法有那些？在哪一步发送请求"><a href="#Vue-的生命周期方法有那些？在哪一步发送请求" class="headerlink" title="Vue 的生命周期方法有那些？在哪一步发送请求"></a>Vue 的生命周期方法有那些？在哪一步发送请求</h2><h2 id="说说-Vue-的内置指令。"><a href="#说说-Vue-的内置指令。" class="headerlink" title="说说 Vue 的内置指令。"></a>说说 Vue 的内置指令。</h2><h2 id="怎么理解-Vue-的单向数据流"><a href="#怎么理解-Vue-的单向数据流" class="headerlink" title="怎么理解 Vue 的单向数据流"></a>怎么理解 Vue 的单向数据流</h2><h2 id="computed-和-watch-的区别和运用的场景"><a href="#computed-和-watch-的区别和运用的场景" class="headerlink" title="computed 和 watch 的区别和运用的场景"></a>computed 和 watch 的区别和运用的场景</h2><h2 id="未被-template-使用的元素，computed-中的属性依赖的-data-发生改变了，computed-会重新计算吗"><a href="#未被-template-使用的元素，computed-中的属性依赖的-data-发生改变了，computed-会重新计算吗" class="headerlink" title="未被 template 使用的元素，computed 中的属性依赖的 data 发生改变了，computed 会重新计算吗"></a>未被 template 使用的元素，computed 中的属性依赖的 data 发生改变了，computed 会重新计算吗</h2><h2 id="v-if-和-v-for-为什么不建议一起使用。"><a href="#v-if-和-v-for-为什么不建议一起使用。" class="headerlink" title="v-if 和 v-for 为什么不建议一起使用。"></a>v-if 和 v-for 为什么不建议一起使用。</h2><h2 id="Vue-响应式数据的原理"><a href="#Vue-响应式数据的原理" class="headerlink" title="Vue 响应式数据的原理"></a>Vue 响应式数据的原理</h2><h2 id="vue3-0-用过吗-了解多少"><a href="#vue3-0-用过吗-了解多少" class="headerlink" title="vue3.0 用过吗 了解多少"></a>vue3.0 用过吗 了解多少</h2><h2 id="Vue-的父子组件生命周期钩子执行顺序"><a href="#Vue-的父子组件生命周期钩子执行顺序" class="headerlink" title="Vue 的父子组件生命周期钩子执行顺序"></a>Vue 的父子组件生命周期钩子执行顺序</h2><h2 id="虚拟-DOM-是什么-有什么优缺点"><a href="#虚拟-DOM-是什么-有什么优缺点" class="headerlink" title="虚拟 DOM 是什么 有什么优缺点"></a>虚拟 DOM 是什么 有什么优缺点</h2><h2 id="虚拟-DOM-原理"><a href="#虚拟-DOM-原理" class="headerlink" title="虚拟 DOM 原理"></a>虚拟 DOM 原理</h2><h2 id="v-model-的原理"><a href="#v-model-的原理" class="headerlink" title="v-model 的原理"></a>v-model 的原理</h2><h2 id="vue-事件绑定原理"><a href="#vue-事件绑定原理" class="headerlink" title="vue 事件绑定原理"></a>vue 事件绑定原理</h2><h2 id="v-for-为什么要加-key"><a href="#v-for-为什么要加-key" class="headerlink" title="v-for 为什么要加 key"></a>v-for 为什么要加 key</h2><h2 id="手写发布订阅"><a href="#手写发布订阅" class="headerlink" title="手写发布订阅"></a>手写发布订阅</h2><h2 id="vue-router-路由钩子函数是什么-执行顺序是什么"><a href="#vue-router-路由钩子函数是什么-执行顺序是什么" class="headerlink" title="vue-router 路由钩子函数是什么 执行顺序是什么"></a>vue-router 路由钩子函数是什么 执行顺序是什么</h2><h2 id="vue-router-原理"><a href="#vue-router-原理" class="headerlink" title="vue-router 原理"></a>vue-router 原理</h2><h2 id="vue-router-动态路由是什么？有什么问题"><a href="#vue-router-动态路由是什么？有什么问题" class="headerlink" title="vue-router 动态路由是什么？有什么问题"></a>vue-router 动态路由是什么？有什么问题</h2><h2 id="Vuex-的理解"><a href="#Vuex-的理解" class="headerlink" title="Vuex 的理解"></a>Vuex 的理解</h2><h2 id="Vuex-页面刷新数据丢失怎么解决"><a href="#Vuex-页面刷新数据丢失怎么解决" class="headerlink" title="Vuex 页面刷新数据丢失怎么解决"></a>Vuex 页面刷新数据丢失怎么解决</h2><h2 id="Vuex-为什么要分模块而且加命名空间"><a href="#Vuex-为什么要分模块而且加命名空间" class="headerlink" title="Vuex 为什么要分模块而且加命名空间"></a>Vuex 为什么要分模块而且加命名空间</h2><h2 id="使用过-Vue-SSR-吗？说一说-SSR"><a href="#使用过-Vue-SSR-吗？说一说-SSR" class="headerlink" title="使用过 Vue SSR 吗？说一说 SSR"></a>使用过 Vue SSR 吗？说一说 SSR</h2><h2 id="Vue-使用了哪些设计者模式"><a href="#Vue-使用了哪些设计者模式" class="headerlink" title="Vue 使用了哪些设计者模式"></a>Vue 使用了哪些设计者模式</h2><h2 id="你做过哪些-vue-的性能优化"><a href="#你做过哪些-vue-的性能优化" class="headerlink" title="你做过哪些 vue 的性能优化"></a>你做过哪些 vue 的性能优化</h2><h2 id="Vue-mixin-的使用场景和原理"><a href="#Vue-mixin-的使用场景和原理" class="headerlink" title="Vue.mixin 的使用场景和原理"></a>Vue.mixin 的使用场景和原理</h2><h2 id="keep-alive-使用场景"><a href="#keep-alive-使用场景" class="headerlink" title="keep-alive 使用场景"></a>keep-alive 使用场景</h2><h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><h2 id="手撕-keep-alive"><a href="#手撕-keep-alive" class="headerlink" title="手撕 keep-alive"></a>手撕 keep-alive</h2><h2 id="Vue-set-方法原理"><a href="#Vue-set-方法原理" class="headerlink" title="Vue.set 方法原理"></a>Vue.set 方法原理</h2><h2 id="Vue-extend-原理"><a href="#Vue-extend-原理" class="headerlink" title="Vue.extend 原理"></a>Vue.extend 原理</h2><h2 id="写过自定义指令吗-原理是啥"><a href="#写过自定义指令吗-原理是啥" class="headerlink" title="写过自定义指令吗 原理是啥"></a>写过自定义指令吗 原理是啥</h2><h2 id="什么是-AST-语法树"><a href="#什么是-AST-语法树" class="headerlink" title="什么是 AST 语法树"></a>什么是 AST 语法树</h2><h2 id="Vue-修饰符有哪些"><a href="#Vue-修饰符有哪些" class="headerlink" title="Vue 修饰符有哪些"></a>Vue 修饰符有哪些</h2><h2 id="Vue-模板编译原理"><a href="#Vue-模板编译原理" class="headerlink" title="Vue 模板编译原理"></a>Vue 模板编译原理</h2><h2 id="生命周期钩子是如何实现的"><a href="#生命周期钩子是如何实现的" class="headerlink" title="生命周期钩子是如何实现的"></a>生命周期钩子是如何实现的</h2><h2 id="函数式组件使用场景和原理"><a href="#函数式组件使用场景和原理" class="headerlink" title="函数式组件使用场景和原理"></a>函数式组件使用场景和原理</h2><h2 id="diff-算法了解吗"><a href="#diff-算法了解吗" class="headerlink" title="diff 算法了解吗"></a>diff 算法了解吗</h2><h1 id="react"><a href="#react" class="headerlink" title="react"></a>react</h1><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1><h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="OSI-七层"><a href="#OSI-七层" class="headerlink" title="OSI 七层"></a>OSI 七层</h2><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="如何实现图片的懒加载"><a href="#如何实现图片的懒加载" class="headerlink" title="如何实现图片的懒加载"></a>如何实现图片的懒加载</h2><h2 id="行内-块-元素"><a href="#行内-块-元素" class="headerlink" title="行内 块 元素"></a>行内 块 元素</h2><h2 id="link和import-的区别"><a href="#link和import-的区别" class="headerlink" title="link和import 的区别"></a><code>link</code>和<code>import</code> 的区别</h2><p>link除了引用样式文件，还可以引用图片等资源文件，而import只引用样式文件<br>link属于html范畴 import属于css范畴<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;any&quot;</span> <span class="attr">mask</span> <span class="attr">href</span>=<span class="string">&quot;//www.baidu.com/img/baidu.svg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>兼容性不同，link不存在兼容性的问题，import在IE5以上支持，是css2.1新增的<br>在样式表文件可以使用import导入其它的样式表文件，而link不可以<br>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。<br>link支持使用Javascript控制DOM去改变样式；而@import不支持。</p><h2 id="你了解的video标签"><a href="#你了解的video标签" class="headerlink" title="你了解的video标签"></a>你了解的video标签</h2><h2 id="h5新特性有哪些"><a href="#h5新特性有哪些" class="headerlink" title="h5新特性有哪些"></a>h5新特性有哪些</h2><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="BFC-的理解"><a href="#BFC-的理解" class="headerlink" title="BFC 的理解"></a>BFC 的理解</h2><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与,<br>哪些情况会产生BFC:<br>根元素<br>float属性不为none<br>position为absolute或fixed<br>display为inline-block, table-cell, table-caption, flex, inline-flex<br>overflow不为visible</p><h2 id="盒模型的理解"><a href="#盒模型的理解" class="headerlink" title="盒模型的理解"></a>盒模型的理解</h2><h2 id="animation-属性"><a href="#animation-属性" class="headerlink" title="animation 属性"></a>animation 属性</h2><h2 id="img-和-backgroundimg-的区别"><a href="#img-和-backgroundimg-的区别" class="headerlink" title="img 和 backgroundimg 的区别"></a>img 和 backgroundimg 的区别</h2><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><h2 id="margin-left和margin-top自身宽度的一半和transform-translate-50-50-，有什么区别"><a href="#margin-left和margin-top自身宽度的一半和transform-translate-50-50-，有什么区别" class="headerlink" title="margin-left和margin-top自身宽度的一半和transform:translate(-50%,-50%)，有什么区别"></a>margin-left和margin-top自身宽度的一半和transform:translate(-50%,-50%)，有什么区别</h2><h2 id="在对于没有设置高度，高度由内容撑起来的盒子上有什么区别，这种盒子可以使用什么方式垂直水平居中"><a href="#在对于没有设置高度，高度由内容撑起来的盒子上有什么区别，这种盒子可以使用什么方式垂直水平居中" class="headerlink" title="在对于没有设置高度，高度由内容撑起来的盒子上有什么区别，这种盒子可以使用什么方式垂直水平居中"></a>在对于没有设置高度，高度由内容撑起来的盒子上有什么区别，这种盒子可以使用什么方式垂直水平居中</h2><h2 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h2><p>1.通配符选择器和继承:权重为0， 2.标签选择器:权重为0001 3.类选择器:权重为0010 4.id选择器:权重为0100 5.行内样式:权重为1000 6.!important:权重为无穷大</p><h2 id="重绘和回流-为什么要减少回流-什么情况引起回流"><a href="#重绘和回流-为什么要减少回流-什么情况引起回流" class="headerlink" title="重绘和回流 为什么要减少回流 什么情况引起回流"></a>重绘和回流 为什么要减少回流 什么情况引起回流</h2><h2 id="flex1-代表什么"><a href="#flex1-代表什么" class="headerlink" title="flex1 代表什么"></a>flex1 代表什么</h2><h2 id="默认1rem是多少px"><a href="#默认1rem是多少px" class="headerlink" title="默认1rem是多少px"></a>默认1rem是多少px</h2><p>16</p><h2 id="chrome最小字体是多少px-怎么实现更小的字体"><a href="#chrome最小字体是多少px-怎么实现更小的字体" class="headerlink" title="chrome最小字体是多少px 怎么实现更小的字体"></a>chrome最小字体是多少px 怎么实现更小的字体</h2><p>最小12px</p><h2 id="SVG和Canvas区别"><a href="#SVG和Canvas区别" class="headerlink" title="SVG和Canvas区别"></a>SVG和Canvas区别</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><h2 id="外边距塌陷问题"><a href="#外边距塌陷问题" class="headerlink" title="外边距塌陷问题"></a>外边距塌陷问题</h2><p>当两个在标准流中相邻（兄弟或父子关系）的块级元素的外边距组合在一起的时候，垂直方向上会发生外边距塌陷的问题，计算方式：</p><ol><li>两个都为正，取最大</li><li>一正一负加起来</li><li>两个负 取绝对值最大</li></ol><h2 id="父类高度塌陷问题"><a href="#父类高度塌陷问题" class="headerlink" title="父类高度塌陷问题"></a>父类高度塌陷问题</h2><p>如果子元素都是浮动</p><ol><li>直接给父元素设置高度，在子元素改变的情况下，此方法使用起来比较繁杂。</li><li>给父元素直接设置 overflow:hidden;样式 </li><li>父元结束标签之前加空div，样式为 clear：both； </li><li>伪元素选择器,父元素加上clearfix</li></ol><h2 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">伪类  :link  :hover         伪元素  ::before    ::after</span><br></pre></td></tr></table></figure><p>其中伪类和伪元素的根本区别在于：它们是否创造了新的元素,,   这个新创造的元素就叫  “伪无素” 。<br>伪元素/伪对象：不存在在DOM文档中，是虚拟的元素，是创建新元素。 这个新元素(伪元素)  是某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中.<br>伪类：存在DOM文档中，(无标签,找不到,  只有符合触发条件时才能看到 ),  逻辑上存在但在文档树中却无须标识的“幽灵”分类。</p><h2 id="css继承"><a href="#css继承" class="headerlink" title="css继承"></a>css继承</h2><p>只有颜色，文字，字体间距行高对齐方式，和列表的样式可以继承<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220225154948.png" alt=""></p><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><h2 id="GUI线程和JS线程"><a href="#GUI线程和JS线程" class="headerlink" title="GUI线程和JS线程"></a>GUI线程和JS线程</h2><h2 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h2><h2 id="性能指标，怎么看"><a href="#性能指标，怎么看" class="headerlink" title="性能指标，怎么看"></a>性能指标，怎么看</h2><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h1 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h1><h2 id="node和java有什么区别"><a href="#node和java有什么区别" class="headerlink" title="node和java有什么区别"></a>node和java有什么区别</h2><h2 id="node单线程相比java的优点"><a href="#node单线程相比java的优点" class="headerlink" title="node单线程相比java的优点"></a>node单线程相比java的优点</h2><h2 id="node怎么开启多线程"><a href="#node怎么开启多线程" class="headerlink" title="node怎么开启多线程"></a>node怎么开启多线程</h2><h2 id="node洋葱模型"><a href="#node洋葱模型" class="headerlink" title="node洋葱模型"></a>node洋葱模型</h2><h2 id="BFF的理解"><a href="#BFF的理解" class="headerlink" title="BFF的理解"></a>BFF的理解</h2><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="二维码扫描多端登录设计思路"><a href="#二维码扫描多端登录设计思路" class="headerlink" title="二维码扫描多端登录设计思路"></a>二维码扫描多端登录设计思路</h2><h2 id="项目数据库设计"><a href="#项目数据库设计" class="headerlink" title="项目数据库设计"></a>项目数据库设计</h2><h2 id="原生设计一个dialog，需要设计哪些部分"><a href="#原生设计一个dialog，需要设计哪些部分" class="headerlink" title="原生设计一个dialog，需要设计哪些部分"></a>原生设计一个dialog，需要设计哪些部分</h2><h2 id="设计一个中间件"><a href="#设计一个中间件" class="headerlink" title="设计一个中间件"></a>设计一个中间件</h2><h1 id="CICD"><a href="#CICD" class="headerlink" title="CICD"></a>CICD</h1><h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><h2 id="nginx主要是做什么的"><a href="#nginx主要是做什么的" class="headerlink" title="nginx主要是做什么的"></a>nginx主要是做什么的</h2><p>静态资源缓存hash，gzip，负载均衡，超时连接</p><h2 id="nginx怎么代理websocket，有什么问题"><a href="#nginx怎么代理websocket，有什么问题" class="headerlink" title="nginx怎么代理websocket，有什么问题"></a>nginx怎么代理websocket，有什么问题</h2><h2 id="nginx怎么开启gzip"><a href="#nginx怎么开启gzip" class="headerlink" title="nginx怎么开启gzip"></a>nginx怎么开启gzip</h2><h2 id="nginx真的解决了跨域吗"><a href="#nginx真的解决了跨域吗" class="headerlink" title="nginx真的解决了跨域吗"></a>nginx真的解决了跨域吗</h2><p>服务端和服务端之间不存在跨域</p><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试指南" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Javascript——自检篇</title>
    <link href="https://zlinni.github.io/posts/2576354353/"/>
    <id>https://zlinni.github.io/posts/2576354353/</id>
    <published>2022-08-07T02:23:45.000Z</published>
    <updated>2022-08-22T07:20:24.834Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>记录 js 输出问题过程和知识点解答</p></div><h1 id="1-暂时性死区和变量提升"><a href="#1-暂时性死区和变量提升" class="headerlink" title="1 暂时性死区和变量提升"></a>1 暂时性死区和变量提升</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi();</span><br></pre></td></tr></table></figure><ul><li>A: Lydia 和 undefined</li><li>B: Lydia 和 ReferenceError</li><li>C: ReferenceError 和 21</li><li>D: undefined 和 ReferenceError</li></ul><details><summary>答案</summary>D let，const 声明前读取有暂时性死区，js 抛出`ReferenceError` 变量提升 `undefined`置顶</details><h1 id="2-作用域以及事件循环"><a href="#2-作用域以及事件循环" class="headerlink" title="2 作用域以及事件循环"></a>2 作用域以及事件循环</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A: 0 1 2 和 0 1 2</li><li>B: 0 1 2 和 3 3 3</li><li>C: 3 3 3 和 0 1 2</li></ul><details><summary>答案</summary>由于 js 的事件循环机制，settimeout 的内容是在循环结束才输出的，第一个 i 声明用的是 var 此时 i 是在全局作用域，也就是我们一直递增到 3 结束循环才输出 settimeout 的内容，也就是 333第二点由于下面是 let 声明的块级作用域，每次循环都会产生新值，所以 setimeout 的时候，i 拿到的是当前作用域里面的值，也就是 012</details><h1 id="3-箭头函数和常规函数的-this"><a href="#3-箭头函数和常规函数的-this" class="headerlink" title="3 箭头函数和常规函数的 this"></a>3 箭头函数和常规函数的 this</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shape = &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="function"><span class="title">diameter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.radius * <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">perimeter</span>: <span class="function">() =&gt;</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * <span class="built_in">this</span>.radius,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">shape.diameter();</span><br><span class="line">shape.perimeter();</span><br></pre></td></tr></table></figure><ul><li>A: 20 and 62.83185307179586</li><li>B: 20 and NaN</li><li>C: 20 and 63</li><li>D: NaN and 63</li></ul><details><summary>答案</summary>shape 调用了 diameter 常规函数，所以 this 指向 shape，读的到 radiusperimeter 是一个箭头函数，对于该函数的 this 指向的是它的周围作用域，也就是包含箭头函数的常规函数，如果没有，就是 window很明显此处没有常规函数包装它，于是指向 window，window 上没有这个属性，对于 undefined+数字输出的是 NaN</details><h1 id="4-值转换"><a href="#4-值转换" class="headerlink" title="4 值转换"></a>4 值转换</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+<span class="literal">true</span>;</span><br><span class="line">!<span class="string">&quot;Lydia&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>A: 1 and false</li><li>B: false and NaN</li><li>C: false and false</li></ul><details><summary>答案</summary>A 注意+还可以转换 string，相当于`Number()`的效果</details><h1 id="5-对象运算优先级"><a href="#5-对象运算优先级" class="headerlink" title="5 对象运算优先级"></a>5 对象运算优先级</h1><p>哪一个是无效的？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bird = &#123;</span><br><span class="line">  <span class="attr">size</span>: <span class="string">&quot;small&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mouse = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Mickey&quot;</span>,</span><br><span class="line">  <span class="attr">small</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>A: mouse.bird.size</li><li>B: mouse[bird.size]</li><li>C: mouse[bird[“size”]]</li><li>D: All of them are valid</li></ul><details><summary>答案</summary>A 先计算括号里面的，如果没有括号链式计算，显然 A 是没有 bird 的</details><h1 id="6-对象相等时地址相同"><a href="#6-对象相等时地址相同" class="headerlink" title="6 对象相等时地址相同"></a>6 对象相等时地址相同</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = &#123; <span class="attr">greeting</span>: <span class="string">&quot;Hey!&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> d;</span><br><span class="line"></span><br><span class="line">d = c;</span><br><span class="line">c.greeting = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(d.greeting);</span><br></pre></td></tr></table></figure><ul><li>A: Hello</li><li>B: undefined</li><li>C: ReferenceError</li><li>D: TypeError</li></ul><details><summary>答案</summary>A 此时内存中的地址相同</details><h1 id="7-和-以及-new-对象"><a href="#7-和-以及-new-对象" class="headerlink" title="7 ==和===以及 new 对象"></a>7 <code>==</code>和<code>===</code>以及 new 对象</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a == b);</span><br><span class="line"><span class="built_in">console</span>.log(a === b);</span><br><span class="line"><span class="built_in">console</span>.log(b === c);</span><br></pre></td></tr></table></figure><ul><li>A: true false true</li><li>B: false false true</li><li>C: true false false</li><li>D: false true true</li></ul><details><summary>答案</summary>C new Number()是新建了一个对象==的时候比较值 所以相同===的时候比较值和类型，所以对象不同于 number</details><h1 id="8-静态方法的调用"><a href="#8-静态方法的调用" class="headerlink" title="8 静态方法的调用"></a>8 静态方法的调用</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chameleon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">colorChange</span>(<span class="params">newColor</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.newColor = newColor;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.newColor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">&#123; newColor = <span class="string">&quot;green&quot;</span> &#125; = &#123;&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.newColor = newColor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> freddie = <span class="keyword">new</span> Chameleon(&#123; <span class="attr">newColor</span>: <span class="string">&quot;purple&quot;</span> &#125;);</span><br><span class="line">freddie.colorChange(<span class="string">&quot;orange&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>A: orange</li><li>B: purple</li><li>C: green</li><li>D: TypeError</li></ul><details><summary>答案</summary>静态方法只能被类调用，不能被实例调用</details><h1 id="9-不声明变量直接赋值"><a href="#9-不声明变量直接赋值" class="headerlink" title="9 不声明变量直接赋值"></a>9 不声明变量直接赋值</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting;</span><br><span class="line">greetign = &#123;&#125;; <span class="comment">// Typo!</span></span><br><span class="line"><span class="built_in">console</span>.log(greetign);</span><br></pre></td></tr></table></figure><ul><li>A: {}</li><li>B: ReferenceError: greetign is not defined</li><li>C: undefined</li></ul><details><summary>答案</summary>A 可以使用`use Strict`确保声明变量的时候必须赋值</details><h1 id="10-给函数添加属性"><a href="#10-给函数添加属性" class="headerlink" title="10 给函数添加属性"></a>10 给函数添加属性</h1><p>当我们这么做时，会发生什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bark</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bark.animal = <span class="string">&quot;dog&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>A: 正常运行!</li><li>B: SyntaxError. 你不能通过这种方式给函数增加属性。</li><li>C: undefined</li><li>D: ReferenceError</li></ul><details> <summary>答案</summary>A js 一切皆对象</details><h1 id="11-构造函数添加方法"><a href="#11-构造函数添加方法" class="headerlink" title="11 构造函数添加方法"></a>11 构造函数添加方法</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">  <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> member = <span class="keyword">new</span> Person(<span class="string">&quot;Lydia&quot;</span>, <span class="string">&quot;Hallie&quot;</span>);</span><br><span class="line">Person.getFullName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(member.getFullName());</span><br></pre></td></tr></table></figure><ul><li>A: TypeError</li><li>B: SyntaxError</li><li>C: Lydia Hallie</li><li>D: undefined undefined</li></ul><details><summary>答案</summary>A 不能像常规对象一样给构造函数添加属性，要想添加属性必须这样写<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.getFullName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>这样才能给所有的实例添加对应的属性。原因是：如果我们可以直接添加方法到构造函数中，那么所有的 Person 实例上都拥有这个方法，对于不需要这个方法的实例，会浪费大量的空间内存。如果添加到原型上面，实例只有在需要这个方法的时候，才会去原型上面找，不占据自身的空间。只在原型中占一个位置，但所有实例都可以访问。</details><h1 id="12-new-和不-new"><a href="#12-new-和不-new" class="headerlink" title="12 new 和不 new"></a>12 new 和不 new</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">  <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lydia = <span class="keyword">new</span> Person(<span class="string">&quot;Lydia&quot;</span>, <span class="string">&quot;Hallie&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> sarah = Person(<span class="string">&quot;Sarah&quot;</span>, <span class="string">&quot;Smith&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lydia);</span><br><span class="line"><span class="built_in">console</span>.log(sarah);</span><br></pre></td></tr></table></figure><ul><li>A: Person {firstName: “Lydia”, lastName: “Hallie”} and undefined</li><li>B: Person {firstName: “Lydia”, lastName: “Hallie”} and Person {firstName: “Sarah”, lastName: “Smith”}</li><li>C: Person {firstName: “Lydia”, lastName: “Hallie”} and {}</li><li>D: Person {firstName: “Lydia”, lastName: “Hallie”} and ReferenceError</li></ul><details><summary>答案</summary>new 的时候 this 默认引用我们创建的空对象不 new 的时候 this 默认引用 window，也就是实际上`window.firstName = Sarah`，但 sarah 还是 undefined</details><h1 id="13-事件传播的三个阶段是什么？"><a href="#13-事件传播的三个阶段是什么？" class="headerlink" title="13 事件传播的三个阶段是什么？"></a>13 事件传播的三个阶段是什么？</h1><ul><li>A: Target &gt; Capturing &gt; Bubbling</li><li>B: Bubbling &gt; Target &gt; Capturing</li><li>C: Target &gt; Bubbling &gt; Capturing</li><li>D: Capturing &gt; Target &gt; Bubbling</li></ul><details><summary>答案</summary>D 在捕获阶段中，事件从祖先元素向下传播到目标元素。当事件到达目标后，冒泡才开始</details><h1 id="14-所有对象都有原型？"><a href="#14-所有对象都有原型？" class="headerlink" title="14 所有对象都有原型？"></a>14 所有对象都有原型？</h1><ul><li>A: true</li><li>B: false</li></ul><details><summary>答案</summary>B 除了基本对象（base object），所有对象都有原型。基本对象可以访问一些方法和属性，比如 .toString。这就是为什么你可以使用内置的 JavaScript 方法！所有这些方法在原型上都是可用的。虽然 JavaScript 不能直接在对象上找到这些方法，但 JavaScript 会沿着原型链找到它们，以便于你使用。</details><h1 id="15-隐式类型转换"><a href="#15-隐式类型转换" class="headerlink" title="15 隐式类型转换"></a>15 隐式类型转换</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>A: NaN</li><li>B: TypeError</li><li>C: “12”</li><li>D: 3</li></ul><details><summary>答案</summary>C 隐式类型转换"12"</details><h1 id="16-运算符"><a href="#16-运算符" class="headerlink" title="16 运算符"></a>16 运算符</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number++);</span><br><span class="line"><span class="built_in">console</span>.log(++number);</span><br><span class="line"><span class="built_in">console</span>.log(number);</span><br></pre></td></tr></table></figure><ul><li>A: 1 1 2</li><li>B: 1 2 2</li><li>C: 0 2 2</li><li>D: 0 1 2<br><details><summary>答案</summary></li></ul><p>C</p><p>&lt;/details&gt;</p><h1 id="17-标记模板字面量"><a href="#17-标记模板字面量" class="headerlink" title="17 标记模板字面量"></a>17 标记模板字面量</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPersonInfo</span>(<span class="params">one, two, three</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(one);</span><br><span class="line">  <span class="built_in">console</span>.log(two);</span><br><span class="line">  <span class="built_in">console</span>.log(three);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">getPersonInfo<span class="string">`<span class="subst">$&#123;person&#125;</span> is <span class="subst">$&#123;age&#125;</span> years old`</span>;</span><br></pre></td></tr></table></figure><ul><li>A: “Lydia” 21 [“”, “ is “, “ years old”]</li><li>B: [“”, “ is “, “ years old”] “Lydia” 21</li><li>C: “Lydia” [“”, “ is “, “ years old”] 21</li></ul><details><summary>答案</summary>B 当函数调用的时候提供标记模板字面量，那么优先将模板的数组传入，随之传入的是其中的变量</details><h1 id="18-比较对象"><a href="#18-比较对象" class="headerlink" title="18 比较对象"></a>18 比较对象</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data === &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;You are an adult!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data == &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;You are still an adult.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hmm.. You don&#x27;t have an age I guess`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkAge(&#123; <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br></pre></td></tr></table></figure><ul><li>A: You are an adult!</li><li>B: You are still an adult.</li><li>C: Hmm.. You don’t have an age I guess</li></ul><details><summary>答案</summary>C 对象不能直接比较相等性，需要对每层对象递归比较才行</details><h1 id="19-拓展运算符"><a href="#19-拓展运算符" class="headerlink" title="19 拓展运算符"></a>19 拓展运算符</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge(<span class="number">21</span>);</span><br></pre></td></tr></table></figure><ul><li>A: “number”</li><li>B: “array”</li><li>C: “object”</li><li>D: “NaN”</li></ul><details><summary>答案</summary>C 拓展运算符返回的是实参组成的数组，因此结果是object</details><h1 id="20-use-strict"><a href="#20-use-strict" class="headerlink" title="20 use strict"></a>20 use strict</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  age = <span class="number">21</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge();</span><br></pre></td></tr></table></figure><p>A: 21<br>B: undefined<br>C: ReferenceError<br>D: TypeError</p><details><summary>答案</summary>C use strict表明下面的变量必须在声明之后赋值，否则抛出指向异常</details><h1 id="21-eval"><a href="#21-eval" class="headerlink" title="21 eval"></a>21 eval</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="built_in">eval</span>(<span class="string">&quot;10*10+5&quot;</span>);</span><br></pre></td></tr></table></figure><p>A: 105<br>B: “105”<br>C: TypeError<br>D: “10*10+5”</p><details><summary>答案</summary>A 代码以字符串的形式传递进来，eval对其求值，如果它是一个表达式，就对表达式求值，返回结果number的105</details><h1 id="22-sessionStorage"><a href="#22-sessionStorage" class="headerlink" title="22 sessionStorage"></a>22 sessionStorage</h1><p>cool_secret 可访问多长时间？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(<span class="string">&quot;cool_secret&quot;</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>A: 永远，数据不会丢失。<br>B: 当用户关掉标签页时。<br>C: 当用户关掉整个浏览器，而不只是关掉标签页。<br>D: 当用户关闭电脑时。</p><details><summary>答案</summary>B</details><h1 id="23-var"><a href="#23-var" class="headerlink" title="23 var"></a>23 var</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure><p>A: 8<br>B: 10<br>C: SyntaxError<br>D: ReferenceError</p><details><summary>答案</summary>B 新值覆盖旧值 但const let不行</details><h1 id="24-对象键和set集合"><a href="#24-对象键和set集合" class="headerlink" title="24 对象键和set集合"></a>24 对象键和set集合</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">1</span>: <span class="string">&quot;a&quot;</span>, <span class="number">2</span>: <span class="string">&quot;b&quot;</span>, <span class="number">3</span>: <span class="string">&quot;c&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">obj.hasOwnProperty(<span class="number">1</span>);</span><br><span class="line">set.has(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">set.has(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>A: false true false true<br>B: false true true true<br>C: true true false true<br>D: true true true true</p><details><summary>答案</summary>C 对象的键始终是字符串。set集合是根据输入的参数决定</details><h1 id="25-同名的键"><a href="#25-同名的键" class="headerlink" title="25 同名的键"></a>25 同名的键</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="string">&quot;one&quot;</span>, <span class="attr">b</span>: <span class="string">&quot;two&quot;</span>, <span class="attr">a</span>: <span class="string">&quot;three&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><p>A: { a: “one”, b: “two” }<br>B: { b: “two”, a: “three” }<br>C: { a: “three”, b: “two” }<br>D: SyntaxError</p><details><summary>答案</summary>C 如果有两个同名的键，新值会替换旧值，但是键还是在原来的位置</details><h1 id="26-全局执行上下文"><a href="#26-全局执行上下文" class="headerlink" title="26 全局执行上下文"></a>26 全局执行上下文</h1><p>JavaScript 全局执行上下文为你做了两件事：全局对象和 this 关键字。</p><p>A: true<br>B: false<br>C: it depends</p><details><summary>答案</summary>A</details><h1 id="27-continue"><a href="#27-continue" class="headerlink" title="27 continue"></a>27 continue</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A: 1 2<br>B: 1 2 3<br>C: 1 2 4<br>D: 1 3 4</p><details><summary>答案</summary>C continue跳过本次迭代</details><h1 id="28-访问原型添加的方法"><a href="#28-访问原型添加的方法" class="headerlink" title="28 访问原型添加的方法"></a>28 访问原型添加的方法</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.giveLydiaPizza = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Just give Lydia pizza already!&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line"></span><br><span class="line">name.giveLydiaPizza();</span><br></pre></td></tr></table></figure><p>A: “Just give Lydia pizza already!”<br>B: TypeError: not a function<br>C: SyntaxError<br>D: undefined</p><details><summary>答案</summary>A 我们向String的原型添加了一个方法，所以下面所属的string对象都可以访问该方法</details><h1 id="29-对象转字符串"><a href="#29-对象转字符串" class="headerlink" title="29 对象转字符串"></a>29 对象转字符串</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">key</span>: <span class="string">&quot;b&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123; <span class="attr">key</span>: <span class="string">&quot;c&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">a[b] = <span class="number">123</span>;</span><br><span class="line">a[c] = <span class="number">456</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br></pre></td></tr></table></figure><p>A: 123<br>B: 456<br>C: undefined<br>D: ReferenceError</p><details><summary>答案</summary>B a在使用b这个键的时候，把b自动转为了字符串，也就是`[object object]`且这个值对应为123第二次转为456输出的时候 也就是456了考察的是对象转字符串</details><h1 id="30-事件循环"><a href="#30-事件循环" class="headerlink" title="30 事件循环"></a>30 事件循环</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;First&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> bar = <span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Second&quot;</span>));</span><br><span class="line"><span class="keyword">const</span> baz = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Third&quot;</span>);</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line">foo();</span><br><span class="line">baz();</span><br></pre></td></tr></table></figure><p>A: First Second Third<br>B: First Third Second<br>C: Second First Third<br>D: Second Third First</p><details><summary>答案</summary>B 事件循环</details><h1 id="31-事件target"><a href="#31-事件target" class="headerlink" title="31 事件target"></a>31 事件target</h1><p>当点击按钮时，event.target 是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onclick=<span class="string">&quot;console.log(&#x27;first div&#x27;)&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;second div&#x27;)&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;button&#x27;)&quot;</span>&gt;</span>Click!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>A: Outer div<br>B: Inner div<br>C: button<br>D: 一个包含所有嵌套元素的数组。</p><details><summary>答案</summary>C 导致事件的最深嵌套元素是事件的target。可以通过`event.stopPropagation`来停止冒泡</details><h1 id="32-事件执行"><a href="#32-事件执行" class="headerlink" title="32 事件执行"></a>32 事件执行</h1><p>当您单击该段落时，日志输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onclick=<span class="string">&quot;console.log(&#x27;div&#x27;)&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;p&#x27;)&quot;</span>&gt;</span>Click here!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>A: p div<br>B: div p<br>C: p<br>D: div</p><details><summary>答案</summary>A 捕获 目标 冒泡默认情况下事件将在冒泡阶段执行除非设置`useCapture:true`</details><h1 id="33-call-和-bind"><a href="#33-call-和-bind" class="headerlink" title="33 call 和 bind"></a>33 call 和 bind</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is <span class="subst">$&#123;age&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi.call(person, <span class="number">21</span>);</span><br><span class="line">sayHi.bind(person, <span class="number">21</span>);</span><br></pre></td></tr></table></figure><p>A: undefined is 21 Lydia is 21<br>B: function function<br>C: Lydia is 21 Lydia is 21<br>D: Lydia is 21 function</p><details><summary>答案</summary>C`.call`绑定的是立刻执行的`bind`返回的是一个函数 需要去执行该函数才可以</details><h1 id="34-typeof-IIFE"><a href="#34-typeof-IIFE" class="headerlink" title="34 typeof IIFE"></a>34 typeof IIFE</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function">() =&gt;</span> <span class="number">0</span>)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> sayHi();</span><br></pre></td></tr></table></figure><p>A: “object”<br>B: “number”<br>C: “function”<br>D: “undefined”</p><details><summary>答案</summary>B sayHi返回的是IIFE的返回值 具体是0 所以是number</details><h1 id="35-falsy"><a href="#35-falsy" class="headerlink" title="35 falsy"></a>35 falsy</h1><p>下面哪些值是 falsy?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">0</span>)</span><br><span class="line">(<span class="string">&quot;&quot;</span>)</span><br><span class="line">(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><p>A: 0, ‘’, undefined<br>B: 0, new Number(0), ‘’, new Boolean(false), undefined<br>C: 0, ‘’, new Boolean(false), undefined<br>D: All of them are falsy</p><details><summary>答案</summary>A new xxx是对象 是truthy，非空字符串也是truthy</details><h1 id="36-typeof-typeof"><a href="#36-typeof-typeof" class="headerlink" title="36 typeof typeof"></a>36 typeof typeof</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;number&quot;</span>;</span><br><span class="line">B: <span class="string">&quot;string&quot;</span>;</span><br><span class="line">C: <span class="string">&quot;object&quot;</span>;</span><br><span class="line">D: <span class="string">&quot;undefined&quot;</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B</details><h1 id="37-设置数组值超过数组长度"><a href="#37-设置数组值超过数组长度" class="headerlink" title="37 设置数组值超过数组长度"></a>37 设置数组值超过数组长度</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">numbers[<span class="number">10</span>] = <span class="number">11</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers)</span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span> x <span class="literal">null</span>, <span class="number">11</span>]</span><br><span class="line"><span class="attr">B</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">11</span>]</span><br><span class="line"><span class="attr">C</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span> x empty, <span class="number">11</span>]</span><br><span class="line"><span class="attr">D</span>: <span class="built_in">SyntaxError</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 当设置的数组值超过数组长度的时候，会自动生成一系列的undefined 这里也就是显示了七个空</details><h1 id="38-catch接收"><a href="#38-catch接收" class="headerlink" title="38 catch接收"></a>38 catch接收</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> x, y</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (x) &#123;</span><br><span class="line">    (x = <span class="number">1</span>), (y = <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">  <span class="built_in">console</span>.log(y)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: <span class="number">1</span> <span class="literal">undefined</span> <span class="number">2</span></span><br><span class="line"><span class="attr">B</span>: <span class="literal">undefined</span> <span class="literal">undefined</span> <span class="literal">undefined</span></span><br><span class="line"><span class="attr">C</span>: <span class="number">1</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="attr">D</span>: <span class="number">1</span> <span class="literal">undefined</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>catch接收的参数x不是实际的x。这个x是属于catch块级作用域的，然后把块级作用域的变量赋为1，同时也设置了y的值 所以输出1 然后下面的x没有赋值是undefined 然后是2</details><h1 id="39-JavaScript-中的一切都是？"><a href="#39-JavaScript-中的一切都是？" class="headerlink" title="39 JavaScript 中的一切都是？"></a>39 JavaScript 中的一切都是？</h1><p>JavaScript 中的一切都是？<br>A: 基本类型与对象<br>B: 函数与对象<br>C: 只有对象<br>D: 数字与对象</p><details><summary>答案</summary>A</details><h1 id="40-reduce"><a href="#40-reduce" class="headerlink" title="40 reduce"></a>40 reduce</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">].reduce(</span><br><span class="line">  <span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> acc.concat(cur);</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">A: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">B: [<span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">C: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">D: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C</details><h1 id="41"><a href="#41" class="headerlink" title="41 !!"></a>41 !!</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">!!<span class="literal">null</span></span><br><span class="line">!!<span class="string">&#x27;&#x27;</span></span><br><span class="line">!!<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: <span class="literal">false</span> <span class="literal">true</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">B</span>: <span class="literal">false</span> <span class="literal">false</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">C</span>: <span class="literal">false</span> <span class="literal">true</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">D</span>: <span class="literal">true</span> <span class="literal">true</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>B</details><h1 id="42-setInterval"><a href="#42-setInterval" class="headerlink" title="42 setInterval"></a>42 setInterval</h1><p>setInterval<br>方法的返回值是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">A: 一个唯一的id;</span><br><span class="line">B: 该方法指定的毫秒数;</span><br><span class="line">C: 传递的函数;</span><br><span class="line">D: <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A</details><h1 id="43-拓展运算符"><a href="#43-拓展运算符" class="headerlink" title="43 拓展运算符"></a>43 拓展运算符</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">&quot;Lydia&quot;</span>];</span><br><span class="line"></span><br><span class="line">A: [<span class="string">&quot;L&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;a&quot;</span>];</span><br><span class="line">B: [<span class="string">&quot;Lydia&quot;</span>];</span><br><span class="line">C: [[], <span class="string">&quot;Lydia&quot;</span>];</span><br><span class="line">D: [[<span class="string">&quot;L&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;a&quot;</span>]];</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A string是可迭代的</details><h1 id="44-generator"><a href="#44-generator" class="headerlink" title="44 generator"></a>44 generator</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> i;</span><br><span class="line">  <span class="keyword">yield</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = generator(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: [<span class="number">0</span>, <span class="number">10</span>], [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="attr">B</span>: <span class="number">20</span>, <span class="number">20</span></span><br><span class="line"><span class="attr">C</span>: <span class="number">10</span>, <span class="number">20</span></span><br><span class="line"><span class="attr">D</span>: <span class="number">0</span>, <span class="number">10</span> and <span class="number">10</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>C generator会停下，直到调用下一个next</details><h1 id="45-Promise-race"><a href="#45-Promise-race" class="headerlink" title="45 Promise.race"></a>45 <code>Promise.race</code></h1><p>返回值是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(res, <span class="number">500</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> secondPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(res, <span class="number">100</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([firstPromise, secondPromise]).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="attr">B</span>: <span class="string">&quot;two&quot;</span></span><br><span class="line"><span class="attr">C</span>: <span class="string">&quot;two&quot;</span> <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="attr">D</span>: <span class="string">&quot;one&quot;</span> <span class="string">&quot;two&quot;</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>race中有一个状态优先改变就输出改变的那一个这里是two 因为他只用100ms另外any 是其中一个变成fulfilled就返回成功，全部都失败才返回失败all是全部成功才返回成功，一个失败就返回失败，相当于any的相反allSettled会等全部执行完，不会因为失败终止</details><h1 id="46-引用交互"><a href="#46-引用交互" class="headerlink" title="46 引用交互"></a>46 引用交互</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> members = [person];</span><br><span class="line">person = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(members);</span><br><span class="line"></span><br><span class="line">A: <span class="literal">null</span>;</span><br><span class="line">B: [<span class="literal">null</span>];</span><br><span class="line">C: [&#123;&#125;];</span><br><span class="line">D: [&#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;];</span><br></pre></td></tr></table></figure><details><summary>答案</summary>D members的第一个元素拷贝了person，但并不是保持着引用，所以最后即使person变了它还是不会变注意只有对象和对象之间才有引用交互</details><h1 id="47-forin"><a href="#47-forin" class="headerlink" title="47 forin"></a>47 forin</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">21</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br><span class="line"><span class="attr">B</span>: <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="attr">C</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="number">21</span></span><br><span class="line"><span class="attr">D</span>: [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Lydia&quot;</span>], [<span class="string">&quot;age&quot;</span>, <span class="number">21</span>]</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B</details><h1 id="48-运算"><a href="#48-运算" class="headerlink" title="48 运算"></a>48 运算</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + <span class="number">4</span> + <span class="string">&quot;5&quot;</span>);</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;345&quot;</span>;</span><br><span class="line">B: <span class="string">&quot;75&quot;</span>;</span><br><span class="line">C: <span class="number">12</span>;</span><br><span class="line">D: <span class="string">&quot;12&quot;</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B</details><h1 id="49-parseInt"><a href="#49-parseInt" class="headerlink" title="49 parseInt"></a>49 parseInt</h1><p>num 是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="built_in">parseInt</span>(<span class="string">&quot;7*6&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">A: <span class="number">42</span>;</span><br><span class="line">B: <span class="string">&quot;42&quot;</span>;</span><br><span class="line">C: <span class="number">7</span>;</span><br><span class="line">D: <span class="literal">NaN</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>parseInt两个参数，一个是解析的参数，另外一个是进制。这里设置了十进制。然后解析7*6由于*不合法，直接解析出7</details><h1 id="50-map"><a href="#50-map" class="headerlink" title="50 map"></a>50 map</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> num === <span class="string">&quot;number&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">A: []</span><br><span class="line"><span class="attr">B</span>: [<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>]</span><br><span class="line"><span class="attr">C</span>: [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>]</span><br><span class="line"><span class="attr">D</span>: [ <span class="number">3</span> x empty ]</span><br></pre></td></tr></table></figure><details><summary>答案</summary>map创建新的值返回给数组，由于数组全是数字所以第一个if永远成立，所以返回undefined</details><h1 id="51-值与引用"><a href="#51-值与引用" class="headerlink" title="51 值与引用"></a>51 值与引用</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">member, year</span>) </span>&#123;</span><br><span class="line">  member.name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line">  year = <span class="string">&quot;1998&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Sarah&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> birthYear = <span class="string">&quot;1997&quot;</span>;</span><br><span class="line"></span><br><span class="line">getInfo(person, birthYear);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person, birthYear);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;, <span class="string">&quot;1997&quot;</span></span><br><span class="line"><span class="attr">B</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Sarah&quot;</span> &#125;, <span class="string">&quot;1998&quot;</span></span><br><span class="line"><span class="attr">C</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;, <span class="string">&quot;1998&quot;</span></span><br><span class="line"><span class="attr">D</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Sarah&quot;</span> &#125;, <span class="string">&quot;1997&quot;</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>A 对象传递是引用传递，普通参数都是值传递。值传递是一份拷贝birthYear是一个值，所以函数内部的形参怎么变都不会影响到外部的birthYearperson是一个对象，传递了引用关系，函数内部改变了它的引用，所以person也变化了</details><h1 id="52-throw"><a href="#52-throw" class="headerlink" title="52 throw"></a>52 throw</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = greeting();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;It worked!&quot;</span>, data);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Oh no an error!&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi();</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;It worked! Hello world!&quot;</span></span><br><span class="line"><span class="attr">B</span>: <span class="string">&quot;Oh no an error: undefined</span></span><br><span class="line"><span class="string">C: SyntaxError: can only throw Error objects</span></span><br><span class="line"><span class="string">D: &quot;</span>Oh no an error: Hello world!</span><br></pre></td></tr></table></figure><details><summary>答案</summary>D throw可以自定义错误，异常可以是一个字符串，一个数字，一个布尔类型，或者是一个对象。本例子中是`Hello world`</details><h1 id="53-构造函数中的返回值"><a href="#53-构造函数中的返回值" class="headerlink" title="53 构造函数中的返回值"></a>53 构造函数中的返回值</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.make = <span class="string">&quot;Lamborghini&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">make</span>: <span class="string">&quot;Maserati&quot;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myCar = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="built_in">console</span>.log(myCar.make);</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;Lamborghini&quot;</span>;</span><br><span class="line">B: <span class="string">&quot;Maserati&quot;</span>;</span><br><span class="line">C: <span class="built_in">ReferenceError</span>;</span><br><span class="line">D: <span class="built_in">TypeError</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B</details><h1 id="54-表达式执行顺序"><a href="#54-表达式执行顺序" class="headerlink" title="54 表达式执行顺序"></a>54 表达式执行顺序</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> x = (y = <span class="number">10</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> y);</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;undefined&quot;</span>, <span class="string">&quot;number&quot;</span>;</span><br><span class="line">B: <span class="string">&quot;number&quot;</span>, <span class="string">&quot;number&quot;</span>;</span><br><span class="line">C: <span class="string">&quot;object&quot;</span>, <span class="string">&quot;number&quot;</span>;</span><br><span class="line">D: <span class="string">&quot;number&quot;</span>, <span class="string">&quot;undefined&quot;</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A</details><h1 id="55-删除原型上的方法"><a href="#55-删除原型上的方法" class="headerlink" title="55 删除原型上的方法"></a>55 删除原型上的方法</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype.bark = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Woof I am <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pet = <span class="keyword">new</span> Dog(<span class="string">&quot;Mara&quot;</span>);</span><br><span class="line"></span><br><span class="line">pet.bark();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> Dog.prototype.bark;</span><br><span class="line"></span><br><span class="line">pet.bark();</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;Woof I am Mara&quot;</span>, <span class="built_in">TypeError</span>;</span><br><span class="line">B: <span class="string">&quot;Woof I am Mara&quot;</span>, <span class="string">&quot;Woof I am Mara&quot;</span>;</span><br><span class="line">C: <span class="string">&quot;Woof I am Mara&quot;</span>, <span class="literal">undefined</span>;</span><br><span class="line">D: <span class="built_in">TypeError</span>, <span class="built_in">TypeError</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A 当调用一个不存在的函数会抛出TypeError异常</details><h1 id="56-set返回值"><a href="#56-set返回值" class="headerlink" title="56 set返回值"></a>56 set返回值</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set);</span><br><span class="line"></span><br><span class="line">A: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">B: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">C: &#123;</span><br><span class="line">  <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">D</span>: &#123;</span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>D 返回Set(4) { 1, 2, 3, 4 }</details><h1 id="57-读取模块"><a href="#57-读取模块" class="headerlink" title="57 读取模块"></a>57 读取模块</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// counter.js</span></span><br><span class="line"><span class="keyword">let</span> counter = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> myCounter <span class="keyword">from</span> <span class="string">&quot;./counter&quot;</span>;</span><br><span class="line"></span><br><span class="line">myCounter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myCounter);</span><br><span class="line"></span><br><span class="line">A: <span class="number">10</span>;</span><br><span class="line">B: <span class="number">11</span>;</span><br><span class="line">C: <span class="built_in">Error</span>;</span><br><span class="line">D: <span class="literal">NaN</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 引入的模块是只读的。只有导出它们的模块才能修改其值</details><h1 id="58-delete"><a href="#58-delete" class="headerlink" title="58 delete"></a>58 delete</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line">age = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> name);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> age);</span><br><span class="line"></span><br><span class="line">A: <span class="literal">false</span>, <span class="literal">true</span>;</span><br><span class="line">B: <span class="string">&quot;Lydia&quot;</span>, <span class="number">21</span>;</span><br><span class="line">C: <span class="literal">true</span>, <span class="literal">true</span>;</span><br><span class="line">D: <span class="literal">undefined</span>, <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A delete返回一个布尔值，true成功fals而失败，只能删除对象的值，所以第一个抛出false，第二个值挂载到了window上， 所以是true</details><h1 id="59-解构赋值"><a href="#59-解构赋值" class="headerlink" title="59 解构赋值"></a>59 解构赋值</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> [y] = numbers;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(y);</span><br><span class="line"></span><br><span class="line">A: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]];</span><br><span class="line">B: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">C: <span class="number">1</span>;</span><br><span class="line">D: [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 数组的解构赋值按顺序赋值 所以是1</details><h1 id="60-拓展运算符组合对象"><a href="#60-拓展运算符组合对象" class="headerlink" title="60 拓展运算符组合对象"></a>60 拓展运算符组合对象</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> admin = &#123; <span class="attr">admin</span>: <span class="literal">true</span>, ...user &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(admin);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: &#123; <span class="attr">admin</span>: <span class="literal">true</span>, <span class="attr">user</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125; &#125;</span><br><span class="line"><span class="attr">B</span>: &#123; <span class="attr">admin</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br><span class="line"><span class="attr">C</span>: &#123; <span class="attr">admin</span>: <span class="literal">true</span>, <span class="attr">user</span>: [<span class="string">&quot;Lydia&quot;</span>, <span class="number">21</span>] &#125;</span><br><span class="line"><span class="attr">D</span>: &#123; <span class="attr">admin</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B</details><h1 id="61-Object-defineProperty"><a href="#61-Object-defineProperty" class="headerlink" title="61 Object.defineProperty"></a>61 <code>Object.defineProperty</code></h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;age&quot;</span>, &#123; <span class="attr">value</span>: <span class="number">21</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;, [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>]</span><br><span class="line"><span class="attr">B</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;, [<span class="string">&quot;name&quot;</span>]</span><br><span class="line"><span class="attr">C</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>&#125;, [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>]</span><br><span class="line"><span class="attr">D</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>&#125;, [<span class="string">&quot;age&quot;</span>]</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B `Object.defineProperty`给对象添加了一个属性，但是默认不可枚举不可修改。所以不会通过`Object.keys`显示出来</details><h1 id="62-JSON-stringfy"><a href="#62-JSON-stringfy" class="headerlink" title="62 JSON.stringfy"></a>62 <code>JSON.stringfy</code></h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> settings = &#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&quot;lydiahallie&quot;</span>,</span><br><span class="line">  <span class="attr">level</span>: <span class="number">19</span>,</span><br><span class="line">  <span class="attr">health</span>: <span class="number">90</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = <span class="built_in">JSON</span>.stringify(settings, [<span class="string">&quot;level&quot;</span>, <span class="string">&quot;health&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;&#123;&quot;</span>level<span class="string">&quot;:19, &quot;</span>health<span class="string">&quot;:90&#125;&quot;</span></span><br><span class="line"><span class="attr">B</span>: <span class="string">&quot;&#123;&quot;</span>username<span class="string">&quot;: &quot;</span>lydiahallie<span class="string">&quot;&#125;&quot;</span></span><br><span class="line"><span class="attr">C</span>: <span class="string">&quot;[&quot;</span>level<span class="string">&quot;, &quot;</span>health<span class="string">&quot;]&quot;</span></span><br><span class="line"><span class="attr">D</span>: <span class="string">&quot;&#123;&quot;</span>username<span class="string">&quot;: &quot;</span>lydiahallie<span class="string">&quot;, &quot;</span>level<span class="string">&quot;:19, &quot;</span>health<span class="string">&quot;:90&#125;&quot;</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>A `JSON.stringfy`的第二个参数是replacer 它可以是一个数组也可以是一个函数如果是一个数组，那么 只取到数组中的属性如果是一个函数，那么会遍历全部的值，函数的返回值会成为这个属性的值</details><h1 id="63-操作"><a href="#63-操作" class="headerlink" title="63 ++操作"></a>63 ++操作</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> increaseNumber = <span class="function">() =&gt;</span> num++;</span><br><span class="line"><span class="keyword">const</span> increasePassedNumber = <span class="function">(<span class="params">number</span>) =&gt;</span> number++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> num1 = increaseNumber();</span><br><span class="line"><span class="keyword">const</span> num2 = increasePassedNumber(num1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num1);</span><br><span class="line"><span class="built_in">console</span>.log(num2);</span><br><span class="line"></span><br><span class="line">A: <span class="number">10</span>, <span class="number">10</span>;</span><br><span class="line">B: <span class="number">10</span>, <span class="number">11</span>;</span><br><span class="line">C: <span class="number">11</span>, <span class="number">11</span>;</span><br><span class="line">D: <span class="number">11</span>, <span class="number">12</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A</details><h1 id="64-对象默认值与传递"><a href="#64-对象默认值与传递" class="headerlink" title="64 对象默认值与传递"></a>64 对象默认值与传递</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = &#123; <span class="attr">number</span>: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">x = &#123; ...value &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log((x.number *= <span class="number">2</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">multiply();</span><br><span class="line">multiply();</span><br><span class="line">multiply(value);</span><br><span class="line">multiply(value);</span><br><span class="line"></span><br><span class="line">A: <span class="number">20</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">160</span>;</span><br><span class="line">B: <span class="number">20</span>, <span class="number">40</span>, <span class="number">20</span>, <span class="number">40</span>;</span><br><span class="line">C: <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">40</span>;</span><br><span class="line">D: <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="number">20</span>, <span class="number">40</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 前面两次是形参默认值且解构，所以每次都是一样的`{number:10}` 因此都是20后面两次传递的是value 因为对象传递是引用 所以第一次20 第二次在第一次的基础上改 变40</details><h1 id="65-reduce"><a href="#65-reduce" class="headerlink" title="65 reduce"></a>65 reduce</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="built_in">console</span>.log(x, y));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: <span class="number">1</span> <span class="number">2</span> and <span class="number">3</span> <span class="number">3</span> and <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="attr">B</span>: <span class="number">1</span> <span class="number">2</span> and <span class="number">2</span> <span class="number">3</span> and <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="attr">C</span>: <span class="number">1</span> <span class="literal">undefined</span> and <span class="number">2</span> <span class="literal">undefined</span> and <span class="number">3</span> <span class="literal">undefined</span> and <span class="number">4</span> <span class="literal">undefined</span></span><br><span class="line"><span class="attr">D</span>: <span class="number">1</span> <span class="number">2</span> and <span class="literal">undefined</span> <span class="number">3</span> and <span class="literal">undefined</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>reduce有四个参数* acc 累加器* cur 当前值* idx 当前索引* src 源数组此时1是累加器 2是当前值 此时打印是console 所以默认返回undefined 下一次累加器则是undefined 所以 第二次 undefined 3第三次 undefined 4结束</details><h1 id="66-继承"><a href="#66-继承" class="headerlink" title="66 继承"></a>66 继承</h1><p>使用哪个构造函数可以成功继承 Dog 类?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Labrador</span> <span class="keyword">extends</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, size</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, size</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">size</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, size</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: <span class="number">1</span></span><br><span class="line"><span class="attr">B</span>: <span class="number">2</span></span><br><span class="line"><span class="attr">C</span>: <span class="number">3</span></span><br><span class="line"><span class="attr">D</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>B super在使用之前不能访问this关键字 否则抛出ReferenceError错误。使用super 需要构造函数传递相应的参数给super。这里传递name</details><h1 id="67-import"><a href="#67-import" class="headerlink" title="67 import"></a>67 import</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;running index.js&#x27;</span>);</span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&#x27;./sum.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;running sum.js&#x27;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: running index.js, running sum.js, <span class="number">3</span></span><br><span class="line"><span class="attr">B</span>: running sum.js, running index.js, <span class="number">3</span></span><br><span class="line"><span class="attr">C</span>: running sum.js, <span class="number">3</span>, running index.js</span><br><span class="line"><span class="attr">D</span>: running index.js, <span class="literal">undefined</span>, running sum.js</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B import会在编译的阶段执行，意味着被导入的模块会先运行，导入模块的文件会后运行。和 require不同 require是在运行时执行的 所以它可以根据需要加载依赖</details><h1 id="68-Symbol"><a href="#68-Symbol" class="headerlink" title="68 Symbol"></a>68 Symbol</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="number">2</span>) === <span class="built_in">Number</span>(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">false</span>) === <span class="built_in">Boolean</span>(<span class="literal">false</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>) === <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line"></span><br><span class="line">A: <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>;</span><br><span class="line">B: <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>;</span><br><span class="line">C: <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>;</span><br><span class="line">D: <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A</details><h1 id="69-padStart"><a href="#69-padStart" class="headerlink" title="69 padStart"></a>69 padStart</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Lydia Hallie&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.padStart(<span class="number">13</span>));</span><br><span class="line"><span class="built_in">console</span>.log(name.padStart(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;Lydia Hallie&quot;</span>, <span class="string">&quot;Lydia Hallie&quot;</span>;</span><br><span class="line">B: <span class="string">&quot; Lydia Hallie&quot;</span>,</span><br><span class="line">  <span class="string">&quot; Lydia Hallie&quot;</span>(</span><br><span class="line">    <span class="string">&quot;[13x whitespace]Lydia Hallie&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[2x whitespace]Lydia Hallie&quot;</span></span><br><span class="line">  );</span><br><span class="line">C: <span class="string">&quot; Lydia Hallie&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Lydia Hallie&quot;</span>(<span class="string">&quot;[1x whitespace]Lydia Hallie&quot;</span>, <span class="string">&quot;Lydia Hallie&quot;</span>);</span><br><span class="line">D: <span class="string">&quot;Lydia Hallie&quot;</span>, <span class="string">&quot;Lyd&quot;</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C padStart api给字符串的前面添加空格，这个字符串的长度是12 现在输入13则添加一个空格 如果输入的小于它的长度则不添加</details><h1 id="70-emoji"><a href="#70-emoji" class="headerlink" title="70 emoji"></a>70 emoji</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;🥑&quot;</span> + <span class="string">&quot;💻&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;🥑💻&quot;</span></span><br><span class="line"><span class="attr">B</span>: <span class="number">257548</span></span><br><span class="line"><span class="attr">C</span>: A string containing their code points</span><br><span class="line"><span class="attr">D</span>: <span class="built_in">Error</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>A</details><h1 id="71-generator"><a href="#71-generator" class="headerlink" title="71 generator"></a>71 generator</h1><p>如何能打印出<br>console.log<br>语句后注释掉的值？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">startGame</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> answer = <span class="keyword">yield</span> <span class="string">&quot;Do you love JavaScript?&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (answer !== <span class="string">&quot;Yes&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Oh wow... Guess we&#x27;re gone here&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;JavaScript loves you back ❤️&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> game = startGame();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="comment">/* 1 */</span>); <span class="comment">// Do you love JavaScript?</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="comment">/* 2 */</span>); <span class="comment">// JavaScript loves you back ❤️</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: game.next(<span class="string">&quot;Yes&quot;</span>).value and game.next().value</span><br><span class="line"><span class="attr">B</span>: game.next.value(<span class="string">&quot;Yes&quot;</span>) and game.next.value()</span><br><span class="line"><span class="attr">C</span>: game.next().value and game.next(<span class="string">&quot;Yes&quot;</span>).value</span><br><span class="line"><span class="attr">D</span>: game.next.value() and game.next.value(<span class="string">&quot;Yes&quot;</span>)</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C</details><h1 id="72-String-raw"><a href="#72-String-raw" class="headerlink" title="72 String.raw"></a>72 <code>String.raw</code></h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`Hello\nworld`</span>);</span><br><span class="line"></span><br><span class="line">A: Hello world!</span><br><span class="line">B: Hello</span><br><span class="line">world</span><br><span class="line"><span class="attr">C</span>: Hello\nworld</span><br><span class="line"><span class="attr">D</span>: Hello\n</span><br><span class="line">world</span><br></pre></td></tr></table></figure><details><summary>答案</summary>`String.raw`函数用来获取模板字符串的原始字符串，它返回一个字符串忽略了转义符,不过反斜杠可能有问题<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="string">`C:\Documents\Projects\table.html`</span></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`<span class="subst">$&#123;path&#125;</span>`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>这将导致：`"C:DocumentsProjects able.html"`直接使用`String.raw`<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`C:\Documents\Projects\table.html`</span></span><br></pre></td></tr></table></figure>它会忽略转义字符并打印：`C:\Documents\Projects\table.html`</details><h1 id="73-Promise"><a href="#73-Promise" class="headerlink" title="73 Promise"></a>73 Promise</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;I made it!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = getData();</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;I made it!&quot;</span></span><br><span class="line"><span class="attr">B</span>: <span class="built_in">Promise</span> &#123;&lt;resolved&gt;: <span class="string">&quot;I made it!&quot;</span>&#125;</span><br><span class="line"><span class="attr">C</span>: <span class="built_in">Promise</span> &#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="attr">D</span>: <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 异步函数始终返回一个promise 要想获取值 使用`data.then((res)=>console.log(res))`</details><h1 id="74-push"><a href="#74-push" class="headerlink" title="74 push"></a>74 push</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addToList</span>(<span class="params">item, list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> list.push(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = addToList(<span class="string">&quot;apple&quot;</span>, [<span class="string">&quot;banana&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line">A: [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>];</span><br><span class="line">B: <span class="number">2</span>;</span><br><span class="line">C: <span class="literal">true</span>;</span><br><span class="line">D: <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B push方法返回新数组的长度</details><h1 id="75-Object-freeze"><a href="#75-Object-freeze" class="headerlink" title="75 Object.freeze"></a>75 <code>Object.freeze</code></h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> box = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(box);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shape = box;</span><br><span class="line">shape.x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(shape)</span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: &#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="attr">B</span>: &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="attr">C</span>: &#123; <span class="attr">x</span>: <span class="number">100</span> &#125;</span><br><span class="line"><span class="attr">D</span>: <span class="built_in">ReferenceError</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>B 声明一个冻结对象，shape赋值的时候，也指向的是那个冻结对象，所以也是没办法改变值的`Object.isFrozen`判断一个对象是否冻结</details><h1 id="76-变量重命名"><a href="#76-变量重命名" class="headerlink" title="76 变量重命名"></a>76 变量重命名</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: myName &#125; = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line">B: <span class="string">&quot;myName&quot;</span>;</span><br><span class="line">C: <span class="literal">undefined</span>;</span><br><span class="line">D: <span class="built_in">ReferenceError</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>D 此时已经重命名为myName了，也就是原先的变量不存在了</details><h1 id="77-纯函数"><a href="#77-纯函数" class="headerlink" title="77 纯函数"></a>77 纯函数</h1><p>以下是个纯函数么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: Yes;</span><br><span class="line">B: No;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A 没有副作用</details><h1 id="78-记忆函数"><a href="#78-记忆函数" class="headerlink" title="78 记忆函数"></a>78 记忆函数</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num <span class="keyword">in</span> cache) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`From cache! <span class="subst">$&#123;cache[num]&#125;</span>`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = num + <span class="number">10</span>;</span><br><span class="line">      cache[num] = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`Calculated! <span class="subst">$&#123;result&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addFunction = add();</span><br><span class="line"><span class="built_in">console</span>.log(addFunction(<span class="number">10</span>));</span><br><span class="line"><span class="built_in">console</span>.log(addFunction(<span class="number">10</span>));</span><br><span class="line"><span class="built_in">console</span>.log(addFunction(<span class="number">5</span> * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">A: Calculated! <span class="number">20</span> Calculated! <span class="number">20</span> Calculated! <span class="number">20</span></span><br><span class="line"><span class="attr">B</span>: Calculated! <span class="number">20</span> From cache! <span class="number">20</span> Calculated! <span class="number">20</span></span><br><span class="line"><span class="attr">C</span>: Calculated! <span class="number">20</span> From cache! <span class="number">20</span> From cache! <span class="number">20</span></span><br><span class="line"><span class="attr">D</span>: Calculated! <span class="number">20</span> From cache! <span class="number">20</span> <span class="built_in">Error</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 记忆化缓存</details><h1 id="79-forin"><a href="#79-forin" class="headerlink" title="79 forin"></a>79 forin</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myLifeSummedUp = [<span class="string">&quot;☕&quot;</span>, <span class="string">&quot;💻&quot;</span>, <span class="string">&quot;🍷&quot;</span>, <span class="string">&quot;🍫&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> myLifeSummedUp) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> myLifeSummedUp) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> and <span class="string">&quot;☕&quot;</span> <span class="string">&quot;💻&quot;</span> <span class="string">&quot;🍷&quot;</span> <span class="string">&quot;🍫&quot;</span></span><br><span class="line"><span class="attr">B</span>: <span class="string">&quot;☕&quot;</span> <span class="string">&quot;💻&quot;</span> <span class="string">&quot;🍷&quot;</span> <span class="string">&quot;🍫&quot;</span> and <span class="string">&quot;☕&quot;</span> <span class="string">&quot;💻&quot;</span> <span class="string">&quot;🍷&quot;</span> <span class="string">&quot;🍫&quot;</span></span><br><span class="line"><span class="attr">C</span>: <span class="string">&quot;☕&quot;</span> <span class="string">&quot;💻&quot;</span> <span class="string">&quot;🍷&quot;</span> <span class="string">&quot;🍫&quot;</span> and <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="attr">D</span>: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> and &#123;<span class="number">0</span>: <span class="string">&quot;☕&quot;</span>, <span class="number">1</span>: <span class="string">&quot;💻&quot;</span>, <span class="number">2</span>: <span class="string">&quot;🍷&quot;</span>, <span class="number">3</span>: <span class="string">&quot;🍫&quot;</span>&#125;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A forin我们可以遍历一个对象自有的、继承的、可枚举的、非Symbol的属性遍历数组取到的是数组的键也就是索引</details><h1 id="80-数组元素"><a href="#80-数组元素" class="headerlink" title="80 数组元素"></a>80 数组元素</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span> + <span class="number">2</span>, <span class="number">1</span> * <span class="number">2</span>, <span class="number">1</span> / <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(list);</span><br><span class="line"></span><br><span class="line">A: [<span class="string">&quot;1 + 2&quot;</span>, <span class="string">&quot;1 * 2&quot;</span>, <span class="string">&quot;1 / 2&quot;</span>];</span><br><span class="line">B: [<span class="string">&quot;12&quot;</span>, <span class="number">2</span>, <span class="number">0.5</span>];</span><br><span class="line">C: [<span class="number">3</span>, <span class="number">2</span>, <span class="number">0.5</span>];</span><br><span class="line">D: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 数组里面可以放表达式 但是最后返回的结果是解析吼的结果</details><h1 id="81-不传形参"><a href="#81-不传形参" class="headerlink" title="81 不传形参"></a>81 不传形参</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hi there, <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sayHi())</span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: Hi there,</span><br><span class="line"><span class="attr">B</span>: Hi there, <span class="literal">undefined</span></span><br><span class="line"><span class="attr">C</span>: Hi there, <span class="literal">null</span></span><br><span class="line"><span class="attr">D</span>: <span class="built_in">ReferenceError</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>B</details><h1 id="82-this"><a href="#82-this" class="headerlink" title="82 this"></a>82 this</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> status = <span class="string">&quot;😎&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> status = <span class="string">&quot;😍&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="string">&quot;🥑&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">getStatus</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.status</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(data.getStatus())</span><br><span class="line">  <span class="built_in">console</span>.log(data.getStatus.call(<span class="built_in">this</span>))</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: <span class="string">&quot;🥑&quot;</span> and <span class="string">&quot;😍&quot;</span></span><br><span class="line"><span class="attr">B</span>: <span class="string">&quot;🥑&quot;</span> and <span class="string">&quot;😎&quot;</span></span><br><span class="line"><span class="attr">C</span>: <span class="string">&quot;😍&quot;</span> and <span class="string">&quot;😎&quot;</span></span><br><span class="line"><span class="attr">D</span>: <span class="string">&quot;😎&quot;</span> and <span class="string">&quot;😎&quot;</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>B 第一个this来自于调用者data 第二个的this来自于window</details><h1 id="83-修改不存在的对象属性"><a href="#83-修改不存在的对象属性" class="headerlink" title="83 修改不存在的对象属性"></a>83 修改不存在的对象属性</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> city = person.city</span><br><span class="line">city = <span class="string">&quot;Amsterdam&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person)</span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br><span class="line"><span class="attr">B</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">city</span>: <span class="string">&quot;Amsterdam&quot;</span> &#125;</span><br><span class="line"><span class="attr">C</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">city</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line"><span class="attr">D</span>: <span class="string">&quot;Amsterdam&quot;</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>A 一开始是person上面没有city 此时赋值给的是undefined，后面修改city 因为先前给的不是person的引用，只是对象中的属性，所以person不变</details><h1 id="84-块级作用域外使用声明的const-let变量"><a href="#84-块级作用域外使用声明的const-let变量" class="headerlink" title="84 块级作用域外使用声明的const/let变量"></a>84 块级作用域外使用声明的const/let变量</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> message = <span class="string">&quot;Sorry, you&#x27;re too young.&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> message = <span class="string">&quot;Yay! You&#x27;re old enough!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(checkAge(<span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;Sorry, you&#x27;re too young.&quot;</span>;</span><br><span class="line">B: <span class="string">&quot;Yay! You&#x27;re old enough!&quot;</span>;</span><br><span class="line">C: <span class="built_in">ReferenceError</span>;</span><br><span class="line">D: <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 在块级作用域外面使用const或者let声明的变量抛出异常ReferenceError</details><h1 id="85-promise链式调用"><a href="#85-promise链式调用" class="headerlink" title="85 promise链式调用"></a>85 promise链式调用</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://www.website.com/api/user/1&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: fetch方法的结果</span><br><span class="line"><span class="attr">B</span>: 第二次调用fetch方法的结果</span><br><span class="line"><span class="attr">C</span>: 前一个.then()中回调方法返回的结果</span><br><span class="line"><span class="attr">D</span>: 总是<span class="literal">undefined</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>C</details><h1 id="86"><a href="#86" class="headerlink" title="86 !!"></a>86 !!</h1><p>哪个选项是将hasName设置为true的方法，前提是不能将true作为参数传递?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hasName = <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: !!name</span><br><span class="line"><span class="attr">B</span>: name</span><br><span class="line"><span class="attr">C</span>: <span class="keyword">new</span> <span class="built_in">Boolean</span>(name)</span><br><span class="line"><span class="attr">D</span>: name.length</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A</details><h1 id="87-数组可迭代"><a href="#87-数组可迭代" class="headerlink" title="87 数组可迭代"></a>87 数组可迭代</h1><p>输出是什么?<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;I want pizza&quot;</span>[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">B: &quot;</span>I<span class="string">&quot;</span></span><br><span class="line"><span class="string">C: SyntaxError</span></span><br><span class="line"><span class="string">D: undefined</span></span><br></pre></td></tr></table></figure></p><details><summary>答案</summary>B</details><h1 id="88-默认参数"><a href="#88-默认参数" class="headerlink" title="88 默认参数"></a>88 默认参数</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2 = num1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num1 + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">A: <span class="literal">NaN</span>;</span><br><span class="line">B: <span class="number">20</span>;</span><br><span class="line">C: <span class="built_in">ReferenceError</span>;</span><br><span class="line">D: <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B 交换则不行</details><h1 id="89-import-as-xxx-from-xxx"><a href="#89-import-as-xxx-from-xxx" class="headerlink" title="89 import * as xxx from xxx"></a>89 <code>import * as xxx from xxx</code></h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> data <span class="keyword">from</span> <span class="string">&quot;./module&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: &#123; <span class="attr">default</span>: <span class="function"><span class="keyword">function</span> <span class="title">default</span>(<span class="params"></span>), <span class="title">name</span>: &quot;<span class="title">Lydia</span>&quot; &#125;</span></span><br><span class="line"><span class="function"><span class="title">B</span>: </span>&#123; <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> <span class="title">default</span>(<span class="params"></span>) &#125;</span></span><br><span class="line"><span class="function"><span class="title">C</span>: </span>&#123; <span class="keyword">default</span>: <span class="string">&quot;Hello world&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;</span><br><span class="line"><span class="attr">D</span>: Global object <span class="keyword">of</span> <span class="built_in">module</span>.js</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A 使用`import *`得到默认导出和具名导出，其中默认导出是一个函数</details><h1 id="90-类和构造函数"><a href="#90-类和构造函数" class="headerlink" title="90 类和构造函数"></a>90 类和构造函数</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> member = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> member);</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;class&quot;</span>;</span><br><span class="line">B: <span class="string">&quot;function&quot;</span>;</span><br><span class="line">C: <span class="string">&quot;object&quot;</span>;</span><br><span class="line">D: <span class="string">&quot;string&quot;</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 实例就是一个对象</details><h1 id="91-push"><a href="#91-push" class="headerlink" title="91 push"></a>91 push</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newList.push(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">A: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">B: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">C: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">D: <span class="built_in">Error</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>D push返回数组长度 此时newList是4 不能对string使用push</details><h1 id="92-箭头函数和原型对象"><a href="#92-箭头函数和原型对象" class="headerlink" title="92 箭头函数和原型对象"></a>92 箭头函数和原型对象</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">giveLydiaPizza</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Here is pizza!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> giveLydiaChocolate = <span class="function">() =&gt;</span> <span class="string">&quot;Here&#x27;s chocolate... now go hit the gym already.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(giveLydiaPizza.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(giveLydiaChocolate.prototype)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: &#123; <span class="attr">constructor</span>: ...&#125; &#123; <span class="attr">constructor</span>: ...&#125;</span><br><span class="line"><span class="attr">B</span>: &#123;&#125; &#123; <span class="attr">constructor</span>: ...&#125;</span><br><span class="line"><span class="attr">C</span>: &#123; <span class="attr">constructor</span>: ...&#125; &#123;&#125;</span><br><span class="line"><span class="attr">D</span>: &#123; <span class="attr">constructor</span>: ...&#125; <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>D 箭头函数没有原型对象</details><h1 id="93-Object-entries"><a href="#93-Object-entries" class="headerlink" title="93 Object.entries"></a>93 <code>Object.entries</code></h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [x, y] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(person)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: name Lydia and age <span class="number">21</span></span><br><span class="line"><span class="attr">B</span>: [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Lydia&quot;</span>] and [<span class="string">&quot;age&quot;</span>, <span class="number">21</span>]</span><br><span class="line"><span class="attr">C</span>: [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>] and <span class="literal">undefined</span></span><br><span class="line"><span class="attr">D</span>: <span class="built_in">Error</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>A `Object.entries`返回一个键值对构成的数组如：`[['name','Lydia'],['age',21]]`</details><h1 id="94-剩余参数的位置"><a href="#94-剩余参数的位置" class="headerlink" title="94 剩余参数的位置"></a>94 剩余参数的位置</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItems</span>(<span class="params">fruitList, ...args, favoriteFruit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...fruitList, ...args, favoriteFruit]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getItems([<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>], <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>]</span><br><span class="line"><span class="attr">B</span>: [[<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>], <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>]</span><br><span class="line"><span class="attr">C</span>: [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, [<span class="string">&quot;pear&quot;</span>], <span class="string">&quot;orange&quot;</span>]</span><br><span class="line"><span class="attr">D</span>: <span class="built_in">SyntaxError</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>D `...args`只能放在参数的最后面，否则抛出语法错误`SyntaxError`</details><h1 id="95-return后新行"><a href="#95-return后新行" class="headerlink" title="95 return后新行"></a>95 return后新行</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nums</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span></span><br><span class="line">  (a &gt; b)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a is bigger&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;b is bigger&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">  a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nums(<span class="number">4</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(nums(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: a is bigger, <span class="number">6</span> and b is bigger, <span class="number">3</span></span><br><span class="line"><span class="attr">B</span>: a is bigger, <span class="literal">undefined</span> and b is bigger, <span class="literal">undefined</span></span><br><span class="line"><span class="attr">C</span>: <span class="literal">undefined</span> and <span class="literal">undefined</span></span><br><span class="line"><span class="attr">D</span>: <span class="built_in">SyntaxError</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>B 此时的return js无法判断它下一个值是否是需要的值，自动加了分号，所以结束了</details><h1 id="96-类"><a href="#96-类" class="headerlink" title="96 类"></a>96 类</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;Lydia&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person = <span class="class"><span class="keyword">class</span> <span class="title">AnotherPerson</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;Sarah&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> member = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(member.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: <span class="string">&quot;Lydia&quot;</span></span><br><span class="line"><span class="attr">B</span>: <span class="string">&quot;Sarah&quot;</span></span><br><span class="line"><span class="attr">C</span>: <span class="built_in">Error</span>: cannot redeclare Person</span><br><span class="line"><span class="attr">D</span>: <span class="built_in">SyntaxError</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>B 我们可以将类设置为等于其他类/函数构造函数。 在这种情况下，我们将Person设置为AnotherPerson。 这个构造函数的名字是Sarah，所以新的Person实例member上的name属性是Sarah。</details><h1 id="97-Symbol"><a href="#97-Symbol" class="headerlink" title="97 Symbol"></a>97 Symbol</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>)]: <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(info)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(info))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: &#123;<span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>): <span class="string">&#x27;b&#x27;</span>&#125; and [<span class="string">&quot;&#123;Symbol(&#x27;a&#x27;)&quot;</span>]</span><br><span class="line"><span class="attr">B</span>: &#123;&#125; and []</span><br><span class="line"><span class="attr">C</span>: &#123; <span class="attr">a</span>: <span class="string">&quot;b&quot;</span> &#125; and [<span class="string">&quot;a&quot;</span>]</span><br><span class="line"><span class="attr">D</span>: &#123;<span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>): <span class="string">&#x27;b&#x27;</span>&#125; and []</span><br></pre></td></tr></table></figure><details><summary>答案</summary>D symbol类型不可枚举，所以`Object.keys`的时候没有返回</details><h1 id="98-剩余参数和箭头函数返回对象"><a href="#98-剩余参数和箭头函数返回对象" class="headerlink" title="98 剩余参数和箭头函数返回对象"></a>98 剩余参数和箭头函数返回对象</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getList = <span class="function">(<span class="params">[x, ...y]</span>) =&gt;</span> [x, y]</span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function"><span class="params">user</span> =&gt;</span> (&#123; <span class="attr">name</span>: user.name, <span class="attr">age</span>: user.age &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getList(list))</span><br><span class="line"><span class="built_in">console</span>.log(getUser(user))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]] and <span class="literal">undefined</span></span><br><span class="line"><span class="attr">B</span>: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]] and &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br><span class="line"><span class="attr">C</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] and &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br><span class="line"><span class="attr">D</span>: <span class="built_in">Error</span> and &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B `...y` 此时y是一个数组包含剩余参数，对于箭头函数 如果要返回一个对象，需要使用圆括号包裹</details><h1 id="99-抛出错误"><a href="#99-抛出错误" class="headerlink" title="99 抛出错误"></a>99 抛出错误</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name());</span><br><span class="line"></span><br><span class="line">A: <span class="built_in">SyntaxError</span>;</span><br><span class="line">B: <span class="built_in">ReferenceError</span>;</span><br><span class="line">C: <span class="built_in">TypeError</span>;</span><br><span class="line">D: <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 当值不是预期类型时，会抛出TypeErrors。 JavaScript期望name是一个函数，因为我们试图调用它。 但它是一个字符串，因此抛出TypeError：name is not a function当你编写了一些非有效的JavaScript时，会抛出语法错误，例如当你把return这个词写成retrun时。 当JavaScript无法找到您尝试访问的值的引用时，抛出ReferenceErrors。</details><h1 id="100-amp-amp"><a href="#100-amp-amp" class="headerlink" title="100 &amp;&amp;"></a>100 <code>&amp;&amp;</code></h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 🎉✨ This is my 100th question! ✨🎉</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> output = <span class="string">`<span class="subst">$&#123;[] &amp;&amp; <span class="string">&#x27;Im&#x27;</span>&#125;</span>possible!</span></span><br><span class="line"><span class="string">You should<span class="subst">$&#123;<span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="string">`n&#x27;t`</span>&#125;</span> see a therapist after so much JavaScript lol`</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: possible! You should see a therapist after so much JavaScript lol</span><br><span class="line"><span class="attr">B</span>: Impossible! You should see a therapist after so much JavaScript lol</span><br><span class="line"><span class="attr">C</span>: possible! You shouldn<span class="string">&#x27;t see a therapist after so much JavaScript lol</span></span><br><span class="line"><span class="string">D: Impossible! You shouldn&#x27;</span>t see a therapist after so much JavaScript lol</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B `[]`是一个真值 在`&&`中会返回后面那个值 `''`是一个假值 直接不返回了</details><h1 id="101-判断真假"><a href="#101-判断真假" class="headerlink" title="101 判断真假"></a>101 判断真假</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = (<span class="literal">false</span> || &#123;&#125; || <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> two = (<span class="literal">null</span> || <span class="literal">false</span> || <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> three = ([] || <span class="number">0</span> || <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(one, two, three)</span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: <span class="literal">false</span> <span class="literal">null</span> []</span><br><span class="line"><span class="attr">B</span>: <span class="literal">null</span> <span class="string">&quot;&quot;</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">C</span>: &#123;&#125; <span class="string">&quot;&quot;</span> []</span><br><span class="line"><span class="attr">D</span>: <span class="literal">null</span> <span class="literal">null</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>C</details>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="javascript" scheme="https://zlinni.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Vite官方文档浓缩</title>
    <link href="https://zlinni.github.io/posts/559196830/"/>
    <id>https://zlinni.github.io/posts/559196830/</id>
    <published>2022-08-03T00:33:05.000Z</published>
    <updated>2022-08-07T02:22:12.040Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>这一篇为什么要叫 vite 官方文档浓缩呢？一方面是自己不太了解 vite，想通过官方文档进行 vite 的学习。一方面是靠自己的理解处理一下文档的细节。话不多说，开刷</p><p>前置知识：CJS/ESM，HMR，ESM 的引入方式，FOUC</p></div><h1 id="为什么选-Vite"><a href="#为什么选-Vite" class="headerlink" title="为什么选 Vite"></a>为什么选 Vite</h1><p>Vite 诞生的背景是大型应用中 webpack 构建速度变慢，需要很久才能开启服务器，即使通过 HMR 也需要很久浏览器才能反馈出内容。以上都是基于打包的学说，而 Vite 诞生的原因则是浏览器开始逐步支持 JS 模块，他使用非打包的方式构建，以冷启动的方式启动，因此构建速度上面极大快于前者。</p><h1 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h1><p>Vite 先将应用中的模块分为依赖和源码两类，改进服务器启动时间。</p><ul><li>依赖：依赖大多数为开发不会变动的纯 js。一些比较大的依赖(比如组件库)处理的成本也很高，依赖通常有多种模块化的格式(eg:CJS/ESM)</li></ul><p>Vite 在依赖处理这方面使用的是 esbuild，由 go 语言编写，比 js 编写的打包器预构建快 10-100 倍</p><ul><li>源码：源码通常包含一些非 js 文件，比如 css，jsx 或者 vue/svelte 组件，特点是时常会被编辑。同时不是所有的源码都需要同时被加载(比如基于路由拆分的代码模块)</li></ul><p>Vite 以原生 ESM 的方式提供源码。相当于让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码的时候才去转换并提供源码。根据情景动态导入源码，大部分是当前屏幕中有的操作才会被处理。</p><p>以下是常规打包构建和非打包预构建的示例图<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803085603.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803085618.png" alt=""></p><p>看图可以发现 Vite 应该是只构建了当前视图中路由和与该路由相关的模块</p><h1 id="缓慢更新"><a href="#缓慢更新" class="headerlink" title="缓慢更新"></a>缓慢更新</h1><p>当你更新应用的时候，常规的打包器使用 HMR，让一个模块热替换自己，而不会影响页面的其他部分，大大的改善了开发体验。不过当应用程序越来越大的时候，这种方式也显得捉襟见肘。</p><h2 id="边界链失活"><a href="#边界链失活" class="headerlink" title="边界链失活"></a>边界链失活</h2><p>Vite 中，HMR 是在原生 ESM 上面执行的。当编辑一个文件的时候，vite 只需要对已编辑的模块与其最近的 HMR 边界的链失活（不需要全部重构建）使得无论应用大小如何，HMR 始终保持快速更新</p><h2 id="加速页面重载"><a href="#加速页面重载" class="headerlink" title="加速页面重载"></a>加速页面重载</h2><p>Vite 使用 HTTP 请求头来使得页面快速重载，对于依赖使用的是<code>Cache-Control: max-age=31536000,immutable</code>进行强缓存，源码模块通过 304 进行协商缓存。</p><h1 id="仍需要打包的生产环境"><a href="#仍需要打包的生产环境" class="headerlink" title="仍需要打包的生产环境"></a>仍需要打包的生产环境</h1><p>上面的 Bundless 只是基于开发环境的，正式上线还是需要进行打包。原因很简单：</p><p>嵌套打包会导致额外的网络往返，即使使用了 HTTP2 也是效率低下</p><p>所以为了在生产环境中获得更好的加载性能，最好还是对代码进行 tree-shaking，懒加载和 chunk 分割（webpack 那套）</p><h2 id="为什么不用-esbuild-打包？"><a href="#为什么不用-esbuild-打包？" class="headerlink" title="为什么不用 esbuild 打包？"></a>为什么不用 esbuild 打包？</h2><p>esbuild 很快，但是还不够完善，尤其是在 css 和代码分割方面。目前采用的是比较稳定的 rollup</p><h1 id="NPM-依赖解析和预构建"><a href="#NPM-依赖解析和预构建" class="headerlink" title="NPM 依赖解析和预构建"></a>NPM 依赖解析和预构建</h1><p>我们知道 esm 是不支持裸导入的，想要将 es 模块在浏览器中使用，有三种方式</p><ol><li>import from URL</li><li>importmap</li><li>assertion</li></ol><p>其中第二种方式使得后续的裸导入成为可能。</p><p>但是 vite 的思路是这样的，检测所有裸导入的模块，对其进行以下操作：</p><ol><li>使用 esbuild 预构建依赖，将 cjs 和 umd 转换为 esm。</li><li>重写导入为合法的 URL(利用第一种方式)，eg:<code>/node_modules/.vite/deps/my-dep.js?v=f3sf2ebd</code>让浏览器能够识别它们</li></ol><h1 id="更快的-Typescript-转译"><a href="#更快的-Typescript-转译" class="headerlink" title="更快的 Typescript 转译"></a>更快的 Typescript 转译</h1><p>vite 使用 esbuild 转 ts 到 js，比 tsc 速度快 20-30 倍。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803093125.png" alt=""></p><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><p>导入 css 文件将会把内容插入到 style 标签中，同时也带有 HMR 支持。也能以字符串的形式检索处理后的，作为其模块默认导出的 css</p><h2 id="import-内联和变基"><a href="#import-内联和变基" class="headerlink" title="@import 内联和变基"></a>@import 内联和变基</h2><p>Vite 通过 <code>postcss-import</code> 预配置支持了 css 的 <code>@import</code> 内联，意味着所有 css 的 <code>url</code> 引用，即使导入的文件在不同的目录内，也总是自动变基</p><h2 id="postcss"><a href="#postcss" class="headerlink" title="postcss"></a>postcss</h2><p>如果项目包含有效的 PostCSS 配置 (任何受 <code>postcss-load-config</code> 支持的格式，例如 <code>postcss.config.js</code>)，它将会自动应用于所有已导入的 CSS。</p><h2 id="cssmodule"><a href="#cssmodule" class="headerlink" title="cssmodule"></a>cssmodule</h2><p>任何以 <code>.module.css</code> 为后缀名的 CSS 文件都被认为是一个 CSS modules 文件。导入这样的文件会返回一个相应的模块对象：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803094958.png" alt=""></p><h2 id="CSS-预处理器"><a href="#CSS-预处理器" class="headerlink" title="CSS 预处理器"></a>CSS 预处理器</h2><p>vite 提供了对<code>.scss, .sass, .less, .styl</code> 和 <code>.stylus</code> 文件的内置支持。没必要安装特定的 vite 插件，但需要安装相应的预处理器依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .scss and .sass</span></span><br><span class="line">npm add -D sass</span><br><span class="line"></span><br><span class="line"><span class="comment"># .less</span></span><br><span class="line">npm add -D less</span><br><span class="line"></span><br><span class="line"><span class="comment"># .styl and .stylus</span></span><br><span class="line">npm add -D stylus</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="构建性能优化"><a href="#构建性能优化" class="headerlink" title="构建性能优化"></a>构建性能优化</h1><div class="note primary flat"><p>下面所罗列的功能会自动应用为构建过程的一部分，除非你想禁用它们，否则没有必要显式配置。</p></div><h2 id="css-代码分割"><a href="#css-代码分割" class="headerlink" title="css 代码分割"></a>css 代码分割</h2><p>vite 会自动的将一个异步的 chunk 模块中使用到的 css 代码抽离出来并为其生成一个单独的文件。这个 css 文件将在异步 chunk 加载完成的时候自动通过一个 link 标签载入，该异步 chunk 会保证只在 css 加载完成后执行，避免发生 FOUC</p><p>不过也可以单独抽离所有的 css 到一个文件中，通过设置：build.cssCodeSplit 为 false 来禁用 css 代码分割。</p><h2 id="预加载指令生成"><a href="#预加载指令生成" class="headerlink" title="预加载指令生成"></a>预加载指令生成</h2><p>vite 会为入口 chunk 和它们打包出的 html 中直接引入自动生成<code>&lt;link ref = &#39;modulepreload&#39;&gt;</code>指令。</p><h2 id="异步-chunk-加载优化"><a href="#异步-chunk-加载优化" class="headerlink" title="异步 chunk 加载优化"></a>异步 chunk 加载优化</h2><p>实际项目中，rollup 通常会生成共用 chunk—-被两个或者两个以上的其他 chunk 共享的 chunk。与动态导入相结合，很容易出现下面的情况<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803102110.png" alt=""></p><p>在无优化的情况下，当异步 chunkA 被加载的时候，浏览器必须先解析 A 才知道 A 和 C 的共用关系，这会导致额外的网络往返。</p><p>Vite 使用一个预加载步骤自动重写代码，来分割动态导入调用，以实现当 A 被请求时，C 也将同时被请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Entry) =&gt; A + C;</span><br></pre></td></tr></table></figure><p>C 里面还可能有更多的嵌套共用内容，所以这种预加载处理是很重要的？</p><p>Vite 具体是这么操作的？预加载的原理？</p><h1 id="Vite-使用插件"><a href="#Vite-使用插件" class="headerlink" title="Vite 使用插件"></a>Vite 使用插件</h1><p>Vite 的插件是基于 Rollup 系统的，并且添加了自己额外的选项</p><p>具体如果想要添加一个插件，需要添加到项目的<code>devDependencies</code>中，并在 vite.config.js 配置文件中的 plugins 数组里面引入他。例如，想要为传统浏览器提供支持可以使用<code>@vitejs/plugin-legacy</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm add -D @vitejs/plugin-legacy</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">import</span> legacy <span class="keyword">from</span> <span class="string">&quot;@vitejs/plugin-legacy&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    legacy(&#123;</span><br><span class="line">      <span class="attr">targets</span>: [<span class="string">&quot;defaults&quot;</span>, <span class="string">&quot;not IE 11&quot;</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>plugin 可以接收多个插件并且会在里面自动扁平化这个数组。</p><p>获取方式<br>Vite 插件：<a href="https://www.npmjs.com/search?q=vite-plugin&amp;ranking=popularity">传送门</a><br>Rollup 插件：<a href="https://www.npmjs.com/search?q=rollup-plugin&amp;ranking=popularity">传送门</a></p><h2 id="强制插件排序"><a href="#强制插件排序" class="headerlink" title="强制插件排序"></a>强制插件排序</h2><p>Vite 的插件可能和 Rollup 的插件冲突，需要修改插件的执行顺序或者只在构建的时候使用。使用修饰符 enforce 来完成这件事</p><ul><li>pre：在 vite 插件之前</li><li>默认/post：在 vite 插件之后</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">import</span> image <span class="keyword">from</span> <span class="string">&quot;@rollup/plugin-image&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      ...image(),</span><br><span class="line">      <span class="attr">enforce</span>: <span class="string">&quot;pre&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>查看兼容性<a href="https://vite-rollup-plugins.patak.dev/">传送门</a></p><h2 id="按需应用"><a href="#按需应用" class="headerlink" title="按需应用"></a>按需应用</h2><p>指定插件在开发(serve)还是生产(build)中使用:apply 修饰符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">import</span> typescript2 <span class="keyword">from</span> <span class="string">&quot;rollup-plugin-typescript2&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      ...typescript2(),</span><br><span class="line">      <span class="attr">apply</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="依赖预构建"><a href="#依赖预构建" class="headerlink" title="依赖预构建"></a>依赖预构建</h1><p>首次启动 vite 会打印相关信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pre-bundling dependencies: （正在预构建依赖：）</span><br><span class="line">  react</span><br><span class="line">  react-dom</span><br><span class="line">(this will be run only when your dependencies or config have changed)（这将只会在你的依赖或配置发生变化时执行）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为此时 vite 正在执行预构建，且每次有新的插件加进来，都会重新预构建。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>vite 的依赖预构建有两个原因</p><ol><li>CJS 和 UMD 兼容性：开发阶段，vite 要将所有的 cjs 模块转化成为 esm，vite 会智能分析所有的 cjs 或者 umd 依赖然后生成对应 esm（关于怎么转 esm 的一些细节在 webpack 的 bundless 章节已经讲述过）</li><li>性能：除了对 cjs，umd 处理之外，vite 还对有许多内部模块的 esm 依赖关系转为单个模块，举个例子，执行 loadash 的时候，会发送六百多个请求，在浏览器端会造成很大的压力，导致页面的加载速度变慢。</li></ol><p>通过预构建 loadash-es 成为一个模块，那么只需要发送一个请求即可。</p><p>注意：开发环境使用的是 esbuild 转化 esm 模块，生产环境使用的是<code>@rollup/plugin-commonjs</code></p><h2 id="自动依赖搜寻"><a href="#自动依赖搜寻" class="headerlink" title="自动依赖搜寻"></a>自动依赖搜寻</h2><p>如果 vite 没有找到你的缓存，也就是没有 304 协商缓存，也没有强缓存，那么 vite 会自动抓取你的源码，找到引入的依赖项，比如裸导入的模块，并将这些依赖项作为预构建包的入口点，预构建通过 esbuild 进行，所以很快。</p><p>在服务器启动之后，如果发现一个新的依赖项进来，且他没有在缓存中，vite 会重新执行依赖构建过程并重载浏览器。</p><h2 id="Monorepo-和链接依赖"><a href="#Monorepo-和链接依赖" class="headerlink" title="Monorepo 和链接依赖"></a>Monorepo 和链接依赖</h2><p>在一个 Monorepo 启动中，该仓库的某个依赖可能会成为另一个包的依赖，vite 会自动侦测没有从 nodemodules 里面解析的依赖项，并将链接的依赖视为源码，他不会尝试打包被链接的依赖，而是会分析被链接依赖的依赖列表。</p><p>不过这需要被链接的依赖被导出为 esm 格式。如果不是，那么你可以在配置中将此依赖添加到 optimizeDeps.include 和 build.commonjsOptions.include 这两项中。<code>optimizeDeps.include</code> 和 <code>build.commonjsOptions.include</code> 这两项中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="attr">optimizeDeps</span>: &#123;</span><br><span class="line">    <span class="attr">include</span>: [<span class="string">&quot;linked-dep&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">commonjsOptions</span>: &#123;</span><br><span class="line">      <span class="attr">include</span>: [<span class="regexp">/linked-dep/</span>, <span class="regexp">/node_modules/</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当这个被链接的依赖发生变更后，在重启开发服务器时在命令中带上 <code>--force</code> 选项让所有更改生效。</p><p>重复删除</p><p>由于对链接依赖的解析方式不同，传递性的依赖项可能会不正确地进行重复数据删除，而造成运行时的问题。如果你偶然发现了这个问题，请使用 npm pack 来修复它。</p><h2 id="自定义行为"><a href="#自定义行为" class="headerlink" title="自定义行为"></a>自定义行为</h2><p>默认的依赖项为启发式可能并不总是可取的，可以使用 optimizeDeps 配置项：include 和 exclude 去配置你想要寻找的依赖或者排除依赖。</p><p>建议：如果依赖项很大（有很多内部模块）或者是 CJS，你应该包含他让 vite 自动去处理，如果依赖项很小并且已经是 esm，那么可以排除他，让浏览器自动加载他。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>包含文件系统缓存和浏览器缓存<br>vite 会将预构建的依赖缓存到<code>node_modules/.vite</code>.它根据几个源来决定是否重新执行预构建</p><ol><li>packgejson 中的 dependencies 列表</li><li>包管理器的 lockfile</li><li>在 vite.config.js 中相关字段配置过的（比如刚刚说的 optimize:inclde/exclude）</li></ol><p>如果想要 vite 强制依赖预构建，需要使用<code>--force</code>来启动开发服务器，或者手动删除<code>node_modules/.vite</code></p><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p>解析后的依赖请求会以 http 头<code>max-age:31536000 immutable</code>进行强缓存，用来提高开发时的页面性能。一旦被缓存，这些请求将永远不会到达开发服务器。如果安装了不同版本的则附加的版本 query 会自动使他们失效(保证只能有一个版本)。如果要调试依赖，可以使用：</p><ol><li>通过浏览器调试工具的 Network 选项卡暂用缓存</li><li>重启 vite dev server 并<code>--force</code>命令以重新进行依赖预构建。</li><li>重载页面</li></ol><h1 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h1><h2 id="将资源引入为-URL"><a href="#将资源引入为-URL" class="headerlink" title="将资源引入为 URL"></a>将资源引入为 URL</h2><p>服务时，引入一个静态资源会返回解析后的公共路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> imgUrl <span class="keyword">from</span> <span class="string">&quot;./img.png&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;hero-img&quot;</span>).src = imgUrl;</span><br></pre></td></tr></table></figure><p>比如 imgURL 在开发时会是<code>/img.png</code>，生产构建后会是<code>/assets/img.2d8efhg.png</code></p><p>这个类似于 webpack 的 file-loader，但是不一样的点在于既可以引入绝对公共路径，也可以引入相对路径</p><ul><li><code>url()</code>在 css 中的引用会以同样方式进行处理。</li><li>如果 <code>vite</code> 引用了 <code>vue</code> 插件，<code>vue sfc</code> 模板中的资源都将自动转换为导入</li><li>常见的图像，媒体，和字体文件类型将被自动检测。可以使用 <code>assetsInclude</code> 选项拓展内部列表。</li><li>引用的资源作为构建资源图的一部分包括在内，将生成散列文件名，并可由插件处理优化。</li><li>较小的资源体积与 <code>assetsInlineLimit</code> 选项值将会被内联为 <code>base64URL</code></li></ul><h2 id="显式-URL-引入"><a href="#显式-URL-引入" class="headerlink" title="显式 URL 引入"></a>显式 URL 引入</h2><p>未被包含在内部列表或 <code>assetsInclude</code> 中的资源，可以使用<code>?url</code>后缀显式导入为一个 URL。比如导入<code>Houdini Paint Worklets</code> 时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> workletURL <span class="keyword">from</span> <span class="string">&quot;extra-scalloped-border/worklet.js?url&quot;</span>;</span><br><span class="line">CSS.paintWorklet.addModule(workletURL);</span><br></pre></td></tr></table></figure><h2 id="将资源引入为字符串"><a href="#将资源引入为字符串" class="headerlink" title="将资源引入为字符串"></a>将资源引入为字符串</h2><p>资源可以使用 ?raw 后缀声明作为字符串引入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shaderString <span class="keyword">from</span> <span class="string">&quot;./shader.glsl?raw&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="导入脚本作为-Worker"><a href="#导入脚本作为-Worker" class="headerlink" title="导入脚本作为 Worker"></a>导入脚本作为 Worker</h2><p>脚本可以通过 <code>?worker</code> 或 <code>?sharedworker</code> 后缀导入为 web worker。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在生产构建中将会分离出 chunk</span></span><br><span class="line"><span class="keyword">import</span> Worker <span class="keyword">from</span> <span class="string">&quot;./shader.js?worker&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker();</span><br><span class="line"></span><br><span class="line"><span class="comment">// sharedworker</span></span><br><span class="line"><span class="keyword">import</span> SharedWorker <span class="keyword">from</span> <span class="string">&quot;./shader.js?sharedworker&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> sharedWorker = <span class="keyword">new</span> SharedWorker();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联为 base64 字符串</span></span><br><span class="line"><span class="keyword">import</span> InlineWorker <span class="keyword">from</span> <span class="string">&quot;./shader.js?worker&amp;inline&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="public-目录"><a href="#public-目录" class="headerlink" title="public 目录"></a>public 目录</h2><p>特点：</p><ol><li>不会被源码引用（js 文件）</li><li>必须保持源文件名称(不被 hash)</li><li>或者只想要得到它的 URL</li></ol><p>上述资源放入 public 最好。可以通过<code>/</code>在开发的时候直接访问到比如<code>public/icon.png =&gt; /icon.png</code></p><p>默认目录：<code>&lt;root&gt;/public</code>,但可以通过<code>publicDir</code>配置</p><h2 id="new-URL-url-import-meta-url"><a href="#new-URL-url-import-meta-url" class="headerlink" title="new URL(url, import.meta.url)"></a><code>new URL(url, import.meta.url)</code></h2><p><code>import.meta.url</code>是 esm 的原生功能，可以暴露当前模块的 url，在 js 模块中可以通过相对路径获得一个完整的静态资源 url。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imgUrl = <span class="keyword">new</span> URL(<span class="string">&quot;./img.png&quot;</span>, <span class="keyword">import</span>.meta.url).href;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;hero-img&quot;</span>).src = imgUrl;</span><br></pre></td></tr></table></figure><p>这在现代浏览器中能够原生使用 - 实际上，Vite 并不需要在开发阶段处理这些代码！</p><p>这个模式同样还可以通过字符串模板支持动态 URL：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getImageUrl</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> URL(<span class="string">`./dir/<span class="subst">$&#123;name&#125;</span>.png`</span>, <span class="keyword">import</span>.meta.url).href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在生产构建时，Vite 才会进行必要的转换保证 URL 在打包和资源哈希后仍指向正确的地址。</p><p>注意无法在 ssr 中使用，因为这个是 esm 的方法，也就意味着在 node 和浏览器有不同的语义，服务器也没办法预先确定客户端主机 url</p><h1 id="构建生产版本"><a href="#构建生产版本" class="headerlink" title="构建生产版本"></a>构建生产版本</h1><p>命令：<code>vite build</code>默认情况使用<code>&lt;root&gt;/index.html</code>作为构建入口。</p><h2 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h2><p>vite 的目标是支持 esm 的浏览器，按照条件进行 browerslist 查询的浏览器</p><p>也可以手动通过<code>build.target</code>配置项构建指定目标。最低支持 es2015</p><p>默认情况下 vite 不包含任何 polyfill，只负责转义，要使用相关的服务进行 polyfill 生成，<code>Polyfill.io</code></p><p>传统浏览器需要插件<code>@vitejs/plugin-legacy</code>的支持，它将会自动生成传统版本的 chunk 与其对应 es 方面语言的 polyfill。</p><h2 id="公共基础路径"><a href="#公共基础路径" class="headerlink" title="公共基础路径"></a>公共基础路径</h2><p>配置 base 项所有的资源会按此路径重写，也可以通过命令行：<code>vite build --base=/my/public/path/</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/vite官方文档浓缩.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Webpack系列" scheme="https://zlinni.github.io/categories/Webpack%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Webpack" scheme="https://zlinni.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化③Bundless基础设施建设</title>
    <link href="https://zlinni.github.io/posts/351158764/"/>
    <id>https://zlinni.github.io/posts/351158764/</id>
    <published>2022-08-02T06:14:30.000Z</published>
    <updated>2022-08-02T08:26:26.799Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>本文将简述前端通过不打包的方式将代码运行在浏览器上的几种方式</p></div><h1 id="原理与浏览器中的-ESM"><a href="#原理与浏览器中的-ESM" class="headerlink" title="原理与浏览器中的 ESM"></a>原理与浏览器中的 ESM</h1><p>当下，主流浏览器已经逐步支持 js 原生模块的导入，出现了很多 bundless 的构建方案，比如 vite，snowpack 等。原理就是利用浏览器对于原生 esm 的支持，进行代码的开发和部署。</p><h2 id="Native-Import-import-from-URL"><a href="#Native-Import-import-from-URL" class="headerlink" title="Native Import: import from URL"></a>Native Import: import from URL</h2><p>通过<code>script[type=module]</code>，可以直接在浏览器中使用原生 ESM，使得前端不打包成为可能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> lodash <span class="keyword">from</span> <span class="string">&quot;http://cdn.skypack.dev/lodash&quot;</span>;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于前端运行在浏览器中，所以他也只能从 URL 中引入 package</p><ol><li>绝对路径：<code>http://cdn.skypack.dev/lodash</code></li><li>相对路径：<code>./lib.js</code></li></ol><p>现在打开浏览器控制台，把下面的代码粘贴在控制台中，就可以调试 loadash 了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; lodash = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;https://cdn.skypack.dev/lodash&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&gt; lodash.get(&#123; <span class="attr">a</span>: <span class="number">3</span> &#125;, <span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Import-Map"><a href="#Import-Map" class="headerlink" title="Import Map"></a>Import Map</h2><p>不过 http Import 每次都要导入完全的 URL，这个肯定是不太合理的，相比以前的裸导入，很不方便,如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lodash <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span>;</span><br></pre></td></tr></table></figure><p>他不同于 nodejs 依赖系统文件系统，层层寻找<code>node_modules</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/home/app/packages/project-a/node_modules/lodash/index.js</span><br><span class="line">/home/app/packages/node_modules/lodash/index.js</span><br><span class="line">/home/app/node_modules/lodash/index.js</span><br><span class="line">/home/node_modules/lodash/index.js</span><br></pre></td></tr></table></figure><p>在 esm 中，可以通过 ImportMap 使得裸导入成为可正常工作</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;importmap&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  &#123;</span></span><br><span class="line"><span class="javascript">    <span class="string">&quot;imports&quot;</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;lodash&quot;</span>: <span class="string">&quot;http://cdn.skypack.dev/lodash&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;ms&quot;</span>: <span class="string">&quot;https://cdn.skypack.dev/ms&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时可以与以前同样的方式进行模块导入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> loadash <span class="keyword">from</span> <span class="string">&#x27;loadash&#x27;</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;loadash&#x27;</span>).then(<span class="function"><span class="params">_</span>=&gt;</span>...)</span><br></pre></td></tr></table></figure><p>那么通过裸导入如何导入子路径呢？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;importmap&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  &#123;</span></span><br><span class="line"><span class="javascript">    <span class="string">&quot;imports&quot;</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;lodash&quot;</span>: <span class="string">&quot;https://cdn.skypack.dev/lodash&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;lodash/&quot;</span>: <span class="string">&quot;https://cdn.skypack.dev/lodash/&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> get <span class="keyword">from</span> <span class="string">&quot;lodash/get.js&quot;</span>;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Import-Assertion"><a href="#Import-Assertion" class="headerlink" title="Import Assertion"></a>Import Assertion</h2><p>通过<code>script[type=module]</code>，不仅可以引入 js 资源，甚至可以引入 json/css 资源，示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">&quot;./xxx.json&quot;</span> assert &#123; <span class="attr">type</span>: <span class="string">&quot;json&quot;</span> &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="如何将-CJS-转化为-ESM"><a href="#如何将-CJS-转化为-ESM" class="headerlink" title="如何将 CJS 转化为 ESM"></a>如何将 CJS 转化为 ESM</h1><p>Bundless 的兴起，要求所有的模块都是 ESM 模块格式。</p><p>目前社区有一部分模块同时支持 ESM 和 CJS，但仍有许多模块仅支持 CJS/UMD,因此将 CJS 转为 ESM 是全部模块 ESM 化的过度阶段</p><h2 id="ESM-与-CJS-的导入导出不同"><a href="#ESM-与-CJS-的导入导出不同" class="headerlink" title="ESM 与 CJS 的导入导出不同"></a>ESM 与 CJS 的导入导出不同</h2><p>在 ESM 中，导入导出有两种方式</p><ol><li>具名导出导入</li><li>默认导出导入</li></ol><p>eg</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具名导入导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; sum &#125;;</span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&quot;sum&quot;</span>;</span><br><span class="line"><span class="comment">// 默认导入导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sum;</span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">&quot;sum&quot;</span>;</span><br></pre></td></tr></table></figure><p>而在 CJS 中,导入导出的方法只有一种</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = sum;</span><br></pre></td></tr></table></figure><p>而所谓的 exports 仅仅是 module.exports 的引用而已</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span> = <span class="built_in">module</span>.exports;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两个等价</span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">module</span>.exports.a = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>下列举两个例子,来验证他俩的区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">module</span>.exports.b = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> hello = <span class="built_in">require</span>(<span class="string">&quot;./hello&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hello);</span><br><span class="line"><span class="comment">// 输出是&#123;a:3,b:4&#125;</span></span><br></pre></td></tr></table></figure><p>第二</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> hello = <span class="built_in">require</span>(<span class="string">&quot;./hello&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hello);</span><br><span class="line"><span class="comment">// 输出是&#123;b:4&#125;</span></span><br></pre></td></tr></table></figure><p>正因为它们两者的不同,所以在两者转换的时候有一些兼容问题需要去解决.</p><h2 id="exports-的转化"><a href="#exports-的转化" class="headerlink" title="exports 的转化"></a>exports 的转化</h2><p>正因为两者不同,所以当 exports 转化的时候,既要转换为<code>exports&#123;&#125;</code>又要转化为<code>export default&#123;&#125;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; a &#125;;</span><br></pre></td></tr></table></figure><p>如果只转化为具名导出不转化为默认导出会发生什么?<br>eg</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Input: CJS</span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">3</span>; <span class="comment">// index.cjs =&gt;提供&#123;a:3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = <span class="built_in">require</span>(<span class="string">&quot;.&quot;</span>); <span class="comment">// foo.cjs</span></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// foo.cjs 输出3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: ESM</span></span><br><span class="line"><span class="comment">// 这是有问题的错误转换示例:</span></span><br><span class="line"><span class="comment">// 此处 a 应该再 export default &#123; a &#125; 一次</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">3</span>; <span class="comment">// index.mjs 提供3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> o <span class="keyword">from</span> <span class="string">&quot;.&quot;</span>; <span class="comment">// foo.mjs 获得3</span></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// foo.mjs 出大问题 3不是对象</span></span><br></pre></td></tr></table></figure><h2 id="module-exports转化"><a href="#module-exports转化" class="headerlink" title="module.exports转化"></a><code>module.exports</code>转化</h2><p>对于<code>module.exports</code>,我们可以遍历其中的 key,通过 ast,将 key 转化为具名导出,将<code>module.exports</code>转化为默认导出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>如果<code>module.exports</code>导出的是函数该如何处理? 特别是<code>exports</code>和<code>module.exports</code>的程序逻辑混合在一起?</p><p>以下是一个正确的转化结果:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">()=&gt;</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">export</span>.a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span>.b = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">()=&gt;</span>&#123;&#125;;</span><br><span class="line">sum.a = <span class="number">3</span>;</span><br><span class="line">sum.b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> = sum;</span><br></pre></td></tr></table></figure></p><p>也可以这么处理:将<code>module.exports</code>与<code>exports</code>的代码使用函数包裹起来,此时我们无需关心其中的逻辑细节.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> esm$<span class="number">1</span> = &#123; <span class="attr">export</span>:&#123;&#125; &#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>,<span class="built_in">exports</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="function">()=&gt;</span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">exports</span>.a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">exports</span>.b = <span class="number">4</span>;</span><br><span class="line">&#125;)(esm$<span class="number">1</span>,esm$<span class="number">1.</span><span class="built_in">exports</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> esm = esm$<span class="number">1.</span><span class="built_in">exports</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; esm <span class="keyword">as</span> <span class="keyword">default</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="一些复杂的转换"><a href="#一些复杂的转换" class="headerlink" title="一些复杂的转换"></a>一些复杂的转换</h2><p>ESM与CJS不仅仅是语法层次上的不同,本身的思维逻辑就完全不一样.所以有一些较为复杂的转换,不做讨论.<br>比如:</p><ol><li>如何处理<code>_dirname</code>;</li><li>如何处理<code>require(dynamicString)</code>;</li><li>如何处理cjs的编程逻辑</li></ol><p>以下代码涉及到编程逻辑,由于<code>exports</code>是一个动态的js对象,而他自然可以使用两次,那应该如何正确的被编为esm呢?<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input: index.cjs</span></span><br><span class="line"><span class="built_in">exports</span>.sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">exports</span>.sum = <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>以下是一种不会出现问题的转换结果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _default = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> sum = (_default.sum = <span class="number">0</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    sum = _default.sum = <span class="number">100</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> _default;</span><br><span class="line"><span class="keyword">export</span> &#123;sum&#125;</span><br></pre></td></tr></table></figure></p><h2 id="CJS-to-ESM的构建工具"><a href="#CJS-to-ESM的构建工具" class="headerlink" title="CJS to ESM的构建工具"></a>CJS to ESM的构建工具</h2><p>CJS向ESM转换,自然有构建工具的参与.比如:<br><code>@rollup/plugin-commonjs</code></p><p>甚至把一些 CommonJS 库转化为 ESM，并且置于 CDN 中，使得我们可以直接使用，而无需构建工具参与</p><ul><li><code>https://cdn.skypack.dev/(opens new window)</code></li><li><code>https://jspm.org/</code></li></ul><h1 id="Bundless的优势与不足"><a href="#Bundless的优势与不足" class="headerlink" title="Bundless的优势与不足"></a>Bundless的优势与不足</h1><p>优势在于 不需要处理打包的问题,直接放到浏览器上面使用.<br>不足在于 现在还有很多模块没有支持esm,所以转换cjs到esm是个问题</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/Bundless基础设施建设.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Webpack系列" scheme="https://zlinni.github.io/categories/Webpack%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Webpack" scheme="https://zlinni.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化②打包体积优化</title>
    <link href="https://zlinni.github.io/posts/1572391089/"/>
    <id>https://zlinni.github.io/posts/1572391089/</id>
    <published>2022-08-02T02:42:19.000Z</published>
    <updated>2022-08-02T08:26:26.794Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>本篇讲述 webpack 打包体积优化的思路和方向</p></div><h1 id="如何分析打包体积"><a href="#如何分析打包体积" class="headerlink" title="如何分析打包体积"></a>如何分析打包体积</h1><p>做过第三方依赖 CDN 引入的话，应该都了解到需要使用<code>webpack-bundle-analyzer</code>分析打包后的体积。</p><p>原理就是 webpack 打包后 Stats 数据进行分析。在 webpack compiler 的 done hook 进行处理。见源码；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compiler.hooks.done.tapAsync(<span class="string">&quot;webpack-bundle-analyzer&quot;</span>, <span class="function">(<span class="params">stats</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><p>stats数据：一个json文件，包含了模块的统计信息，用cli命令生成<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802134913.png" alt=""></p><p>在默认配置下，<code>webpack-bundle-analyzer</code>(opens new window)将会启动服务打开一个各个 chunk 下各个 module 占用体积的可视化图。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802104855.png" alt=""></p><p>可以通过他找到在打包体积中最大的模块并进行优化。</p><p>在查看页面有三个选项：</p><ol><li>stat：每个模块的原始体积。</li><li>parsed：每个模块经过 webpack 打包处理后的体积，比如 terser 等做了压缩，就会显示在上面。</li><li>gzip:经过 gzip 压缩后的体积。</li></ol><h2 id="analyze"><a href="#analyze" class="headerlink" title="analyze"></a>analyze</h2><p>在实际项目中，往往通过环境变量 analyze 配置该插件，code 如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin =</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;webpack-bundle-analyzer&quot;</span>).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. BundleAnalyzerPlugin是如何工作的?</span></span><br><span class="line"><span class="comment">// 2. stat parsed gzip分别是何意义</span></span><br><span class="line"><span class="comment">// 3. terserPlugin 对此结果有影响吗</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> webpack(&#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&quot;./index.js&quot;</span>,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">    <span class="attr">plugins</span>: [process.env.ANALYZE &amp;&amp; <span class="keyword">new</span> BundleAnalyzerPlugin()],</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1().run(<span class="function">(<span class="params">err, stat</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><p>在打包时，通过制定环境变量即可分析打包体积。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE=<span class="literal">true</span> npm run build</span><br></pre></td></tr></table></figure><h1 id="js-压缩"><a href="#js-压缩" class="headerlink" title="js 压缩"></a>js 压缩</h1><p>通过 ast 分析，根据选项配置一些策略，来生成一颗颗粒更小体积的 AST 并生成代码</p><p>目前前端工程化中使用 terser 和 swc 进行 js 代码压缩，它们拥有相同的 api</p><p>常见的压缩 ast 的几种方案如下：</p><h2 id="去除多余字符，空格，换行以及注释"><a href="#去除多余字符，空格，换行以及注释" class="headerlink" title="去除多余字符，空格，换行以及注释"></a>去除多余字符，空格，换行以及注释</h2><p>code</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时这个文件大小是 62kb，一般来说中文会占用更多的空间。</p><p>多余的空白字符会占用大量的体积，如空格，换行符，另外注释也会占用文件体积。当我们把所有空白和注释都去掉之后，代码体积减小到 30kb，如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过替换掉多余的字符会有什么影响呢？</p><p>其实有影响的，比如代码压缩到一行的时候要注意行尾的分号。</p><h2 id="压缩变量名，函数名，以及属性名"><a href="#压缩变量名，函数名，以及属性名" class="headerlink" title="压缩变量名，函数名，以及属性名"></a>压缩变量名，函数名，以及属性名</h2><p>code</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们可以很明显的知道这两个变量只在 sum 的作用域产生影响，所以他们的变量名其实可以更短。</p><p>不仅如此，如果 sum 函数还是在一个 module 中不被导出，那么 sum 这个函数名也可以更短。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩: 缩短变量名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再压缩: 去除空余字符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上的示例中，当代码完成压缩的时候，其实代码的混淆也顺带完成。但此时缩短变量的命名需要在 ast 中支持，不至于在作用域中造成命名冲突。</p><h2 id="解析程序逻辑，合并声明以及布尔值简化"><a href="#解析程序逻辑，合并声明以及布尔值简化" class="headerlink" title="解析程序逻辑，合并声明以及布尔值简化"></a>解析程序逻辑，合并声明以及布尔值简化</h2><p>合并声明的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;jojo&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后=&gt;</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;jojo&quot;</span>,</span><br><span class="line">  age = <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>布尔值简化的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!b &amp;&amp; !c &amp;&amp; !d &amp;&amp; !e;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后=&gt;</span></span><br><span class="line">!(b || c || d || e);</span><br></pre></td></tr></table></figure><h2 id="解析程序逻辑：编译预运算"><a href="#解析程序逻辑：编译预运算" class="headerlink" title="解析程序逻辑：编译预运算"></a>解析程序逻辑：编译预运算</h2><p>在编译期进行运算，减少运行时的计算量，如下示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="keyword">const</span> ONE_YEAR = <span class="number">365</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="keyword">const</span> ONE_YAAR = <span class="number">31536000</span>;</span><br></pre></td></tr></table></figure><p>以及一个更复杂的例子，简直是杀手锏级别的优化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;hello, world&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h1><p>介绍：<br>Tree Shaking 指的是基于 ES Module 进行静态分析，通过 AST 将用不到的函数进行移除，从而减小打包体积。</p><p>例子：by rollup</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&quot;./math.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">5</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure><p>mathjs</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于sub函数没有被引用到所以最终不会对他进行打包</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包后的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maths.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TREE-SHAKING */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">5</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure><h2 id="import"><a href="#import" class="headerlink" title="import *"></a><code>import *</code></h2><p>当使用<code>import *</code>的时候，treeshaking 仍然有效.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> \* <span class="keyword">as</span> maths <span class="keyword">from</span> <span class="string">&quot;./maths&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tree Shaking 依然生效</span></span><br><span class="line">maths.sum(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">maths[<span class="string">&quot;sum&quot;</span>](<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><code>import * as maths</code>，其中 <code>maths</code> 的数据结构是固定的，无复杂数据，通过 AST 分析可查知其引用关系。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maths = &#123;</span><br><span class="line">  <span class="function"><span class="title">sum</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">sub</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="JSON-TreeShaking"><a href="#JSON-TreeShaking" class="headerlink" title="JSON TreeShaking"></a>JSON TreeShaking</h2><p>tree shaking甚至可以对json进行优化，原理是因为json格式简单，通过ast容易预测结果，不像js对象有复杂的类型与副作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;a&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&quot;b&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> obj <span class="keyword">from</span> <span class="string">&quot;./main.json&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj.b 由于未使用到，仍旧不会被打包</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a);</span><br></pre></td></tr></table></figure><h2 id="引入支持-Tree-Shaking-的-Package"><a href="#引入支持-Tree-Shaking-的-Package" class="headerlink" title="引入支持 Tree Shaking 的 Package"></a>引入支持 Tree Shaking 的 Package</h2><p>在<a href="https://npm.devtool.tech/lodash-es">npm.devtool.tech</a>中我们可以很清楚的看到每个包是否支持treeshaking。我们最好是引入支持treeshaking的包来减小生产环境的体积。</p><h1 id="corejs-polyfill"><a href="#corejs-polyfill" class="headerlink" title="corejs polyfill"></a>corejs polyfill</h1><p>corejs是关于ES标准最出名的polyfill。polyfill指的是当浏览器不支持某个最新api的时候，他帮你实现，中文名称叫做垫片。</p><p>由于垫片的存在，打包后的体积便会增加，所支持的浏览器版本越高，需要的垫片越少，打包体积越小。</p><p>相应的如果要向下兼容，那么垫片就越多，打包体积就越大。</p><p>看一个<code>Array.from</code>的垫片代码,有了他的存在，任意浏览器都能使用这个api<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Production steps of ECMA-262, Edition 6, 22.1.2.1</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.from) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.from = <span class="function">() =&gt;</span> &#123; <span class="comment">// 省略若干代码 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而Corejs的厉害之处就是他包含了所有的es6+的polyfill，并且集成在babel等编译工具之中。</p><p>曾经我们试过使用<code>?.</code>可选链操作符，babel会我们对应添加支持。但是如果是新的api就不是了，就需要corejs做polyfill帮助我们能够使用。目前他已经集成了，所以不用考虑这个问题。</p><h1 id="browserslist"><a href="#browserslist" class="headerlink" title="browserslist"></a>browserslist</h1><p>我们知道corejs能帮助我们给向下的浏览器兼容新的api，也知道了他的缺点是兼容的越多，需要的polyfill越多，体积越大。相应的就诞生了垫片体积控制工具browserslist</p><p>他用特定的语句来查询浏览器列表，如： <code>last 2 Chrome versions</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npx browserslist <span class="string">&quot;last 2 Chrome versions&quot;</span></span><br><span class="line">chrome <span class="number">100</span></span><br><span class="line">chrome <span class="number">99</span></span><br></pre></td></tr></table></figure><p>细说起来，他是现代前端工程化必不可缺的一种工具。无论是处理js的babel，还是处理css的postcss，凡是与垫片有关的，它们背后都有browserslist的身影。</p><ul><li><code>babel</code>，在 <code>@babel/preset-env</code> 中使用 <code>core-js</code> 作为垫片</li><li><code>postcss</code> 使用 <code>autoprefixer</code> 作为垫片</li></ul><p>刚刚也说了垫片体积和浏览器版本直接挂钩，所以如果项目只需要支持最新的两个谷歌浏览器，那么关于browserslist的查询，可以写作<code>last 2 Chrome versions</code></p><p>随着时间的推移，该查询语句会返回更新的浏览器，垫片的体积就会减小。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>browserslist的原理实际上就是根据正则解析查询语句。对浏览器版本数据库<code>caniuse-lite</code>进行查询，返回所得到的浏览器版本列表。</p><p>因为browserslist并不维护数据库，因此他会经常提醒你去更新<code>caniuse-lite</code>这个库，由于lock文件的存在，需要使用以下的命令去手动更新数据库。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx browserslist@last --update-db</span><br></pre></td></tr></table></figure><p>该命令将会对<code>caniuse-lite</code>进行升级，可以体现在lock文件中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">     <span class="string">&quot;caniuse-lite&quot;</span>: &#123;</span><br><span class="line">-      <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.30001265&quot;</span>,</span><br><span class="line">-      <span class="string">&quot;resolved&quot;</span>: <span class="string">&quot;https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001265.tgz&quot;</span>,</span><br><span class="line">-      <span class="string">&quot;integrity&quot;</span>: <span class="string">&quot;sha512-YzBnspggWV5hep1m9Z6sZVLOt7vrju8xWooFAgN6BA5qvy98qPAPb7vNUzypFaoh2pb3vlfzbDO8tB57UPGbtw==&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.30001332&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;resolved&quot;</span>: <span class="string">&quot;https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001332.tgz&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;integrity&quot;</span>: <span class="string">&quot;sha512-10T30NYOEQtN6C11YGg411yebhvpnC6Z102+B95eAsN0oB6KUs01ivE8u+G6FMIRtIrVlYXhL+LUwQ3/hXwDWw==&quot;</span>,</span><br><span class="line">       <span class="string">&quot;dev&quot;</span>: <span class="literal">true</span></span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure><h2 id="一些常用的查询语法"><a href="#一些常用的查询语法" class="headerlink" title="一些常用的查询语法"></a>一些常用的查询语法</h2><p>如下：</p><h3 id="根据用户份额"><a href="#根据用户份额" class="headerlink" title="根据用户份额"></a>根据用户份额</h3><blockquote><p>5%: 在全球用户份额大于 5% 的浏览器<br>5% in CN: 在中国用户份额大于 5% 的浏览器</p></blockquote><h3 id="根据最新浏览器版本"><a href="#根据最新浏览器版本" class="headerlink" title="根据最新浏览器版本"></a>根据最新浏览器版本</h3><ul><li>last 2 versions: 所有浏览器的最新两个版本</li><li>last 2 Chrome versions: Chrome 浏览器的最新两个版本</li></ul><h3 id="不再维护的浏览器"><a href="#不再维护的浏览器" class="headerlink" title="不再维护的浏览器"></a>不再维护的浏览器</h3><ul><li>dead: 官方不在维护已过两年，比如 IE10</li></ul><h3 id="浏览器版本号"><a href="#浏览器版本号" class="headerlink" title="浏览器版本号"></a>浏览器版本号</h3><ul><li>Chrome &gt; 90: Chrome 大于 90 版本号的浏览器</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/打包体积优化.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Webpack系列" scheme="https://zlinni.github.io/categories/Webpack%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Webpack" scheme="https://zlinni.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>CodeTop0-100</title>
    <link href="https://zlinni.github.io/posts/3103992604/"/>
    <id>https://zlinni.github.io/posts/3103992604/</id>
    <published>2022-08-01T02:41:13.000Z</published>
    <updated>2022-08-10T11:51:11.405Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>codetop 前一百题，review and review</p></div><h1 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3. 无重复字符的最长字串"></a>3. 无重复字符的最长字串</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>老题新做<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802084740.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>利用 includes api 的特性以及循环弹出顶层的特性，将每个元素 push 进来后下一轮比对是否存在，存在则弹出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> str <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.includes(str)) &#123;</span><br><span class="line">      arr.shift();</span><br><span class="line">    &#125;</span><br><span class="line">    arr.push(str);</span><br><span class="line">    <span class="keyword">if</span> (max &lt; arr.length) max = arr.length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802085418.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路：从后往前对比插入，大的数字优先插入末尾。但需要注意的是某一方提前结束的情况发生，此时如果一方提前结束了，终止判断直接用后一方直到后一方数字完全用完(j&lt;0)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = m - <span class="number">1</span>,</span><br><span class="line">    j = n - <span class="number">1</span>,</span><br><span class="line">    len = m + n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    nums1[len--] = i &gt;= <span class="number">0</span> &amp;&amp; nums1[i] &gt;= nums2[j] ? nums1[i--] : nums2[j--];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a>165. 比较版本号</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802090214.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路是分割<code>.</code>并遍历最长的 length（因为要同时比较），相等跳过，不等判断返回结果。</p><p>注意 前导 0 的情况可以用<code>~~</code>或者 <code>parseInt</code> 去解决，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compareVersion = <span class="function"><span class="keyword">function</span> (<span class="params">version1, version2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> v1arr = version1.split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> v2arr = version2.split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> maxLen = <span class="built_in">Math</span>.max(v1arr.length, v2arr.length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxLen; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = v1arr[i] || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> v2 = v2arr[i] || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (v1 === v2) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (~~v1 &lt; ~~v2) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (~~v1 &gt; ~~v2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a>415. 字符串相加</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802092739.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路：从后往前累加到一个数组内，因为是字符串要转数字使用+ 最后从数组还原使用<code>join(&#39;&#39;)</code><br>小技巧，从后往前读可以使用新的 api <code>Array.at(-1)</code> 注意余数和进位数字的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addStrings = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> last = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> maxLen = <span class="built_in">Math</span>.max(num1.length, num2.length);</span><br><span class="line">  <span class="keyword">let</span> newAdd = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (maxLen--) &#123;</span><br><span class="line">    <span class="keyword">let</span> c1 = num1.at(last) ? +num1.at(last) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> c2 = num2.at(last) ? +num2.at(last) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> count = c1 + c2 + newAdd;</span><br><span class="line">    res.unshift((count % <span class="number">10</span>) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    newAdd = <span class="built_in">Math</span>.floor(count / <span class="number">10</span>);</span><br><span class="line">    last--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newAdd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    res.unshift(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802093916.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路：设置匹配规则，遍历的 s 的时候如果元素满足左括号就把规则中的右括号 push 进数组，如果元素是右括号，说明此时弹出的括号要和右括号匹配 否则返回 false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> rule = &#123;</span><br><span class="line">    <span class="string">&quot;(&quot;</span>: <span class="string">&quot;)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[&quot;</span>: <span class="string">&quot;]&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&#123;&quot;</span>: <span class="string">&quot;&#125;&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> str <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="string">&quot;(&quot;</span> || str === <span class="string">&quot;[&quot;</span> || str === <span class="string">&quot;&#123;&quot;</span>) &#123;</span><br><span class="line">      arr.push(rule[str]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr.pop() !== str) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !arr.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802101606.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(nums[i])) &#123;</span><br><span class="line">      <span class="keyword">let</span> less = map.get(nums[i]);</span><br><span class="line">      <span class="keyword">return</span> [less, i];</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(target - nums[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802102816.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>入门回溯，使用 used 记录已经使用过的元素，终止条件是 path 长度等于数组长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> used = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length).fill(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length === nums.length) &#123;</span><br><span class="line">      res.push([...path]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">      path.push(nums[i]);</span><br><span class="line">      used[i] = <span class="literal">true</span>;</span><br><span class="line">      dfs(path);</span><br><span class="line">      path.pop();</span><br><span class="line">      used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs([]);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803191326.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>dfs 注意第一次进去的是 root 的 val</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">n, sum</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!n.left &amp;&amp; !n.right &amp;&amp; sum === targetSum) &#123;</span><br><span class="line">      res = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n.left) dfs(n.left, sum + n.left.val);</span><br><span class="line">    <span class="keyword">if</span> (n.right) dfs(n.right, sum + n.right.val);</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs(root, root.val);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803192042.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>时刻牢记：层序遍历有两层循环，外层退出条件是队列为空，因为队列为空了，意味着已经走到最后一步结束了。内层循环是为了让孩子进队列并弹出队头元素，弹出有两个目的，一是清空当前队列，二是保留当前队头元素；让孩子进队列是为了下一次层序。</p><p>容易犯错的点：退出当前循环的条件是队列为空,且因为弹出会影响数组长度，所以要保存数组长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> queue = [root];</span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = queue.length;</span><br><span class="line">    <span class="keyword">const</span> temp = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> n = queue.shift();</span><br><span class="line">      temp.push(n.val);</span><br><span class="line">      <span class="keyword">if</span> (n.left) queue.push(n.left);</span><br><span class="line">      <span class="keyword">if</span> (n.right) queue.push(n.right);</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(temp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803194353.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>斐波那契:思路，把每个问题分割成子问题，去逐步处理子问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = [];</span><br><span class="line">  fn[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  fn[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    fn[i] = fn[i - <span class="number">1</span>] + fn[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803194839.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路：比较每次的和和当前项的关系，大的替换。因为我们每次只需要保留两数之间的最大值，然后有个流程上面的最大值，用于比较每次的最大值，找到最大的最大值返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> max = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    sum = <span class="built_in">Math</span>.max(nums[i], sum + nums[i]);</span><br><span class="line">    max = <span class="built_in">Math</span>.max(sum, max);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803200529.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>三指针，注意满足条件就剪枝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">let</span> mid = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> last = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (mid &lt; last) &#123;</span><br><span class="line">      <span class="keyword">let</span> sum = nums[i] + nums[mid] + nums[last];</span><br><span class="line">      <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">        res.push([nums[i], nums[mid], nums[last]]);</span><br><span class="line">        mid++;</span><br><span class="line">        <span class="keyword">while</span> (nums[mid] === nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">          mid++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        mid++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803202441.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>反转链表的流程其实就是<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803202542.png" alt=""></p><p>稍微理解一下这个图就可以了。并且注意最后 cur 已经走完，但是 pre 构建完了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = (head)&#123;</span><br><span class="line">  <span class="keyword">let</span> cur = head;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">    [cur.next,pre,cur] = [pre,cur,cur.next]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803202756.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>快指针每次都比慢指针多走一步，如果有环，必定会重合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> slow = head;</span><br><span class="line">  <span class="keyword">let</span> fast = head;</span><br><span class="line">  <span class="keyword">while</span> (slow &amp;&amp; fast &amp;&amp; fast.next) &#123;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    <span class="keyword">if</span> (slow === fast) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220804165959.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>基本思路是，使用后一次和前一次做差加初始的值进行判断，如果持续收益大于 0 说明本次是正收益，保留，否则置为 0.最后比较得到 max</p><p>注意 因为是比较前后，最后一位要省去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">prices</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    last = <span class="built_in">Math</span>.max(<span class="number">0</span>, last + prices[i + <span class="number">1</span>] - prices[i]);</span><br><span class="line">    max = <span class="built_in">Math</span>.max(max, last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="215-数组中的第-K-个最大元素"><a href="#215-数组中的第-K-个最大元素" class="headerlink" title="215. 数组中的第 K 个最大元素"></a>215. 数组中的第 K 个最大元素</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220804170410.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">nums, k</span>) =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220804170654.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = s.length;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line">  <span class="keyword">let</span> res = s[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    dp[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s.charAt(i) !== s.charAt(j)) <span class="keyword">continue</span>;</span><br><span class="line">      dp[i][j] = j - i &lt;= <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; res.length) &#123;</span><br><span class="line">        res = s.slice(i, j + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a>912. 排序数组</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220804171859.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>手撕快速排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> left = [];</span><br><span class="line">  <span class="keyword">let</span> right = [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="129-根到叶子节点数字之和"><a href="#129-根到叶子节点数字之和" class="headerlink" title="129. 根到叶子节点数字之和"></a>129. 根到叶子节点数字之和</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220805231049.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code dfs</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">n, sum</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!n.left &amp;&amp; !n.right) &#123;</span><br><span class="line">      res += +[...sum].join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n.left) &#123;</span><br><span class="line">      sum.push(n.left.val);</span><br><span class="line">      dfs(n.left, sum);</span><br><span class="line">      sum.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n.right) &#123;</span><br><span class="line">      sum.push(n.right.val);</span><br><span class="line">      dfs(n.right, sum);</span><br><span class="line">      sum.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs(root, [root.val]);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220807163006.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路：<br>dfs 判断是否处于二位平面，且是否为 1，满足条件沉没陆地，判断下个格子并 dfs</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">grid</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!grid) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> xLen = grid[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">let</span> yLen = grid.length;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> d = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, -<span class="number">1</span>],</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">const</span> inArea = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; yLen &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt;= xLen;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">i, j, grid</span>) =&gt;</span> &#123;</span><br><span class="line">    grid[i][j] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">      <span class="keyword">let</span> x = i + d[k][<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">let</span> y = j + d[k][<span class="number">1</span>];</span><br><span class="line">      inArea(x, y) &amp;&amp; grid[x][y] === <span class="string">&quot;1&quot;</span> &amp;&amp; dfs(x, y, grid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; yLen; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; xLen; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        dfs(i, j, grid);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h1><h1 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a>300. 最长上升子序列</h1><h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h1><h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220805225849.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="comment">// 技巧 变量都要带进递归</span></span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">l, r, path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length === <span class="number">2</span> * n) &#123;</span><br><span class="line">      res.push([...path].join(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      path.push(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">      dfs(l - <span class="number">1</span>, r, path);</span><br><span class="line">      path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意是左括号的数量小于右括号才能让右括号进栈</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">      path.push(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">      dfs(l, r - <span class="number">1</span>, path);</span><br><span class="line">      path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs(n, n, []);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220807164321.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>注意条件<code>!n 和 !n.right&amp;&amp;!n.left</code>的不同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">n, depth</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!n.left &amp;&amp; !n.right) &#123;</span><br><span class="line">      max = <span class="built_in">Math</span>.max(depth, max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n.left) dfs(n.left, depth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (n.right) dfs(n.right, depth + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs(root, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220807171332.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>分解问题再合并问题<br>求 1 就是求 0 的次数和求 1 的次数的最小值比较<br>求 2 其实就是求 1 的次数和求 2 的次数的最小值比较<br>因此推到出状态转移方程为：<br><code>dp[i] = Math.min(dp[i],dp[i-coin]+1)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">coins, amount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(amount + <span class="number">1</span>).fill(<span class="literal">Infinity</span>); <span class="comment">//考虑0</span></span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> coin <span class="keyword">of</span> coins) &#123;</span><br><span class="line">      <span class="keyword">if</span> (coin &gt; i) <span class="keyword">continue</span>; <span class="comment">//如果当前硬币值大于当前所求额度则不能组合 跳过</span></span><br><span class="line">      dp[i] = <span class="built_in">Math</span>.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[amount] === <span class="literal">Infinity</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220808193614.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>走四个方向为一次 dfs，如果中间没有 length 就直接返回。</p><p>走右边相当于 i 为 0 的情况，就直接把整个数组开头 shift 然后解构过来</p><p>走下面相当于 i 大于 0 且小于数组长度的情况，就一直获取前面每个子数组里面 pop 的内容，(因为第一个被 shift 了 长度-1)</p><p>走左边相当于 i 为最后一个的时候，直接把数组最后的元素 pop 然后反转</p><p>注意这个过程中，如果只走了一圈 比如<br>左右下 xxx 左上 xxx 右的情况 出现了很多空子数组，但整个数组还是有长度的</p><p>就会 push 很多 undefined 进去，要阻止他，就得使用<code>if (arr[i] &amp;&amp; !arr[i].length) return; //防止只走一圈就结束的情况</code></p><p>接着我们要完成往上的操作，往上的操作相当于倒着读取数组，然后把子数组的最前面一项拿出来</p><p>注意这个过程也需要判断子数组是否为空</p><p>最后没结束就继续递归</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">matrix</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length; <span class="comment">//保存length</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &amp;&amp; !arr[i].length) <span class="keyword">return</span>; <span class="comment">//防止只走一圈就结束的情况</span></span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">        res.push(...arr.shift());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i === len - <span class="number">1</span>) &#123;</span><br><span class="line">        res.push(...arr.pop().reverse());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.push(arr[i - <span class="number">1</span>].pop());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!arr[i].length) <span class="keyword">return</span>;</span><br><span class="line">      res.push(arr[i].shift());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span>;</span><br><span class="line">    dfs(arr);</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs(matrix);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220807204102.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span>;</span><br><span class="line">    dfs(n.left);</span><br><span class="line">    res.push(n.val);</span><br><span class="line">    dfs(n.right);</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="146-LRU-缓存机制"><a href="#146-LRU-缓存机制" class="headerlink" title="146. LRU 缓存机制"></a>146. LRU 缓存机制</h1><h1 id="剑指-Offer-22-链表中倒数第-k-个节点"><a href="#剑指-Offer-22-链表中倒数第-k-个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第 k 个节点"></a>剑指 Offer 22. 链表中倒数第 k 个节点</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220808224105.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>注意使用 dummy</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getKthFromEnd = <span class="function"><span class="keyword">function</span> (<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  <span class="keyword">let</span> slow = dummy;</span><br><span class="line">  <span class="keyword">let</span> fast = dummy;</span><br><span class="line">  <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (fast.next) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> slow.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h1><h1 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a>剑指 Offer 10- I. 斐波那契数列</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220809185822.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a>695. 岛屿的最大面积</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220809190153.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>在求岛屿数量的基础上增加个 count 和 max 即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxAreaOfIsland = <span class="function"><span class="keyword">function</span> (<span class="params">grid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> xLen = grid[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">const</span> yLen = grid.length;</span><br><span class="line">  <span class="keyword">const</span> d = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, -<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">const</span> inArea = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; yLen &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; xLen;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">i, j, grid</span>) =&gt;</span> &#123;</span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">      <span class="keyword">const</span> x = i + d[k][<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">const</span> y = j + d[k][<span class="number">1</span>];</span><br><span class="line">      inArea(x, y) &amp;&amp; grid[x][y] &amp;&amp; dfs(x, y, grid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; yLen; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; xLen; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="number">1</span>) &#123;</span><br><span class="line">        dfs(i, j, grid);</span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, count);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="103-二叉树的锯齿型层序遍历"><a href="#103-二叉树的锯齿型层序遍历" class="headerlink" title="103. 二叉树的锯齿型层序遍历"></a>103. 二叉树的锯齿型层序遍历</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220809200416.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zigzagLevelOrder = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> q = [root];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> isTran = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (q.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = [];</span><br><span class="line">    <span class="keyword">const</span> len = q.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> n = q.shift();</span><br><span class="line">      temp.push(n.val);</span><br><span class="line">      <span class="keyword">if</span> (n.left) q.push(n.left);</span><br><span class="line">      <span class="keyword">if</span> (n.right) q.push(n.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isTran) &#123;</span><br><span class="line">      res.push(temp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.push(temp.reverse());</span><br><span class="line">    &#125;</span><br><span class="line">    isTran = !isTran;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220809203702.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>因为是正整数数组，所以每次都是递增的<br>使用滑动窗口<br>当右指针移动扩大窗口的时候，判断是否满足 target，如果满足则右指针减左指针得到窗口长度和当前的最小长度比较。然后左指针移动，缩小窗口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">target, nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> l = (r = sum = <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> res = <span class="literal">Infinity</span>;</span><br><span class="line">  <span class="keyword">while</span> (r &lt; nums.length) &#123;</span><br><span class="line">    sum += nums[r++]; <span class="comment">//扩大窗口</span></span><br><span class="line">    <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">      res = <span class="built_in">Math</span>.min(res, r - l); <span class="comment">//r-l代表满足条件的窗口长度</span></span><br><span class="line">      sum -= nums[l++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res === <span class="literal">Infinity</span> ? <span class="number">0</span> : res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化①打包器的资源处理</title>
    <link href="https://zlinni.github.io/posts/3551608196/"/>
    <id>https://zlinni.github.io/posts/3551608196/</id>
    <published>2022-07-30T08:30:58.000Z</published>
    <updated>2022-08-01T15:03:10.057Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在前端工程化这块，打包肯定是大家初次入门的时候会接触到的玩意，最常见的一个例子就是第三方资源 CDN 外部引入。在网上各路教程中都说明他是减少了项目体积，实则不然，下面详细讲述前端打包的方案</p></div><h1 id="模块化方案"><a href="#模块化方案" class="headerlink" title="模块化方案"></a>模块化方案</h1><div class="note primary flat"><p>对于模块化，cjs，es，umd 模块你知道吗？</p></div><h2 id="cjs"><a href="#cjs" class="headerlink" title="cjs"></a>cjs</h2><p>首先是 cjs，全称 <code>Commonjs</code>，是 node 中的模块规范，通过 <code>require</code> 及 <code>export</code> 进行导入导出，进一步延申的化，<code>module.export</code>属于 <code>commonjs2</code>.</p><p>因为他属于 node 的模块，也就是意味着他只能在 node 环境中，也就是不能直接用在浏览器之上。如果你的前端项目需要用到以 cjs 规范写的模块，那么就会出问题(比如 cdn 加载)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="built_in">exports</span>.sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; sum &#125; = <span class="built_in">require</span>(<span class="string">&quot;./sum.js&quot;</span>);</span><br></pre></td></tr></table></figure><p>解决方法是 <code>webpack</code> 的 <code>enhanced-resolve</code>，webpack 是通过引入这个库来解析模块的，他相当于增强版的<code>require.resolve</code>。他会将 require 或者 import 语句中的资源，解析为引入文件的绝对路径，然后通过文件读取加载资源。具体参见这篇文章<a href="https://juejin.cn/post/7004267670832955423#heading-1">【webpack 系列】3. webpack 是如何解析模块的</a></p><p>关键字：<code>cjs</code>，<code>node</code>，<code>require</code> 和 <code>export</code></p><h2 id="esm"><a href="#esm" class="headerlink" title="esm"></a>esm</h2><p>全称<code>es module</code>。是 <code>tc39</code> 对于 <code>ESMAScript</code> 的模块化规范，因为他是规范，所以能用在 node 和浏览器环境下，使用<code>import/export</code>进行模块的导入导出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&quot;./sum&quot;</span>;</span><br></pre></td></tr></table></figure><p>esm 为静态导入，正因为如此，可以在编译的时期进行 tree shaking，减小 js 体积。(判断一个模块是否支持 tree shaking 就要看他发包内容有没有 es，而不是看源码是不是 esm 写的)<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220730171548.png" alt=""></p><p>如果需要动态导入，tc39 为动态加载模块定义了 API: import(module) 。可将以下代码粘贴到控制台执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ms = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&quot;https://cdn.skypack.dev/ms@latest&quot;</span>);</span><br><span class="line"></span><br><span class="line">ms.default(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>esm 是未来的趋势，目前一些 cdn 厂商和前端构建工具都致力于 cjs 模块像 esm 的转化，比如 <code>skypack</code>、 <code>snowpack</code>、<code>vite</code> 等。</p><p>目前浏览器和 node 均支持 esm</p><p>cjs 和 esm 的区别</p><ul><li>cjs 模块输出的是一个值的拷贝，esm 输出的是值的引用</li><li>cjs 是运行时加载，esm 是编译时加载。</li></ul><p>怎么理解这句话呢，实际上可以直接拿 cdn 的 esm 模块来使用，<a href="https://cdn.jsdelivr.net/npm/array-uniq/index.js">array-uniq</a>，就会发现我们并没有使用到他，但是他已经加载出来了。相应的 cjs 模块就不行。源于 nodejs 是 js 的一个解析引擎，是运行时的。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220730165648.png" alt=""></p><h2 id="umd"><a href="#umd" class="headerlink" title="umd"></a>umd</h2><p>umd 是一种兼容 cjs 和 amd 的模块，既可以在 node/webpack 环境中被 require 使用，也可以在浏览器中直接用 cdn 以<code>script.src</code>引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&quot;function&quot;</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">    <span class="comment">// AMD</span></span><br><span class="line">    define([<span class="string">&quot;jquery&quot;</span>], factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// CommonJS (如果有exports关键字就是cjs)</span></span><br><span class="line">    <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">&quot;jquery&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 全局变量</span></span><br><span class="line">    root.returnExports = factory(root.jQuery);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看出 umd 的本质就是一个 IIFE。</p><p>这三种模块方案大致如此，部分 npm package 也会被同时打包出 commonjs/esm/umd 三种模块，以供不同的需求的业务使用。比如 antd</p><h1 id="AST-抽象语法树"><a href="#AST-抽象语法树" class="headerlink" title="AST 抽象语法树"></a>AST 抽象语法树</h1><p>AST 全称 Abstract Syntax Tree，抽象语法树，涉及到工程化的诸多环节的应用，比如：</p><ol><li>如何将 ts 转换为 js</li><li>如何将 sass/less 转化为 css</li><li>如何将 es6 转化为 es5(babel)</li><li>如何将 js 代码格式化 prettier/eslint</li><li>如何识别 jsx</li><li>graphQL，MDX，Vue SFC 等等</li></ol><p>这种语言转换的过程实际就是对其 AST，核心步骤是</p><ol><li>code -&gt; ast(parse)</li><li>ast -&gt; ast(transform)</li><li>ast -&gt; code(generate)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AST</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Program&quot;</span>,</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;end&quot;</span>: <span class="number">11</span>,</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;VariableDeclaration&quot;</span>,</span><br><span class="line">      <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">&quot;end&quot;</span>: <span class="number">11</span>,</span><br><span class="line">      <span class="string">&quot;declarations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;VariableDeclarator&quot;</span>,</span><br><span class="line">          <span class="string">&quot;start&quot;</span>: <span class="number">6</span>,</span><br><span class="line">          <span class="string">&quot;end&quot;</span>: <span class="number">11</span>,</span><br><span class="line">          <span class="string">&quot;id&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">            <span class="string">&quot;start&quot;</span>: <span class="number">6</span>,</span><br><span class="line">            <span class="string">&quot;end&quot;</span>: <span class="number">7</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;a&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;init&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Literal&quot;</span>,</span><br><span class="line">            <span class="string">&quot;start&quot;</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">&quot;end&quot;</span>: <span class="number">11</span>,</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="string">&quot;raw&quot;</span>: <span class="string">&quot;4&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;const&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;module&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 vue 的环节中也讲到了如何解析模板语法为 ast，就是生成类似的对象。对于不同语言有不同的解析器，js 的解析器和 css 的解析器就完全不一样。相同的语言也有不同的解析器，比如 babel 和 espree</p><h2 id="AST-的生成"><a href="#AST-的生成" class="headerlink" title="AST 的生成"></a>AST 的生成</h2><p>这一步称之为解析 parse，这个步骤有两个阶段，一是词法分析，二是语法分析。</p><p>词法分析是将代码转化为 token 数组，我们常见的 mdeditor 和 eslint，hightlight,模板语法等就是利用了这个步骤去判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code</span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Token</span></span><br><span class="line">[</span><br><span class="line">  &#123; <span class="attr">type</span>: &#123; ... &#125;, <span class="attr">value</span>: <span class="string">&quot;a&quot;</span>, <span class="attr">start</span>: <span class="number">0</span>, <span class="attr">end</span>: <span class="number">1</span>, <span class="attr">loc</span>: &#123; ... &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: &#123; ... &#125;, <span class="attr">value</span>: <span class="string">&quot;=&quot;</span>, <span class="attr">start</span>: <span class="number">2</span>, <span class="attr">end</span>: <span class="number">3</span>, <span class="attr">loc</span>: &#123; ... &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: &#123; ... &#125;, <span class="attr">value</span>: <span class="string">&quot;3&quot;</span>, <span class="attr">start</span>: <span class="number">4</span>, <span class="attr">end</span>: <span class="number">5</span>, <span class="attr">loc</span>: &#123; ... &#125; &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>语法分析是将 token 流转化为结构化的 ast，方便操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Program&quot;</span>,</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;end&quot;</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;ExpressionStatement&quot;</span>,</span><br><span class="line">      <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">&quot;end&quot;</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="string">&quot;expression&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;AssignmentExpression&quot;</span>,</span><br><span class="line">        <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;end&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">&quot;operator&quot;</span>: <span class="string">&quot;=&quot;</span>,</span><br><span class="line">        <span class="string">&quot;left&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">          <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="string">&quot;end&quot;</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="string">&quot;name&quot;</span>: <span class="string">&quot;a&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;right&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Literal&quot;</span>,</span><br><span class="line">          <span class="string">&quot;start&quot;</span>: <span class="number">4</span>,</span><br><span class="line">          <span class="string">&quot;end&quot;</span>: <span class="number">5</span>,</span><br><span class="line">          <span class="string">&quot;value&quot;</span>: <span class="number">3</span>,</span><br><span class="line">          <span class="string">&quot;raw&quot;</span>: <span class="string">&quot;3&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;module&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>可通过自己写一个解析器，将语言 DSL 解析为 AST 进行练手，以下两个示例是不错的选择</p><ol><li>解析简单的 HTML 为 AST</li><li>解析 Marktodwn List 为 AST</li></ol><p>或可参考一个最简编译器的实现 the super tiny compiler</p><h1 id="原理与运行时分析"><a href="#原理与运行时分析" class="headerlink" title="原理与运行时分析"></a>原理与运行时分析</h1><h2 id="webpack-runtime"><a href="#webpack-runtime" class="headerlink" title="webpack runtime"></a>webpack runtime</h2><p>webpack 的 runtime，也就是 webpack 最后生成的代码，做了以下三件事：</p><ol><li><code>_webpack_modules_</code>:维护一个所有模块的数组。将入口模块解析为 ast，根据 ast 深度优先搜索出所有的模块，并构建出这个模块数组。每个模块都由一个包裹函数<code>(module, module.exports, __webpack_require__)</code>对模块进行包裹而成。</li><li><code>__webpack_require__(moduleId)</code>手动实现加载一个模块。对已经加载过的模块进行缓存，对未加载的模块，执行 id 定位到<code>__webpack_modules__</code>中的包裹函数，执行并返回 module.exports 并缓存</li><li><code>__webpack_require__(0)</code>: 运行第一个模块，即运行入口模块</li></ol><p>另外，当涉及到多个 chunk 的打包方式中，比如 code spliting，webpack 会有 jsonp 加载 chunk 的运行时代码</p><p>以下是 <code>webpack runtime</code> 的最简代码，配置示例可见 <code>node-examples</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span> <span class="keyword">var</span> __webpack_modules__ = [</span><br><span class="line">  ,</span><br><span class="line">  <span class="comment">/* 0 */</span> <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="comment">/***/</span> <span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="function">(<span class="params">...args</span>) =&gt;</span> args.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***/</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line">];</span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// The module cache</span></span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// The require function</span></span><br><span class="line"><span class="comment">/******/</span> <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">// Check if module is in cache</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">var</span> cachedModule = __webpack_module_cache__[moduleId];</span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">if</span> (cachedModule !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">/******/</span> <span class="keyword">return</span> cachedModule.exports;</span><br><span class="line">    <span class="comment">/******/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">var</span> <span class="built_in">module</span> = (__webpack_module_cache__[moduleId] = &#123;</span><br><span class="line">    <span class="comment">/******/</span> <span class="comment">// no module.id needed</span></span><br><span class="line">    <span class="comment">/******/</span> <span class="comment">// no module.loaded needed</span></span><br><span class="line">    <span class="comment">/******/</span> <span class="built_in">exports</span>: &#123;&#125;,</span><br><span class="line">    <span class="comment">/******/</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">// Execute the module function</span></span><br><span class="line">  <span class="comment">/******/</span> __webpack_modules__[moduleId](</span><br><span class="line">    <span class="built_in">module</span>,</span><br><span class="line">    <span class="built_in">module</span>.exports,</span><br><span class="line">    __webpack_require__</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">// Return the exports of the module</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="keyword">var</span> __webpack_exports__ = &#123;&#125;;</span><br><span class="line"><span class="comment">// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.</span></span><br><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> sum = __webpack_require__(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  sum(<span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>对 webpack runtime 做进一步的精简，代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> __webpack_modules__ = [<span class="function">()=&gt;</span>&#123;&#125;];</span><br><span class="line"><span class="keyword">const</span> __webpack_require__ = <span class="function">(<span class="params">id</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">    <span class="attr">exports</span>:&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> m = __webpack_modules__[id](<span class="built_in">module</span>,_webpack_require__)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br><span class="line">__webpack_require__(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="rollup"><a href="#rollup" class="headerlink" title="rollup"></a>rollup</h2><p>在 rollup 中，并不会将所有模块置于 modules 中使用 Module Wrapper 进行维护，他仅仅将所有模块铺平展开。</p><p>举例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> name <span class="keyword">from</span> <span class="string">&quot;./name&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//name.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;jojo&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包后</span></span><br><span class="line"><span class="comment">// output.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;jojo&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure><p>对于他的这种方案要是遇到变量冲突如何解决，如下：直接重新命名</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220801134201.png" alt=""></p><h1 id="运行时-chunk-加载分析"><a href="#运行时-chunk-加载分析" class="headerlink" title="运行时 chunk 加载分析"></a>运行时 chunk 加载分析</h1><p>问：webpack 的 code spliting 是如何动态加载 chunk 的?</p><p>一个 webpack 运行时，包括最重要的两个数据结构：</p><ol><li><code>__webpack_modules__</code>维护一个所有模块的数组。将入口模块解析为 ast，根据 ast 深度优先搜索所有的模块，并构建出这个模块数组。每个模块都由一个包裹函数<code>(module, module.exports, __webpack_require__)</code>对模块进行包裹而成。</li><li><code>__webpack_require__(moduleId)</code>手动实现加载一个模块。对已经加载过的模块进行缓存，对未加载的模块，根据 id 定位到<code>__webpack_modules__</code>中的包裹函数，执行并返回<code>module.exports</code>并缓存。</li></ol><h2 id="code-spliting"><a href="#code-spliting" class="headerlink" title="code spliting"></a>code spliting</h2><p>在 webpack 中通过 import 可以实现 code spliting。假设有以下文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&quot;./sum&quot;</span>).then(<span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</span><br><span class="line">  m.default(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sum;</span><br></pre></td></tr></table></figure><p>使用下面的 webpack 配置进行打包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">entry</span>:<span class="string">&#x27;./index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">mode</span>:<span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>:&#123;</span><br><span class="line">    <span class="attr">filename</span>:<span class="string">&#x27;[name].[contenthash].js&#x27;</span>,</span><br><span class="line">    <span class="attr">chunkFilename</span>:<span class="string">&#x27;chunk.[name].[id].[contenthash].js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>:path.resolve(_dirname,<span class="string">&#x27;dist/deterministic&#x27;</span>),</span><br><span class="line">    <span class="attr">clean</span>:<span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">optimization</span>:&#123;</span><br><span class="line">    <span class="attr">moduleIds</span>:<span class="string">&#x27;deterministic&#x27;</span>,</span><br><span class="line">    <span class="attr">chunkIds</span>:<span class="string">&#x27;deterministic&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行时解析"><a href="#运行时解析" class="headerlink" title="运行时解析"></a>运行时解析</h2><p>观测打包后的文件<code>dist/deterministic/main.xxxxxx.js</code>,可以发现：使用<code>import()</code>加载数据时，以上代码将被编译为以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require__</span><br><span class="line">  .e(<span class="comment">/* import() | sum */</span> <span class="number">644</span>)</span><br><span class="line">  .then(__webpack_require__.bind(__webpack_require__, <span class="number">709</span>))</span><br><span class="line">  .then(<span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</span><br><span class="line">    m.default(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>此时 644 为 chunkId，观测<code>chunk.sum.xxx.js</code>文件，以下为 sum 函数所构建的 chunk</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line">(self[<span class="string">&quot;webpackChunk&quot;</span>] = self[<span class="string">&quot;webpackChunk&quot;</span>] || []).push([</span><br><span class="line">  [<span class="number">644</span>],</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/***/</span> <span class="number">709</span>: <span class="comment">/***/</span> <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      __unused_webpack_module,</span></span></span><br><span class="line"><span class="params"><span class="function">      __webpack_exports__,</span></span></span><br><span class="line"><span class="params"><span class="function">      __webpack_require__</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) =&gt;</span> &#123;</span><br><span class="line">      __webpack_require__.r(__webpack_exports__);</span><br><span class="line">      <span class="comment">/* harmony export */</span> __webpack_require__.d(__webpack_exports__, &#123;</span><br><span class="line">        <span class="comment">/* harmony export */</span> <span class="keyword">default</span>: <span class="function">() =&gt;</span> __WEBPACK_DEFAULT_EXPORT__,</span><br><span class="line">        <span class="comment">/* harmony export */</span></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* harmony default export */</span> <span class="keyword">const</span> __WEBPACK_DEFAULT_EXPORT__ = sum;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/***/</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>以下两个数据结构是加载 chunk 的关键：</p><ol><li><code>__webpack_require__.e</code>：加载 chunk。该函数使用<code>document.createElement(&#39;script&#39;)</code>异步加载 chunk 并封装为 promise。</li><li><code>self[&quot;webpackChunk&quot;].push</code>:JSONP callback，收集 modules 至<code>__webpack_modules__</code>并将<code>__webpack_require__.e</code>的 promise 进行 resolve</li></ol><p>实际上在 webpack 中可以配置<code>output.chunkLoading</code>来选择加载 chunk 的方式，比如选择通过<code>import()</code>的方式来加载。（由于在生产环境中要考虑 import 的兼容性，目前 JSONP 的方案比较多）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;main.[contenthash].js&#x27;</span>,</span><br><span class="line">    <span class="attr">chunkFilename</span>: <span class="string">&#x27;[name].chunk.[chunkhash].js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist/import&#x27;</span>),</span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 默认为 `jsonp`</span></span><br><span class="line">    <span class="attr">chunkLoading</span>: <span class="string">&#x27;import&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="打包器-webpack-rollup-如何加载-json，image-等非-js-资源"><a href="#打包器-webpack-rollup-如何加载-json，image-等非-js-资源" class="headerlink" title="打包器(webpack/rollup)如何加载 json，image 等非 js 资源"></a>打包器(webpack/rollup)如何加载 json，image 等非 js 资源</h1><p>我们知道在 webpack 中一切都是模块，所以加载 json 等非 js 资源的时候，就需要模块加载器，也就是俗称的 loader。将他们转化为模块。</p><h2 id="加载-json"><a href="#加载-json" class="headerlink" title="加载 json"></a>加载 json</h2><p>以 json 为例子</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user.json 中内容</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="number">10086</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;jojo&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在现代前端中，我们把他视为 module 时，使用 import 引入资源。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> user <span class="keyword">from</span> <span class="string">&quot;./user.json&quot;</span>;</span><br></pre></td></tr></table></figure><p>而我们的打包器，如 webpack 与 rollup，将通过以下的方式来加载 json 资源</p><p>这样将被视为普通的 js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际上会被编译为以下内容</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">10086</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;jojo&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 webpack 中通过 loader 处理此类资源，示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> json = <span class="keyword">typeof</span> source === <span class="string">&quot;string&quot;</span> ? source : <span class="built_in">JSON</span>.stringfy(source);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`module.exports = <span class="subst">$&#123;json&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h2><p>那图片是如何处理的呢？</p><p>更简单，他将替换成自身的路径。示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">`$PUBLIC_URL/assets/image/main.png`</span>;</span><br></pre></td></tr></table></figure><p>而我们在<code>import image</code>的时候，其实是图片自身的路径，将他置于<code>src</code>属性即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mainImage <span class="keyword">from</span> <span class="string">&#x27;main.jpg&#x27;</span>;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;mainImage&#125;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="加载-css"><a href="#加载-css" class="headerlink" title="加载 css"></a>加载 css</h2><p>在 webpack 中处理 css 比较费劲。需要借用两个 loader 来做这件事。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><code>css-loader</code>处理 css 中 <code>url</code> 与<code>@import</code>,并将其视为模块引入，此处是通过 postcss 来解析处理。postcss 对于工程化中 css 的处理可见一斑。</li><li><code>style-loader</code>将样式注入到 DOM 中。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(./basic.css);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">./shanyue.png</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>cssloader 的原理就是 postcss，借用<code>postcss-value-parser</code>解析 css 为 ast。并将 css 中的<code>url()</code>与<code>@import</code>解析为模块。</p><p>styleloader 将 css 注入到 dom，原理为使用 DOM API 手动创建 style 标签，并将 css 内容注入到 style 中。</p><p>源码实现中借用了许多运行时代码。而最简单的实现仅需几行代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">  function injectCSS(css)&#123;</span></span><br><span class="line"><span class="string">    const style = document.createElement(&#x27;style&#x27;);</span></span><br><span class="line"><span class="string">    style.appendChild(document.createTextNode(css))</span></span><br><span class="line"><span class="string">    document.head.appendChild(style)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  injectCSS(\`<span class="subst">$&#123;source&#125;</span>`</span>\)</span><br><span class="line">  <span class="string">`</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>使用 DOM API 加载 CSS 资源，由于 CSS 需要在 JS 资源加载完后通过 DOM API 进行控制加载，容易出现页面抖动，在线上低效且性能低下。且对于 SSR 极其不友好。</p><p>由于性能需要，在线上通常单独加载 css，这就要求打包器能够将 css 打包，此时需要借助于<code>mini-css-extract-plugin</code>将 css 单独抽离出来。</p><h2 id="注入-js-到-html"><a href="#注入-js-到-html" class="headerlink" title="注入 js 到 html"></a>注入 js 到 html</h2><p>如果最终打包的 mainjs 既没有做 code spliting，也没有做 hash 化路径。大可以通过在<code>index.html</code>中手动控制 js 资源。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span> <span class="attr">defer</span> /&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure><p>不过往往事与愿违：</p><ol><li>mainjs 即我们最后生成的文件带有 hash 值。</li><li>由于长期缓存的需要，入口文件不仅只有一个，还包括第三方模块打包而成的 vendorjs，同样带有 hash</li><li>脚本地址同时需要注入 publicPath，而在生产环境与测试环境的 publicPath 并不一致。</li></ol><p>因此需要一个插件做这件事情，在 webpack 中叫<code>html-webpack-plugin</code>在 rollup 的世界里叫<code>@rollup/plugin-html</code></p><p>而注入的原理为当打包器已生成 <code>entryPoint</code> 文件资源后，获得其文件名以及 <code>publicPath</code>，并将其注入到 <code>html</code> 中</p><p>以 <code>html-webpack-plugin</code> 为例，它在 <code>compilation</code> 处理资源的 <code>processAssets</code> 获得其打包生成的资源。伪代码如下，可在 <code>mini-node:html-webpack-plugin (opens new window)</code>获得源码并运行示例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlWebpackPlugin</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.options = options || &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> webpack = compiler.webpack;</span><br><span class="line"></span><br><span class="line">    compiler.hooks.thisCompilation.tap(<span class="string">&quot;HtmlWebpackPlugin&quot;</span>, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// compilation 是 webpack 中最重要的对象，文档见 [compilation-object](https://webpack.js.org/api/compilation-object/#compilation-object-methods)</span></span><br><span class="line"></span><br><span class="line">      compilation.hooks.processAssets.tapAsync(</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&quot;HtmlWebpackPlugin&quot;</span>,</span><br><span class="line"></span><br><span class="line">          <span class="comment">// processAssets 处理资源的时机，此阶段为资源已优化后，更多阶段见文档</span></span><br><span class="line">          <span class="comment">// https://webpack.js.org/api/compilation-hooks/#list-of-asset-processing-stages</span></span><br><span class="line">          <span class="attr">stage</span>: webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">(<span class="params">compilationAssets, callback</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// compilationAssets 将得到所有生成的资源，如各个 chunk.js、各个 image、css</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 获取 webpac.output.publicPath 选项，(PS: publicPath 选项有可能是通过函数设置)</span></span><br><span class="line">          <span class="keyword">const</span> publicPath = getPublicPath(compilation);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 本示例仅仅考虑单个 entryPoint 的情况</span></span><br><span class="line">          <span class="comment">// compilation.entrypoints 可获取入口文件信息</span></span><br><span class="line">          <span class="keyword">const</span> entryNames = <span class="built_in">Array</span>.from(compilation.entrypoints.keys());</span><br><span class="line"></span><br><span class="line">          <span class="comment">// entryPoint.getFiles() 将获取到该入口的所有资源，并能够保证加载顺序！！！如 runtime-chunk -&gt; main-chunk</span></span><br><span class="line">          <span class="keyword">const</span> assets = entryNames</span><br><span class="line">            .map(<span class="function">(<span class="params">entryName</span>) =&gt;</span></span><br><span class="line">              compilation.entrypoints.get(entryName).getFiles()</span><br><span class="line">            )</span><br><span class="line">            .flat();</span><br><span class="line">          <span class="keyword">const</span> scripts = assets.map(<span class="function">(<span class="params">src</span>) =&gt;</span> publicPath + src);</span><br><span class="line">          <span class="keyword">const</span> content = html(&#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="built_in">this</span>.options.title || <span class="string">&quot;Demo&quot;</span>,</span><br><span class="line">            scripts,</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// emitAsset 用以生成资源文件，也是最重要的一步</span></span><br><span class="line">          compilation.emitAsset(</span><br><span class="line">            <span class="string">&quot;index.html&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> webpack.sources.RawSource(content)</span><br><span class="line">          );</span><br><span class="line">          callback();</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="HMR"><a href="#HMR" class="headerlink" title="HMR"></a>HMR</h1><p>全称Hot Module Replacement，热模块替换，无需刷新在内存环境中即可替换掉旧模块。与live Reload相对应</p><p>在webpack的运行时中，<code>__webpack_modules__</code>用于维护所有模块。</p><p>而热模块替换的原理，即是通过chunk的方式加载最新的modules，找到<code>_webpack_modules_</code>里面对应的模块逐一替换。并删除其上下缓存</p><p>其精简数据结构如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack 运行时代码</span></span><br><span class="line"><span class="keyword">const</span> __webpack_modules = [</span><br><span class="line">  <span class="function">(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, __webpack_require__</span>) =&gt;</span> &#123;</span><br><span class="line">    __webpack_require__(<span class="number">0</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这是一号模块&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// HMR Chunk 代码</span></span><br><span class="line"><span class="comment">// JSONP 异步加载的所需要更新的 modules，并在 __webpack_modules__ 中进行替换</span></span><br><span class="line">self[<span class="string">&quot;webpackHotUpdate&quot;</span>](<span class="number">0</span>, &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这是最新的一号模块&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>以下为更具体更完整的流程，每一步都涉及很多，有兴趣的可以阅读webpack-dev-server以及开发环境webpack运行时的源码</p><ol><li>webpack-dev-server将打包输出bundle使用内存型文件系统控制，而非真实的文件系统。此时使用的是memfs模拟node的fs API</li><li>每当文件发生变更的时候，webpack会重新编译，webpack-dev-server将会监控到此时文件变更事件。并找到对应的module。此时使用的是chokidar的文件监控模块</li><li>webpack-dev-server将会把变更模块通知到浏览器端，此时使用websocket与浏览器进行交流。此时使用的是ws</li><li>浏览器根据websocket接收到hash，并通过hash以jsonp的方式请求更新模块的chunk</li><li>浏览器加载chunk，并使用新的模块对就模块进行热替换。并删除其上下缓存</li></ol><h1 id="构建性能优化"><a href="#构建性能优化" class="headerlink" title="构建性能优化"></a>构建性能优化</h1><p>首先我们要知道怎么评估性能：使用<a href="https://github.com/stephencookdev/speed-measure-webpack-plugin">speed-measure-webpack-plugin</a>可以评估每个loader/plugin的执行耗时。</p><h2 id="更快的loader：swc"><a href="#更快的loader：swc" class="headerlink" title="更快的loader：swc"></a>更快的loader：swc</h2><p>在webpack中耗时最久的是负责ast转换的loader。</p><p>当loader进行编译的时候，ast操作均为cpu密集型任务，使用js性能低下，此时可以采用高性能语言rust编写的swc</p><p>比如js转化由babel转化为更快的swc</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;swc-loader&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="持久化缓存cache"><a href="#持久化缓存cache" class="headerlink" title="持久化缓存cache"></a>持久化缓存cache</h2><p>webpack内置了关于缓存的插件，可以通过cache字段开启。</p><p>他将module，chunk等信息序列化到磁盘中，二次构建避免重复编译计算，编译速度得到很大的提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">cache</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;filesystem&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如对一个js文件配置了eslint，ts，babel等loader。可能执行五次编译。被五次解析为ast。</p><ol><li>acorn：用于依赖分析，解析为acorn的ast</li><li>eslint-parser： 用以lint，解析为espree的ast</li><li>ts：用以ts…</li><li>babel: 转化es6+</li><li>terser：压缩混淆。解析为acorn的ast</li></ol><p>当开启了持久化缓存，最耗时的ast解析将能够从磁盘的缓存中获取，再次编译时无需进行解析ast</p><p>得益于持久化缓存。二次编译甚至可得到与unbundle的vite相近的开发体验。</p><h2 id="多线程-thread-loader"><a href="#多线程-thread-loader" class="headerlink" title="多线程 thread-loader"></a>多线程 thread-loader</h2><p><code>thread-loader</code>为官方推荐的开启多线程的loader，可以对babel解析ast时开启多线程处理，提升编译的性能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;thread-loader&quot;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">workers</span>: <span class="number">8</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在webpack4中使用的是happypack plugin。but他已经很久不维护了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/打包器的资源处理.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Webpack系列" scheme="https://zlinni.github.io/categories/Webpack%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Webpack" scheme="https://zlinni.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript_Challenges</title>
    <link href="https://zlinni.github.io/posts/4172318439/"/>
    <id>https://zlinni.github.io/posts/4172318439/</id>
    <published>2022-07-24T14:19:08.000Z</published>
    <updated>2022-08-02T13:42:42.603Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>开始提前批直通车啦~~ 本篇带来 ts 超集的各种挑战加个人解说。源码地址：<a href="https://github.com/type-challenges/type-challenges/">传送门</a></p></div><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220724223740.png" alt=""></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloWorld = <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure><h1 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220724223909.png" alt=""></p><p>code</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyPick&lt;T, K&gt; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyPick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解释：pick 就是获取第一个参数的类型的其中几个，写法是<code>Pick&lt;target,&#39;属性1&#39;|&#39;属性2&#39;&gt;</code>，所以要实现他，就是说第二个属性要在 T 中，extends keyof 保证 K 的所有的类型在 T 中，in 保证 P 所有的类型在 K 中。</p><p>那么这里会有一个疑问。in 和 keyof 的区别</p><p>首先 keyof 是取 interface 的联合类型，</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInfo &#123;</span><br><span class="line">  <span class="attr">userName</span>: <span class="string">&quot;jojo&quot;</span>;</span><br><span class="line">  psw: <span class="string">&quot;123&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> value = keyof UserInfo;</span><br><span class="line"><span class="comment">// value= &#x27;userName&#x27;|&#x27;psw&#x27;</span></span><br></pre></td></tr></table></figure><p>in 是取联合类型，主要用于数组和对象的构建。<br>切记不要用于 interface 否则会报错，</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> name = <span class="string">&quot;firstName&quot;</span> | <span class="string">&quot;lastName&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> JOJOName = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> name]: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//JOJOName = &#123;firstName:string,lastName:string&#125;</span></span><br></pre></td></tr></table></figure><p>用于实际开发，举例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">obj: <span class="built_in">Object</span>, key: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&quot;jojo&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> value = getValue(obj1, <span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样写就丧失了 ts 的优势</p><ol><li>无法确定返回值的类型，</li><li>无法对 key 进行约束</li></ol><p>所以我们要这样写</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Object</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&quot;jojo&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> value = getValue(obj1, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 如果第二个参数不是obj1中的参数就会报错</span></span><br></pre></td></tr></table></figure><h1 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220725095917.png" alt=""></p><p>解释：需要将 T 中的参数变为只读</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyReadonly&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Tuple-to-Object-元组转换为对象"><a href="#Tuple-to-Object-元组转换为对象" class="headerlink" title="Tuple to Object 元组转换为对象"></a>Tuple to Object 元组转换为对象</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220725100347.png" alt=""></p><p>解释：需要取出元组的值，并且构造成对象</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToObject&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">any</span>[]&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> T[<span class="built_in">number</span>]]: P;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意<code>T[number]</code>是可以取出元组中的值,所以不用 keyof 了</p><h1 id="第一个元素"><a href="#第一个元素" class="headerlink" title="第一个元素"></a>第一个元素</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220725103040.png" alt=""></p><p>解释：取出 T 的第一个元素 非空判断</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> First&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> <span class="built_in">never</span>[] ? <span class="built_in">never</span> : T[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h1 id="获取元组长度"><a href="#获取元组长度" class="headerlink" title="获取元组长度"></a>获取元组长度</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220725103445.png" alt=""></p><p>解释：如果元组存在 length 属性则返回 length 值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Length&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">length</span>: infer L &#125;</span><br><span class="line">  ? L</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p>注意输入的类型是数组才行</p><h1 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220725104229.png" alt=""></p><p>解释：排除 T 中带有 U 的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyExclude&lt;T,U&gt; = T <span class="keyword">extends</span> U:<span class="built_in">never</span>:T</span><br></pre></td></tr></table></figure><p>简述 T 的类型在 U 里面就排除</p><h1 id="Awaited"><a href="#Awaited" class="headerlink" title="Awaited"></a>Awaited</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220725123703.png" alt=""></p><p>解释：实现该方法返回 promise 对象类型，要点是判断其中类型是否为 promise 在判断 promise 内的类型是否还是 promise 类型(递归)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyAwaited&lt;T <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;unknown&gt;&gt; = T <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;infer U&gt;</span><br><span class="line">  ? U <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;unknown&gt;</span><br><span class="line">    ? MyAwaited&lt;U&gt;</span><br><span class="line">    : U</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h1 id="If"><a href="#If" class="headerlink" title="If"></a>If</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220725124910.png" alt=""></p><p>解释：C 是 true 就返回 T 的类型，是 false 就返回 F 的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> If&lt;C <span class="keyword">extends</span> <span class="built_in">Boolean</span>, T, F&gt; = C <span class="keyword">extends</span> <span class="literal">true</span> ? T : F;</span><br></pre></td></tr></table></figure><h1 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220725125530.png" alt=""></p><p>解释：实现 js 的 concat 效果，合并两个类型数组。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Concat&lt;T <span class="keyword">extends</span> unknown[], U <span class="keyword">extends</span> unknown[]&gt; = [...T, ...U];</span><br></pre></td></tr></table></figure><p>使用解构即可。</p><h1 id="Includes"><a href="#Includes" class="headerlink" title="Includes"></a>Includes</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220726145707.png" alt=""></p><p>解释：后一个类型如果包含在前面的类型中就返回 true 否则返回 false</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Includes&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">any</span>[], U&gt; = T <span class="keyword">extends</span> [infer F, ...infer R]</span><br><span class="line">  ? Equal&lt;F, U&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? <span class="literal">true</span></span><br><span class="line">    : Includes&lt;R, U&gt;</span><br><span class="line">  : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h1 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220726151820.png" alt=""></p><p>解释：实现 js 的 push</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Push&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], U&gt; = [...T, U];</span><br></pre></td></tr></table></figure><h1 id="Unshift"><a href="#Unshift" class="headerlink" title="Unshift"></a>Unshift</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220726152550.png" alt=""></p><p>解释：实现 js 的 unshift</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Unshift&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], U&gt; = [U, ...T];</span><br></pre></td></tr></table></figure><h1 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220726152713.png" alt=""></p><p>解释：获取函数参数类型以数组输出</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyParameters&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...args: infer K</span><br><span class="line">) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? K</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p>注意的点在于其实<code>...args</code>的类型是<code>any[]</code>也就是以为着结果以数组输出的使用也可以利用上，直接使用 infer 去推断他的具体类型。</p><h1 id="获取函数返回类型"><a href="#获取函数返回类型" class="headerlink" title="获取函数返回类型"></a>获取函数返回类型</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220726153737.png" alt=""></p><p>解释：获取函数的返回类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyReturnType&lt;T&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; infer K ? K : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p>和上一题类似</p><h1 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220726154358.png" alt=""></p><p>解释：Pick 和 Exclude 的结合</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyOmit&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> P <span class="keyword">extends</span> K ? <span class="built_in">never</span> : P]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">type</span> MyOmit&lt;T, K <span class="keyword">extends</span> keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure><h1 id="Readonly2"><a href="#Readonly2" class="headerlink" title="Readonly2"></a>Readonly2</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220726213353.png" alt=""></p><p>解释：如果不传 K 则默认为 readonly 否则就按 K 的内容对 T 进行只读的限制。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyReadonly2&lt;T, K <span class="keyword">extends</span> keyof T = keyof T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125; &amp; &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> P <span class="keyword">extends</span> K ? <span class="built_in">never</span> : P]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意的点首先是默认赋值，因为他不存在其实就是相当于用了全部的 T 的键，然后还有一点就是，他是 readonly 和 omit 的结合。在 K 中的所有值都是 readonly，不在 k 中的所有值都是 omit</p><h1 id="Deep-Readonly"><a href="#Deep-Readonly" class="headerlink" title="Deep Readonly"></a>Deep Readonly</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220726215552.png" alt=""></p><p>解释：使用深度只读将对象的每个属性包括对象本身变成只读</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeepReadonly&lt;T&gt; = keyof T <span class="keyword">extends</span> <span class="built_in">never</span></span><br><span class="line">  ? T</span><br><span class="line">  : &#123; <span class="keyword">readonly</span> [k <span class="keyword">in</span> keyof T]: DeepReadonly&lt;T[k]&gt; &#125;;</span><br></pre></td></tr></table></figure><p>注意其实递归设置 readonly 是比较简单的，但是细节在于递归的设置，此处如果不是对象就返回初始类型</p><h1 id="元组转集合"><a href="#元组转集合" class="headerlink" title="元组转集合"></a>元组转集合</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220728110948.png" alt=""></p><p>解释：把元组转为集合</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToUnion&lt;T&gt; = T <span class="keyword">extends</span> (infer U)[] ? U : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p>关键在于通过 infer 推断集合的类型，以及取出元组的类型</p><h1 id="可串联构造器"><a href="#可串联构造器" class="headerlink" title="可串联构造器"></a>可串联构造器</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220728112156.png" alt=""></p><h1 id="最后一个元素"><a href="#最后一个元素" class="headerlink" title="最后一个元素"></a>最后一个元素</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220728155341.png" alt=""></p><p>解释:取出数组最后一个元素</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Last&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [...any, infer U] ? U : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h1 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220728155753.png" alt=""></p><p>解释:实现 pop</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pop&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [...infer Head, infer R]</span><br><span class="line">  ? [...Head]</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220728160431.png" alt=""></p><p>解释:实现 PromiseAll 获取数组值的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AwaitedAll&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> []</span><br><span class="line">  ? []</span><br><span class="line">  : T <span class="keyword">extends</span> [infer F, ...infer R]</span><br><span class="line">  ? [Awaited&lt;F&gt;, ...AwaitedAll&lt;R&gt;]</span><br><span class="line">  : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">PromiseAll</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">any</span>[]&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="keyword">readonly</span> [...T]</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Promise</span>&lt;<span class="title">AwaitedAll</span>&lt;<span class="title">T</span>&gt;&gt;</span>;</span><br></pre></td></tr></table></figure><ul><li>结合 awaited 的学习知识获取 Promise 的类型</li><li>结合类型解构和递归处理 Promise 的情况</li><li>注意空数组的情况</li><li>因为 promise 的结果是不能改变的，所以要加 readonly</li><li>解构 T 类型传入自定义的 AwaitedAll</li></ul><h1 id="Type-Lookup"><a href="#Type-Lookup" class="headerlink" title="Type Lookup"></a>Type Lookup</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220729163101.png" alt=""></p><p>解释：从 U 中获取 type 为 T 的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LookUp&lt;U, T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = U <span class="keyword">extends</span> &#123; <span class="attr">type</span>: T &#125; ? U : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h1 id="Trim-Left"><a href="#Trim-Left" class="headerlink" title="Trim Left"></a>Trim Left</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220729172654.png" alt=""></p><p>解释:删除字符串左边的空格</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Space = <span class="string">&quot; &quot;</span> | <span class="string">&quot;\n&quot;</span> | <span class="string">&quot;\t&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> TrimLeft&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;Space&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">  ? TrimLeft&lt;R&gt;</span><br><span class="line">  : S;</span><br></pre></td></tr></table></figure><p>技巧:结合模板字符串操作递归删除</p><h1 id="Trim"><a href="#Trim" class="headerlink" title="Trim"></a>Trim</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802164041.png" alt=""></p><p>解释:实现 trim 删除字符串两端的所有空格</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Space = <span class="string">&quot; &quot;</span> | <span class="string">&quot;\n&quot;</span> | <span class="string">&quot;\t&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> Trim&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;Space&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">  ? Trim&lt;R&gt;</span><br><span class="line">  : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer K&#125;</span><span class="subst">$&#123;Space&#125;</span>`</span></span><br><span class="line">  ? Trim&lt;K&gt;</span><br><span class="line">  : S;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">type</span> Trim&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span></span><br><span class="line">  | <span class="string">`<span class="subst">$&#123;Space&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">  | <span class="string">`<span class="subst">$&#123;infer R&#125;</span><span class="subst">$&#123;Space&#125;</span>`</span></span><br><span class="line">  ? Trim&lt;R&gt;</span><br><span class="line">  : S;</span><br></pre></td></tr></table></figure><p>先删左边再删右边</p><h1 id="Capitalize"><a href="#Capitalize" class="headerlink" title="Capitalize"></a>Capitalize</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802165712.png" alt=""></p><p>解释:大写第一个字母</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyCapitalize&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer F&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">  ? <span class="string">`<span class="subst">$&#123;Uppercase&lt;F&gt;&#125;</span><span class="subst">$&#123;R&#125;</span>`</span></span><br><span class="line">  : S;</span><br></pre></td></tr></table></figure><p>不能使用<code>[infer F,...infer R]</code>是因为我们解析的是单个字符串</p><h1 id="Replace"><a href="#Replace" class="headerlink" title="Replace"></a>Replace</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802171025.png" alt=""></p><p>实现 Replace 替换</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Replace&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  From <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  To <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = From <span class="keyword">extends</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  ? S</span><br><span class="line">  : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer F&#125;</span><span class="subst">$&#123;From&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">  ? <span class="string">`<span class="subst">$&#123;F&#125;</span><span class="subst">$&#123;To&#125;</span><span class="subst">$&#123;R&#125;</span>`</span></span><br><span class="line">  : S;</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="ts" scheme="https://zlinni.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>Vue3+Canvas实现动态登陆背景页面</title>
    <link href="https://zlinni.github.io/posts/2008259094/"/>
    <id>https://zlinni.github.io/posts/2008259094/</id>
    <published>2022-07-20T12:21:31.000Z</published>
    <updated>2022-07-20T13:17:36.621Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>好久好久没写博客了，人一旦停止记录，就会感觉学习没有积累。虽然相应的有更多时间去coding，不过记录一下才更不容易忘记。</p></div><h1 id="展示效果"><a href="#展示效果" class="headerlink" title="展示效果"></a>展示效果</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/canvas背景图.gif" alt=""></p><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>其实对particle熟悉的话，就知道这个和他基本上是一样的效果，为什么不直接用particle呢？首先是因为nuxt3开发不知道怎么使用这个插件，只好网上cv一个然后改成对应的vue代码，不过改代码也是一件慢慢进步的事情。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">ref</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">:width</span>=<span class="string">&quot;state.width&quot;</span> <span class="attr">:height</span>=<span class="string">&quot;state.height&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 获取dom</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> canvas = ref(<span class="literal">null</span>);</span></span><br><span class="line"><span class="javascript">interface stateInit &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">width</span>: number,</span></span><br><span class="line"><span class="javascript">    <span class="attr">height</span>: number</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> state = reactive&lt;stateInit&gt;(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">width</span>: <span class="number">500</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">height</span>: <span class="number">500</span>,</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> ctx = ref(<span class="literal">null</span>);</span></span><br><span class="line"><span class="javascript">onMounted(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    ctx.value = canvas.value.getContext(<span class="string">&#x27;2d&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    setCanvasSize();</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onresize = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        setCanvasSize();</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    raf();</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> colors = reactive([<span class="string">&#x27;#ed1941&#x27;</span>, <span class="string">&#x27;#f05b72&#x27;</span>, <span class="string">&#x27;#ef4136&#x27;</span>, <span class="string">&#x27;#f15a22&#x27;</span>, <span class="string">&#x27;#8e3e1f&#x27;</span>, <span class="string">&#x27;#fcaf17&#x27;</span>, <span class="string">&#x27;#b76f40&#x27;</span>, <span class="string">&#x27;#00ae9d&#x27;</span>, <span class="string">&#x27;#009ad6&#x27;</span>, <span class="string">&#x27;#1d953f&#x27;</span>, <span class="string">&#x27;#426ab3&#x27;</span>, <span class="string">&#x27;#6950a1&#x27;</span>, <span class="string">&#x27;#74787c&#x27;</span>, <span class="string">&#x27;#2a5caa&#x27;</span>]);</span></span><br><span class="line"><span class="javascript"><span class="comment">// 设置canvas宽高</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> setCanvasSize = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    state.width = <span class="built_in">window</span>.innerWidth;</span></span><br><span class="line"><span class="javascript">    state.height = <span class="built_in">window</span>.innerHeight - <span class="number">40</span>;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="javascript"> * 获取min（包含） - max（不包含）之间的随机数</span></span></span><br><span class="line"><span class="comment"><span class="javascript"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>min 最小值</span></span></span><br><span class="line"><span class="comment"><span class="javascript"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>max 最大值</span></span></span><br><span class="line"><span class="comment"><span class="javascript"> * <span class="doctag">@returns </span></span></span></span><br><span class="line"><span class="comment"><span class="javascript"> */</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> getRandom = (min: number, <span class="attr">max</span>: number): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() * (max - min) + min;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="javascript"> * 获取两点距离</span></span></span><br><span class="line"><span class="comment"><span class="javascript"> * <span class="doctag">@param <span class="type">&#123;object&#125;</span> </span>a 第一个点的位置</span></span></span><br><span class="line"><span class="comment"><span class="javascript"> * <span class="doctag">@param <span class="type">&#123;object&#125;</span> </span>b 第二个点的位置</span></span></span><br><span class="line"><span class="comment"><span class="javascript"> * <span class="doctag">@returns</span></span></span></span><br><span class="line"><span class="comment"><span class="javascript"> */</span></span></span><br><span class="line"><span class="javascript">interface pos &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">x</span>: number,</span></span><br><span class="line"><span class="javascript">    <span class="attr">y</span>: number</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> getDistance = (a: pos, <span class="attr">b</span>: pos): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> x = a.x - b.x;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> y = a.y - b.y;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="built_in">Math</span>.hypot(x, y); <span class="comment">// Math.sqrt(x * x + y * y);</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 创建粒子函数</span></span></span><br><span class="line"><span class="javascript">interface particle &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">radius</span>: number,</span></span><br><span class="line"><span class="javascript">    <span class="attr">x</span>: number,</span></span><br><span class="line"><span class="javascript">    <span class="attr">y</span>: number,</span></span><br><span class="line"><span class="javascript">    <span class="attr">speedX</span>: number,</span></span><br><span class="line"><span class="javascript">    <span class="attr">speedY</span>: number,</span></span><br><span class="line"><span class="javascript">    <span class="attr">color</span>: string</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> create = (): <span class="function"><span class="params">particle</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 粒子半径</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> radius = getRandom(<span class="number">2.2</span>, <span class="number">4</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 粒子位置</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> x = getRandom(<span class="number">0</span> + radius, state.width - radius);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> y = getRandom(<span class="number">0</span> + radius, state.height - radius);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 粒子运动速度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> speedX = getRandom(-<span class="number">1</span>, <span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> speedY = getRandom(-<span class="number">1</span>, <span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 粒子颜色</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> color = colors[<span class="built_in">Math</span>.floor(getRandom(<span class="number">0</span>, colors.length))];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        radius,</span></span><br><span class="line"><span class="javascript">        x,</span></span><br><span class="line"><span class="javascript">        y,</span></span><br><span class="line"><span class="javascript">        speedX,</span></span><br><span class="line"><span class="javascript">        speedY,</span></span><br><span class="line"><span class="javascript">        color</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 绘制粒子函数</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> draw = (particle: particle): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// const ctx = canvas.value.getContext(&#x27;2d&#x27;);</span></span></span><br><span class="line"><span class="javascript">    ctx.value.beginPath();</span></span><br><span class="line"><span class="javascript">    ctx.value.fillStyle = particle.color;</span></span><br><span class="line"><span class="javascript">    ctx.value.arc(particle.x, particle.y, particle.radius, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span></span><br><span class="line"><span class="javascript">    ctx.value.fill();</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 连线粒子函数</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> link = (particle: particle): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// const ctx = canvas.value.getContext(&#x27;2d&#x27;);</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> particles) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> distance = getDistance(particle, p);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (distance &lt; <span class="number">150</span>) &#123;</span></span><br><span class="line"><span class="javascript">            ctx.value.beginPath();</span></span><br><span class="line"><span class="javascript">            ctx.value.lineWidth = <span class="number">0.1</span>;</span></span><br><span class="line"><span class="javascript">            ctx.value.strokeStyle = particle.color;</span></span><br><span class="line"><span class="javascript">            ctx.value.moveTo(particle.x, particle.y);</span></span><br><span class="line"><span class="javascript">            ctx.value.lineTo(p.x, p.y);</span></span><br><span class="line"><span class="javascript">            ctx.value.stroke();</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 移动粒子函数</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> move = (particle: particle): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 碰撞边界后反弹</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (particle.x &lt;= particle.radius || particle.x + particle.radius &gt;= state.width) &#123;</span></span><br><span class="line"><span class="javascript">        particle.speedX *= -<span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (particle.y &lt;= particle.radius || particle.y + particle.radius &gt;= state.height) &#123;</span></span><br><span class="line"><span class="javascript">        particle.speedY *= -<span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    particle.x += particle.speedX;</span></span><br><span class="line"><span class="javascript">    particle.y += particle.speedY;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 粒子数组</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> particles: particle[] = [];</span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">88</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> particle = create();</span></span><br><span class="line"><span class="javascript">    particles.push(particle);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 动画</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> raf = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    step()</span></span><br><span class="line"><span class="javascript">    <span class="comment">// window.requestAnimationFrame(step);</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> step = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// const ctx = canvas.value.getContext(&#x27;2d&#x27;);</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 清空画布</span></span></span><br><span class="line"><span class="javascript">    ctx.value.clearRect(<span class="number">0</span>, <span class="number">0</span>, state.width, state.height);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 更新粒子</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">const</span> particle <span class="keyword">of</span> particles) &#123;</span></span><br><span class="line"><span class="javascript">        move(particle);</span></span><br><span class="line"><span class="javascript">        draw(particle);</span></span><br><span class="line"><span class="javascript">        link(particle);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.requestAnimationFrame(step);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">* &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">canvas</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>HTML基础面</title>
    <link href="https://zlinni.github.io/posts/3179434621/"/>
    <id>https://zlinni.github.io/posts/3179434621/</id>
    <published>2022-06-20T02:35:44.000Z</published>
    <updated>2022-07-10T12:35:33.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="网站开发中，如何实现图片的懒加载"><a href="#网站开发中，如何实现图片的懒加载" class="headerlink" title="网站开发中，如何实现图片的懒加载"></a>网站开发中，如何实现图片的懒加载</h1><p>懒加载，顾名思义，在当前网页，滑动页面到能看到图片的时候再加载图片</p><p>故问题拆分成两个：</p><ol><li>如何判断图片出现在了当前视口 （即如何判断我们能够看到图片）</li><li>如何控制图片的加载</li></ol><h2 id="方案一-位置计算-滚动事件-Scroll-DataSet-API"><a href="#方案一-位置计算-滚动事件-Scroll-DataSet-API" class="headerlink" title="方案一: 位置计算 + 滚动事件 (Scroll) + DataSet API"></a>方案一: 位置计算 + 滚动事件 (Scroll) + DataSet API</h2><p>如何判断图片出现在了当前视口<br>clientTop，offsetTop，clientHeight 以及 scrollTop 各种关于图片的高度作比对</p><p>这些高度都代表了什么意思？</p><p>这我以前有可能是知道的，那时候我比较单纯，喜欢死磕。我现在想通了，背不过的东西就不要背了</p><p>所以它有一个问题：复杂琐碎不好理解！</p><p>所以只知道静态的还不够，还要知道动态的。</p><p>如何动态？监听 <code>window.scroll</code> 事件</p><p>如何控制图片的加载？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;jojo.jpg&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>设置个临时的 data 属性 data-src，控制加载的时候使用 src 替代。利用 DataSet API 实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.src = img.datset.src;</span><br></pre></td></tr></table></figure><h2 id="方案二-getBoundingClientRect-API-Scroll-with-Throttle-DataSet-API"><a href="#方案二-getBoundingClientRect-API-Scroll-with-Throttle-DataSet-API" class="headerlink" title="方案二: getBoundingClientRect API + Scroll with Throttle + DataSet API"></a>方案二: getBoundingClientRect API + Scroll with Throttle + DataSet API</h2><p>改进一下</p><p>如何判断图片出现在了当前视口<br>引入一个新的 API， <code>Element.getBoundingClientRect()</code> 方法返回元素的大小及其相对于视口的位置。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220620144635.png" alt=""></p><p>判断出现在视口的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clientHeight 代表当前视口的高度</span></span><br><span class="line">img.getBoundingClientRect().top &lt; <span class="built_in">document</span>.documentElement.clientHeight;</span><br></pre></td></tr></table></figure><p>监听 window.scroll 事件也优化一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.throttle(func, [(wait = <span class="number">0</span>)], [(options = &#123;&#125;)]);</span><br></pre></td></tr></table></figure><h2 id="方案三-IntersectionObserver-API-DataSet-API"><a href="#方案三-IntersectionObserver-API-DataSet-API" class="headerlink" title="方案三: IntersectionObserver API + DataSet API"></a>方案三: IntersectionObserver API + DataSet API</h2><p>再改进一下</p><p>如何判断图片出现在了当前视口<br>方案二使用的方法是: <code>window.scroll</code> 监听 <code>Element.getBoundingClientRect()</code> 并使用 <code>_.throttle</code> 节流</p><p>一系列组合动作太复杂了，于是浏览器出了一个三合一事件: <code>IntersectionObserver API</code>，一个能够监听元素是否到了当前视口的事件，一步到位！</p><p>事件回调的参数是 <code>IntersectionObserverEntry (opens new window)</code>的集合，代表关于是否在可见视口的一系列值</p><p>其中，<code>entry.isIntersecting</code> 代表目标元素可见</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">changes</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// changes: 目标元素集合</span></span><br><span class="line">  changes.forEach(<span class="function">(<span class="params">change</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// intersectionRatio</span></span><br><span class="line">    <span class="keyword">if</span> (change.isIntersecting) &#123;</span><br><span class="line">      <span class="keyword">const</span> img = change.target;</span><br><span class="line">      img.src = img.dataset.src;</span><br><span class="line">      observer.unobserve(img);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">observer.observe(img);</span><br></pre></td></tr></table></figure><h2 id="方案四-LazyLoading-属性"><a href="#方案四-LazyLoading-属性" class="headerlink" title="方案四: LazyLoading 属性"></a>方案四: LazyLoading 属性</h2><p>略</p><p>方案二简单 demo</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>图片懒加载<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2021/08/24/15/38/sand-6570980_960_720.jpg&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">alt</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2013/02/21/19/06/drink-84533_960_720.jpg&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">alt</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">      <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2014/12/15/17/16/boardwalk-569314_960_720.jpg&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">alt</span>=<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">      <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2013/07/18/20/26/sea-164989_960_720.jpg&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">alt</span>=<span class="string">&quot;4&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">      <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2015/04/23/22/00/tree-736885_960_720.jpg&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">alt</span>=<span class="string">&quot;5&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">      <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2017/03/26/21/54/yoga-2176668_960_720.jpg&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">alt</span>=<span class="string">&quot;6&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">      <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2015/03/17/14/05/sparkler-677774_960_720.jpg&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">alt</span>=<span class="string">&quot;7&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.20/lodash.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> images = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;img&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> lazyLoad = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        images.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 触发条件为img元素的CSSOM对象到视口顶部的距离 &lt; 100px + 视口高度，+100px为了提前触发图片加载</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (</span></span><br><span class="line"><span class="javascript">            item.getBoundingClientRect().top &lt;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.documentElement.clientHeight + <span class="number">100</span></span></span><br><span class="line"><span class="javascript">          ) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (<span class="string">&quot;src&quot;</span> <span class="keyword">in</span> item.dataset) &#123;</span></span><br><span class="line"><span class="javascript">              item.src = item.dataset.src;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">      &#125;;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>, _.throttle(lazyLoad, <span class="number">200</span>));</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结：图片懒加载有 4 种方式，首先最常用就是插件的懒加载，其次是位置计算加监视 scroll 事件结合 dataset api 替换图片路径。然后是 getBoundingClientRect 方法，监听滚动事件，对应 img 元素到视口顶部的距离小于视口高度的时候触发，并用上节流，接着是 IntersectionObserver 方法，他是上面操作的合体，他第一个参数接收元素的集合，然后遍历元素集合，如果元素.isIntersecting 目标元素可见的话，就用 dataset api 替换。</p><h1 id="浏览器剪切板"><a href="#浏览器剪切板" class="headerlink" title="浏览器剪切板"></a>浏览器剪切板</h1><ol><li>第三方库</li><li>Clipboard API</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">把内容输入到剪切板;</span><br><span class="line">navigator.clipboard.writeText(text);</span><br></pre></td></tr></table></figure><ol><li>Selection API/Range API</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selection = <span class="built_in">window</span>.getSelection();</span><br><span class="line"><span class="keyword">const</span> range = <span class="built_in">document</span>.createRange();</span><br><span class="line"></span><br><span class="line"><span class="comment">// RangeAPI: 制造区域</span></span><br><span class="line">range.selectNodeContents(element);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Selection: 选中区域</span></span><br><span class="line">selection.addRange(range);</span><br><span class="line"></span><br><span class="line">selectedText = selection.toString();</span><br></pre></td></tr></table></figure><p>取消选择的代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.getSelection().removeAllRanges();</span><br></pre></td></tr></table></figure><h1 id="localhost-3000-与-localhost-5000-的-cookie-信息是否共享"><a href="#localhost-3000-与-localhost-5000-的-cookie-信息是否共享" class="headerlink" title="localhost:3000 与 localhost:5000 的 cookie 信息是否共享"></a>localhost:3000 与 localhost:5000 的 cookie 信息是否共享</h1><p>根据同源策略，cookie 是区分端口的，但是浏览器实现来说，“cookie 区分域，而不区分端口，也就是说，同一个 ip 下的多个端口下的 cookie 是共享的！</p><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>CSRF (Cross-site request forgery)，跨站请求伪造，又称为 one-click attack，顾名思义，通过恶意引导用户一次点击劫持 cookie 进行攻击。</p><ol><li>使用 JSON API。当进行 CSRF 攻击时，请求体通过 <form> 构建，请求头为 application/www-form-urlencoded。它难以发送 JSON 数据被服务器所理解。</li><li>CSRF Token。生成一个随机的 token，切勿放在 cookie 中，每次请求手动携带该 token 进行校验。</li><li>SameSite Cookie。设置为 Lax 或者 Strict，禁止发送第三方 Cookie。</li></ol><h1 id="读取剪切板内容"><a href="#读取剪切板内容" class="headerlink" title="读取剪切板内容"></a>读取剪切板内容</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否能够有读取剪贴板的权限</span></span><br><span class="line"><span class="comment">// result.state == &quot;granted&quot; || result.state == &quot;prompt&quot;</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> navigator.permissions.query(&#123; <span class="attr">name</span>: <span class="string">&quot;clipboard-read&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取剪贴板内容</span></span><br><span class="line"><span class="keyword">const</span> text = <span class="keyword">await</span> navigator.clipboard.readText();</span><br></pre></td></tr></table></figure><h1 id="json-转-demo-json-并下载"><a href="#json-转-demo-json-并下载" class="headerlink" title="json 转 demo.json 并下载"></a>json 转 demo.json 并下载</h1><p>和 img 点击下载差不多</p><p>不过 json 有两种方法转，第一种是 DataURL，第二种是 Blob=&gt;ObjectURL。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span>(<span class="params">url, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  a.download = name;</span><br><span class="line">  a.href = url;</span><br><span class="line">  a.dispatchEvent(<span class="keyword">new</span> MouseEvent(<span class="string">&quot;click&quot;</span>));</span><br><span class="line">  <span class="comment">// a.click();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let url = &#x27;https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220621084732.png&#x27;;</span></span><br><span class="line"><span class="comment">// let name = &#x27;test&#x27;</span></span><br><span class="line"><span class="comment">// download(url,name);</span></span><br><span class="line"><span class="keyword">const</span> json = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">5</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// JSON.stringify(value[, replacer[, space]])</span></span><br><span class="line"><span class="comment">// 首行缩进</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="built_in">JSON</span>.stringify(json, <span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> dataUrl = <span class="string">`data:,<span class="subst">$&#123;str&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// download(dataUrl,&quot;demo.json&quot;);</span></span><br><span class="line"><span class="comment">// new Blob(array,options);</span></span><br><span class="line"><span class="keyword">const</span> url = URL.createObjectURL(<span class="keyword">new</span> Blob(str.split(<span class="string">&quot;&quot;</span>)));</span><br><span class="line">download(url, <span class="string">&quot;demo.json&quot;</span>);</span><br></pre></td></tr></table></figure><p>总结：下载是利用 a 标签加模拟点击，json 使用是转 dataurl 或者 objecturl，注意 dataurl 的时候需要序列化，objecturl 的时候需要传入数组(简单 split 即可)</p><h1 id="简单介绍-requestIdleCallback-及使用场景"><a href="#简单介绍-requestIdleCallback-及使用场景" class="headerlink" title="简单介绍 requestIdleCallback 及使用场景"></a>简单介绍 requestIdleCallback 及使用场景</h1><p>requestIdleCallback 维护一个队列，在浏览器空闲的时间去执行。</p><h1 id="白屏时间首屏时间的计算"><a href="#白屏时间首屏时间的计算" class="headerlink" title="白屏时间首屏时间的计算"></a>白屏时间首屏时间的计算</h1><p>白屏时间:<code>window.performance.timing.domLoading - window.performance.timing.navigationStart</code><br>首屏时间:<code>window.performance.timing.domInteractive - window.performance.timing.navigationStart</code></p><h1 id="重排重绘"><a href="#重排重绘" class="headerlink" title="重排重绘"></a>重排重绘</h1><p>重排和重绘是关键渲染路径中的两步</p><p>重排 重新排列(元素位置发生变动) 代价极高<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220621091518.png" alt=""></p><p>重绘 样式发生变动，但位置没有变化。此时在关键渲染路径中的 Paint 阶段，将渲染树中的每个节点转换成屏幕上的实际像素，这一步通常称为绘制或栅格化<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220621114729.png" alt=""></p><p>重排必定造成重绘</p><ol><li>使用 DocumentFragment 进行 DOM 操作，不过现在原生操作很少也基本上用不到</li><li>CSS 样式尽量批量修改</li><li>避免使用 table 布局</li><li>为元素提前设置好高宽，不因多次渲染改变位置</li></ol><h1 id="DataURL-是什么"><a href="#DataURL-是什么" class="headerlink" title="DataURL 是什么"></a>DataURL 是什么</h1><p>DataURL 是前缀为 data:协议的 URL，允许创建者向文档插入小文件，比如图片等。DataURL 由四个部分组成，</p><ol><li>前缀 data:</li><li>指示数据类型的 MIME 类型。例如：image/jpeg 表示 jpeg 文件，如果省略，默认值为 text/plain;charset=US-SACII</li><li>非文本，可选 base64</li><li>数据</li></ol><h1 id="如何取消请求的发送"><a href="#如何取消请求的发送" class="headerlink" title="如何取消请求的发送"></a>如何取消请求的发送</h1><p>根据发送网络请求的 API 不同，取消方法不同</p><ul><li>xhr</li><li>fetch</li><li>axios<br>如果使用 XMLHttpRequest 发送请求可以使用 XMLHttpRequest.abort()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest(),</span><br><span class="line">  method = <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  url = <span class="string">&quot;https://developer.mozilla.org/&quot;</span>;</span><br><span class="line">xhr.open(method, url, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消发送请求</span></span><br><span class="line">xhr.abort();</span><br></pre></td></tr></table></figure><p>如果使用 fetch 发送请求可以使用 AbortController</p><ol><li>发送请求时使用一个 signal 选项控制 fetch 请求</li><li>control.abort() 用以取消请求发送</li><li>取消请求发送之后会得到异常 AbortError</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> AbortController();</span><br><span class="line"><span class="keyword">const</span> signal = controller.signal;</span><br><span class="line">fetch(<span class="string">&quot;https://somewhere&quot;</span>, &#123; signal &#125;);</span><br><span class="line">controller.abort();</span><br></pre></td></tr></table></figure><p>如果使用 axios，取消原理同 fetch</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">var</span> source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">&#x27;https://somewhere&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">cancelToken</span>: source.token</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">source.cancel()</span><br></pre></td></tr></table></figure><p>而其中的原理可分为两部分</p><p>浏览器端: 基于 XHR，xhr.abort()，见源码 axios/lib/adapters/xhr.js(opens new window)<br>Node 端: 基于 http/https/follow-redirects，使用 request.abort()，见源码 axios/lib/adapters/http.js</p><h1 id="textarea-如何禁止拉伸"><a href="#textarea-如何禁止拉伸" class="headerlink" title="textarea 如何禁止拉伸"></a>textarea 如何禁止拉伸</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">textarea &#123;</span><br><span class="line">  <span class="attr">resize</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在-Canvas-中如何处理跨域的图片"><a href="#在-Canvas-中如何处理跨域的图片" class="headerlink" title="在 Canvas 中如何处理跨域的图片"></a>在 Canvas 中如何处理跨域的图片</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.setAttribute(<span class="string">&quot;crossOrigin&quot;</span>, <span class="string">&quot;anonymous&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="HTML-标签有哪些行内元素"><a href="#HTML-标签有哪些行内元素" class="headerlink" title="HTML 标签有哪些行内元素"></a>HTML 标签有哪些行内元素</h1><ul><li>a</li><li>img</li><li>picture</li><li>span</li><li>input</li><li>textarea</li><li>select</li><li>label</li></ul><h1 id="什么是-URL-编码-URL-Encode"><a href="#什么是-URL-编码-URL-Encode" class="headerlink" title="什么是 URL 编码 (URL Encode)"></a>什么是 URL 编码 (URL Encode)</h1><p>encodeURI 用来编码 URI，其不会编码保留字符：<code>;,/?😡&amp;=+$</code></p><p>encodeURIComponent 用来编码 URI 参数，除了字符：<code>A-Z a-z 0-9 - _ . ! ~ * &#39; ( )</code>，都将会转义</p><h1 id="浏览器-dom-api"><a href="#浏览器-dom-api" class="headerlink" title="浏览器 dom api"></a>浏览器 dom api</h1><h1 id="设置和删除-cookie"><a href="#设置和删除-cookie" class="headerlink" title="设置和删除 cookie"></a>设置和删除 cookie</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">document</span>.cookie</span><br><span class="line">&lt; <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">document</span>.cookie = <span class="string">&#x27;a=3&#x27;</span></span><br><span class="line">&lt; <span class="string">&quot;a=3&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">document</span>.cookie</span><br><span class="line">&lt; <span class="string">&quot;a=3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把该字段的 max-age 设置为 -1</span></span><br><span class="line">&gt; <span class="built_in">document</span>.cookie = <span class="string">&#x27;a=3; max-age=-1&#x27;</span></span><br><span class="line">&lt; <span class="string">&quot;a=3; max-age=-1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除成功</span></span><br><span class="line">&gt; <span class="built_in">document</span>.cookie</span><br><span class="line">&lt; <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="如何判断当前环境是移动端还是-PC-端"><a href="#如何判断当前环境是移动端还是-PC-端" class="headerlink" title="如何判断当前环境是移动端还是 PC 端"></a>如何判断当前环境是移动端还是 PC 端</h1><p>判断 navigator.userAgent，对于 Android/iPhone 可以匹配以下正则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> appleIphone = <span class="regexp">/iPhone/i</span>;</span><br><span class="line"><span class="keyword">const</span> appleIpod = <span class="regexp">/iPod/i</span>;</span><br><span class="line"><span class="keyword">const</span> appleTablet = <span class="regexp">/iPad/i</span>;</span><br><span class="line"><span class="keyword">const</span> androidPhone = <span class="regexp">/\bAndroid(?:.+)Mobile\b/i</span>; <span class="comment">// Match &#x27;Android&#x27; AND &#x27;Mobile&#x27;</span></span><br><span class="line"><span class="keyword">const</span> androidTablet = <span class="regexp">/Android/i</span>;</span><br></pre></td></tr></table></figure><p>当然，不要重复造轮子，推荐一个库: <a href="https://github.com/kaimallea/isMobile">https://github.com/kaimallea/isMobile</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> isMobile <span class="keyword">from</span> <span class="string">&quot;ismobilejs&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mobile = isMobile();</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">isPc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> userAgentInfo = navigator.userAgent;</span><br><span class="line">  <span class="keyword">var</span> Agents = <span class="keyword">new</span> <span class="built_in">Array</span>(</span><br><span class="line">    <span class="string">&quot;Android&quot;</span>,</span><br><span class="line">    <span class="string">&quot;iPhone&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SymbianOS&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Windows Phone&quot;</span>,</span><br><span class="line">    <span class="string">&quot;iPad&quot;</span>,</span><br><span class="line">    <span class="string">&quot;iPod&quot;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">  flag = !Agents.some(<span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userAgentInfo.indexOf(ele) &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CSP-是干什么用的了"><a href="#CSP-是干什么用的了" class="headerlink" title="CSP 是干什么用的了"></a>CSP 是干什么用的了</h1><p>CSP 只允许加载指定的脚本和样式，最大限度的防止 xss 攻击。</p><p>设置 CSP，设置响应头：<code>Content Security Policy</code></p><ol><li>外部脚本可以通过指定域名来限制：<code>Content-Security-Policy: script-src &#39;self&#39;</code>，self 代表只加载当前域名</li><li>如果网站必须加载内联脚本 (inline script) ，则可以提供一个 nonce 才能执行脚本，攻击者则无法注入脚本进行攻击。<code>Content-Security-Policy: script-src &#39;nonce-xxxxxxxxxxxxxxxxxx&#39;</code></li></ol><p>github 的 CSP</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: <span class="keyword">default</span>-src <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">  base-uri <span class="string">&#x27;self&#x27;</span>;</span><br><span class="line">  block-all-mixed-content;</span><br><span class="line">  connect-src <span class="string">&#x27;self&#x27;</span> uploads.github.com www.githubstatus.com collector.githubapp.com api.github.com www.google-analytics.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com cdn.optimizely.com logx.optimizely.com/v1/events wss:<span class="comment">//alive.github.com;</span></span><br><span class="line">  font-src github.githubassets.com;</span><br><span class="line">  form-action <span class="string">&#x27;self&#x27;</span> github.com gist.github.com;</span><br><span class="line">  frame-ancestors <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">  frame-src render.githubusercontent.com;</span><br><span class="line">  img-src <span class="string">&#x27;self&#x27;</span> data: github.githubassets.com identicons.github.com collector.githubapp.com github-cloud.s3.amazonaws.com *.githubusercontent.com;</span><br><span class="line">  manifest-src <span class="string">&#x27;self&#x27;</span>;</span><br><span class="line">  media-src <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">  script-src github.githubassets.com;</span><br><span class="line">  style-src <span class="string">&#x27;unsafe-inline&#x27;</span> github.githubassets.com;</span><br><span class="line">  worker-src github.com/socket-worker.js gist.github.com/socket-worker.js</span><br></pre></td></tr></table></figure><p>常用指令集<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220621145250.png" alt=""></p><p>指令值<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220621145335.png" alt=""></p><p>使用：</p><ol><li>通过 HTTP Header 来定义 ：<br>“Content-Security-Policy:” 策略集</li><li>通过 html meta 标签使用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;content-security-policy&quot;</span> content=<span class="string">&quot;策略集&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>总结<br>CSP 是内容安全策略，用于阻止外部脚本的注入和运行，有效防止 xss 攻击。其中设置的方式是通过 nginx 设置，或者通过 meta 标签设置。其中指令有 default-src，script-src，style-src，img-src 等，定义某个东西的过滤策略。值有*，none，self，直接写地址等方式。来设置不被过滤的地址。</p><h1 id="preload-和-prefetch-的区别"><a href="#preload-和-prefetch-的区别" class="headerlink" title="preload 和 prefetch 的区别"></a>preload 和 prefetch 的区别</h1><ol><li>preload 用于加载当前路由必须资源，优先级高。一般对于 bundle spliting 资源和 code spliting 资源做 preload。</li><li>prefetch 优先级低，在浏览器 idle 状态加载资源。一般用来加载其他路由资源，如当页面出现 Link，可 prefetch 当前 Link 的路由资源。（next.js 默认会对 link 做懒加载+prefetch，即当某条 Link 出现页面中，即自动 prefetch 该 Link 指向的路由资源</li></ol><h1 id="fetch-中-crendentials-指什么意思，可以取什么值"><a href="#fetch-中-crendentials-指什么意思，可以取什么值" class="headerlink" title="fetch 中 crendentials 指什么意思，可以取什么值"></a>fetch 中 crendentials 指什么意思，可以取什么值</h1><p>credentials 指在使用 fetch 发送请求时是否应当发送 cookie</p><p>omit: 从不发送 cookie.<br>same-origin: 同源时发送 cookie (浏览器默认值)<br>include: 同源与跨域时都发送 cookie</p><h1 id="当-cookie-没有设置-maxage-时，cookie-会存在多久"><a href="#当-cookie-没有设置-maxage-时，cookie-会存在多久" class="headerlink" title="当 cookie 没有设置 maxage 时，cookie 会存在多久"></a>当 cookie 没有设置 maxage 时，cookie 会存在多久</h1><p>此时的 cookie 就是会话级别的了，浏览器一关闭就关闭了</p><h1 id="如何找到当前页面出现次数最多的-HTML-标签"><a href="#如何找到当前页面出现次数最多的-HTML-标签" class="headerlink" title="如何找到当前页面出现次数最多的 HTML 标签"></a>如何找到当前页面出现次数最多的 HTML 标签</h1><ol><li><code>document.querySelector(&#39;*&#39;)</code></li><li><code>document.getElementsByTagName(&#39;*&#39;)</code></li></ol><h1 id="什么是层叠上下文-stacking-context"><a href="#什么是层叠上下文-stacking-context" class="headerlink" title="什么是层叠上下文 (stacking context)"></a>什么是层叠上下文 (stacking context)</h1><p>我们假定用户正面向（浏览器）视窗或网页，而 HTML 元素沿着其相对于用户的一条虚构的 z 轴排开，层叠上下文就是对这些 HTML 元素的一个三维构想。众 HTML 元素基于其元素属性按照优先级顺序占据这个空间。</p><p>其中，z-index 会影响这个层级的优先性</p><h1 id="如何实现页面文本不可复制"><a href="#如何实现页面文本不可复制" class="headerlink" title="如何实现页面文本不可复制"></a>如何实现页面文本不可复制</h1><p>有 CSS 和 JS 两种方法，以下任选其一或结合使用</p><p>使用 CSS 如下：</p><p><code>user-select: none;</code><br>或使用 JS 如下，监听 selectstart 事件，禁止选中。</p><p>当用户选中一片区域时，将触发 selectstart 事件，Selection API 将会选中一片区域。禁止选中区域即可实现页面文本不可复制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.onselectstart = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.oncopy = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="异步加载-JS-脚本时，async-与-defer-有何区别"><a href="#异步加载-JS-脚本时，async-与-defer-有何区别" class="headerlink" title="异步加载 JS 脚本时，async 与 defer 有何区别"></a>异步加载 JS 脚本时，async 与 defer 有何区别</h1><h1 id="load-事件与-DomContentLoaded-事件的先后顺序"><a href="#load-事件与-DomContentLoaded-事件的先后顺序" class="headerlink" title="load 事件与 DomContentLoaded 事件的先后顺序"></a>load 事件与 DomContentLoaded 事件的先后顺序</h1><p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载.</p><p>当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发 load 事件</p><h1 id="vue-react-的路由实现原理"><a href="#vue-react-的路由实现原理" class="headerlink" title="vue\react 的路由实现原理"></a>vue\react 的路由实现原理</h1><p>本质都是监听 url 的变化，实现方式有两种，一种是 hash 模式，一种是 history 模式，其中 hash 模式是默认的模式，兼容性好，当井号后面的哈希值变化时，通过 hashOnchange 事件监听然后页面跳转，无需刷新页面就能重新加载对应的页面。history 模式要后端配置，通过<code>history.pushState</code>和<code>history.replaceState</code>改变 url</p><h1 id="前端实现文件上传"><a href="#前端实现文件上传" class="headerlink" title="前端实现文件上传"></a>前端实现文件上传</h1><p>elementplus，或者原生的 input 标签，type 为 file 然后加点击事件</p><h1 id="DOM-中如何阻止事件默认行为，如何判断事件否可阻止？"><a href="#DOM-中如何阻止事件默认行为，如何判断事件否可阻止？" class="headerlink" title="DOM 中如何阻止事件默认行为，如何判断事件否可阻止？"></a>DOM 中如何阻止事件默认行为，如何判断事件否可阻止？</h1><p><code>e.preventDefault</code>阻止默认事件<br><code>e.cancelable</code>是否可取消</p><h1 id="什么是事件委托，e-currentTarget-与-e-target-有何区别"><a href="#什么是事件委托，e-currentTarget-与-e-target-有何区别" class="headerlink" title="什么是事件委托，e.currentTarget 与 e.target 有何区别"></a>什么是事件委托，e.currentTarget 与 e.target 有何区别</h1><p>事件委托指的是大量事件触发的时候，将事件监听器绑在父元素进行监听。</p><p><code>e.currentTarget</code>总是指向事件绑定的元素，<code>e.target</code>指的是触发的元素</p><h1 id="浏览器中-cookie-有哪些字段"><a href="#浏览器中-cookie-有哪些字段" class="headerlink" title="浏览器中 cookie 有哪些字段"></a>浏览器中 cookie 有哪些字段</h1><ul><li>Domain</li><li>Path</li><li>Expire/MaxAge</li><li>HttpOnly</li><li>Secure</li><li>SameSite</li></ul><h1 id="SameSite-Cookie-有哪些值，是如何预防-CSRF-攻击的"><a href="#SameSite-Cookie-有哪些值，是如何预防-CSRF-攻击的" class="headerlink" title="SameSite Cookie 有哪些值，是如何预防 CSRF 攻击的"></a>SameSite Cookie 有哪些值，是如何预防 CSRF 攻击的</h1><p>None:任何情况发<br>Lax:导航到第三方的 get 连接会发，跨域的图片，iframe，form 表单不会发<br>Strict:都不会发</p><p>目前主流浏览器的模式是 Lax，能够预防大部分的 CSRF</p><h1 id="sessionStorage-与-localStorage-有何区别"><a href="#sessionStorage-与-localStorage-有何区别" class="headerlink" title="sessionStorage 与 localStorage 有何区别"></a>sessionStorage 与 localStorage 有何区别</h1><p>localStorage 生命周期是永久除非自主清除 sessionStorage 生命周期为当前窗口或标签页，关闭窗口或标签页则会清除数据</p><p>他们均只能存储字符串类型的对象</p><p>不同浏览器无法共享 localStorage 或 sessionStorage 中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享 sessionStorage 的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个 iframe 标签且他们属于同源页面，那么他们之间是可以共享 sessionStorage 的。</p><h1 id="TypeArray-ArrayBuffer"><a href="#TypeArray-ArrayBuffer" class="headerlink" title="TypeArray/ArrayBuffer"></a>TypeArray/ArrayBuffer</h1><p><a href="https://zh.javascript.info/arraybuffer-binary-arrays">https://zh.javascript.info/arraybuffer-binary-arrays</a></p><h1 id="简述下-WebWorker，它如何进行通信"><a href="#简述下-WebWorker，它如何进行通信" class="headerlink" title="简述下 WebWorker，它如何进行通信"></a>简述下 WebWorker，它如何进行通信</h1><p>js 多线程通信，只能访问 navigator，setTimeout 和有限的 api</p><p>通过 onmessage 和 postmessage 通信，全局对象是 self</p><h1 id="浏览器中监听事件函数-addEventListener-第三个参数有那些值"><a href="#浏览器中监听事件函数-addEventListener-第三个参数有那些值" class="headerlink" title="浏览器中监听事件函数 addEventListener 第三个参数有那些值"></a>浏览器中监听事件函数 addEventListener 第三个参数有那些值</h1><ul><li>capture。监听器会在时间捕获阶段传播到 event.target 时触发。</li><li>passive。监听器不会调用 preventDefault()。</li><li>once。监听器只会执行一次，执行后移除。</li><li>singal。调用 abort()移除监听器。</li></ul><h1 id="浏览器中如何使用原生的-ESM"><a href="#浏览器中如何使用原生的-ESM" class="headerlink" title="浏览器中如何使用原生的 ESM"></a>浏览器中如何使用原生的 ESM</h1><ul><li>url 引入<br>···javascript<script type="module">import lodash from "https://cdn.skypack.dev/lodash";</script></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* importMap</span><br><span class="line">```javascript</span><br><span class="line">&lt;script type=&quot;importmap&quot;&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;imports&quot;: &#123;</span><br><span class="line">      &quot;lodash&quot;: &quot;https://cdn.skypack.dev/lodash&quot;,</span><br><span class="line">      &quot;ms&quot;: &quot;https://cdn.skypack.dev/ms&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>importAssertion</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">&quot;./data.json&quot;</span> assert &#123; <span class="attr">type</span>: <span class="string">&quot;json&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试指南" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的mini-vue⑧--parse篇</title>
    <link href="https://zlinni.github.io/posts/2151465192/"/>
    <id>https://zlinni.github.io/posts/2151465192/</id>
    <published>2022-06-14T02:37:48.000Z</published>
    <updated>2022-06-19T06:46:00.579Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是模板编译 Intro 篇，是关于 Vue3 中模板编译的简单介绍。</p></div><h1 id="编译的目的"><a href="#编译的目的" class="headerlink" title="编译的目的"></a>编译的目的</h1><p>之前我们编译都是以手写渲染函数的形式进行的，因此进行模板编译的目的就是将模板代码编译成渲染函数</p><p>来看一下 vue 是怎么把模板编译成渲染函数的<a href="https://vue-next-template-explorer.netlify.app/"></a></p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220614105242.png" alt=""></p><p>这里的<code>_createElementBlock</code>就相当于 h 函数，<code>_toDisplayString</code>就是为了转换插值符号 msg 的结果</p><p>这里值得一提的是 vue 能支持 jsx 的原理，因为 jsx 的最终产物也是一段渲染函数。</p><h1 id="编译的步骤"><a href="#编译的步骤" class="headerlink" title="编译的步骤"></a>编译的步骤</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220614105756.png" alt=""></p><h1 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h1><p>原始的模板代码就是一段字符串，通过解析 parse 转为原始的 AST 抽象语法树</p><h1 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h1><p>AST 经过 transform 生成一个 codegenNode。codegenNode 是 AST 到生成渲染函数代码的中间步骤，它由原始的 AST 语义而得来。比如对于原始的 AST 来说：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;ok&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;ok&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>没什么区别，都是一个元素带有不同属性而已，但是 vif 的操作是带有特殊语义的，不能像纯元素节点一样采用同样的代码生成方式，transform 的作用就在此，一方面解析 AST，一方面为生成代码做准备。因此这一部分也是 vue compiler 模块最复杂的部分。</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/8cb3d9f0fc34d823a7fe100627275dd.png" alt=""></p><h1 id="codegen"><a href="#codegen" class="headerlink" title="codegen"></a>codegen</h1><p>即是 code generate。遍历 codegenNode，递归生成最终的渲染函数代码</p><h1 id="Mini-Vue-的-compiler-实现原则"><a href="#Mini-Vue-的-compiler-实现原则" class="headerlink" title="Mini-Vue 的 compiler 实现原则"></a>Mini-Vue 的 compiler 实现原则</h1><ol><li>只实现能够支撑流程跑通的最基本的功能</li><li>舍弃所有的优化手段，选项功能</li><li>假定所有的输入都是合法的（不做任何的语法容错处理）</li><li>为了减少代码量，某些地方会使用一些与源码差别很大的简化手段</li><li>会舍弃一些非常麻烦的实现</li></ol><h1 id="认识-AST"><a href="#认识-AST" class="headerlink" title="认识 AST"></a>认识 AST</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;ok&quot;</span>&gt;</span>hello &#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="TODO" alt=""></p><p>AST 分为元素节点，属性节点，指令节点，文本节点和差值节点</p><h2 id="AST-Node-的类型"><a href="#AST-Node-的类型" class="headerlink" title="AST Node 的类型"></a>AST Node 的类型</h2><p>其中 root 节点代表根节点，因为可能不止一个 root。SIMPLE_EXPRESSION 节点是简单表达式节点，附带在以上五种节点之中的节点，还有复杂表达式节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NodeTypes = &#123;</span><br><span class="line">  <span class="attr">ROOT</span>: <span class="string">&quot;ROOT&quot;</span>,</span><br><span class="line">  <span class="attr">ELEMENT</span>: <span class="string">&quot;ELEMENT&quot;</span>,</span><br><span class="line">  <span class="attr">TEXT</span>: <span class="string">&quot;TEXT&quot;</span>,</span><br><span class="line">  <span class="attr">SIMPLE_EXPRESSION</span>: <span class="string">&quot;SIMPLE_EXPRESSION&quot;</span>,</span><br><span class="line">  <span class="attr">INTERPOLATION</span>: <span class="string">&quot;INTERPOLATION&quot;</span>,</span><br><span class="line">  <span class="attr">ATTRIBUTE</span>: <span class="string">&quot;ATTRIBUTE&quot;</span>,</span><br><span class="line">  <span class="attr">DIRECTIVE</span>: <span class="string">&quot;DIRECTIVE&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ElementTypes = &#123;</span><br><span class="line">  <span class="attr">ELEMENT</span>: <span class="string">&quot;ELEMENT&quot;</span>,</span><br><span class="line">  <span class="attr">COMPONENT</span>: <span class="string">&quot;COMPONENT&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h2><p>这里为了方便大大简化了。其实 vue 还有很多节点，用于优化的操作。所以这里只写了 children 方便我们执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: NodeTypes.ROOT,</span><br><span class="line">  <span class="attr">children</span>: [],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="纯文本节点"><a href="#纯文本节点" class="headerlink" title="纯文本节点"></a>纯文本节点</h2><p>相当于例子中的 hello</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: NodeTypes.TEXT,</span><br><span class="line">  <span class="attr">content</span>: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表达式节点"><a href="#表达式节点" class="headerlink" title="表达式节点"></a>表达式节点</h2><p>这个 content 相当于例子中的 name，isStatic 表示它是否是静态。静态的话说明 content 就是一段字符串，动态的话 content 是一个变量 or 一段 js 表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: NodeTypes.SIMPLE_EXPRESSION,</span><br><span class="line">  <span class="attr">content</span>: string,</span><br><span class="line">  <span class="comment">// 表达式是否静态。静态可以理解为content就是一段字符串；而动态的content指的是一个变量，或一段js表达式</span></span><br><span class="line">  <span class="attr">isStatic</span>: boolean,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插值节点"><a href="#插值节点" class="headerlink" title="插值节点"></a>插值节点</h2><p>包含了表达式节点，content 相当于例子中的 name，isStatic 是 false 说明 name 是一个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: NodeTypes.INTERPOLATION,</span><br><span class="line">  <span class="attr">content</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: NodeTypes.SIMPLE_EXPRESSION,</span><br><span class="line">    <span class="attr">content</span>: string,</span><br><span class="line">    <span class="attr">isStatic</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125; <span class="comment">// 表达式节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元素节点"><a href="#元素节点" class="headerlink" title="元素节点"></a>元素节点</h2><p>相当于例子中的 div，就是标签。当然因为也可以是自定义标签，比如组件类型，所以这里有个 tagType 标识是否是组件类型。然后属性节点和指令节点都在这里面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: NodeTypes.ELEMENT,</span><br><span class="line">  <span class="attr">tag</span>: string, <span class="comment">// 标签名,</span></span><br><span class="line">  <span class="attr">tagType</span>: ElementTypes, <span class="comment">// 是组件还是原生元素,</span></span><br><span class="line">  <span class="attr">props</span>: [], <span class="comment">// 属性节点数组,</span></span><br><span class="line">  <span class="attr">directives</span>: [], <span class="comment">// 指令数组</span></span><br><span class="line">  <span class="attr">isSelfClosing</span>: boolean, <span class="comment">// 是否是自闭合标签,</span></span><br><span class="line">  <span class="attr">children</span>: [],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性节点"><a href="#属性节点" class="headerlink" title="属性节点"></a>属性节点</h2><p>相当于例子中的 id，但这个属性节点是可以没有 value 值的，比如 checked</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: NodeTypes.ATTRIBUTE,</span><br><span class="line">  <span class="attr">name</span>: string,</span><br><span class="line">  <span class="attr">value</span>: <span class="literal">undefined</span> | &#123;</span><br><span class="line">    <span class="attr">type</span>: NodeTypes.TEXT,</span><br><span class="line">    <span class="attr">content</span>: string,</span><br><span class="line">  &#125; <span class="comment">// 纯文本节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指令节点"><a href="#指令节点" class="headerlink" title="指令节点"></a>指令节点</h2><p>在下一节中有</p><h1 id="指令节点-1"><a href="#指令节点-1" class="headerlink" title="指令节点"></a>指令节点</h1><p>例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;myClass&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这个例子可以解析成以下的情况：<br>name: bind, arg: class, exp: myClass</p><p>name: on, arg: click, exp: handleClick</p><p>它的代码是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: NodeTypes.DIRECTIVE,</span><br><span class="line">  <span class="attr">name</span>: string,</span><br><span class="line">  <span class="attr">exp</span>: <span class="literal">undefined</span> | &#123;</span><br><span class="line">    <span class="attr">type</span>: NodeTypes.SIMPLE_EXPRESSION,</span><br><span class="line">    <span class="attr">content</span>: string,</span><br><span class="line">    <span class="attr">isStatic</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;, <span class="comment">// 表达式节点</span></span><br><span class="line">  <span class="attr">arg</span>: <span class="literal">undefined</span> | &#123;</span><br><span class="line">    <span class="attr">type</span>: NodeTypes.SIMPLE_EXPRESSION,</span><br><span class="line">    <span class="attr">content</span>: string,</span><br><span class="line">    <span class="attr">isStatic</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125; <span class="comment">// 表达式节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 exp 就是解析的变量或者表达式，arg 就是函数名称或者绑定的变量名称，当然也可以不存在，比如 v-if 就没有</p><h1 id="示例的最终结果"><a href="#示例的最终结果" class="headerlink" title="示例的最终结果"></a>示例的最终结果</h1><p><code>&lt;div id=&quot;foo&quot; v-if=&quot;ok&quot;&gt;hello &#123;&#123;name&#125;&#125;&lt;/div&gt;</code></p><p>我们接下来要将这个模板例子编译成以下的状态</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;ROOT&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;children&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;ELEMENT&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;tag&quot;</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;tagType&quot;</span>: <span class="string">&quot;ELEMENT&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;props&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;ATTRIBUTE&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;value&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;TEXT&quot;</span>, <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;foo&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;directives&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;DIRECTIVE&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;if&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;exp&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;SIMPLE_EXPRESSION&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;isStatic&quot;</span>: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;isSelfClosing&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;children&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;TEXT&quot;</span>, <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;hello &quot;</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;INTERPOLATION&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;content&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;SIMPLE_EXPRESSION&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;isStatic&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;name&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ast"><a href="#ast" class="headerlink" title="ast"></a>ast</h1><p>首先我们创建 compiler 目录新建 ast,index 和 parse 三个 js</p><p>下面是 ast 通过 createRoot 接收 children 然后返回一个根节点和它的孩子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NodeTypes = &#123;</span><br><span class="line">  <span class="attr">ROOT</span>: <span class="string">&quot;ROOT&quot;</span>,</span><br><span class="line">  <span class="attr">ELEMENT</span>: <span class="string">&quot;ELEMENT&quot;</span>,</span><br><span class="line">  <span class="attr">TEXT</span>: <span class="string">&quot;TEXT&quot;</span>,</span><br><span class="line">  <span class="attr">SIMPLE_EXPRESSION</span>: <span class="string">&quot;SIMPLE_EXPRESSION&quot;</span>,</span><br><span class="line">  <span class="attr">INTERPOLATION</span>: <span class="string">&quot;INTERPOLATION&quot;</span>,</span><br><span class="line">  <span class="attr">ATTRIBUTE</span>: <span class="string">&quot;ATTRIBUTE&quot;</span>,</span><br><span class="line">  <span class="attr">DIRECTIVE</span>: <span class="string">&quot;DIRECTIVE&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ElementTypes = &#123;</span><br><span class="line">  <span class="attr">ELEMENT</span>: <span class="string">&quot;ELEMENT&quot;</span>,</span><br><span class="line">  <span class="attr">COMPONENT</span>: <span class="string">&quot;COMPONENT&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRoot</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: NodeTypes.ROOT,</span><br><span class="line">    children,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="parse-1"><a href="#parse-1" class="headerlink" title="parse"></a>parse</h1><p>vue 采用了设计模式编写这一部分的内容</p><p>首先是我们的 parse 函数,接收一个 content,通过 createRoot 函数返回编译后的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> context = createParserContext(content);</span><br><span class="line">  <span class="keyword">const</span> children = parseChildren(context);</span><br><span class="line">  <span class="keyword">return</span> createRoot(children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="createParserContext"><a href="#createParserContext" class="headerlink" title="createParserContext"></a>createParserContext</h2><p>通过这个返回接收到的模板字符串和提供编译的选项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createParserContext</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 编译选项</span></span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="comment">// 插值 vue的插值是可以换的</span></span><br><span class="line">      <span class="attr">delimiters</span>: [<span class="string">&quot;&#123;&#123;&quot;</span>, <span class="string">&quot;&#125;&#125;&quot;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 返回接收到的模板字符串</span></span><br><span class="line">    <span class="attr">source</span>: content,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="parseChildren"><a href="#parseChildren" class="headerlink" title="parseChildren"></a>parseChildren</h2><p>在实现 parseChildren 之前我们需要两个工具函数</p><h3 id="advanceBy"><a href="#advanceBy" class="headerlink" title="advanceBy"></a>advanceBy</h3><p>我们的 vue 模板编译其实是像吃豆人一样的,需要一个一个字符串去消化,所以我们要根据情况截取字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:返回截取的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;文本节点&#125;</span> <span class="variable">context</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;需要的字符串数量&#125;</span> <span class="variable">numberOfCharacters</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;截取的字符&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">advanceBy</span>(<span class="params">context, numberOfCharacters</span>) </span>&#123;</span><br><span class="line">  context.source = context.source.slice(numberOfCharacters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="advanceSpaces"><a href="#advanceSpaces" class="headerlink" title="advanceSpaces"></a>advanceSpaces</h3><p>我们的 html 标签里面,其实也会有一些空格的情况出现,所以我们要去掉这些空格,否则会影响到我们的模板编译</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 去掉所有空格</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">context</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">advanceSpaces</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> match = <span class="regexp">/^[\t\r\n\f ]+/</span>.exec(context.source);</span><br><span class="line">  <span class="keyword">if</span> (match) &#123;</span><br><span class="line">    advanceBy(context, match[<span class="number">0</span>].length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以此时的 parseChildren 代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseChildren</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// parseChildren需要返回一个children</span></span><br><span class="line">  <span class="keyword">const</span> nodes = [];</span><br><span class="line">  <span class="keyword">while</span> (!isEnd(context)) &#123;</span><br><span class="line">    <span class="keyword">const</span> s = context.source;</span><br><span class="line">    <span class="keyword">let</span> node;</span><br><span class="line">    <span class="comment">// 这里我们判断以 &#123; 开头则为插值节点，以&lt;开头则为元素节点，其他就是文本节点</span></span><br><span class="line">    <span class="keyword">if</span> (s.startsWith(context.options.delimiters[<span class="number">0</span>])) &#123;</span><br><span class="line">      <span class="comment">//parseInterpolation</span></span><br><span class="line">      node = parseInterpolation(context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] === <span class="string">&quot;&lt;&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// parseElement</span></span><br><span class="line">      node = parseElement(context);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// parseText</span></span><br><span class="line">      node = parseText(context);</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.push(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的循环条件函数为</p><h3 id="isEnd"><a href="#isEnd" class="headerlink" title="isEnd"></a>isEnd</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEnd</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> s = context.source;</span><br><span class="line">  <span class="comment">// s为空字符串,为&lt;/都代表结束了</span></span><br><span class="line">  <span class="keyword">return</span> s.startsWith(<span class="string">&quot;&lt;/&quot;</span>) || !s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后分为文本节点，元素节点，插值节点的处理</p><h2 id="parseText"><a href="#parseText" class="headerlink" title="parseText"></a>parseText</h2><p>对于文本节点，我们可以用匹配的方式进行判断然后缩小范围。<br>比如<code>&lt;div id=&quot;foo&quot; v-if=&quot;ok&quot;&gt;hello &#123;&#123;name&#125;&#125;&lt;/div&gt;</code><br>中，我们可以先匹配<code>&lt;</code>,将范围缩小到<code>hello &#123;&#123;name&#125;&#125;</code>然后再匹配<code>&#123;</code>缩小到<code>hello</code>最后利用 advanceBy 删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseText</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> endTokens = [<span class="string">&quot;&lt;&quot;</span>, context.options.delimiters[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">let</span> endIndex = context.source.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; endTokens.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = context.source.indexOf(endTokens[i]);</span><br><span class="line">    <span class="comment">// 缩小范围</span></span><br><span class="line">    <span class="keyword">if</span> (index != -<span class="number">1</span> &amp;&amp; index &lt; endIndex) &#123;</span><br><span class="line">      endIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> content = parseTextData(context, endIndex);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: NodeTypes.TEXT,</span><br><span class="line">    content,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过上面的方法还是有缺陷，比如识别不了<code>a&lt;b</code>或者<code>&lt;/</code>这样的符号就不行，当然插值后面有文本也不行</p><h3 id="parseTextData"><a href="#parseTextData" class="headerlink" title="parseTextData"></a>parseTextData</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseTextData</span>(<span class="params">context, length</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> text = context.source.slice(<span class="number">0</span>, length);</span><br><span class="line">  <span class="comment">// 去掉这一部分</span></span><br><span class="line">  advanceBy(context, length);</span><br><span class="line">  <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="parseInterpolation"><a href="#parseInterpolation" class="headerlink" title="parseInterpolation"></a>parseInterpolation</h2><p>处理插值节点的思路就是找到前后的标识符，然后先去掉前面标识符的长度，再 parseTextData，最后再去掉后面标识符的长度。注意空格是合法的所以要对节点进行 trim</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseInterpolation</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [open, close] = context.options.delimiters;</span><br><span class="line">  advanceBy(context, open.length);</span><br><span class="line">  <span class="keyword">const</span> closeIndex = context.source.indexOf(close);</span><br><span class="line">  <span class="comment">// &#123;&#123;  name   &#125;&#125;也是合法的 所以要去掉空格</span></span><br><span class="line">  <span class="keyword">const</span> content = parseTextData(context, closeIndex).trim();</span><br><span class="line">  advanceBy(context, close.length);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: NodeTypes.INTERPOLATION,</span><br><span class="line">    <span class="attr">content</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: NodeTypes.SIMPLE_EXPRESSION,</span><br><span class="line">      content,</span><br><span class="line">      <span class="attr">isStatic</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;, <span class="comment">// 表达式节点</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="parseElement"><a href="#parseElement" class="headerlink" title="parseElement"></a>parseElement</h2><p>对于属性节点和指令节点我们放在 parseElement 里面去统一解析</p><p><code>&lt;div id=&quot;foo&quot; v-if=&quot;ok&quot;&gt;hello &#123;&#123;name&#125;&#125;&lt;/div&gt;</code></p><p>首先还是例子 对于这个例子来说，我们要解析出<code>&lt;div id=&quot;foo&quot; v-if=&quot;ok&quot;&gt;</code>和<code>&lt;/div&gt;</code>，那么前提就是要判断它的开始标签和结束标签，中间穿插这个解析</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start tag(解析属性，指令)</span><br><span class="line">parseChildren(解析插值，文本)</span><br><span class="line">end tag</span><br></pre></td></tr></table></figure><p>对于标签，简单来说分为自闭合标签和非自闭合标签，所以我们单独写个函数分割</p><h3 id="parseTag"><a href="#parseTag" class="headerlink" title="parseTag"></a>parseTag</h3><p>这一部分中，通过正则将标签匹配出来，然后吃掉标签和空格，接着拿到属性和指令内容(这一步留到后面写)。</p><p>由于我们的标签还分为 组件标签 和 元素标签 所以我们再写函数进行判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseTag</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> match = <span class="regexp">/^&lt;\/?([a-z][^\t\r\n\f /&gt;]*)/i</span>.exec(context.source);</span><br><span class="line">  <span class="keyword">const</span> tag = match[<span class="number">1</span>];</span><br><span class="line">  advanceBy(context, match[<span class="number">0</span>].length);</span><br><span class="line">  advanceSpaces(context);</span><br><span class="line">  <span class="keyword">const</span> &#123; props, directives &#125; = parseAttributes(context);</span><br><span class="line">  <span class="comment">// 判断是否自闭合</span></span><br><span class="line">  <span class="keyword">const</span> isSelfClosing = context.source.startsWith(<span class="string">&quot;/&gt;&quot;</span>);</span><br><span class="line">  advanceBy(context, isSelfClosing ? <span class="number">2</span> : <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> tagType = isComponent(tag, context)</span><br><span class="line">    ? ElementTypes.COMPONENT</span><br><span class="line">    : ElementTypes.ELEMENT;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: NodeTypes.ELEMENT,</span><br><span class="line">    tag, <span class="comment">// 标签名,</span></span><br><span class="line">    tagType, <span class="comment">// 是组件还是原生元素,</span></span><br><span class="line">    props, <span class="comment">// 属性节点数组,</span></span><br><span class="line">    directives, <span class="comment">// 指令数组</span></span><br><span class="line">    isSelfClosing, <span class="comment">// 是否是自闭合标签,</span></span><br><span class="line">    <span class="attr">children</span>: [],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时发现辨析标签比较困难，引入 vue 提供的解析标签到<code>index.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HTML_TAGS =</span><br><span class="line">  <span class="string">&quot;html,body,base,head,link,meta,style,title,address,article,aside,footer,&quot;</span> +</span><br><span class="line">  <span class="string">&quot;header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,&quot;</span> +</span><br><span class="line">  <span class="string">&quot;figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,&quot;</span> +</span><br><span class="line">  <span class="string">&quot;data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,&quot;</span> +</span><br><span class="line">  <span class="string">&quot;time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,&quot;</span> +</span><br><span class="line">  <span class="string">&quot;canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,&quot;</span> +</span><br><span class="line">  <span class="string">&quot;th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,&quot;</span> +</span><br><span class="line">  <span class="string">&quot;option,output,progress,select,textarea,details,dialog,menu,&quot;</span> +</span><br><span class="line">  <span class="string">&quot;summary,template,blockquote,iframe,tfoot&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VOID_TAGS =</span><br><span class="line">  <span class="string">&quot;area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeMap</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = str</span><br><span class="line">    .split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    .reduce(<span class="function">(<span class="params">map, item</span>) =&gt;</span> ((map[item] = <span class="literal">true</span>), map), <span class="built_in">Object</span>.create(<span class="literal">null</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">val</span>) =&gt;</span> !!map[val];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isVoidTag = makeMap(VOID_TAGS);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isNativeTag = makeMap(HTML_TAGS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">&quot;./parse&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; NodeTypes &#125; <span class="keyword">from</span> <span class="string">&quot;./ast&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; compile &#125; <span class="keyword">from</span> <span class="string">&quot;./compile&quot;</span>;</span><br></pre></td></tr></table></figure><p>并在配置项里增加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createParserContext</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 编译选项</span></span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="comment">// 插值 vue的插值是可以换的</span></span><br><span class="line">      <span class="attr">delimiters</span>: [<span class="string">&quot;&#123;&#123;&quot;</span>, <span class="string">&quot;&#125;&#125;&quot;</span>],</span><br><span class="line">      <span class="comment">// 放到options是为了可以跨平台</span></span><br><span class="line">      isVoidTag,</span><br><span class="line">      isNativeTag,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 返回接收到的模板字符串</span></span><br><span class="line">    <span class="attr">source</span>: content,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们的 isComponent 函数就可以编写了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isComponent</span>(<span class="params">tag, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !context.options.isNativeTag(tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到 parseElement，因为有了这个标签判断方法，大致的 js 如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseElement</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// start tag</span></span><br><span class="line">  <span class="keyword">const</span> element = parseTag(context);</span><br><span class="line">  <span class="comment">// 其实这里判断自闭合这个条件还不够，eg:&lt;input&gt;</span></span><br><span class="line">  <span class="comment">// 所以引入了index中的isVoidTag</span></span><br><span class="line">  <span class="keyword">if</span> (element.isSelfClosing || context.options.isVoidTag(element.tag)) &#123;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// parseChildren</span></span><br><span class="line">  element.children = parseChildren(context);</span><br><span class="line">  <span class="comment">// end Tag</span></span><br><span class="line">  parseTag(context);</span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在解决刚刚留下来的 parseAttributes，解析属性和指令节点</p><h3 id="parseAttributes"><a href="#parseAttributes" class="headerlink" title="parseAttributes"></a>parseAttributes</h3><p>parseTag 中已经帮我们截断了标签。所以目标是<code>&lt;div id=&quot;foo&quot; v-if=&quot;ok&quot;&gt;</code>，不过我们依然需要判断是否自闭合，才进行解析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseAttributes</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> props = [];</span><br><span class="line">  <span class="keyword">const</span> directives = [];</span><br><span class="line">  <span class="comment">// parseTag已经截断了 目标是&lt;div id=&quot;foo&quot; v-if=&quot;ok&quot;&gt;且要判断自闭合</span></span><br><span class="line">  <span class="keyword">while</span> (</span><br><span class="line">    context.source.length &amp;&amp;</span><br><span class="line">    !context.source.startsWith(<span class="string">&quot;&gt;&quot;</span>) &amp;&amp;</span><br><span class="line">    !context.source.startsWith(<span class="string">&quot;/&gt;&quot;</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">let</span> attr = parseAttribute(context);</span><br><span class="line">    <span class="keyword">if</span> (attr.type === NodeTypes.DIRECTIVE) &#123;</span><br><span class="line">      directives.push(attr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      props.push(attr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    props,</span><br><span class="line">    directives,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的解析又需要用到<code>parseAttribute</code>方法</p><h4 id="parseAttribute"><a href="#parseAttribute" class="headerlink" title="parseAttribute"></a>parseAttribute</h4><p>这个方法是为了匹配并删除属性名产生的，匹配完之后，对于属性节点我们要获取等号后的内容，不过我们知道也不是时常有等号的，比如:<code>checked</code>就是没有等号也成立的内容，所以进一步封装方法 parseAttributeValue。对于指令节点，我们通过 match 后的 name 判断，因为指令节点一般以<code>:</code>,<code>@</code>,<code>v-</code>开头，分类判断，最后返回。不过我们在最后处理返回值的时候也要注意会有类似<code>my-class</code>的情况。要将他去掉-转为小驼峰才能识别<code>myClass</code>，需要个工具类函数帮助我们</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseAttribute</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 匹配并删除属性名</span></span><br><span class="line">  <span class="keyword">const</span> match = <span class="regexp">/^[^\t\r\n\f /&gt;][^\t\r\n\f /&gt;=]*/</span>.exec(context.source);</span><br><span class="line">  <span class="keyword">const</span> name = match[<span class="number">0</span>];</span><br><span class="line">  advanceBy(context, name.length);</span><br><span class="line">  advanceSpaces(context);</span><br><span class="line">  <span class="comment">// 获取value 考虑value不存在的情况</span></span><br><span class="line">  <span class="keyword">let</span> value;</span><br><span class="line">  <span class="keyword">if</span> (context.source[<span class="number">0</span>] === <span class="string">&quot;=&quot;</span>) &#123;</span><br><span class="line">    advanceBy(context, <span class="number">1</span>);</span><br><span class="line">    advanceSpaces(context);</span><br><span class="line">    value = parseAttributeValue(context);</span><br><span class="line">    advanceSpaces(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// DIRECTIVE</span></span><br><span class="line">  <span class="comment">// 指令节点通过name判断 因为必然以v- : @开头</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/^(:|@|v-)/</span>.test(name)) &#123;</span><br><span class="line">    <span class="keyword">let</span> dirName, argContent;</span><br><span class="line">    <span class="keyword">if</span> (name[<span class="number">0</span>] === <span class="string">&quot;:&quot;</span>) &#123;</span><br><span class="line">      dirName = <span class="string">&quot;bind&quot;</span>;</span><br><span class="line">      argContent = name.slice(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name[<span class="number">0</span>] === <span class="string">&quot;@&quot;</span>) &#123;</span><br><span class="line">      dirName = <span class="string">&quot;on&quot;</span>;</span><br><span class="line">      argContent = name.slice(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;v-&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">// 此时还没考虑v-if的情况</span></span><br><span class="line">      [dirName, argContent] = name.slice(<span class="number">2</span>).split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">type</span>: NodeTypes.DIRECTIVE,</span><br><span class="line">      <span class="attr">name</span>: dirName,</span><br><span class="line">      <span class="attr">exp</span>: value &amp;&amp; &#123;</span><br><span class="line">        <span class="attr">type</span>: NodeTypes.SIMPLE_EXPRESSION,</span><br><span class="line">        <span class="attr">content</span>: value.content,</span><br><span class="line">        <span class="attr">isStatic</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;, <span class="comment">// 表达式节点</span></span><br><span class="line">      <span class="attr">arg</span>: argContent &amp;&amp; &#123;</span><br><span class="line">        <span class="attr">type</span>: NodeTypes.SIMPLE_EXPRESSION,</span><br><span class="line">        <span class="comment">// 注意:my-class的情况 value会将他转为驼峰</span></span><br><span class="line">        <span class="attr">content</span>: camelize(argContent),</span><br><span class="line">        <span class="attr">isStatic</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;, <span class="comment">// 表达式节点</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ATTRIBUTE</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: NodeTypes.ATTRIBUTE,</span><br><span class="line">    name,</span><br><span class="line">    <span class="attr">value</span>: value &amp;&amp; &#123;</span><br><span class="line">      <span class="attr">type</span>: NodeTypes.TEXT,</span><br><span class="line">      <span class="attr">content</span>: value.content,</span><br><span class="line">    &#125;, <span class="comment">// 纯文本节点</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="parseAttributeValue"><a href="#parseAttributeValue" class="headerlink" title="parseAttributeValue"></a>parseAttributeValue</h5><p>对于等号后的内容，其实不加引号和加引号都是合法的，这里偷个懒，认为输入的必须加引号才成立。方法就是获取第一个字符后匹配最后一个 index，再通过 parseTextData 获取内容, 最后删掉那个多余的引号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseAttributeValue</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// id=&#x27;foo&#x27; id=foo id=&quot;foo&quot; 都是合法的 这里只考虑有引号的情况</span></span><br><span class="line">  <span class="keyword">const</span> quote = context.source[<span class="number">0</span>];</span><br><span class="line">  advanceBy(context, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> endIndex = context.source.indexOf(quote);</span><br><span class="line">  <span class="keyword">const</span> content = parseTextData(context, endIndex);</span><br><span class="line">  <span class="comment">// &#x27;foo&#x27; =&gt; &#x27;foo + &#x27;</span></span><br><span class="line">  advanceBy(context, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    content,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="camelize"><a href="#camelize" class="headerlink" title="camelize"></a>camelize</h5><p>工具类中的转小驼峰的方法，例子是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my-first-class-</span></span><br><span class="line"><span class="comment">// myFirstClass</span></span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">camelize</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 第一个参数是匹配到的字符，第二个参数是括号分组后匹配的字符</span></span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/-(\w)/g</span>, <span class="function">(<span class="params">_, c</span>) =&gt;</span> &#123;</span><br><span class="line">    c ? c.toUpperCase() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="whitespace-优化"><a href="#whitespace-优化" class="headerlink" title="whitespace 优化"></a>whitespace 优化</h1><p>例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;div&gt;</span></span><br><span class="line"><span class="comment">  foo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      bar</span></span><br><span class="line"><span class="comment">&lt;/div&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>a<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>b<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>c<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个例子中，如果我们采用原来的解析方法，会多了很多<code>/r/n</code>之类的不必要字符，算做了文本节点，所以这里有个优化的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> removedWhitespaces = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> node = nodes[i];</span><br><span class="line">  <span class="keyword">if</span> (node.type === NodeTypes.TEXT) &#123;</span><br><span class="line">    <span class="comment">// 区分文本节点是否空白</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/[^\t\r\f\n ]/</span>.test(node.content)) &#123;</span><br><span class="line">      <span class="comment">// 文本节点有一些空白</span></span><br><span class="line">      node.content = node.content.replace(<span class="regexp">/[\t\r\f\n ]+/g</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 文本节点全是空白 分情况</span></span><br><span class="line">      <span class="comment">// 文本节点处于两个元素节点之间并且有换行符才能删</span></span><br><span class="line">      <span class="keyword">const</span> prev = node[i - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">const</span> next = node[i + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        !prev ||</span><br><span class="line">        !next ||</span><br><span class="line">        (prev.type === NodeTypes.ELEMENT &amp;&amp;</span><br><span class="line">          next.type === NodeTypes.ELEMENT &amp;&amp;</span><br><span class="line">          <span class="regexp">/[\r\n]/</span>.test(node.content))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        removedWhitespaces = <span class="literal">true</span>;</span><br><span class="line">        nodes[i] = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 替换成一个空格</span></span><br><span class="line">        node.content = <span class="string">&quot; &quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果里面没有删除也会执行filter造成损耗 所以给个标识</span></span><br><span class="line"><span class="keyword">return</span> removedWhitespaces ? nodes.filter(<span class="built_in">Boolean</span>) : nodes;</span><br></pre></td></tr></table></figure><p>之后跑代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">&quot;./compiler/index&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(parse(<span class="string">`&lt;div id=&quot;foo&quot; v-if=&quot;ok&quot;&gt;hello &#123;&#123;name&#125;&#125;&lt;/div&gt;`</span>))</span><br></pre></td></tr></table></figure></p><p>如果结果如下 说明基本是正确的<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220619115543.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的mini-vue⑦--scheduler篇</title>
    <link href="https://zlinni.github.io/posts/3541433463/"/>
    <id>https://zlinni.github.io/posts/3541433463/</id>
    <published>2022-06-13T00:44:49.000Z</published>
    <updated>2022-06-19T06:45:51.977Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是 scheduler 篇，是关于 Vue3 中调度机制的深入讨论。</p></div><h1 id="为什么需要-scheduler"><a href="#为什么需要-scheduler" class="headerlink" title="为什么需要 scheduler"></a>为什么需要 scheduler</h1><p>在我们上节组件的实践中，我们跑了一个这样的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render, h &#125; <span class="keyword">from</span> <span class="string">&quot;./runtime&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;./reactiveDemo/ref&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> Comp = &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      count.value++;</span><br><span class="line">      <span class="built_in">console</span>.log(count.value);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">      add,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      h(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, ctx.count),</span><br><span class="line">      h(</span><br><span class="line">        <span class="string">&quot;button&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">onClick</span>: ctx.add,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;add&quot;</span></span><br><span class="line">      ),</span><br><span class="line">    ];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnode = h(Comp);</span><br><span class="line">render(vnode, <span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure><p>如果我们将例子中的 add 函数修改成如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.value++;</span><br><span class="line">  count.value++;</span><br><span class="line">  count.value++;</span><br><span class="line">  <span class="built_in">console</span>.log(count.value);</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;render&#x27;</span>);</span><br><span class="line">   <span class="keyword">return</span> [</span><br><span class="line">     h(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, ctx.count),</span><br><span class="line">     h(</span><br><span class="line">       <span class="string">&quot;button&quot;</span>,</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="attr">onClick</span>: ctx.add,</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="string">&quot;add&quot;</span></span><br><span class="line">     ),</span><br><span class="line">   ];</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>我们会发现它是可以运行，一次加 3，但是右侧控制台中会发现这样的情况</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220613085131.png" alt=""></p><p>说明了我们每执行一次 add 操作，渲染函数就执行了三次。很明显这样是不对的，我们期望它每次执行 add 就只执行一次，回想一下之前 reactive 篇中的 effect 和 computed，我们用到了 scheduler 机制去帮助我们在 trigger 中优先执行 scheduler，所以我们也可以用同样的机制，优先执行完 add 操作再执行 render</p><h1 id="使用调度机制"><a href="#使用调度机制" class="headerlink" title="使用调度机制"></a>使用调度机制</h1><p>只需要在 update 里面加一个 scheduler 的配置项即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">instance.update = effect(</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">scheduler</span>: queueJob,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="queueJob"><a href="#queueJob" class="headerlink" title="queueJob"></a>queueJob</h1><p>接下来我们编写一个 queueJob 函数，它接收 job 作为参数，其实这个 job 就是我们的 effectFn，我们还需要一个任务栈用于放 job，并且还要对 job 进行去重(？)之后放入队列进行任务的执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue = [];</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueJob</span>(<span class="params">job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!queue.length || !queue.includes(job)) &#123;</span><br><span class="line">    queue.push(job);</span><br><span class="line">    <span class="comment">// 清空队列的操作</span></span><br><span class="line">    queueFlush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="queueFlush"><a href="#queueFlush" class="headerlink" title="queueFlush"></a>queueFlush</h1><p>这一步主要是看任务是否正在执行，如果有正在执行的任务就等待任务执行结束，如果没有就用异步任务执行 job</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueFlush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 任务是否正在执行 不在的话才能进入promise 且要等每次promise执行完才能进入下一个任务</span></span><br><span class="line">  <span class="keyword">if</span> (!isFlushing) &#123;</span><br><span class="line">    isFlushing = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(flushJobs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="flushJobs"><a href="#flushJobs" class="headerlink" title="flushJobs"></a>flushJobs</h1><p>我们的任务执行完才清空队列进行下一次任务,且由于 job 是用户代码可能会出错，所以要用 try 包裹起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushJobs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 因为是用户代码可能会出错</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 注意不能用len = queue.length 因为它可能在执行的时候继续添加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; queue.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> job = queue[i];</span><br><span class="line">      job();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isFlushing = <span class="literal">false</span>;</span><br><span class="line">    queue.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实践一下就会发现，要直接获取 dom 的数据还是不行或者获取，这里就需要 settimeout 或者 vue 的 nextTick</p><p>所以我们要实现一个 nextTick</p><h1 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h1><p>对于 nextTick 有两种情况，1 是使用的时候还存在正在执行的 promise，则直接返回当前正在执行的 promise 成功的回调，2 是当前的任务都已经执行完了，那么就返回一个新的 promise 成功执行的回调。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代表正在执行的promise</span></span><br><span class="line"><span class="keyword">let</span> currentFlushPromise = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 封装一下Promise.resolve()</span></span><br><span class="line"><span class="keyword">const</span> resolvedPromise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果有在执行的promise则返回当前在执行的promise成功回调的结果，如果没有则返回一个新的promise的成功回调结果</span></span><br><span class="line">    <span class="keyword">const</span> p = currentFlushPromise || resolvedPromise;</span><br><span class="line">    <span class="keyword">return</span> p.then(fn);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueFlush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 任务是否正在执行 不在的话才能进入promise 且要等每次promise执行完才能进入下一个任务</span></span><br><span class="line">    <span class="keyword">if</span> (!isFlushing) &#123;</span><br><span class="line">        isFlushing = <span class="literal">true</span>;</span><br><span class="line">        currentFlushPromise = resolvedPromise.then(flushJobs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清空队列了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushJobs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 因为是用户代码可能会出错</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        isFlushing = <span class="literal">false</span>;</span><br><span class="line">        queue.length = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意清空currentFlushPromise</span></span><br><span class="line">        currentFlushPromise = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们还会用到 es6 的 await 语法，比如<code>await nextTick()</code>这个时候是不传参的，所以针对这种写法我们也要注意</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = currentFlushPromise || resolvedPromise;</span><br><span class="line">  <span class="comment">// 如果fn存在就p.then否则就把p传回去</span></span><br><span class="line">  <span class="keyword">return</span> fn ? p.then(fn) : p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们已经写好了完整的 scheduler</p><h1 id="scheduler-完整代码"><a href="#scheduler-完整代码" class="headerlink" title="scheduler 完整代码"></a>scheduler 完整代码</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue = [];</span><br><span class="line"><span class="keyword">let</span> isFlushing = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> currentFlushPromise = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> resolvedPromise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果有在执行的promise则返回当前在执行的promise成功回调的结果，如果没有则返回一个新的promise的成功回调结果</span></span><br><span class="line">  <span class="keyword">const</span> p = currentFlushPromise || resolvedPromise;</span><br><span class="line">  <span class="keyword">return</span> fn ? p.then(fn) : p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;effectFn&#125;</span> <span class="variable">job</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueJob</span>(<span class="params">job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!queue.length || !queue.includes(job)) &#123;</span><br><span class="line">    queue.push(job);</span><br><span class="line">    <span class="comment">// 清空队列的操作</span></span><br><span class="line">    queueFlush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueFlush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 任务是否正在执行 不在的话才能进入promise 且要等每次promise执行完才能进入下一个任务</span></span><br><span class="line">  <span class="keyword">if</span> (!isFlushing) &#123;</span><br><span class="line">    isFlushing = <span class="literal">true</span>;</span><br><span class="line">    currentFlushPromise = resolvedPromise.then(flushJobs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清空队列了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushJobs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 因为是用户代码可能会出错</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 注意不能用len = queue.length 因为它可能在执行的时候继续添加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; queue.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> job = queue[i];</span><br><span class="line">      job();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isFlushing = <span class="literal">false</span>;</span><br><span class="line">    queue.length = <span class="number">0</span>;</span><br><span class="line">    currentFlushPromise = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="createApp"><a href="#createApp" class="headerlink" title="createApp"></a>createApp</h1><p>接下来我们写 minivue 的 createApp，我们一般都是 createApp 包裹住一个组件，然后<code>.mount(document.body)</code>这样写，不需要 render 和 h 函数生成 vnode</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Zlinni 984328216@qq.com</span></span><br><span class="line"><span class="comment"> * @Date: 2022-05-22 19:49:21</span></span><br><span class="line"><span class="comment"> * @LastEditors: Zlinni 984328216@qq.com</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2022-06-13 19:24:24</span></span><br><span class="line"><span class="comment"> * @FilePath: \mini-vue\zMini-vue\src\index.js</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2022 by Zlinni 984328216@qq.com, All Rights Reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123; render, h, createApp &#125; <span class="keyword">from</span> <span class="string">&quot;./runtime&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;./reactive/ref&quot;</span>;</span><br><span class="line">createApp(&#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      count.value++;</span><br><span class="line">      count.value++;</span><br><span class="line">      count.value++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">      add,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;render&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      h(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, ctx.count.value),</span><br><span class="line">      h(</span><br><span class="line">        <span class="string">&quot;button&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">onClick</span>: ctx.add,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;add&quot;</span></span><br><span class="line">      ),</span><br><span class="line">    ];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).mount(<span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure><p>首先我们创建一个<code>createApp.js</code>，这个 createApp 接受一个参数，是组件，返回一个组件实例，我们还需要将他用 mount 挂载起来，其中对于 mount 来说，可以接受一个 dom 也可以接收字符串，比如我们在创建 vue 实例的时候经常会写的<code>mount(#app)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isString &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">&quot;./render&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&quot;./vnode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;组件&#125;</span> <span class="variable">rootComponent</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;组件的实例&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params">rootComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = &#123;</span><br><span class="line">    <span class="function"><span class="title">mount</span>(<span class="params">rootContainer</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 如果它是字符串就把他转换成DOM对象</span></span><br><span class="line">      <span class="keyword">if</span> (isString(rootContainer)) &#123;</span><br><span class="line">        rootContainer = <span class="built_in">document</span>.querySelector(rootContainer);</span><br><span class="line">      &#125;</span><br><span class="line">      render(h(rootComponent), rootContainer);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就实现了这个 createApp，但是 vue 为什么要单独写一个 createApp 呢。实际上，它是为了后面更好的拓展 Vue 下面的其他方法，比如我们用过的 <code>use()</code>,<code>mixin()</code>等方法</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本节中我们学习了 vue 的 scheduler 调度机制，从之前 effect 和 computed 的案例开始说起，沿用 scheduler 的优先执行机制(异步任务)来帮助我们优化组件的更新过程，其中对于任务队列(queueJob)，我们只在队列为空或者不存在相同的任务的时候才将任务放进任务栈，然后去执行任务(queueFlush),这个过程中我们要把当前执行的任务保存起来，到真正执行环节(flushJobs)的时候，因为这些任务是用户代码需要包裹起来，然后将它们逐个从任务栈中取出来执行。执行结束之后改变标志位并清空当前执行任务的标志。</p><p>我们还学到了nextTick，其实nextTick就和我们的调度机制息息相关，我们拿到了scheduler中正在执行的任务，就将nextTick的事件放到它的成功回调后，当然还要考虑一种情况如果任务都执行完了，就将事件放在新的promise的成功回调中。不过最后我们还考虑到了es6的await使用nextTick的情况，我们就把nextTick的返回值稍作修改，当有fn传进来就返回任务的成功回调，否则就返回整个任务promise。</p><p>下一节我们将学习vue的模板编译。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的mini-vue⑥--component篇</title>
    <link href="https://zlinni.github.io/posts/1033180007/"/>
    <id>https://zlinni.github.io/posts/1033180007/</id>
    <published>2022-06-12T02:21:17.000Z</published>
    <updated>2022-06-19T11:42:12.592Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是 Component 篇，是关于 Vue3 中组件的深入讨论。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/componentImage.png" alt=""></p><h1 id="组件是什么"><a href="#组件是什么" class="headerlink" title="组件是什么"></a>组件是什么</h1><div class="note primary flat"><p>从开发者的视角来看，组件分为状态组件和函数组件，vue 其实也有函数式组件，但它和状态组件，从实现上来讲几乎没有多大区别，因此我们只考虑状态组件，以下所讲的组件都是状态组件</p></div><p>React 的组件示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.add&#125;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue3 的组件示例（optional）（渲染函数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">createApp(&#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      h(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, ctx.count),</span><br><span class="line">      h(</span><br><span class="line">        <span class="string">&quot;button&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">onClick</span>: ctx.add,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;add&quot;</span></span><br><span class="line">      ),</span><br><span class="line">    ];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><p>Vue3 的组件示例（composition）（渲染函数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">createApp(&#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> add = <span class="function">() =&gt;</span> count.value++;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">      add,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      h(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, ctx.count),</span><br><span class="line">      h(</span><br><span class="line">        <span class="string">&quot;button&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">onClick</span>: ctx.add,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;add&quot;</span></span><br><span class="line">      ),</span><br><span class="line">    ];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><p>所以从实现来看都有共同点：</p><ol><li>都有 instance 实例，以承载内部的状态，方法等</li><li>都有一个 render 函数</li><li>都通过 render 产出 vnode</li><li>都有一套更新策略，以重新执行 render 函数</li><li>在此基础上附加各种能力，如生命周期，通信机制，slot，provide，inject 等等</li></ol><p>不过我们不打算实现 optional API 的写法，只实现 composition API。也不打算实现 slot，provide，inject 等等</p><p>所以根据此基础我们先来改造一开始没用做完的 processComponent</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processComponent</span>(<span class="params">prevVNode, vnode, container, anchor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO processComponent</span></span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    <span class="comment">// TODO updateComponent</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountComponent(vnode, container, anchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将 mountComponent 放在<code>component.js</code>中并引入。</p><p>不过在编写 mountComponent 之前，我们看一个例子：</p><h1 id="prop-和-attr"><a href="#prop-和-attr" class="headerlink" title="prop 和 attr"></a>prop 和 attr</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Comp = &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&quot;foo&quot;</span>],</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;a&quot;</span>, <span class="attr">id</span>: ctx.bar &#125;, ctx.foo);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnodeProps = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnode = h(Comp, vnodeProps);</span><br><span class="line">render(vnode, root); <span class="comment">// 渲染为&lt;div class=&quot;a&quot; bar=&quot;bar&quot;&gt;foo&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p>这个例子只 prop 了一个 foo，没有接收 bar。所以对应也渲染了 foo 出来，没有渲染 id 为 bar。但是为什么又有一个 <code>bar=&quot;bar&quot;</code>属性呢？这个是因为 vue3 会默认的将没有 prop 进来的参数自动作为 attribute 添加到根节点上。</p><p>所以我们的实例要有 props 和 attrs 两个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params">vnode, container, anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">type</span>: Component &#125; = vnode;</span><br><span class="line">  <span class="comment">// 一个组件必然有一个实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = &#123;</span><br><span class="line">    <span class="attr">props</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">attrs</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 初始化props</span></span><br><span class="line">  initProps(instance, vnode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="initProps"><a href="#initProps" class="headerlink" title="initProps"></a>initProps</h2><p>这一步操作主要是为了分离 props 和 attrs，setup 的 props 中存在的就分配给 props，不存在的就分配给 attrs。然后再把 props 变成响应式放出去使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span>(<span class="params">instance, vnode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 我们知道type在vnode里面</span></span><br><span class="line">  <span class="comment">// 起别名免得命名冲突 此时这两个就对应了例子中的Comp和vnodeProps</span></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">type</span>: Component, <span class="attr">props</span>: vnodeProps &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> props = (instance.props = &#123;&#125;);</span><br><span class="line">  <span class="keyword">const</span> attrs = (instance.attrs = &#123;&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> vnodeProps) &#123;</span><br><span class="line">    <span class="comment">// 因为prop有很多种类型，我们把它当作只能接收数组类型来简单处理</span></span><br><span class="line">    <span class="comment">// 又因为这个props不一定声明，所以用可选链</span></span><br><span class="line">    <span class="keyword">if</span> (Component.props?.includes(key)) &#123;</span><br><span class="line">      props[key] = vnodeProps[key];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      attrs[key] = vnodeProps[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 因为props的数据也是响应式的，但是它不能被修改，这里就先用reactive来简单替代</span></span><br><span class="line">  instance.props = reactive(instance.props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><p>再次回到 mountComponent,我们接下来要去出发 setup 将我们的 props 和 attrs 传进去。根据 vue3 官网我们知道 setup 接收两个参数<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220612151936.png" alt=""></p><p>其中 props 我们已经写了，context 是一个对象，包含着 attrs，slot，emit，我们只简单实现 attrs，所以也就将 attrs 传进去即可。另外由于 setup 最终会把响应式数据 return 出去，所以我们还需要保存下这个结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">type</span>: Component &#125; = vnode;</span><br><span class="line"><span class="comment">// 一个组件必然有一个实例</span></span><br><span class="line"><span class="keyword">const</span> instance = &#123;</span><br><span class="line">  <span class="attr">props</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">attrs</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 将结果保存起来</span></span><br><span class="line">  <span class="attr">setupState</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 初始化props</span></span><br><span class="line">initProps(instance, vnode);</span><br><span class="line"><span class="comment">// 因为setup也可能不存在，所以可选链</span></span><br><span class="line">instance.setupState = Component.setup?.(instance.props, &#123;</span><br><span class="line">  <span class="attr">attrs</span>: instance.attrs,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接下来我们就继续执行 mountComponent 函数</p><h2 id="ctx"><a href="#ctx" class="headerlink" title="ctx"></a>ctx</h2><p>render 接收一个 ctx，通过观察发现 ctx 包含了 props 或者 setupState</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = &#123;</span><br><span class="line">  <span class="attr">props</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">attrs</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 将结果保存起来</span></span><br><span class="line">  <span class="attr">setupState</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 观测实例发现ctx可以取到setupState和props</span></span><br><span class="line">  <span class="attr">ctx</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意vue源码里面是采用代理从props里面找，找不到再找setupState，这里偷懒直接合并</span></span><br><span class="line">instance.ctx = &#123;</span><br><span class="line">  ...instance.props,</span><br><span class="line">  ...instance.setupState,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="封装-mount"><a href="#封装-mount" class="headerlink" title="封装 mount"></a>封装 mount</h2><p>然后我们将执行 render 函数的操作封装成一个方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 将执行render的操作封装成一个函数</span></span><br><span class="line">  <span class="attr">mount</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这里就不用可选链了,因为render对于组件来说必须存在的</span></span><br><span class="line">instance.mount = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">  Component.render(instance.ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="normalizeVNode"><a href="#normalizeVNode" class="headerlink" title="normalizeVNode"></a>normalizeVNode</h3><p>不过我们还要对 mount 返回的结果进行一个预处理</p><p>如果它只是一个 h 函数好说,但是如果它是一个数组的情况,就不是一个标准的 vnode,而且我们如果想对只返回一个字符串等操作做处理,那么我们就需要一个辅助函数 normalizeVNode,我们将他放到<code>vnode.js</code>里面做处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">normalizeVNode</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是个数组我们就用Fragment把他包装一下</span></span><br><span class="line">  <span class="keyword">if</span> (isArray(result)) &#123;</span><br><span class="line">    <span class="keyword">return</span> h(Fragment, <span class="literal">null</span>, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isObject(result)) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// string||number</span></span><br><span class="line">  <span class="keyword">return</span> h(Text, <span class="literal">null</span>, result.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次回到 mountComponent</p><p>我们将组件产物的 vnode 命名为 subTree</p><h3 id="subTree"><a href="#subTree" class="headerlink" title="subTree"></a>subTree</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">instance.mount = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subTree = normalizeVNode(Component.render(instance.ctx));</span><br><span class="line">  <span class="comment">// 直接patch 但是注意这里的引入方式,可以直接传入也可以导出然后使用</span></span><br><span class="line">  patch(<span class="literal">null</span>, subTree, container, anchor);</span><br><span class="line">&#125;;</span><br><span class="line">instance.mount();</span><br></pre></td></tr></table></figure><h1 id="案例-1"><a href="#案例-1" class="headerlink" title="案例 1"></a>案例 1</h1><p>之后我们跑一下这段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render, h &#125; <span class="keyword">from</span> <span class="string">&quot;./runtime&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> Comp = &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&quot;foo&quot;</span>],</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;a&quot;</span>, <span class="attr">id</span>: ctx.bar &#125;, ctx.foo);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnodeProps = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnode = h(Comp, vnodeProps);</span><br><span class="line">render(vnode, <span class="built_in">document</span>.body); <span class="comment">// 渲染为&lt;div class=&quot;a&quot; bar=&quot;bar&quot;&gt;foo&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p>第一次跑的时候会发现它少了一个 bar 属性，前面也提到了 vue3 会默认的将没有 prop 进来的参数自动作为 attribute 添加到根节点上。所以这个 bar 是一定存在的，至于为什么跑了这段代码他没出现，原因是我们没有处理 attr 的继承</p><h2 id="fallThrough"><a href="#fallThrough" class="headerlink" title="fallThrough"></a>fallThrough</h2><p>这个方法用于处理 attr 的继承，因为我们的这个 props 最后是会在 patchDomProp 中进行处理的。所以我们现在要把 bar 传过去的方法就是将他和我们现在的 props 合并(虽然 vue3 不是这样做的，从简吧)</p><p>具体做法是如果存在 attr 属性，就将组件的节点所在的 props 和 instance 的 attrs 合并.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fallThrough</span>(<span class="params">instance, subTree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(instance.attrs).length) &#123;</span><br><span class="line">    subTree.props = &#123;</span><br><span class="line">      ...subTree.props,</span><br><span class="line">      ...instance.attrs,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220612163006.png" alt=""></p><p>可以看到最后结果和我们预想的一致</p><h1 id="案例-2"><a href="#案例-2" class="headerlink" title="案例 2"></a>案例 2</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render, h &#125; <span class="keyword">from</span> <span class="string">&quot;./runtime&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;./reactiveDemo/ref&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> Comp = &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      count.value++;</span><br><span class="line">      <span class="built_in">console</span>.log(count.value);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">      add,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      h(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, ctx.count),</span><br><span class="line">      h(</span><br><span class="line">        <span class="string">&quot;button&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">onClick</span>: ctx.add,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;add&quot;</span></span><br><span class="line">      ),</span><br><span class="line">    ];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnode = h(Comp);</span><br><span class="line">render(vnode, <span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220612164141.png" alt=""></p><p>在案例二中我们发现跑出来的结果并没有 count，这个是因为真正的 vue 里面处理掉了这个 value 值，不需要 value 值就可以访问基础类型响应式数据，而我们图方便就不这样做了，选择直接改为<code>h(&quot;div&quot;, null, ctx.count.value)</code>重新跑</p><p>我们发现 dom 已经渲染出来了</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220612164130.png" alt=""></p><p>但是不论我们如何点击都没有改变值，现在我们输出一下 count 值试一试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.value++;</span><br><span class="line">  <span class="built_in">console</span>.log(count.value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220612164409.png" alt=""></p><p>我们发现结果已经加了 但是 dom 并没有更新，原因很简单，因为我们只 mount 了一次，没有写 update 操作</p><h1 id="update"><a href="#update" class="headerlink" title="update"></a>update</h1><p>既然是更新，就需要拿到上一次的结果进行 patch，所以我们要将 subTree 存起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">instance.update = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> prev = instance.subTree;</span><br><span class="line">  <span class="keyword">const</span> subTree = (instance.subTree = normalizeVNode(</span><br><span class="line">    Component.render(instance.ctx)</span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(instance.attrs).length) &#123;</span><br><span class="line">    subTree.props = &#123;</span><br><span class="line">      ...subTree.props,</span><br><span class="line">      ...instance.attrs,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 需要上一次的subTree来更新，所以要把subTree保存起来。</span></span><br><span class="line">  patch(prev, subTree, container, anchor);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么还有一个问题，就是怎么触发更新。</p><p>在我们之前的响应式学习中，我们知道响应式是由 reactive 建立，由 effect 触发的，只要改变了响应式数据，那么就会在 proxy 里面触发 trigger 方法，对依赖进行查找并执行相应的 effect。</p><p>那么对于这个 update 其实也很简单，只要用 effect 把 update 包裹起来即可实现更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">instance.update = effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> prev = instance.subTree;</span><br><span class="line">  <span class="keyword">const</span> subTree = (instance.subTree = normalizeVNode(</span><br><span class="line">    Component.render(instance.ctx)</span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(instance.attrs).length) &#123;</span><br><span class="line">    subTree.props = &#123;</span><br><span class="line">      ...subTree.props,</span><br><span class="line">      ...instance.attrs,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 需要上一次的subTree来更新，所以要把subTree保存起来。</span></span><br><span class="line">  patch(prev, subTree, container, anchor);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="合并-mount-和-update"><a href="#合并-mount-和-update" class="headerlink" title="合并 mount 和 update"></a>合并 mount 和 update</h2><p>这里又会出现一个问题，就是我们在写 effect 的时候默认是给他执行一次的，除了配置项 lazy 之外，所以为了解决这个问题，我们可以将 mount 和 update 合并</p><p>为了区分它是不是第一次 mount，需要一个变量 isMounted</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = &#123;</span><br><span class="line">  <span class="attr">props</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">attrs</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 将结果保存起来</span></span><br><span class="line">  <span class="attr">setupState</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 观测实例发现ctx可以取到setupState和props</span></span><br><span class="line">  <span class="attr">ctx</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 将执行render的操作封装成一个函数</span></span><br><span class="line">  <span class="attr">update</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">subTree</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">isMounted</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line">instance.update = effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!instance.isMounted) &#123;</span><br><span class="line">    <span class="keyword">const</span> subTree = (instance.subTree = normalizeVNode(</span><br><span class="line">      Component.render(instance.ctx)</span><br><span class="line">    ));</span><br><span class="line">    <span class="comment">// 此处的fallThrough就是之前的遍历</span></span><br><span class="line">    fallThrough(instance, subTree);</span><br><span class="line">    <span class="comment">// 直接patch 但是注意这里的引入方式</span></span><br><span class="line">    patch(<span class="literal">null</span>, subTree, container, anchor);</span><br><span class="line">    vnode.el = subTree.el;</span><br><span class="line">    instance.isMounted = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> prev = instance.subTree;</span><br><span class="line">    <span class="keyword">const</span> subTree = (instance.subTree = normalizeVNode(</span><br><span class="line">      Component.render(instance.ctx)</span><br><span class="line">    ));</span><br><span class="line">    fallThrough(instance, subTree);</span><br><span class="line">    <span class="comment">// 需要上一次的subTree来更新，所以要把subTree保存起来。</span></span><br><span class="line">    patch(prev, subTree, container, anchor);</span><br><span class="line">    vnode.el = subTree.el;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>至此就完成了组件的主动更新</p><h1 id="被动更新"><a href="#被动更新" class="headerlink" title="被动更新"></a>被动更新</h1><p>见例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Child = &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&quot;foo&quot;</span>],</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;a&quot;</span>, <span class="attr">id</span>: ctx.bar &#125;, ctx.foo);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Parent = &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> vnodeProps = reactive(&#123;</span><br><span class="line">      <span class="attr">foo</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">      <span class="attr">bar</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123; vnodeProps &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h(Child, ctx.vnodeProps);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">render(h(Parent), root);</span><br></pre></td></tr></table></figure><p>这个例子中，父组件发生了一次更新，是主动更新，但是父组件的渲染的时候，这个 child 是已经存在的组件，如果子组件对应的 props 也发生变化了，就会触发 updateComponent。导致了子组件的更新，也就是被动更新。</p><h1 id="updateComponent"><a href="#updateComponent" class="headerlink" title="updateComponent"></a>updateComponent</h1><p>先不考虑子组件的 props 发生变化的情况，我们来处理这个 updateComponent</p><p>它接收两个参数，一个是 prevVNode 一个是 vnode，由于是更新，所以我们要尽可能考虑能复用原先实例 instance 中的 update 方法。为了解决这个问题，我们可以将实例 instance 挂载到 vnode 上面，</p><h2 id="挂载实例到-vnode"><a href="#挂载实例到-vnode" class="headerlink" title="挂载实例到 vnode"></a>挂载实例到 vnode</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  type,</span><br><span class="line">  props,</span><br><span class="line">  children,</span><br><span class="line">  shapeFlag,</span><br><span class="line">  <span class="attr">el</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">anchor</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">key</span>: props &amp;&amp; props.key,</span><br><span class="line">  <span class="attr">component</span>: <span class="literal">null</span>, <span class="comment">//专门用于存储组件的实例</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> instance = (vnode.component = &#123;</span><br><span class="line">  <span class="attr">props</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">attrs</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">setupState</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">ctx</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">update</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">subTree</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">isMounted</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 回到updateComponent</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateComponent</span>(<span class="params">prevVNode,vnode</span>)</span>&#123;</span><br><span class="line">  vnode.component = prevVNode.component;</span><br><span class="line">  vnode.component.update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="next-传递节点"><a href="#next-传递节点" class="headerlink" title="next 传递节点"></a>next 传递节点</h2><p>这就到了实例的 instance 里面，但此时执行的还是原先的 prevVNode，我们还需要传递 vnode 新节点过去</p><p>这里就再给实例添加一个属性 next 初始值设置为 null，然后在 updateComponent 里面传递</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = (vnode.component = &#123;</span><br><span class="line">  <span class="attr">props</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">attrs</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 将结果保存起来</span></span><br><span class="line">  <span class="attr">setupState</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 观测实例发现ctx可以取到setupState和props</span></span><br><span class="line">  <span class="attr">ctx</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 将执行render的操作封装成一个函数</span></span><br><span class="line">  <span class="attr">update</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">subTree</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">isMounted</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 存储新的vnode</span></span><br><span class="line">  <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateComponent</span>(<span class="params">prevVNode, vnode</span>) </span>&#123;</span><br><span class="line">  vnode.component = prevVNode.component;</span><br><span class="line">  vnode.component.next = vnode;</span><br><span class="line">  vnode.component.update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重新初始化-next"><a href="#重新初始化-next" class="headerlink" title="重新初始化 next"></a>重新初始化 next</h2><p>现在如果 next 存在就是被动更新。我们复用 vnode，将节点传进来 并将 next 置为 null 防止下次主动更新触发被动更新出错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (instance.next) &#123;</span><br><span class="line">  <span class="comment">// 被动更新</span></span><br><span class="line">  <span class="comment">// 复用vnode，将节点传进来 并将next置为null防止下次主动更新触发被动更新出错</span></span><br><span class="line">  vnode = instance.next;</span><br><span class="line">  instance.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取最新-props"><a href="#获取最新-props" class="headerlink" title="获取最新 props"></a>获取最新 props</h2><p>回顾一下我们的案例，主要是父组件的 props 改变导致了子组件的被动更新。所以其原因还是在 props，我们这里也要去获取最新的 props 值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (instance.next) &#123;</span><br><span class="line">  <span class="comment">// 被动更新</span></span><br><span class="line">  <span class="comment">// 复用vnode，将节点传进来 并将next置为null防止下次主动更新触发被动更新出错</span></span><br><span class="line">  vnode = instance.next;</span><br><span class="line">  instance.next = <span class="literal">null</span>;</span><br><span class="line">  initProps(instance, vnode);</span><br><span class="line">  instance.ctx = &#123;</span><br><span class="line">    ...instance.props,</span><br><span class="line">    ...instance.setupState,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们的 context 是合并来的并不是像源码一样代理来的，所以要手动合并一次</p><h1 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h1><p>我们最开始遗留的问题，就是没考虑子组件的 props 是否改变，改变了才应该去更新。</p><p>这个方法就是 react 里面的方法，react 将这个方法暴露出来给用户让他决定是否更新，vue 就将其内置。主要的操作这里就省略了。</p><h1 id="unmountComponent"><a href="#unmountComponent" class="headerlink" title="unmountComponent"></a>unmountComponent</h1><p>直接把 vnode 里面挂载的 component 中的 subTree 卸载即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unmountComponent</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  unmount(vnode.component.subTree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然真实的卸载组件流程没那么简单，他还要去处理destroy和beforeDestroy的情况</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>component篇是之前遗留下来的一个章节，我们从一个例子入手了解组件的script部分是由setup和render组成，setup负责接收props和context，其中context对象内部又有attrs，slot，inject等内容，且由于vue的特性是，将组件没有props的内容当作attrs传进去，为了实现分离的特性，我们尝试写了initProps函数，之后我们调用了组件的setup函数传入props和attrs，并将它的结果保存在了setupState里面，因为setup的数据最后会return出去。</p><p>render部分则有一个参数ctx，包含了props或者setupState，它要找到对应的依赖，vue中是使用代理的方式，从props开始找，找不到再去setupState里面找。另外值得一提的是可以没有setup，但是必须有render。然后，由于render中的h函数有几种情况：数组，对象，单个字符串三种形式，不能按照同一个情况处理。所以编写了normalizeVNode方法，在数组的时候用Fragment包裹起来，对象就直接返回，字符串就用文本包裹起来。</p><p>组件挂载生成的节点叫做subTree。</p><p>先前遗留的attrs继承问题，用fallThrough方法来解决。vue中应该是通过代理的方式。</p><p>之后介绍了组件的更新，分为主动更新和被动更新，主动更新是拿到之前的subTree然后对比更新，被动更新是因为父组件重新render的时候，子组件的props改变了，导致子组件被动更新。最后是卸载。</p><p>下一节将讲述scheduler部分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的mini-vue⑤--最长上升子序列篇</title>
    <link href="https://zlinni.github.io/posts/2778725059/"/>
    <id>https://zlinni.github.io/posts/2778725059/</id>
    <published>2022-06-11T01:57:31.000Z</published>
    <updated>2022-06-12T02:23:35.980Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是最长上升子序列 篇，是关于 Vue3 中 LIS 的深入讨论。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220612100818.png" alt=""></p><h1 id="LIS"><a href="#LIS" class="headerlink" title="LIS"></a>LIS</h1><p>Longest Increasing Subsequence 最长上升子序列。是指一个序列中最长的单调递增的子序列。</p><p>我们可以拿 leetcode 的题作为例子来编写：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220611154750.png" alt=""></p><h2 id="dp-O-n²"><a href="#dp-O-n²" class="headerlink" title="dp O(n²)"></a>dp O(n²)</h2><p>例子：<br><code>nums=[10,9,2,5,3,7,101,18]</code><br>dp 的思路如下:</p><p>初始化 dp 为 1 <code>dp=[1,1,1,1,1,1,1,1]</code>，然后循环比对前面的，只要它大于了前面的数就把下标置为前面的数的最大长度+1，当然这个过程还要比较和自身的大小，如果自身更大取自身.最后返回最大值</p><p>过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">9</span> <span class="number">2</span> <span class="number">5</span> <span class="number">3</span> <span class="number">7</span> <span class="number">101</span> <span class="number">18</span></span><br><span class="line"> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span>   <span class="number">4</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 最小是1</span></span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length).fill(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 比对前面的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        <span class="comment">// 取最大的</span></span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max = <span class="built_in">Math</span>.max(dp[i], max);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="贪心-O-n²"><a href="#贪心-O-n²" class="headerlink" title="贪心 O(n²)"></a>贪心 O(n²)</h2><p>这个算法的核心是看最大的数然后更新</p><p>例子：<br><code>nums=[10,9,2,5,3,7,101,18,1]</code></p><p>过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">9</span> <span class="number">2</span> <span class="number">5</span> <span class="number">101</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">init</span><br><span class="line">arr <span class="number">10</span></span><br><span class="line"><span class="number">9</span>&lt;<span class="number">10</span> replace</span><br><span class="line">arr <span class="number">9</span></span><br><span class="line"><span class="number">2</span>&lt;<span class="number">9</span> replace</span><br><span class="line">arr <span class="number">2</span></span><br><span class="line"><span class="number">5</span>&gt;<span class="number">2</span> add</span><br><span class="line">arr <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">101</span>&gt;<span class="number">5</span> add</span><br><span class="line">arr <span class="number">2</span> <span class="number">5</span> <span class="number">101</span></span><br><span class="line"><span class="number">3</span>&lt;<span class="number">101</span> but <span class="number">3</span>&gt;<span class="number">2</span> <span class="number">3</span>&lt;<span class="number">5</span>(find first num bigger than <span class="built_in">this</span>) replace</span><br><span class="line">arr <span class="number">2</span> <span class="number">3</span> <span class="number">101</span></span><br><span class="line"><span class="number">7</span>&lt;<span class="number">101</span> replace</span><br><span class="line">arr <span class="number">2</span> <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="number">18</span>&gt;<span class="number">7</span> add</span><br><span class="line">arr <span class="number">2</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span></span><br><span class="line"><span class="number">1</span>&lt;<span class="number">18</span> but <span class="number">1</span>&lt;<span class="number">2</span> replace</span><br><span class="line">arr <span class="number">1</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span></span><br><span class="line"><span class="attr">answer</span>:<span class="number">4</span></span><br></pre></td></tr></table></figure><p>所以我们可以知道，当他小于目标数组 arr 中末尾的数字的时候从头判断找到第一个比他大的数字执行替换的操作，大于的时候执行新增操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [nums[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt;= arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= arr[j]) &#123;</span><br><span class="line">          arr[j] = nums[i];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr.push(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="贪心-二分-O-nlogn"><a href="#贪心-二分-O-nlogn" class="headerlink" title="贪心+二分 O(nlogn)"></a>贪心+二分 O(nlogn)</h2><p>我们可以发现，在查找的过程中该数组是一个有序数组，所以我们可以用二分查找进行优化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [nums[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt;= arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">let</span> l = <span class="number">0</span>,</span><br><span class="line">        r = arr.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = ~~((l + r) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; arr[mid]) &#123;</span><br><span class="line">          l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; arr[mid]) &#123;</span><br><span class="line">          r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          l = mid;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[l] = nums[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr.push(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="position-形成-LIS-的集合"><a href="#position-形成-LIS-的集合" class="headerlink" title="position 形成 LIS 的集合"></a>position 形成 LIS 的集合</h2><p>我们真正需要做的实际上是生成一个带有原数据中对应下标的 LIS 的 seq 数组，而不是长度。所以我们应该先找到这一部分的 LIS，但为了找到这一部分的 LIS,我们又需要查看全部的元素的位置是否满足 LIS，举例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num <span class="number">10</span> <span class="number">9</span> <span class="number">2</span> <span class="number">5</span> <span class="number">101</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span> <span class="number">1</span></span><br><span class="line">pos  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>   <span class="number">2</span> <span class="number">1</span> <span class="number">2</span>  <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="comment">// 得到</span></span><br><span class="line">ans      <span class="number">2</span>       <span class="number">3</span> <span class="number">7</span> <span class="number">18</span></span><br></pre></td></tr></table></figure><p>如果我们有这么一个 pos 数组告诉我们具体的 LIS 下标，我们是不是就能很轻易得到对应的 LIS 元素了。</p><p>所以以这个出发去编写 pos 数组，它的过程如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">num <span class="number">10</span> <span class="number">9</span> <span class="number">2</span> <span class="number">5</span> <span class="number">101</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">init</span><br><span class="line">arr <span class="number">10</span></span><br><span class="line">pos <span class="number">0</span></span><br><span class="line"><span class="number">9</span>&lt;<span class="number">10</span> replace <span class="number">10.</span>index</span><br><span class="line">arr <span class="number">9</span></span><br><span class="line">pos <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span>&lt;<span class="number">9</span> replace <span class="number">9.</span>index</span><br><span class="line">arr <span class="number">2</span></span><br><span class="line">pos <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">5</span>&gt;<span class="number">2</span> add len-<span class="number">1</span></span><br><span class="line">arr <span class="number">2</span> <span class="number">5</span></span><br><span class="line">pos <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">101</span>&gt;<span class="number">5</span> add len-<span class="number">1</span></span><br><span class="line">arr <span class="number">2</span> <span class="number">5</span> <span class="number">101</span></span><br><span class="line">pos <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span>&lt;<span class="number">101</span> but <span class="number">3</span>&gt;<span class="number">2</span> <span class="number">3</span>&lt;<span class="number">5</span>(find first num bigger than <span class="built_in">this</span>) replace &amp;&amp; <span class="number">5.</span>index</span><br><span class="line">arr <span class="number">2</span> <span class="number">3</span> <span class="number">101</span></span><br><span class="line">pos <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">7</span>&lt;<span class="number">101</span> replace <span class="number">101.</span>index</span><br><span class="line">arr <span class="number">2</span> <span class="number">3</span> <span class="number">7</span></span><br><span class="line">pos <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">18</span>&gt;<span class="number">7</span> add len-<span class="number">1</span></span><br><span class="line">arr <span class="number">2</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span></span><br><span class="line">pos <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span>&lt;<span class="number">18</span> but <span class="number">1</span>&lt;<span class="number">2</span> replace <span class="number">2.</span>index</span><br><span class="line">arr <span class="number">1</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span></span><br><span class="line">pos <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">num <span class="number">10</span> <span class="number">9</span> <span class="number">2</span> <span class="number">5</span> <span class="number">101</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span> <span class="number">1</span></span><br><span class="line">idx  <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>   <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>  <span class="number">7</span> <span class="number">8</span></span><br><span class="line">pos  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>   <span class="number">2</span> <span class="number">1</span> <span class="number">2</span>  <span class="number">3</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">ans      <span class="number">2</span>       <span class="number">3</span> <span class="number">7</span> <span class="number">18</span></span><br><span class="line">idx      <span class="number">2</span>       <span class="number">5</span> <span class="number">6</span>  <span class="number">7</span></span><br><span class="line"><span class="attr">answerIdx</span>:[<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><p>所以我们需要做的是，在每次 arr 进行 add 操作的时候，pos 就把 arr 的长度-1 放进来；在每次执行 replace 操作的时候，把二分查找替换的 l 传进来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [nums[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">const</span> pos = [<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt;= arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">let</span> l = <span class="number">0</span>,</span><br><span class="line">        r = arr.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = ~~((l + r) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; arr[mid]) &#123;</span><br><span class="line">          l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; arr[mid]) &#123;</span><br><span class="line">          r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          l = mid;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[l] = nums[i];</span><br><span class="line">      pos.push(l);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr.push(nums[i]);</span><br><span class="line">      pos.push(arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过我们在操作到这里的时候，只是得到了一个下标集合，刚才的 answerIdx 是我们自己判断出来的，接下来我们就实现 answerIdx 这一步</p><h2 id="cur-得到-seq"><a href="#cur-得到-seq" class="headerlink" title="cur 得到 seq"></a>cur 得到 seq</h2><p>answerIdx 这一步，是将 pos 中的 LIS 转为了对应的 idx。我们仔细观察可以发现，其实 pos 的长度是和 idx 一样的，因为它就是全部元素形成 LIS 的一个集合，而我们又发现也得到 arr 了，arr 的长度-1 就是 pos 中最大的元素，所以我们不妨设置一个变量 cur，让他等于 arr 的最大长度-1，此时我们只要从后往前遍历 pos，当 cur 和 pos 的数据是一样的时候，就说明这个数据是不用移动的，就可以把 pos 中对应的下标加入到 seq 数组中。然后又因为我们这个 arr 其实是不会再用到的了，所以可以直接复用 arr。下面来演示这个过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">num <span class="number">10</span> <span class="number">9</span> <span class="number">2</span> <span class="number">5</span> <span class="number">101</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 已知</span></span><br><span class="line">num <span class="number">10</span> <span class="number">9</span> <span class="number">2</span> <span class="number">5</span> <span class="number">101</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span> <span class="number">1</span></span><br><span class="line">idx <span class="number">0</span>  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>   <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>  <span class="number">8</span></span><br><span class="line">arr <span class="number">1</span>  <span class="number">3</span> <span class="number">7</span> <span class="number">18</span></span><br><span class="line">pos <span class="number">0</span>  <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span>   <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>  <span class="number">0</span></span><br><span class="line">cur <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从后往前遍历pos</span></span><br><span class="line">pos <span class="number">0</span></span><br><span class="line">pos <span class="number">3</span> cur-- arr[<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">7</span>]</span><br><span class="line">pos <span class="number">2</span> cur-- arr[<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">pos <span class="number">1</span> cur-- arr[<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">...</span><br><span class="line">pos <span class="number">0</span> cur-- arr[<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">cur=-<span class="number">1</span> stop</span><br><span class="line"></span><br><span class="line"><span class="attr">arr</span>:   [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"><span class="attr">answer</span>:[<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">18</span>]</span><br></pre></td></tr></table></figure><p>这样就获得了这个 seq 数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [nums[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">const</span> pos = [<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt;= arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">let</span> l = <span class="number">0</span>,</span><br><span class="line">        r = arr.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = ~~((l + r) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; arr[mid]) &#123;</span><br><span class="line">          l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; arr[mid]) &#123;</span><br><span class="line">          r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          l = mid;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[l] = nums[i];</span><br><span class="line">      pos.push(l);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr.push(nums[i]);</span><br><span class="line">      pos.push(arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> cur = arr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = pos.length - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; cur &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur === pos[i]) &#123;</span><br><span class="line">      arr[cur--] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="source"><a href="#source" class="headerlink" title="source"></a>source</h2><p>我们之前说过 source 为-1 的时候是直接更新，所以我们也应该在算法里面移除-1 的考虑</p><p>最后全部代码为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSequence</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [nums[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">const</span> pos = [<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] === -<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt;= arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">let</span> l = <span class="number">0</span>,</span><br><span class="line">        r = arr.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = ~~((l + r) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; arr[mid]) &#123;</span><br><span class="line">          l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; arr[mid]) &#123;</span><br><span class="line">          r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          l = mid;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[l] = nums[i];</span><br><span class="line">      pos.push(l);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr.push(nums[i]);</span><br><span class="line">      pos.push(arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> cur = arr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = pos.length - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; cur &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur === pos[i]) &#123;</span><br><span class="line">      arr[cur--] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>最后回到本源，我们要给 vnode 添加一个 key 属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  type,</span><br><span class="line">  props,</span><br><span class="line">  children,</span><br><span class="line">  shapeFlag,</span><br><span class="line">  <span class="attr">el</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">anchor</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">key</span>: props &amp;&amp; props.key,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外在 patchProps 里面也要注意 key 的判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除旧属性有的，新属性没有的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">  <span class="comment">// 当前属性是 &#x27;key&#x27; 则跳过</span></span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">&quot;key&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newProps[key] == <span class="literal">null</span>) &#123;</span><br><span class="line">    patchDomProp(oldProps[key], <span class="literal">null</span>, key, el);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加旧属性没有的，新属性有的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">&quot;key&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldProps[key] !== newProps[key]) &#123;</span><br><span class="line">    patchDomProp(oldProps[key], newProps[key], key, el);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本节中我们以 leetcode 为例学习了 LIS 算法的核心原理，使用 dp，贪心去实现，然后又通过二分优化了查找过程，后面我们发现我们需要的是实际的元素而不是下标，就采用了 pos 数组帮助我们得到了形成 LIS 的集合，再设置 cur 并复用 arr 得到我们的 seq 数组。下节我们将介绍组件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的mini-vue③--patch篇</title>
    <link href="https://zlinni.github.io/posts/2046694271/"/>
    <id>https://zlinni.github.io/posts/2046694271/</id>
    <published>2022-06-10T08:15:01.000Z</published>
    <updated>2022-06-19T06:55:05.270Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是patch 篇，是关于 Vue3 中 patch 的基本理解和实践。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/patch222.png" alt=""></p><h1 id="patch的介绍"><a href="#patch的介绍" class="headerlink" title="patch的介绍"></a>patch的介绍</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/patch.png" alt=""></p><p><code>patch</code> 是对比新旧节点的算法，当新节点不存在的时候，执行卸载操作，当新节点存在的时候，进行对比</p><p>卸载操作需要判断对应节点的类型，如果是组件执行组件的卸载，如果是 <code>Fragment</code> 执行 <code>Fragment</code> 的卸载，最后到 <code>Text</code> 和 <code>Element</code> 执行 <code>removeChild</code></p><p><code>patch</code> 操作需要判断新旧节点的类型是否相同，不同的话就要卸载旧的节点将原有的节点树完全卸载掉。</p><p>然后再判断新节点<br>新节点是否是组件，如果是则进行 <code>processComponent</code>；</p><p>新节点如果是 <code>Text</code> 类型，执行 <code>processText</code>。之后再来判断旧节点是否存在，如果存在说明之前已经创建过旧的文本内容了，直接复用这个文本节点，更新他的 <code>textContent</code>，如果不存在旧节点，直接使用 <code>mountTextNode</code> 挂载文本节点</p><p>新节点如果是 <code>Fragment</code> 类型，就执行 <code>processFragment</code>，如果此时旧节点不存在，直接使用 <code>mountChildren</code>，如果旧节点存在就要进行 <code>diff</code></p><p>新节点最后就判断为 <code>Element</code> 类型，执行 <code>processElement</code>。之后来判断旧节点是否存在，如果不存在，直接使用 <code>mountElement</code> 对新节点进行挂载。如果存在，则要对他进行 <code>diff</code> 操作了。</p><p>因为此时新旧节点的 <code>type</code> 一样，就直接复用 <code>type</code>，只要对 <code>props</code> 和 <code>children</code> 进行 <code>diff</code></p><p>分析完了之后就开始准备写新的 <code>render</code> 函数了</p><h1 id="render"><a href="#render" class="headerlink" title="render"></a>render</h1><p>我们之前的 <code>render</code> 是挂载了一个节点，怎么才能产生新旧节点呢？</p><p>实际上我们只要将 <code>vnode</code> 挂载在 <code>container</code> 上面，下次进入的时候获取 <code>container</code> 上面的 <code>vnode</code>，此时这个 <code>vnode</code> 就是旧节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prevNode = container._vnode;</span><br><span class="line">  container._vnode = vnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来进行判断了，我们首先判断新节点存不存在。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prevNode = container._vnode;</span><br><span class="line">  <span class="keyword">if</span> (!vnode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevNode) &#123;</span><br><span class="line">      unmount(prevNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    patch(prevNode, vnode, container);</span><br><span class="line">  &#125;</span><br><span class="line">  container._vnode = vnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就要编写 <code>unmount</code> 和 <code>patch</code></p><h2 id="unmount"><a href="#unmount" class="headerlink" title="unmount"></a>unmount</h2><p>前面的情况就是利用 shapeflag 判断组件的卸载或 <code>fragment</code> 的卸载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params">vnode</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;shapeFlag,el&#125; = vnode;</span><br><span class="line">    <span class="keyword">if</span>(shapeFlag&amp;ShapeFlags.COMPONENT)&#123;</span><br><span class="line">        unmountComponent(vnode)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shapeFlag&amp;ShapeFlags.FRAGMENT)&#123;</span><br><span class="line">        unmountFragment(vnode)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      ...?</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们发现最后一种情况：对 <code>Text</code> 或 <code>Element</code> 进行 <code>removeChild</code> 的时候，没有获取到具体的 el，所以我们要从 <code>vnode</code> 里面拿 el，也就是要在 <code>vnode</code> 的返回值里面添加一个 el</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  type,</span><br><span class="line">  props,</span><br><span class="line">  children,</span><br><span class="line">  shapeFlag,</span><br><span class="line">  <span class="attr">el</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>且在挂载 <code>element</code> 和 <code>textnode</code> 之后需要将 el 挂载到 <code>vnode</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountElement</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出元素 挂载元素 挂载props children</span></span><br><span class="line">  <span class="keyword">const</span> &#123; type, props &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">  <span class="comment">// 将props挂载到el上</span></span><br><span class="line">  mountProps(props, el);</span><br><span class="line">  <span class="comment">// 把节点挂载到el上</span></span><br><span class="line">  mountChildren(vnode, el);</span><br><span class="line">  container.appendChild(el);</span><br><span class="line">  <span class="comment">// 保存el</span></span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountTextNode</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(vnode.children);</span><br><span class="line">  container.appendChild(textNode);</span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以现在最后一种情况应该这样写了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag, el &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.COMPONENT) &#123;</span><br><span class="line">    unmountComponent(vnode);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.FRAGMENT) &#123;</span><br><span class="line">    unmountFragment(vnode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其次是Text或者Element 但要拿到child节点</span></span><br><span class="line">    <span class="comment">// 所以要在vnode里面初始化一个el</span></span><br><span class="line">    el.parentNode.removeChild(el);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>接下来是实现 <code>patch</code> 的部分，要通过他判断新旧节点的类型是否相同，设置一个函数。然后分情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">prevVNode, vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode &amp;&amp; !isSameVNode(prevVNode, vnode)) &#123;</span><br><span class="line">    unmount(prevVNode);</span><br><span class="line">    <span class="comment">// 注意卸载之后要将节点设置为null</span></span><br><span class="line">    prevVNode = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.COMPONENT) &#123;</span><br><span class="line">    processComponent(prevVNode, vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT) &#123;</span><br><span class="line">    processText(prevVNode, vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.FRAGMENT) &#123;</span><br><span class="line">    processFragment(prevVNode, vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    processElement(prevVNode, vnode, container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSameVNode</span>(<span class="params">prevVNode, vnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prevVNode.type === vnode.type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后要处理剩下的四个函数 <code>processComponent，processText，processFragment，processElement</code></p><h3 id="processText"><a href="#processText" class="headerlink" title="processText"></a>processText</h3><p>存在旧节点的时候，复用旧节点的 <code>textContent</code>。否则执行 <code>mountTextNode</code>，这个前面也写过了。直接 cv 即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processText</span>(<span class="params">prevVNode, vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    vnode.el = prevVNode.el;</span><br><span class="line">    prevVNode.el.textContent = vnode.children;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountTextNode(vnode, container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountTextNode</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(vnode.children);</span><br><span class="line">  container.appendChild(textNode);</span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="processElement"><a href="#processElement" class="headerlink" title="processElement"></a>processElement</h3><p>对于存在旧节点的情况下调用 <code>patchElement</code> 进行 <code>diff</code> 比较，不存在的情况则调用原先写过的 <code>mountElement</code> 进行挂载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processElement</span>(<span class="params">prevVNode, vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    patchElement(prevVNode, vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountElement(vnode, container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的一点是 <code>mountChildren</code> 中我们之前是没有实现 <code>mount</code> 的，其实在这里用 <code>patch</code> 实现即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountChildren</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag, children &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">    mountTextNode(vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    <span class="comment">// 递归调用挂载</span></span><br><span class="line">    children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">      patch(<span class="literal">null</span>, child, container);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外就是 <code>patchElement</code>，因为此时新旧节点的 <code>type</code> 都是一样的，所以将旧节点的 el 赋值给新节点的 el，然后对比它们之间的 <code>props</code> 和 <code>children</code> 的异同。</p><h4 id="patchProps"><a href="#patchProps" class="headerlink" title="patchProps"></a>patchProps</h4><p>其中包含了两个函数一个是 <code>patchProps</code> 一个是 <code>patchChildren</code></p><p>对于 <code>patchProps</code>，回顾一下 <code>props</code> 的内容,他是一个对象里面有很多属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">class</span>: <span class="string">&#x27;a b&#x27;</span>,</span><br><span class="line">  <span class="attr">style</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    <span class="attr">fontSize</span>: <span class="string">&#x27;14px&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>),</span><br><span class="line">  <span class="attr">checked</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">custom</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们对于新旧节点的 <code>props</code>，需要取出对应的 <code>value</code> 值，对比是否相同，如果相同我们才去进行重新赋值。并且我们还要遍历旧属性，移除旧属性中有的，新属性中没有的。遍历新属性，添加旧属性没有的新属性有的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchProps</span>(<span class="params">oldProps, newProps, el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (oldProps === newProps) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 防止传过来的props是空 注意这里没有用到es6赋默认值的写法是因为他有可能传递的是null，es6默认值只能处理undefined的情况</span></span><br><span class="line">  oldProps = oldProps || &#123;&#125;;</span><br><span class="line">  newProps = newProps || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除旧属性有的，新属性没有的</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">    <span class="comment">// 当前属性是 &#x27;key&#x27; 则跳过</span></span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&quot;key&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newProps[key] == <span class="literal">null</span>) &#123;</span><br><span class="line">      patchDomProp(oldProps[key], <span class="literal">null</span>, key, el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加旧属性没有的，新属性有的</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&quot;key&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldProps[key] !== newProps[key]) &#123;</span><br><span class="line">      patchDomProp(oldProps[key], newProps[key], key, el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="patchDomProp"><a href="#patchDomProp" class="headerlink" title="patchDomProp"></a>patchDomProp</h5><p><code>patchDomProp</code> 这一步操作和我们之前写的 <code>mountProps</code> 有点类似。不过有几个细节要注意：</p><p>如果 <code>next</code> 是 <code>false</code> 或者是 <code>null</code> 的话，他就会变成字符串，而不是去掉，我们希望的是去掉。所以要写<code>el.className = next || &#39;&#39;</code></p><p>如果新旧属性中的 <code>style</code> 有不一致的，我们添加新的 <code>styleName</code>，移除不需要的 <code>styleName</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next为空直接移除</span></span><br><span class="line"><span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">  el.removeAttribute(<span class="string">&quot;style&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 我们添加新的 styleName</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> styleName <span class="keyword">in</span> next) &#123;</span><br><span class="line">    el.style[styleName] = next[styleName];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除不需要的 `styleName`。</span></span><br><span class="line">  <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> styleName <span class="keyword">in</span> prev) &#123;</span><br><span class="line">      <span class="keyword">if</span> (next[styleName] == <span class="literal">null</span>) &#123;</span><br><span class="line">        el.style[styleName] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果事件中存在旧事件，移除旧事件，如果存在新事件，添加新事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="regexp">/^on[^a-z]/</span>.test(key)) &#123;</span><br><span class="line">  <span class="keyword">const</span> eventName = key.slice(<span class="number">2</span>).toLowerCase();</span><br><span class="line">  <span class="comment">// 移除旧事件</span></span><br><span class="line">  <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">    el.removeEventListener(eventName, prev);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加新事件</span></span><br><span class="line">  <span class="keyword">if</span> (next) &#123;</span><br><span class="line">    el.addEventListener(eventName, next);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line">  <span class="comment">// 如果是class 直接赋className</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;class&quot;</span>:</span><br><span class="line">    el.className = next;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">// 如果是style 遍历赋值value值</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;style&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> styleName <span class="keyword">in</span> next) &#123;</span><br><span class="line">      el.style[styleName] = next[styleName];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> styleName <span class="keyword">in</span> prev) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next[styleName] == <span class="literal">null</span>) &#123;</span><br><span class="line">          el.style[styleName] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">// 如果是事件，正则匹配on开头，并将后面的转为小写单词 然后添加事件</span></span><br><span class="line">  <span class="comment">// 如果是别的属性，分类判断，不能统一设置attribute</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^on[^a-z]/</span>.test(key)) &#123;</span><br><span class="line">      <span class="keyword">const</span> eventName = key.slice(<span class="number">2</span>).toLowerCase();</span><br><span class="line">      <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">        el.removeEventListener(eventName, prev);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (next) &#123;</span><br><span class="line">        el.addEventListener(eventName, next);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (domPropsRE.test(key)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (next === <span class="string">&quot;&quot;</span> || isBoolean(el[key])) &#123;</span><br><span class="line">        next = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      el[key] = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (next == <span class="literal">null</span> || next === <span class="literal">false</span>) &#123;</span><br><span class="line">        el.removeAttribute(key);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el.setAttribute(key, next);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意此时我们已经可以利用 <code>patchProps</code> 取代 <code>mountProps</code> 了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountElement</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出元素 挂载元素 挂载props children</span></span><br><span class="line">  <span class="keyword">const</span> &#123; type, props &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">  <span class="comment">// 将props挂载到el上</span></span><br><span class="line">  <span class="comment">// mountProps(props, el);</span></span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    patchProps(<span class="literal">null</span>, props, el);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把节点挂载到el上</span></span><br><span class="line">  mountChildren(vnode, el);</span><br><span class="line">  container.appendChild(el);</span><br><span class="line">  <span class="comment">// 保存el</span></span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="patchChildren"><a href="#patchChildren" class="headerlink" title="patchChildren"></a>patchChildren</h4><p>我们重新修改一下 <code>mountChildren</code>，让他的职责更加单一</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountElement</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出元素 挂载元素 挂载props children</span></span><br><span class="line">  <span class="keyword">const</span> &#123; type, props, shapeFlag, children &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">  <span class="comment">// 将props挂载到el上</span></span><br><span class="line">  <span class="comment">// mountProps(props, el);</span></span><br><span class="line">  patchProps(<span class="literal">null</span>, props, el);</span><br><span class="line">  <span class="comment">// 把节点挂载到el上</span></span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">    mountTextNode(vnode, el);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    mountChildren(children, el);</span><br><span class="line">  &#125;</span><br><span class="line">  container.appendChild(el);</span><br><span class="line">  <span class="comment">// 保存el</span></span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountChildren</span>(<span class="params">children, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归调用挂载</span></span><br><span class="line">  children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">    patch(<span class="literal">null</span>, child, container);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后开始写 <code>patchChildren</code>，这一部分中，我们需要对九种情况进行判断<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/patchChildren.jpg" alt=""></p><p>简单写一下模板大致如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchChildren</span>(<span class="params">prevVNode, vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">shapeFlag</span>: prevShapeFlag, <span class="attr">children</span>: c1 &#125; = prevVNode;</span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag, <span class="attr">children</span>: c2 &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">      container.textContent = c2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      unmountChildren(c1);</span><br><span class="line">      container.textContent = c2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      container.textContent = c2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">      container.textContent = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      mountChildren(c2, container);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      patchArrayChildren(c1, c2, container);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mountChildren(c2, container);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">      container.textContent = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      unmountChildren(c1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时剩下的 <code>unmountChildren</code> 和 <code>patchArrayChildren</code> 两个函数暂未实现，但是我们发现可以对这个模板做一个合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    unmountChildren(c1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c1 !== c2) &#123;</span><br><span class="line">    container.textContent = c2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面一段是 vue 源码的合并结构，虽然简介但是还是分情况比较好理解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    unmountChildren(c1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c2 !== c1) &#123;</span><br><span class="line">    container.textContent = c2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// c2 is array or null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    <span class="comment">// c1 was array</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      <span class="comment">// c2 is array</span></span><br><span class="line">      <span class="comment">// patchArrayChildren()</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// c2 is null</span></span><br><span class="line">      unmountChildren(c1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// c1 was text or null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">      container.textContent = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      mountChildren(c2, container, anchor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们编写 <code>unmountChildren</code>，其实他也就是遍历 <code>children</code> 然后卸载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unmountChildren</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">    unmount(child);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就到了 <code>patchArrayChildren</code>，这个部分</p><h5 id="patchArrayChildren"><a href="#patchArrayChildren" class="headerlink" title="patchArrayChildren"></a>patchArrayChildren</h5><p>举个例子，我们看他如何实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> n1 = h(<span class="string">&quot;ul&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">  h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;a&quot;</span>),</span><br><span class="line">  h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;b&quot;</span>),</span><br><span class="line">  h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;c&quot;</span>),</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> n2 = h(<span class="string">&quot;ul&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">  h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;d&quot;</span>),</span><br><span class="line">  h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;e&quot;</span>),</span><br><span class="line">  h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;f&quot;</span>),</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><blockquote><p>c1: a b c<br>c2: d e f</p><p>c1: a b c<br>c2: d e f g h</p><p>c1: a b c g h<br>c2: d e f</p></blockquote><p>对比新旧孩子，如果长度相同则执行 <code>patch</code> 对比，如果新孩子比旧孩子长则挂载新孩子多出来的部分，如果旧孩子比新孩子长则删除旧孩子多出来的部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchArrayChildren</span>(<span class="params">c1, c2, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldLength = c1.length;</span><br><span class="line">  <span class="keyword">const</span> newLength = c2.length;</span><br><span class="line">  <span class="keyword">const</span> commonLength = <span class="built_in">Math</span>.min(oldLength, newLength);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; commonLength; i++) &#123;</span><br><span class="line">    patch(c1[i], c2[i], container);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (oldLength &gt; newLength) &#123;</span><br><span class="line">    unmountChildren(c1.slice(commonLength));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldLength &lt; newLength) &#123;</span><br><span class="line">    mountChildren(c2.slice(commonLength), container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是处理 <code>processFragment</code> 了</p><h3 id="processFragment"><a href="#processFragment" class="headerlink" title="processFragment"></a>processFragment</h3><p>旧节点存在的时候对比新旧的孩子，不存在时候直接挂载新节点的孩子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processFragment</span>(<span class="params">prevVNode, vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    patchChildren(prevVNode, vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountChildren(vnode.children, container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render, Fragment, h &#125; <span class="keyword">from</span> <span class="string">&quot;./runtime&quot;</span>;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  h(<span class="string">&quot;ul&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;first&quot;</span>),</span><br><span class="line">    h(Fragment, <span class="literal">null</span>, []),</span><br><span class="line">    h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;last&quot;</span>),</span><br><span class="line">  ]),</span><br><span class="line">  <span class="built_in">document</span>.body</span><br><span class="line">);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  render(</span><br><span class="line">    h(<span class="string">&quot;ul&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">      h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;first&quot;</span>),</span><br><span class="line">      h(Fragment, <span class="literal">null</span>, [h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;middle&quot;</span>)]),</span><br><span class="line">      h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;last&quot;</span>),</span><br><span class="line">    ]),</span><br><span class="line">    <span class="built_in">document</span>.body</span><br><span class="line">  );</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>我们跑这个例子之前，知道这个 <code>Fragment</code> 节点应该是 2s 加入到 first 和 last 中间的，而实际的结果却是他到了最后面。</p><p>我们先分析一下原因：首先 <code>patch</code> 新旧节点，它们类型是相同的，是 <code>Fragment</code>，则进入 <code>processFragment</code>。此时旧节点不存在，执行 <code>mountChildren</code>，然后执行 <code>patch</code>，传的值是<code>(null, child, container)</code>，到 <code>patch</code>，此时孩子是一个元素节点，所以执行 <code>processElement</code>。之后 <code>mountElement</code>。</p><p>这一步就是问题所在了，<code>mountElement</code> 中，我们的 el 是直接挂载到 <code>container</code> 中的，也就是<code>container.appendChild(el);</code>代码。所以他被加到了最后面</p><p>为了解决这个问题我们要使用 <code>anchor</code> 属性。</p><h4 id="Anchor"><a href="#Anchor" class="headerlink" title="Anchor"></a>Anchor</h4><p><code>anchor</code> 属性和 el 类似，因为 <code>Fragment</code> 节点之前挂载到的是容器，所以我们不知道应该在何处插入或者删除我们的 <code>Fragment</code> 节点，就要使用 el 和 <code>anchor</code> 生成节点然后就可以在这两个节点中间插入 <code>Fragment</code>。</p><p>所以我们要在 <code>vnode</code> 返回值里面添加 <code>anchor</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  type,</span><br><span class="line">  props,</span><br><span class="line">  children,</span><br><span class="line">  shapeFlag,</span><br><span class="line">  <span class="attr">el</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">anchor</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后重新写一下 <code>processFragment</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processFragment</span>(<span class="params">prevVNode, vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果旧节点的el存在就复用，anchor也是一样</span></span><br><span class="line">  <span class="keyword">const</span> fragmentStartAnchor = (vnode.el = prevVNode</span><br><span class="line">    ? prevVNode.el</span><br><span class="line">    : <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>));</span><br><span class="line">  <span class="keyword">const</span> fragmentEndAnchor = (vnode.anchor = prevVNode</span><br><span class="line">    ? prevVNode.anchor</span><br><span class="line">    : <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    patchChildren(prevVNode, vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    container.appendChild(fragmentStartAnchor);</span><br><span class="line">    container.appendChild(fragmentEndAnchor);</span><br><span class="line">    <span class="comment">// 传递anchor</span></span><br><span class="line">    mountChildren(vnode.children, container, fragmentEndAnchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，就需要在后续的地方增加 <code>anchor</code> 属性了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountChildren</span>(<span class="params">children, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归调用挂载</span></span><br><span class="line">  children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">    patch(<span class="literal">null</span>, child, container,anchor);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">prevVNode, vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode &amp;&amp; !isSameVNode(prevVNode,vnode)) &#123;</span><br><span class="line">    unmount(prevVNode);</span><br><span class="line">    prevVNode = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    shapeFlag</span><br><span class="line">  &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.COMPONENT) &#123;</span><br><span class="line">    processComponent(prevVNode, vnode, container,anchor);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT) &#123;</span><br><span class="line">    processText(prevVNode, vnode, container,anchor);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.FRAGMENT) &#123;</span><br><span class="line">    processFragment(prevVNode, vnode, container,anchor);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    processElement(prevVNode, vnode, container,anchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processElement</span>(<span class="params">prevVNode, vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    patchElement(prevVNode, vnode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountElement(vnode, container,anchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountElement</span>(<span class="params">vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出元素 挂载元素 挂载props children</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    props,</span><br><span class="line">    shapeFlag,</span><br><span class="line">    children</span><br><span class="line">  &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">  <span class="comment">// 将props挂载到el上</span></span><br><span class="line">  <span class="comment">// mountProps(props, el);</span></span><br><span class="line">  patchProps(<span class="literal">null</span>, props, el);</span><br><span class="line">  <span class="comment">// 把节点挂载到el上</span></span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">    mountTextNode(vnode, el);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    mountChildren(children, el);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// container.appendChild(el);</span></span><br><span class="line">  container.insertBefore(el,anchor);</span><br><span class="line">  <span class="comment">// 保存el</span></span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processText</span>(<span class="params">prevVNode, vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    vnode.el = prevVNode.el;</span><br><span class="line">    prevVNode.el.textContent = vnode.children;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountTextNode(vnode, container,anchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountTextNode</span>(<span class="params">vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(vnode.children);</span><br><span class="line">  <span class="comment">// container.appendChild(textNode);</span></span><br><span class="line">  container.insertBefore(textNode,anchor);</span><br><span class="line">  vnode.el = textNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processFragment</span>(<span class="params">prevVNode, vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fragmentStartAnchor = vnode.el = prevVNode ? prevVNode.el : <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> fragmentEndAnchor = vnode.anchor = prevVNode ? prevVNode.anchor : <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    <span class="comment">// 用fragmentEndAnchor作为他的anchor</span></span><br><span class="line">    patchChildren(prevVNode, vnode, container,fragmentEndAnchor);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 此处也要insertuu</span></span><br><span class="line">    container.insertBefore(fragmentStartAnchor,anchor)</span><br><span class="line">    container.insertBefore(fragmentEndAnchor,anchor)</span><br><span class="line">    mountChildren(vnode.children, container,fragmentEndAnchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>总之在需要 <code>anchor</code> 的节点都需要添加 <code>anchor</code> 属性，并且最后的时候需要替换 <code>appendChild</code> 为 <code>insertBefore</code></p><p>之后我们编写遗留的 <code>unmountFragment</code>，这个函数本身我们可以用 <code>unmountChildren</code> 的形式来写，但是现在由于添加了 el 和 <code>anchor</code> 两个文本节点，所以我们要换种方式了。</p><p>思路大概就是将他们循环删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unmountFragment</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; <span class="attr">el</span>: cur, <span class="attr">anchor</span>: end &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> &#123; parentNode &#125; = cur;</span><br><span class="line">  <span class="keyword">while</span> (cur != end) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = cur.nextSibling;</span><br><span class="line">    parentNode.removeChild(cur);</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  parentNode.removeChild(end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时回去测试我们的用例，发现可以成功 <code>patch</code> 了。</p><p>最后还有一个小问题，就是关于 <code>patchArrayChildren</code> 里面的。我们看这么个例子</p><blockquote><p>h1, h1, h1<br>h1, h2, h1</p></blockquote><p>例如，对上面这个例子进行 <code>patchChildren</code> 第一次 <code>patch</code> 时，<code>n2.el = n1.el</code>，没有创建元素，<code>anchor</code> 没有用。 第二次 <code>patch</code> 时，先删除了 n1，对 n2 进行创建，执行 <code>insertBefore</code>，<code>anchor</code> 就需要设置为 <code>n1</code> 的下一个兄弟节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">prevVNode, vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode &amp;&amp; !isSameVNode(prevVNode,vnode)) &#123;</span><br><span class="line">    anchor = prevVNode.el.nextSibling;</span><br><span class="line">    unmount(prevVNode);</span><br><span class="line">    prevVNode = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果是</p><blockquote><p>n1, “” n1 “”,<br>n1 n1, n2, n1</p></blockquote><p>如果 <code>n1</code> 是 <code>Fragment</code>，那么 <code>anchor</code> 应该设置为 <code>n1</code> 的 <code>anchor</code> 的下一个兄弟节点。</p><p>所以不妨将两个情况合并为以下的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anchor = (prevVNode.anchor || prevVNode.el).nextSibling;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本节里，我们学习了patch算法简单的对新旧节点进行比对，然后根据对应的情况去挂载新节点或删除旧节点，后面又重新编写了render方法来对我们之前的操作做一些补充和修改。下节将进行核心diff算法的学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的mini-vue总集篇</title>
    <link href="https://zlinni.github.io/posts/3894586884/"/>
    <id>https://zlinni.github.io/posts/3894586884/</id>
    <published>2022-06-10T00:48:38.000Z</published>
    <updated>2022-06-19T07:35:04.044Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是总集篇，包含了 mini-vue 的全部基本实现，参见传送门内容</p></div><h1 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h1><h1 id="reactive篇"><a href="#reactive篇" class="headerlink" title="reactive篇"></a>reactive篇</h1><div class="note primary flat"><p><a href="https://zlinni.github.io/posts/3451170570">从零开始的mini-vue①—reactive篇</a></p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/reactivedaotu.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/computedandref.png" alt=""></p><h1 id="vnode篇"><a href="#vnode篇" class="headerlink" title="vnode篇"></a>vnode篇</h1><div class="note primary flat"><p><a href="https://zlinni.github.io/posts/2797606246">从零开始的mini-vue②—vnode篇</a></p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/虚拟DOM.png" alt=""></p><h1 id="patch篇"><a href="#patch篇" class="headerlink" title="patch篇"></a>patch篇</h1><div class="note primary flat"><p><a href="https://zlinni.github.io/posts/2046694271">从零开始的mini-vue③—patch篇</a></p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/patch222.png" alt=""></p><h1 id="核心diff篇"><a href="#核心diff篇" class="headerlink" title="核心diff篇"></a>核心diff篇</h1><div class="note primary flat"><p><a href="https://zlinni.github.io/posts/606001916">从零开始的mini-vue④—核心diff篇</a></p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/核心diff.png" alt=""></p><h1 id="最长上升子序列篇"><a href="#最长上升子序列篇" class="headerlink" title="最长上升子序列篇"></a>最长上升子序列篇</h1><div class="note primary flat"><p><a href="https://zlinni.github.io/posts/2778725059">从零开始的mini-vue⑤—最长上升子序列篇</a></p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220612100818.png" alt=""></p><h1 id="Component-篇"><a href="#Component-篇" class="headerlink" title="Component 篇"></a>Component 篇</h1><div class="note primary flat"><p><a href="https://zlinni.github.io/posts/1033180007">从零开始的mini-vue⑥—Component篇</a></p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/componentImage.png" alt=""></p><h1 id="Scheduler-篇"><a href="#Scheduler-篇" class="headerlink" title="Scheduler 篇"></a>Scheduler 篇</h1><div class="note primary flat"><p><a href="https://zlinni.github.io/posts/3541433463">从零开始的mini-vue⑦—Scheduler篇</a></p></div><h1 id="Compiler-篇"><a href="#Compiler-篇" class="headerlink" title="Compiler 篇"></a>Compiler 篇</h1><div class="note primary flat"><p><a href="https://zlinni.github.io/posts/2151465192">从零开始的mini-vue⑧—Compiler篇</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的mini-vue④--核心diff篇</title>
    <link href="https://zlinni.github.io/posts/606001916/"/>
    <id>https://zlinni.github.io/posts/606001916/</id>
    <published>2022-06-08T08:52:44.000Z</published>
    <updated>2022-06-13T13:43:15.587Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是核心 diff 篇，是关于 Vue3 中 patch 的深入讨论。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/核心diff.png" alt=""></p><h1 id="patchArrayChildren-的问题"><a href="#patchArrayChildren-的问题" class="headerlink" title="patchArrayChildren 的问题"></a>patchArrayChildren 的问题</h1><p>在上一节我们实现了<code>patchArrayChildren</code>，但是我们这个实现是比较简单粗暴的，直接对数组一对一进行的 diff 操作。</p><p>实际上它还是存在一些问题的，看下面的例子</p><blockquote><p>c1: a b c<br>c2: x a b c</p></blockquote><p>我们在新孩子头部插入了一个节点，很明显我们只要在 a 前面插入一个 x 即可。但是按照我们现在的做法，它需要每个都变化一次。</p><p>所以有没有办法解决这个问题？有的，就是要引入一个 key 去告诉框架什么节点是应该去复用的，从而减小操作虚拟 DOM 的次数</p><p>而我们前面实现的 patchArrayChildren 其实就是 patchUnkeyedChildren</p><p>这里先偷个懒 只要第一个元素有 key 就当作有 key</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">  <span class="comment">// 只要第一个元素有key就当作有key</span></span><br><span class="line">  <span class="keyword">if</span> (c1[<span class="number">0</span>] &amp;&amp; c1[<span class="number">0</span>].key != <span class="literal">null</span> &amp;&amp; c2[<span class="number">0</span>] &amp;&amp; c2[<span class="number">0</span>].key != <span class="literal">null</span>) &#123;</span><br><span class="line">    patchkeyedChildren(c1, c2, container, anchor);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    patchUnkeyedChildren(c1, c2, container, anchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="patchUnkeyedChildren"><a href="#patchUnkeyedChildren" class="headerlink" title="patchUnkeyedChildren"></a>patchUnkeyedChildren</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220608202141.png" alt=""></p><p>根据上面的图，我们先按最简单的方式去写 patchkeyedChildren，首先我们遍历新旧孩子，然后，找到 key 一致的新旧孩子去进行 patch。patch 之后再移动到新节点的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchkeyedChildren</span>(<span class="params">c1, c2, container, anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; c2.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 找c2</span></span><br><span class="line">    <span class="keyword">const</span> next = c2[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; c1.length; j++) &#123;</span><br><span class="line">      <span class="comment">// 找c1</span></span><br><span class="line">      <span class="keyword">const</span> prev = c1[i];</span><br><span class="line">      <span class="comment">// key相同 patch</span></span><br><span class="line">      <span class="keyword">if</span> (next.key === prev.key) &#123;</span><br><span class="line">        patch(prev, next, container, anchor);</span><br><span class="line">        <span class="comment">// 考虑anchor,此时我们patch之后要重新排列,所以c2的第一个是要放在c1的最前面的,</span></span><br><span class="line">        <span class="comment">// const curAnchor = c1[0].el;</span></span><br><span class="line">        <span class="comment">// 然后c2的第二个节点是要放在第一个节点后面,以此类推</span></span><br><span class="line">        <span class="comment">// const curAnchor = c2[i-1].el.nextSibling;</span></span><br><span class="line">        <span class="comment">// 所以对这两个情况进行合并</span></span><br><span class="line">        <span class="keyword">const</span> curAnchor = i === <span class="number">0</span> ? c1[<span class="number">0</span>].el : c2[i - <span class="number">1</span>].el.nextSibling;</span><br><span class="line">        <span class="comment">// 移动 insertBefore特性,如果此节点不存在,则进行移动操作,存在则插入</span></span><br><span class="line">        container.insertBefore(next.el, curAnchor);</span><br><span class="line">        <span class="comment">// 找到就break</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="maxNewIndexSoFar"><a href="#maxNewIndexSoFar" class="headerlink" title="maxNewIndexSoFar"></a>maxNewIndexSoFar</h2><p>进一步优化,因为上个版本不管顺序如何都会进行 insertBefore 操作.当他确实需要移动的时候我们才去移动</p><p>举例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c1 &gt; a b c</span><br><span class="line">c2 &gt; a c b</span><br><span class="line">maxNewIndexSoFar = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">a -- a c1 = <span class="number">0</span> = <span class="number">0</span> =&gt; maxNewIndexSoFar = <span class="number">0</span></span><br><span class="line">c -- c c1 = <span class="number">2</span> &gt; <span class="number">0</span> =&gt; update maxNewIndexSoFar = <span class="number">2</span></span><br><span class="line">b -- b c1 = <span class="number">1</span> &lt; <span class="number">2</span> =&gt; move b</span><br></pre></td></tr></table></figure><p>我们需要设置一个变量来记录 next 在 c1 中找到的最大值,如果小于这个值则移动大于或等于则更新这个值.这样就做到了有需要移动的时候才移动.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchkeyedChildren</span>(<span class="params">c1, c2, container, anchor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 记录当前next在c1中找到的最大值</span></span><br><span class="line">  <span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; c2.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 找c2</span></span><br><span class="line">    <span class="keyword">const</span> next = c2[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; c1.length; j++) &#123;</span><br><span class="line">      <span class="comment">// 找c1</span></span><br><span class="line">      <span class="keyword">const</span> prev = c1[i];</span><br><span class="line">      <span class="comment">// key相同 patch</span></span><br><span class="line">      <span class="keyword">if</span> (next.key === prev.key) &#123;</span><br><span class="line">        patch(prev, next, container, anchor);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; maxNewIndexSoFar) &#123;</span><br><span class="line">          <span class="comment">// move 此时i必定大于0 所以不需要判断i===0的情况了</span></span><br><span class="line">          <span class="keyword">const</span> curAnchor = c2[i - <span class="number">1</span>].el.nextSibling;</span><br><span class="line">          container.insertBefore(next.el, curAnchor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// update</span></span><br><span class="line">          maxNewIndexSoFar = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find-标志位"><a href="#find-标志位" class="headerlink" title="find 标志位"></a>find 标志位</h2><p>再考虑 c1 中没有找到相同 key 的情况</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220608214640.png" alt=""></p><p>所以我们设置一个标志位,来决定是否存在这种情况,如果循环结束都没用改变状态则说明是新的节点,直接插入即可.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchkeyedChildren</span>(<span class="params">c1, c2, container, anchor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 记录当前next在c1中找到的最大值</span></span><br><span class="line">  <span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; c2.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 找c2</span></span><br><span class="line">    <span class="keyword">const</span> next = c2[i];</span><br><span class="line">    <span class="comment">// 标志位初始化</span></span><br><span class="line">    <span class="keyword">let</span> find = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; c1.length; j++) &#123;</span><br><span class="line">      <span class="comment">// 找c1</span></span><br><span class="line">      <span class="keyword">const</span> prev = c1[i];</span><br><span class="line">      <span class="comment">// key相同 patch</span></span><br><span class="line">      <span class="keyword">if</span> (next.key === prev.key) &#123;</span><br><span class="line">        find = <span class="literal">true</span>;</span><br><span class="line">        patch(prev, next, container, anchor);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; maxNewIndexSoFar) &#123;</span><br><span class="line">          <span class="comment">// move 此时i必定大于0 所以不需要判断i===0的情况了</span></span><br><span class="line">          <span class="keyword">const</span> curAnchor = c2[i - <span class="number">1</span>].el.nextSibling;</span><br><span class="line">          container.insertBefore(next.el, curAnchor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// update</span></span><br><span class="line">          maxNewIndexSoFar = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果到最后都没找到说明要插入</span></span><br><span class="line">    <span class="keyword">if</span> (!find) &#123;</span><br><span class="line">      <span class="keyword">const</span> curAnchor = i === <span class="number">0</span> ? c1[<span class="number">0</span>].el : c2[i - <span class="number">1</span>].el.nextSibling;</span><br><span class="line">      patch(<span class="literal">null</span>, next, container, curAnchor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旧节点多于新节点的时候"><a href="#旧节点多于新节点的时候" class="headerlink" title="旧节点多于新节点的时候"></a>旧节点多于新节点的时候</h2><p>还有一种情况,就是旧节点多于新节点的时候</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220608215815.png" alt=""></p><p>这时候我们就要移除多余的旧节点,遍历旧节点如果 c2 中找不到此节点就卸载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历c1如果找不到则卸载</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; c1.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> prev = c1[i];</span><br><span class="line">  <span class="keyword">if</span> (!c2.find(<span class="function">(<span class="params">next</span>) =&gt;</span> next.key === prev.key)) &#123;</span><br><span class="line">    unmount(prev);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map-优化"><a href="#map-优化" class="headerlink" title="map 优化"></a>map 优化</h2><p>此时我们的算法复杂度是 O(n²),我们可以拿 map 来优化一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="comment">// 保存prev和它的下标</span></span><br><span class="line">c1.forEach(<span class="function">(<span class="params">prev, j</span>) =&gt;</span> &#123;</span><br><span class="line">  map.set(prev.key, &#123;</span><br><span class="line">    prev,</span><br><span class="line">    j,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 记录当前next在c1中找到的最大值</span></span><br><span class="line"><span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; c2.length; i++) &#123;</span><br><span class="line">  <span class="comment">// 找c2</span></span><br><span class="line">  <span class="keyword">const</span> next = c2[i];</span><br><span class="line">  <span class="comment">// 如果存在就看情况替换</span></span><br><span class="line">  <span class="keyword">if</span> (map.has(next.key)) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; prev, j &#125; = map.get(next.key);</span><br><span class="line">    patch(prev, next, container, anchor);</span><br><span class="line">    <span class="keyword">if</span> (j &lt; maxNewIndexSoFar) &#123;</span><br><span class="line">      <span class="comment">// move 此时i必定大于0 所以不需要判断i===0的情况了</span></span><br><span class="line">      <span class="keyword">const</span> curAnchor = c2[i - <span class="number">1</span>].el.nextSibling;</span><br><span class="line">      container.insertBefore(next.el, curAnchor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// update</span></span><br><span class="line">      maxNewIndexSoFar = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不存在就相当于之前find=false的情况.直接patch挂载</span></span><br><span class="line">    <span class="keyword">const</span> curAnchor = i === <span class="number">0</span> ? c1[<span class="number">0</span>].el : c2[i - <span class="number">1</span>].el.nextSibling;</span><br><span class="line">    patch(<span class="literal">null</span>, next, container, curAnchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于我们最后的旧节点多余的情况的优化,可以采用这样的思路,如果前面的节点找到就删除,一直到最后,如果还有存在的节点,就是多余的节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (map.has(next.key)) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; prev, j &#125; = map.get(next.key);</span><br><span class="line">  patch(prev, next, container, anchor);</span><br><span class="line">  <span class="keyword">if</span> (j &lt; maxNewIndexSoFar) &#123;</span><br><span class="line">    <span class="comment">// move 此时i必定大于0 所以不需要判断i===0的情况了</span></span><br><span class="line">    <span class="keyword">const</span> curAnchor = c2[i - <span class="number">1</span>].el.nextSibling;</span><br><span class="line">    container.insertBefore(next.el, curAnchor);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// update</span></span><br><span class="line">    maxNewIndexSoFar = j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 每次匹配完就删除</span></span><br><span class="line">  map.delete(next.key);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 最后多余的节点就卸载</span></span><br><span class="line">map.forEach(<span class="function">(<span class="params">&#123;prev&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  unmount(prev);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>至此算法复杂度就降低到了 O(N)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchkeyedChildren</span>(<span class="params">c1, c2, container, anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  c1.forEach(<span class="function">(<span class="params">prev, j</span>) =&gt;</span> &#123;</span><br><span class="line">    map.set(prev.key, &#123;</span><br><span class="line">      prev,</span><br><span class="line">      j,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 记录当前next在c1中找到的最大值</span></span><br><span class="line">  <span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; c2.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 找c2</span></span><br><span class="line">    <span class="keyword">const</span> next = c2[i];</span><br><span class="line">    <span class="keyword">const</span> curAnchor = i === <span class="number">0</span> ? c1[<span class="number">0</span>].el : c2[i - <span class="number">1</span>].el.nextSibling;</span><br><span class="line">    <span class="keyword">if</span> (map.has(next.key)) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; prev, j &#125; = map.get(next.key);</span><br><span class="line">      patch(prev, next, container, anchor);</span><br><span class="line">      <span class="keyword">if</span> (j &lt; maxNewIndexSoFar) &#123;</span><br><span class="line">        container.insertBefore(next.el, curAnchor);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// update</span></span><br><span class="line">        maxNewIndexSoFar = j;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 每次匹配完就删除</span></span><br><span class="line">      map.delete(next.key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      patch(<span class="literal">null</span>, next, container, curAnchor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后多余的节点就卸载</span></span><br><span class="line">  map.forEach(<span class="function">(<span class="params">&#123; prev &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    unmount(prev);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>据说以上的 diff 算法就是 react 的 diff 算法</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>对于此算法来说,有一个缺点:<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220608221923.png" alt=""></p><p>这个情况肉眼可见只需要移动一次 li-c 节点即可.但实际上,react 的 diff 算法移动了两次</p><p>原因是:首先比较 li-c 发现旧节点下标 2 的地方就是 li-c,于是刷新 maxNewIndexSoFar 为 2,接着 li-a 开始找,找到下标 0,0 小于 2,此时需要交换 li-a,li-b 开始找,找到下标 1,1 小于 2,也需要交换,所以这里有缺点.</p><h1 id="vue2-diff"><a href="#vue2-diff" class="headerlink" title="vue2 diff"></a>vue2 diff</h1><p>为了解决这个问题,vue2 采用了双端比较的方法,来对四个端点进行比较和移动,如果都不行再逐个比较.<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220609230958.png" alt=""></p><h1 id="vue3-diff"><a href="#vue3-diff" class="headerlink" title="vue3 diff"></a>vue3 diff</h1><p>在 Vue3 中将采用另外一种核心 Diff 算法，它借鉴于 ivi 和 inferno</p><h2 id="从左往右再从右往左"><a href="#从左往右再从右往左" class="headerlink" title="从左往右再从右往左"></a>从左往右再从右往左</h2><p>首先从左往右依次比对 然后从右往左依次比对<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220609231057.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> e1 = c1.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> e2 = c2.length - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 从左到右依次比对</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2 &amp;&amp; c1[i].key === c2[i].key) &#123;</span><br><span class="line">  patch(c1[i], c2[i], container, anchor);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从右至左依次比对</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2 &amp;&amp; c1[e1].key === c2[e2].key) &#123;</span><br><span class="line">  patch(c1[e1], c2[e2], container, anchor);</span><br><span class="line">  e1--;</span><br><span class="line">  e2--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对比完的情况一"><a href="#对比完的情况一" class="headerlink" title="对比完的情况一"></a>对比完的情况一</h2><p>经过上述操作如果将旧节点比对完,则 mount 剩下的新节点 此时 i&gt;e1<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220609231202.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; e1) &#123;</span><br><span class="line">  <span class="comment">// 作为此区间的所有节点都mount</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt;= e2; j++) &#123;</span><br><span class="line">    <span class="comment">// 找到下一个节点</span></span><br><span class="line">    <span class="keyword">const</span> nextPos = e2 + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 因为此时这个节点可能为末尾节点，所以得存在才取</span></span><br><span class="line">    <span class="comment">// 否则就取原来的anchor</span></span><br><span class="line">    <span class="keyword">const</span> curAnchor = (c2[nextPos] &amp;&amp; c2[nextPos].el) || anchor;</span><br><span class="line">    <span class="comment">// 执行插入</span></span><br><span class="line">    patch(<span class="literal">null</span>, c2[j], container, curAnchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对比完的情况二"><a href="#对比完的情况二" class="headerlink" title="对比完的情况二"></a>对比完的情况二</h2><p>经过上述操作如果将新节点对比完,则 unmount 剩下的旧节点 此时 i&gt;e2<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220609231337.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123;</span><br><span class="line"> <span class="comment">// 说明新的节点被比对完毕，要去卸载旧的节点</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt;= e1; j++) &#123;</span><br><span class="line">   unmount(c1[j]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不满足则采用传统-diff-标记和删除"><a href="#不满足则采用传统-diff-标记和删除" class="headerlink" title="不满足则采用传统 diff(标记和删除)"></a>不满足则采用传统 diff(标记和删除)</h2><p>若不满足以上的情况,则采用传统的 diff 算法,但不真的添加和移动,只进行标记和删除 取得一个 source 数组，<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220609231503.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 若以上都不满足则采用传统的diff算法，但不真的添加和移动，只做标记和删除</span></span><br><span class="line"> <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="comment">//  c1也可能被截断了 所以是</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt;= e1; j++) &#123;</span><br><span class="line">  <span class="keyword">const</span> prev = c1[j];</span><br><span class="line">  map.set(prev.key, &#123;</span><br><span class="line">    prev,</span><br><span class="line">    j</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  c1.forEach((prev, j) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//    map.set(prev.key, &#123;</span></span><br><span class="line"><span class="comment">//      prev,</span></span><br><span class="line"><span class="comment">//      j</span></span><br><span class="line"><span class="comment">//    &#125;);</span></span><br><span class="line"><span class="comment">//  &#125;)</span></span><br><span class="line"> <span class="comment">// 记录当前next在c1中找到的最大值</span></span><br><span class="line"> <span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">// 移动判断标识</span></span><br><span class="line"> <span class="keyword">let</span> move = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//  这个source数组里面就是对应的c1的下标，多余的情况就是-1，-1就是需要直接mount的情况</span></span><br><span class="line"><span class="comment">// 且长度是之前e2的长度减去i再+1</span></span><br><span class="line"> <span class="keyword">const</span> source = <span class="keyword">new</span> <span class="built_in">Array</span>(e2-i+<span class="number">1</span>).fill(-<span class="number">1</span>);</span><br><span class="line"><span class="comment">// c2也可能被截断了所以是</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; source.length; k++) &#123;</span><br><span class="line">   <span class="comment">// 找c2</span></span><br><span class="line">   <span class="keyword">const</span> next = c2[k+i];</span><br><span class="line">   <span class="comment">// const curAnchor = i === 0 ? c1[0].el : c2[i - 1].el.nextSibling;</span></span><br><span class="line">   <span class="keyword">if</span> (map.has(next.key)) &#123;</span><br><span class="line">     <span class="keyword">const</span> &#123;</span><br><span class="line">       prev,</span><br><span class="line">       j</span><br><span class="line">     &#125; = map.get(next.key);</span><br><span class="line">     patch(prev, next, container, anchor);</span><br><span class="line">     <span class="keyword">if</span> (j &lt; maxNewIndexSoFar) &#123;</span><br><span class="line">       <span class="comment">// 代表需要移动</span></span><br><span class="line">       move = <span class="literal">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// update</span></span><br><span class="line">       maxNewIndexSoFar = j;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 得到source数组</span></span><br><span class="line">     source[k] = j;</span><br><span class="line">     <span class="comment">// 每次匹配完就删除</span></span><br><span class="line">     map.delete(next.key);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// todo</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 最后多余的节点就卸载</span></span><br><span class="line"> map.forEach(<span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">   prev</span></span></span><br><span class="line"><span class="params"><span class="function"> &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">   unmount(prev)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们要编写 move 的情况了,需要移动的话,我们要采用最长上升子序列算法.</p><h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><p>先说结论,最长上升子序列的节点不需要移动,用这个算法会得到 source 数组里面最长上升子序列的对应下标，合起来是一个 seq 数组，这个数组里面的元素不需要移动。</p><div class="note primary flat"><p>TIP</p><p>什么是最长递增子序列：给定一个数值序列，找到它的一个子序列，并且子序列中的值是递增的，子序列中的元素在原序列中不一定连续。</p><p>例如给定数值序列为：[ 0, 8, 4, 12 ]</p><p>那么它的最长递增子序列就是：[0, 8, 12]</p><p>当然答案可能有多种情况，例如：[0, 4, 12] 也是可以的</p></div><p>假设我们现在已经采取了最长上升子序列算法完成了 seq 数组，进行下一步的判断。</p><p>设两个指针都指向 source 和 seq 的末尾。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> seq = getSequence(source);</span><br><span class="line"><span class="comment">// 从末尾向前遍历</span></span><br><span class="line"><span class="keyword">let</span> j = seq.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k = source.length - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="不需要移动的情况"><a href="#不需要移动的情况" class="headerlink" title="不需要移动的情况"></a>不需要移动的情况</h3><p>如果此时 seq 中的值和 source 的下标对应，说明不需要移动,两指针都减一进行下一轮比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (seq[j] == k) &#123;</span><br><span class="line">  <span class="comment">// 不用移动</span></span><br><span class="line">  <span class="comment">// 此时k和最长上升子序列的值一样,直接j--让他进入下一轮的比较</span></span><br><span class="line">  j--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="需要-mount-的情况"><a href="#需要-mount-的情况" class="headerlink" title="需要 mount 的情况"></a>需要 mount 的情况</h3><p>如果此时 source 的值为-1，说明这个节点需要 mount，source 指针减一</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (source[k] === -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// mount todo curAnchor pos</span></span><br><span class="line">  patch(<span class="literal">null</span>, c2[pos], container, curAnchor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="需要移动的情况"><a href="#需要移动的情况" class="headerlink" title="需要移动的情况"></a>需要移动的情况</h3><p>如果此时 source 的值不为-1 且它的下标又不和 seq 中的值对应，则需要移动，source 减一</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">  <span class="comment">// 移动 todo curAnchor pos</span></span><br><span class="line">  container.insertBefore(c2[pos].el, curAnchor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-anchor"><a href="#注意-anchor" class="headerlink" title="注意 anchor"></a>注意 anchor</h3><p>那么现在的问题是这个 anchor 和 pos 要怎么写，对于 pos，因为此时我们是进行了前面说的一二大步骤才进入这个传统 diff 的，已经走了 i 步，所以起点要加 i。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pos = k + i;</span><br></pre></td></tr></table></figure><p>对于 anchor 来说，它其实就是当前节点的下一位，当然还要考虑末尾的情况所以是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nextPos = pos + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> curAnchor = (c2[nextPos] &amp;&amp; c2[nextPos].el) || anchor;</span><br></pre></td></tr></table></figure><p>我们会发现上面有两种情况都需要 anchor 和 pos，所以我们可以合并一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (move) &#123;</span><br><span class="line">  <span class="comment">// 得到最长上升子序列的下标</span></span><br><span class="line">  <span class="keyword">const</span> seq = getSequence(source);</span><br><span class="line">  <span class="comment">// 从末尾向前遍历</span></span><br><span class="line">  <span class="keyword">let</span> j = seq.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = source.length - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (seq[j] == k) &#123;</span><br><span class="line">      <span class="comment">// 不用移动</span></span><br><span class="line">      <span class="comment">// 此时k和最长上升子序列的值一样,直接j--让他进入下一轮的比较</span></span><br><span class="line">      j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 挂载节点的下标就是k，因为起点变了所以要加i</span></span><br><span class="line">      <span class="keyword">const</span> pos = k + i;</span><br><span class="line">      <span class="comment">// anchor就是当前节点的下一位</span></span><br><span class="line">      <span class="keyword">const</span> nextPos = pos + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> curAnchor = (c2[nextPos] &amp;&amp; c2[nextPos].el) || anchor;</span><br><span class="line">      <span class="keyword">if</span> (source[k] === -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// mount</span></span><br><span class="line">        patch(<span class="literal">null</span>, c2[pos], container, curAnchor);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 移动</span></span><br><span class="line">        container.insertBefore(c2[pos].el, curAnchor);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊情况：不需要移动，但还有未添加的元素"><a href="#特殊情况：不需要移动，但还有未添加的元素" class="headerlink" title="特殊情况：不需要移动，但还有未添加的元素"></a>特殊情况：不需要移动，但还有未添加的元素</h2><blockquote><p>c1: a b c<br>c2: a x b y c<br>source: [1,-1,2,-1,3]<br>seq: [1,2,3]</p></blockquote><p>上面的例子，<code>move</code> 是 <code>false</code>，因此专门用一个 <code>toMounted</code> 去处理这种情况<br><code>toMounted</code> 记录待新增的元素的下标</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toMounted = [];</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 如果不满足条件，把下标添加给toMounted</span></span><br><span class="line"><span class="keyword">if</span>(...)&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  toMounted(k+i);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>(toMounted.length)&#123;</span><br><span class="line">  <span class="comment">// 因为判断插入所以依旧是从后往前</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> k=toMounted.length-<span class="number">1</span>;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">    <span class="comment">// 因为刚刚下标就是给了toMounted 所以此时的坐标就是toMounted中的元素</span></span><br><span class="line">    <span class="keyword">const</span> pos = toMounted[k];</span><br><span class="line">    <span class="keyword">const</span> nextPos = pos+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> curAnchor = (c2[nextPos]&amp;&amp;c2[nextPos].el) || anchor;</span><br><span class="line">    patch(<span class="literal">null</span>,c2[pos],container,curAnchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>至此除了最长上升子序列方法之外都完成了</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们在这一节通过 patchArrayChildren 暴露出来的一对一对比低效的问题,找到了添加 key 去判断的解决方法,其中编写了 patchUnkeyedChildren 来对比新旧孩子,找到 key 一致的孩子去进行 patch,然后我们通过 maxNewIndexSoFar 去优化 insertBefore 的情况，让它在合适的时候才插入，再通过 find 标志位标志新节点没有找到旧节点的情况，直接 mount，随后再判断旧节点多于新节点的情况，直接卸载多余的旧节点。接着我们通过 map 优化了上述的循环代码，让复杂度从 O(n²)降低到 O(n).</p><p>当我们完成后又根据一个简单的例子(移动多次)发现该 diff 算法的缺点，随后看到了 vue2 vue3 解决该问题的方法。其中我们对 vue3 的 diff 算法进行深入了解。vue3 的 diff 是先从左往右对比再从右往左对比，找到需要 mount 的新节点区间或需要卸载的旧节点区间。找不到这两个情况就进行传统的 diff，不过不进行挂载和移动，还是用一个 map 进行标记和删除。之后对于先前 react 算法的缺点，用最长上升子序列解决。最长上升子序列的数组内的元素不需要移动。我们又判断了挂载(source 为-1)和移动(不为-1 又不和 seq 对上)的情况，来进行挂载和移动的操作。最后对于特殊的情况，就是旧节点间夹杂需要挂载的新节点的情况。去设置一个 toMounted 数组，在非 move 的情况时把对应的下标加入到数组中，后面单独拿出来挂载。</p><p>本节的遗漏的最长上升子序列算法将在下一节讲述。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的mini-vue②--vnode篇</title>
    <link href="https://zlinni.github.io/posts/2797606246/"/>
    <id>https://zlinni.github.io/posts/2797606246/</id>
    <published>2022-06-06T02:26:33.000Z</published>
    <updated>2022-06-10T08:29:49.555Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是虚拟 DOM 篇，是关于 Vue3 中响应式的篇章，包含了<code>vnode</code>,<code>render</code>的实现</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/虚拟DOM.png" alt=""></p><h1 id="vnode"><a href="#vnode" class="headerlink" title="vnode"></a>vnode</h1><p>本节中我们将会实现这样的例子(注意 html 中使用 <code>defer</code> 挂载 js，以及使用样式)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render, h, Text &#125; <span class="keyword">from</span> <span class="string">&quot;./runtime&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用h生成vnode</span></span><br><span class="line"><span class="keyword">const</span> vnode = h(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">class</span>: <span class="string">&quot;a b&quot;</span>,</span><br><span class="line">    <span class="attr">style</span>: &#123;</span><br><span class="line">      <span class="attr">border</span>: <span class="string">&quot;1px solid&quot;</span>,</span><br><span class="line">      <span class="attr">fontSize</span>: <span class="string">&quot;14px&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;click&quot;</span>),</span><br><span class="line">    <span class="attr">checked</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">custom</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  [</span><br><span class="line">    h(<span class="string">&quot;ul&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">      h(<span class="string">&quot;li&quot;</span>, &#123; <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span> &#125; &#125;, <span class="number">1</span>),</span><br><span class="line">      h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="number">2</span>),</span><br><span class="line">      h(<span class="string">&quot;li&quot;</span>, &#123; <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">&quot;blue&quot;</span> &#125; &#125;, <span class="number">3</span>),</span><br><span class="line">      h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, [h(Text, <span class="literal">null</span>, <span class="string">&quot;hello world&quot;</span>)]),</span><br><span class="line">    ]),</span><br><span class="line">  ]</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 将生成的vnode挂载到body上</span></span><br><span class="line">render(vnode, <span class="built_in">document</span>.body);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* &lt;style&gt;</span></span><br><span class="line"><span class="comment">  .a &#123;</span></span><br><span class="line"><span class="comment">    background-color: aqua;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  .b &#123;</span></span><br><span class="line"><span class="comment">    padding: 20px;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&lt;/style&gt; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们在完成这个例子之前，还是有必要了解一下虚拟 DOM 的种类</p><h1 id="虚拟-DOM-的种类"><a href="#虚拟-DOM-的种类" class="headerlink" title="虚拟 DOM 的种类"></a>虚拟 DOM 的种类</h1><ol><li>Element<br>element 对应普通元素，原理是使用 <code>document.createElement()</code>创建的。<code>type</code> 指的是标签名，<code>props</code> 指的是元素属性，<code>children</code> 指子元素，可以为字符串或者数组，为字符串的时候代表只有一个文本节点。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">props</span>:<span class="built_in">Object</span>,</span><br><span class="line">  <span class="attr">children</span>:<span class="built_in">string</span> | VNode[]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>:&#123;<span class="attr">class</span>:<span class="string">&#x27;a&#x27;</span>&#125;,</span><br><span class="line">  <span class="attr">children</span>:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Text<br>text 对应文本节点，原理是使用 <code>document.createTextNode()</code>创建的。<code>type</code> 定义为一个 <code>Symbol</code>，<code>props</code> 为空，<code>children</code> 为字符串，指具体的文本内容</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="built_in">Symbol</span>,</span><br><span class="line">  <span class="attr">props</span>:<span class="literal">null</span>,</span><br><span class="line">  <span class="attr">children</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Fragment<br>Fragment 为一个不会真实渲染的节点。相当于 <code>template</code> 或 <code>react</code> 的 Fragment。<code>type</code> 为一个 <code>Symbol</code>，<code>props</code> 为空，<code>children</code> 为一个数组，表示子节点。最后渲染的时候会挂载到 Fragment 的父节点上面。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="built_in">Symbol</span>,</span><br><span class="line">  <span class="attr">props</span>:<span class="literal">null</span>,</span><br><span class="line">  <span class="attr">children</span>:[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Component<br>Component 是组件，组件有自己的一套特殊的渲染方法，但组件最终的产物也是上面三种 VNode 的集合。组件的 <code>type</code>，就是定义组件的对象，<code>props</code> 即是外部传入组件的 <code>props</code> 数据，<code>children</code> 即是组件的 <code>slot</code>(不准备实现 <code>slot</code> 跳过)</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="built_in">Object</span>,</span><br><span class="line">  <span class="attr">props</span>:<span class="built_in">Object</span>,</span><br><span class="line">  <span class="attr">children</span>:<span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:&#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`&#123;&#123;msg&#125;&#125;&#123;&#123;name&#125;&#125;`</span>,</span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">props</span>:&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;world&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ShapeFlags-快速标识-VNode-的类型"><a href="#ShapeFlags-快速标识-VNode-的类型" class="headerlink" title="ShapeFlags 快速标识 VNode 的类型"></a>ShapeFlags 快速标识 VNode 的类型</h1><p><code>ShapeFlags</code> 是一组标记，用于快速辨识 VNode 的类型</p><h2 id="复习位运算"><a href="#复习位运算" class="headerlink" title="复习位运算"></a>复习位运算</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按位与运算 相同的不变 不同的为0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">&amp;</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// 按位或运算 相同的不变 不同的为1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">|</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="ShapeFlags-的生成"><a href="#ShapeFlags-的生成" class="headerlink" title="ShapeFlags 的生成"></a>ShapeFlags 的生成</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ShapeFlags = &#123;</span><br><span class="line">  <span class="attr">ELEMENT</span>: <span class="number">1</span>, <span class="comment">// 00000001</span></span><br><span class="line">  <span class="attr">TEXT</span>: <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">// 00000010</span></span><br><span class="line">  <span class="attr">FRAGMENT</span>: <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">// 00000100</span></span><br><span class="line">  <span class="attr">COMPONENT</span>: <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">// 00001000</span></span><br><span class="line">  <span class="attr">TEXT_CHILDREN</span>: <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">// 00010000</span></span><br><span class="line">  <span class="attr">ARRAY_CHILDREN</span>: <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">// 00100000</span></span><br><span class="line">  <span class="attr">CHILDREN</span>: (<span class="number">1</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">5</span>), <span class="comment">//00110000</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以发现他利用了二进制位运算<code>&lt;&lt;</code>和<code>|</code>生成，使用的时候用<code>&amp;</code>判断，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag &amp; ShapeFlags.ELEMENT)</span><br></pre></td></tr></table></figure><p>再例如，一个值为 33 的 flag，它的二进制值为 00100001，那么它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="number">33</span>;</span><br><span class="line">flag &amp; ShapeFlags.ELEMENT; <span class="comment">// true</span></span><br><span class="line">flag &amp; ShapeFlags.ARRAY_CHILDREN; <span class="comment">// true</span></span><br><span class="line">flag &amp; ShapeFlags.CHILDREN; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>它的生成还可以用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = ShapeFlags.ELEMENT | ShapeFlags.ARRAY_CHILDREN;</span><br></pre></td></tr></table></figure><h1 id="VNode-初步形态"><a href="#VNode-初步形态" class="headerlink" title="VNode 初步形态"></a>VNode 初步形态</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type,</span><br><span class="line">  props,</span><br><span class="line">  children,</span><br><span class="line">  shapeFlag,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="h-函数—生成-VNode"><a href="#h-函数—生成-VNode" class="headerlink" title="h 函数—生成 VNode"></a>h 函数—生成 VNode</h1><p><code>h</code> 函数的用途就是生成 VNode。<br>它接收三个参数：<code>type</code>, <code>props</code>, <code>children</code>, 返回一个 VNode</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isArray, isNumber, isString &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ShapeFlags = &#123;</span><br><span class="line">  <span class="attr">ELEMENT</span>: <span class="number">1</span>, <span class="comment">// 00000001</span></span><br><span class="line">  <span class="attr">TEXT</span>: <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">// 00000010</span></span><br><span class="line">  <span class="attr">FRAGMENT</span>: <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">// 00000100</span></span><br><span class="line">  <span class="attr">COMPONENT</span>: <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">// 00001000</span></span><br><span class="line">  <span class="attr">TEXT_CHILDREN</span>: <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">// 00010000</span></span><br><span class="line">  <span class="attr">ARRAY_CHILDREN</span>: <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">// 00100000</span></span><br><span class="line">  <span class="attr">CHILDREN</span>: (<span class="number">1</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">5</span>), <span class="comment">//00110000</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Text = <span class="built_in">Symbol</span>(<span class="string">&quot;Text&quot;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Fragment = <span class="built_in">Symbol</span>(<span class="string">&quot;Fragment&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String | Object | Text | Fragment&#125;</span> <span class="variable">type</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object | null&#125;</span> <span class="variable">props</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String | Number | Array | null&#125;</span> <span class="variable">children</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="variable">VNode</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">type, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断shapeFlag得到它的类型</span></span><br><span class="line">  <span class="keyword">let</span> shapeFlag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (isString(type)) &#123;</span><br><span class="line">    shapeFlag = ShapeFlags.ELEMENT;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === Text) &#123;</span><br><span class="line">    shapeFlag = ShapeFlags.TEXT;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === Fragment) &#123;</span><br><span class="line">    shapeFlag = ShapeFlags.FRAGMENT;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    shapeFlag = ShapeFlags.COMPONENT;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 再判断children</span></span><br><span class="line">  <span class="keyword">if</span> (isString(children) || isNumber(children)) &#123;</span><br><span class="line">    shapeFlag |= ShapeFlags.TEXT_CHILDREN;</span><br><span class="line">    <span class="comment">// 数字转字符串</span></span><br><span class="line">    children = children.toString();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(children)) &#123;</span><br><span class="line">    shapeFlag |= ShapeFlags.ARRAY_CHILDREN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    props,</span><br><span class="line">    children,</span><br><span class="line">    shapeFlag,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="render-挂载虚拟-DOM"><a href="#render-挂载虚拟-DOM" class="headerlink" title="render 挂载虚拟 DOM"></a>render 挂载虚拟 DOM</h1><p>这一步我们要将 <code>vnode</code> 中的 shapeFlag 解析并判断节点类型，根据不同的节点类型进行不同的挂载操作</p><p><code>render</code> 需要接收两个参数，一个是节点 <code>vnode</code>，一个是挂载的容器 <code>container</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isBoolean &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ShapeFlags &#125; <span class="keyword">from</span> <span class="string">&quot;./vnode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  mount(vnode, container);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 挂载虚拟dom</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 解析shapeFlag</span></span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ELEMENT) &#123;</span><br><span class="line">    mountElement(vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT) &#123;</span><br><span class="line">    mountTextNode(vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.FRAGMENT) &#123;</span><br><span class="line">    mountFragment(vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountComponent(vnode, container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，我们还要操作四种类型的挂载，分别是</p><ol><li>元素挂载 <code>mountElement</code></li><li>文本节点挂载 <code>mountTextNode</code></li><li>虚拟节点挂载 <code>mountFragment</code></li><li>组件挂载 <code>mountComponent</code></li></ol><h2 id="mountElement"><a href="#mountElement" class="headerlink" title="mountElement"></a>mountElement</h2><p>对于我们的 element 类型，我们也知道了他的底层是靠 <code>document.createElement</code> 方法来生成元素的，生成之后我们需要将 <code>props</code> 挂载到该元素上，再将子节点挂载到元素上，然后挂载到容器内。</p><p>综上所述分为以下几个步骤：</p><ol><li>生成元素 el</li><li>挂载 <code>props</code> 到 el <code>mountProps</code></li><li>挂载子节点到 el <code>mountChildren</code></li><li>挂载 el 到 <code>container</code></li></ol><p>代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountElement</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出元素 挂载元素 挂载props children</span></span><br><span class="line">  <span class="keyword">const</span> &#123; type, props &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">  <span class="comment">// 将props挂载到el上</span></span><br><span class="line">  mountProps(props, el);</span><br><span class="line">  <span class="comment">// 把节点挂载到el上</span></span><br><span class="line">  mountChildren(vnode, el);</span><br><span class="line">  container.appendChild(el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>mountProps</code> 和 <code>mountChildren</code>，我们先来做后者</p><h3 id="mountChildren"><a href="#mountChildren" class="headerlink" title="mountChildren"></a>mountChildren</h3><p>前面介绍 element 的时候我们讲到：</p><div class="note primary flat"><p>children 指子元素，可以为字符串或者数组，为字符串的时候代表只有一个文本节点。</p></div><p>所以我们就要对子元素的两种情况进行判断并挂载</p><p><code>mountChildren</code> 也是接收两个参数，一个是节点 <code>vnode</code>，一个是容器 <code>container</code></p><p>对于数组的操作我们递归调用挂载即可。对于字符串我们还需要编写挂载文本节点的情况，这个下面会讲到文本节点所以先掠过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountChildren</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag, children &#125; = vnode;</span><br><span class="line">  <span class="comment">// 文本节点</span></span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">    mountTextNode(vnode, container);</span><br><span class="line">    <span class="comment">// 数组的时候</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    <span class="comment">// 递归调用挂载</span></span><br><span class="line">    children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">      mount(child, container);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mountProps"><a href="#mountProps" class="headerlink" title="mountProps"></a>mountProps</h3><p><code>mountProps</code> 接收两个参数，一个是 <code>props</code> 渲染器，一个是生成的元素 <code>el</code></p><p>对于我们的 <code>props</code> 有以下几个种类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">class</span>: <span class="string">&#x27;a b&#x27;</span>,</span><br><span class="line">  <span class="attr">style</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    <span class="attr">fontSize</span>: <span class="string">&#x27;14px&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>),</span><br><span class="line">  <span class="attr">checked</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">custom</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先要分析一下我们有几种情况</p><ol><li><code>class</code> 字符串</li><li><code>style</code> 对象</li><li><code>event</code> 事件</li><li>其他属性</li></ol><p>那么来按点分析：</p><h4 id="class-字符串"><a href="#class-字符串" class="headerlink" title="class 字符串"></a>class 字符串</h4><p>如果是 <code>class</code>，直接赋 <code>className</code> 即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;class&#x27;</span>:</span><br><span class="line">    el.className = value;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h4 id="style-对象"><a href="#style-对象" class="headerlink" title="style 对象"></a>style 对象</h4><p>如果是 <code>style</code>，因为他是一个对象，所以我们要遍历这个 <code>style</code>，把对应的值赋给<code>el.style[styleName]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是style 遍历赋值value值</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;style&quot;</span>:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> styleName <span class="keyword">in</span> value) &#123;</span><br><span class="line">    el.style[styleName] = value[styleName];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h4 id="event-事件"><a href="#event-事件" class="headerlink" title="event 事件"></a>event 事件</h4><p>如果是事件，这里偷懒一下，只触发以 <code>on</code> 开头的事件，利用正则我们很快可以匹配上，再把 <code>Click</code> 变小写，然后利用<code>el.addEventListener(eventName, value);</code>这个 api 即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="regexp">/^on[^a-z]/</span>.test(key)) &#123;</span><br><span class="line">  <span class="keyword">const</span> eventName = key.slice(<span class="number">2</span>).toLowerCase();</span><br><span class="line">  el.addEventListener(eventName, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><p>如果是其他属性，这时候我们就要注意了，虽然一般情况下我们用<code>setAttribute</code>这个 <code>api</code>，就可以帮助我们设置属性以及属性对应的值，但是如果我们的属性是<code>value|checked|selected|muted|disabled</code>这几种，那么我们设置<code>true|false</code>的时候，他会被转换成字符串导致赋值失效。所以，我们要正则匹配这种情况，单独给他赋值这个属性<code>el[key] = value;</code></p><p>另外不仅如此,也可能存在没有赋值的情况，比如我只想让多选框选中，那么就给他<code>checked</code>，我们需要将他处理成 true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (domPropsRE.test(key)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (value === <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    value = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  el[key] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，我们设置成 <code>false</code> 或者 <code>null</code> 的时候，代表我们希望移除掉这个属性，所以要利用到 <code>removeAttribute</code>，最后的情况就是 <code>setAttribute</code> 了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span> || value === <span class="literal">false</span>) &#123;</span><br><span class="line">  el.removeAttribute(key);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  el.setAttribute(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> domPropsRE = <span class="regexp">/[A-Z]|^(value|checked|selected|muted|disabled)$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountProps</span>(<span class="params">props, el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = props[key];</span><br><span class="line">    <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">      <span class="comment">// 如果是class 直接赋className</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;class&quot;</span>:</span><br><span class="line">        el.className = value;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 如果是style 遍历赋值value值</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;style&quot;</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> styleName <span class="keyword">in</span> value) &#123;</span><br><span class="line">          el.style[styleName] = value[styleName];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 如果是事件，正则匹配on开头，并将后面的转为小写单词 然后添加事件</span></span><br><span class="line">      <span class="comment">// 如果是别的属性，分类判断，不能统一设置attribute</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/^on[^a-z]/</span>.test(key)) &#123;</span><br><span class="line">          <span class="keyword">const</span> eventName = key.slice(<span class="number">2</span>).toLowerCase();</span><br><span class="line">          el.addEventListener(eventName, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (domPropsRE.test(key)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (value === <span class="string">&quot;&quot;</span> &amp;&amp; isBoolean(el[key])) &#123;</span><br><span class="line">            value = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          el[key] = value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (value == <span class="literal">null</span> || value === <span class="literal">false</span>) &#123;</span><br><span class="line">            el.removeAttribute(key);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            el.setAttribute(key, value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>至此处理完了 <code>mountElement</code>，我们知道了 <code>element</code> 中对于子元素的处理为数组遍历和文本挂载，对于 <code>props</code> 的处理按四种大情况讨论，其中对于其他属性我们还要按照一般的属性和特殊的几种属性讨论，以及赋值的情况下给移除还是挂载。下面进入 <code>mountTextNode</code> 环节</p></div><h2 id="mountTextNode"><a href="#mountTextNode" class="headerlink" title="mountTextNode"></a>mountTextNode</h2><div class="note primary flat"><p>上面我们遗留了一个问题，就是关于子元素的文本节点处理的问题。</p></div><p>其实 <code>mountTextNode</code> 原理就是 <code>document.createTextNode()</code>，具体传入的内容是 <code>vnode</code>.<code>children</code>,因为我们前面讲到,<code>TEXT</code> 节点他的孩子就是具体的文本内容。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="built_in">Symbol</span>,</span><br><span class="line">  <span class="attr">props</span>:<span class="literal">null</span>,</span><br><span class="line">  <span class="attr">children</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountTextNode</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(vnode.children);</span><br><span class="line">  container.appendChild(textNode);</span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mountFragment"><a href="#mountFragment" class="headerlink" title="mountFragment"></a>mountFragment</h2><p>他本身不渲染，直接把父节点挂载上去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountFragment</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 本身不渲染 直接把父节点挂载上去</span></span><br><span class="line">  mountChildren(vnode, container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a>mountComponent</h2><p>暂时不写</p><div class="note primary flat"><p>至此我们的挂载虚拟 DOM 暂时完成，下面看我们的 <code>patch</code> 部分</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个部分的篇幅有点长，我们学到了何为vnode，然后初步的编写一个虚拟 DOM 并生成vnode然后挂载并渲染，下节进行<code>patch</code>的学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的mini-vue①--reactive篇</title>
    <link href="https://zlinni.github.io/posts/3451170570/"/>
    <id>https://zlinni.github.io/posts/3451170570/</id>
    <published>2022-05-30T02:33:04.000Z</published>
    <updated>2022-06-10T08:29:28.670Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是 reactive 篇，是关于 Vue3 中响应式的篇章，包含了<code>reactive</code>,<code>ref</code>,<code>computed</code>的实现</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/reactivedaotu.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/computedandref.png" alt=""></p><h1 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h1><p>项目使用 webpack 构建，demo 的代码放在<code>index.js</code>之中，将其打包成为<code>mini-vue.js</code>,之后<code>index.html</code>引入，控制台查看 demo 输出。</p><h1 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h1><p>Vue3 中的<code>reactive</code>用于处理对象数据，将引用类型的数据转化为响应式。其实它是由两个部分组成的，见例子。我们知道它由 <code>reactive</code> 和 <code>effect</code> 组成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observed = reactive(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">&#125;);</span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;observed.count is:&quot;</span>, observed.count);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们把这个 effect 叫做副作用函数，副作用函数的执行会影响其他变量或者函数的执行。这里它是作用是收集依赖，在依赖发生改变的时候触发更新。</p><p>它们两个是怎么产生联系的呢?核心是进行依赖收集 track 和触发依赖更新 trigger</p><p>依赖收集就是保存依赖和副作用之间的关系.</p><p>触发依赖更新就是当依赖变更的时候,找到并执行依赖它的副作用</p><p>我们知道了上述的操作，将它们分为两个部分进行编写，一是<code>reactive.js</code> 二是<code>effect.js</code></p><h2 id="reactive-部分"><a href="#reactive-部分" class="headerlink" title="reactive 部分"></a>reactive 部分</h2><p>刚才提及到，reactive 处理的是对象类型的数据，所以我们要编写一个方法判断对象</p><p>所以我们新建<code>utils</code>文件夹，写入<code>index.js</code>,用于编写我们的工具类方法</p><p>判断对象类型的数据的方法,需要注意的是由于<code>null</code>也会被判断为 object，所以要多加判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> funtcion <span class="function"><span class="title">isObject</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们要考虑怎么去将数据变为响应式。</p><p>学过 vue3 基础的都知道，vue3 使用的是 Proxy 来对响应式数据进行 track 和 trigger</p><p>proxy 接收两个参数，一个是 target 一个是 handler，前者是拦截的对象，后者是分为了 get 和 set 两步操作。</p><p>同时 get 接收三个参数，对象，需要拦截的属性 key，接收者 receiver</p><p>这个 receiver 指向原始读操作所在的对象，一般指的是 Proxy 实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, property, receiver</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> receiver;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">d.a === d; <span class="comment">// true</span></span><br><span class="line"><span class="comment">//d对象本身没有a属性，所以读取d.a的时候，会去d的原型proxy对象找。这时，receiver就指向d，代表原始的读操作所在的那个对象。</span></span><br></pre></td></tr></table></figure><p>set 接收四个参数，对象，需要拦截的属性，改变的 value 值，接收者 receiver。最后返回一个布尔值</p><p>我们还需要反射对象 Reflect，我们通过它可以获取对象上的某个指定属性的方法(get)，也可以去修改对象属性上的值(set)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">      track(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">      trigger(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们入手<code>effect.js</code></p><h2 id="effect-部分"><a href="#effect-部分" class="headerlink" title="effect 部分"></a>effect 部分</h2><p>我们在这个部分需要对副作用函数进行处理和剖析，以及对我们的 track 和 trigger 进行编写</p><p>首先我们需要拿到并执行这个副作用函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//todo</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  effectFn();</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是用户写的 effect，可能会报错，所以要用 try 来包裹住,且我们的 track 要收集我们的依赖，就要知道依赖有没有被执行，也就是有没有调用 effect 中的方法，所以我们要设计一个标识记录该方法。这里就用到全局变量<code>activeEffect</code>,去缓存我们的 effect，然后在执行完之后给它还原回去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = effectFn;</span><br><span class="line">      <span class="keyword">return</span> fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      activeEffect = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  effectFn();</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们要来写 track 和 trigger 部分，但我们得先考虑一下，我们依赖的数据结构应该怎么设计</p><p>先了解一下这样的一个执行过程：</p><p>副作用执行=&gt;副作用依赖的响应式对象改变=&gt;响应式对象改变=&gt;响应式对象的属性改变</p><p>且响应式对象的属性可以由多个副作用依赖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  响应式对象<span class="number">1</span>:&#123;</span><br><span class="line">    属性<span class="number">1</span>:[副作用<span class="number">1</span>，副作用<span class="number">2</span>，副作用<span class="number">3.</span>..],</span><br><span class="line">    属性<span class="number">2</span>:[副作用<span class="number">1</span>，副作用<span class="number">2</span>，副作用<span class="number">3.</span>..],</span><br><span class="line">  &#125;,</span><br><span class="line">  响应式对象<span class="number">2</span>:&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们就知道得先存储响应式对象，这里就使用<code>WeakMap</code>作为它的数据结构，这样的好处是里面的响应式对象在不被使用的时候会被垃圾回收。命名为<code>targetMap</code></p><p>再考虑响应式对象的属性，我们将他存放在一个<code>map</code>中，命名为<code>depsMap</code></p><p>接着是它的副作用，副作用存放在一个<code>set</code>中，因为可能有多个副作用依赖同样的属性，命名为<code>deps</code></p><p>这样，我们的结构就是如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">targetMap:&#123;</span><br><span class="line">  响应式对象(target):&#123;</span><br><span class="line">    <span class="attr">depsMap</span>:&#123;</span><br><span class="line">      属性(key):&#123;</span><br><span class="line">        <span class="attr">deps</span>:&#123;</span><br><span class="line">          副作用(activeEffect)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完依赖的数据结构之后，就可以开始写 track 了</p><p>我们现在再次了解一下 track 的作用:添加依赖，也就是要找到层级结构中的依赖，对此，我们进行下面写法。</p><h3 id="track-部分"><a href="#track-部分" class="headerlink" title="track 部分"></a>track 部分</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="comment">// track的作用是收集依赖</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果不是正在执行的依赖 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!activeEffect) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构建depsMap</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构建deps</span></span><br><span class="line">  <span class="keyword">let</span> deps = depsMap.get(key);</span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    depsMap.set(key, (deps = <span class="keyword">new</span> <span class="built_in">Set</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加依赖</span></span><br><span class="line">  deps.add(activeEffect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trigger-部分"><a href="#trigger-部分" class="headerlink" title="trigger 部分"></a>trigger 部分</h3><p>对于 trigger 部分，其实就是 track 的逆运算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trigger用于触发更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果它有副作用,才执行</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> deps = depsMap.get(key);</span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  deps.forEach(<span class="function">(<span class="params">effectFn</span>) =&gt;</span> &#123;</span><br><span class="line">    effectFn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此一个最简单的响应式已经设计好了,接下来我们通过一些特例,来处理特殊情况以及优化</p><h1 id="特例处理与优化"><a href="#特例处理与优化" class="headerlink" title="特例处理与优化"></a>特例处理与优化</h1><div class="note primary flat"><p>下面有六个特例，对应处理 reactive 的六种情况</p></div><ol><li><code>reactive(reactive(obj))</code></li><li><code>let a = reactive(obj), b = reactive(obj)</code></li><li><code>hasChanged</code></li><li>深层对象代理</li><li>数组</li><li>嵌套 effect</li></ol><h2 id="嵌套-reactive"><a href="#嵌套-reactive" class="headerlink" title="嵌套 reactive"></a>嵌套 reactive</h2><p><code>reactive(reactive(obj))</code></p><p>对于第一种情况，是同一个对象被多次响应式处理了。正常的情况应该是只处理一次。</p><p>我们可以给响应式对象添加一个<code>_isReactive</code>属性，依此来判断.</p><p>注意这里用了<code>!!</code>将结果转为 boolean</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isReactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(target &amp;&amp; target._isReactive);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断是否已经是响应式对象</span></span><br><span class="line">  <span class="keyword">if</span> (isReactive(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">      <span class="comment">//判断key是否为__isReactive</span></span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&quot;__isReactive&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      track(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">      trigger(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isReactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(target &amp;&amp; target.__isReactive);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多次对同个对象进行响应式处理"><a href="#多次对同个对象进行响应式处理" class="headerlink" title="多次对同个对象进行响应式处理"></a>多次对同个对象进行响应式处理</h2><div class="note primary flat"><p><code>let a = reactive(obj), b = reactive(obj)</code></p><p>这个可以说是和上面的特例优点类似，但是实际上的处理却不太一样。</p></div><p>对于第一个特例，我们是通过判断标识<code>__isReactive</code>来判断它是否被代理过，然后如果已经存在这个属性，则将其拦截为 true。</p><p>对于第二个特例，我们要通过一个数据结构来存储我们的响应式对象，当目标对象下次被响应式处理的时候，判断数据结构中是否有该响应式对象，有则直接返回该响应式对象。</p><!-- 所以这两个处理主要的区别在于，是否返回同样的响应式，对于第一种，多次嵌套，它返回的是嵌套内容，对于第二种，它返回的是处理过的响应式对象。 --><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"><span class="comment">// 创建proxyMap</span></span><br><span class="line"><span class="keyword">const</span> proxyMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isReactive(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有则直接返回该响应式对象</span></span><br><span class="line">  <span class="keyword">if</span> (proxyMap.get(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&quot;__isReative&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      track(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">      trigger(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 设置</span></span><br><span class="line">  proxyMap.set(target, proxy);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isReactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(target &amp;&amp; target.__isReative);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="响应式内容是否改变-懒处理不触发更新"><a href="#响应式内容是否改变-懒处理不触发更新" class="headerlink" title="响应式内容是否改变(懒处理不触发更新)"></a>响应式内容是否改变(懒处理不触发更新)</h2><p><code>hasChanged</code>是代表着响应式对象是否被改变的操作。在 vue3 中，如果响应式的数据和上一次的没有改变，则不触发更新</p><p>那么很快就知道入手点在 proxy 的 set 中了。不过在此之前我们得编写<code>hasChanged</code>函数,它需要对我们此次的值和上一次的值比较。</p><p>不过光是对比，很容易就遗留一个特殊情况，就是<code>NaN</code>和<code>NaN</code>的情况，看起来是一样的值，实际上的比较是 false 的，所以要对这个特殊值进行处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">hasChanged</span>(<span class="params">oldValue, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> oldValue !== value &amp;&amp; !(<span class="built_in">Number</span>.isNaN(oldValue) &amp;&amp; <span class="built_in">Number</span>.isNaN(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们开始处理 set 了，我们就还要搞清楚<code>oldValue</code>和<code>value</code>是怎么处理的。对于前者，它就是我们现在响应式对象中的属性值，<code>target[key]</code>，value 则是本次传入的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hasChanged, isObject &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxyMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isReactive(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (proxyMap.get(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&quot;__isReative&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      track(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">      <span class="comment">// 处理hasChanged</span></span><br><span class="line">      <span class="keyword">let</span> oldValue = target[key];</span><br><span class="line">      <span class="keyword">if</span> (hasChanged(oldValue, value)) &#123;</span><br><span class="line">        trigger(target, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  proxyMap.set(target, proxy);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isReactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(target &amp;&amp; target.__isReative);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深层对象代理"><a href="#深层对象代理" class="headerlink" title="深层对象代理"></a>深层对象代理</h2><p>我们的响应式对象可能是多层嵌套的，首先这个在 vue2 中，它对于深层对象的处理方式是暴力遍历然后为每个对象赋上响应式。但在 vue3 中，对于这些深层对象是进行一个懒处理。也就是它没有对每个对象进行响应式处理，只对当前层次的对象进行响应式处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&quot;__isReative&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    track(target, key);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">    <span class="keyword">let</span> oldValue = target[key];</span><br><span class="line">    <span class="keyword">if</span> (hasChanged(oldValue, value)) &#123;</span><br><span class="line">      trigger(target, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是对象继续响应式处理，如果不是，就只处理当前层次</span></span><br><span class="line">    <span class="keyword">return</span> isObject(res) ? reactive(res) : res;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxyMap.set(target, proxy);</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observed1 = reactive(&#123;</span><br><span class="line">  <span class="attr">count1</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">count2</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">obj</span>: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observed2 = reactive(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">100</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;sum is:&quot;</span>, observed1.count1 + observed1.count2 + observed2.count);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;sum is:&quot;</span>, observed1.count1 + observed1.count2 + observed2.count);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="数组处理"><a href="#数组处理" class="headerlink" title="数组处理"></a>数组处理</h2><p>在 vue2 中，我们知道它是重写了数据的几个 api，然后拦截了数组进行处理，且因为 vue2 对<code>defineProperty</code>处理，性能的原因，我们修改数组下标和长度是没办法被检测的，但在 vue3 中 proxy 解决了这个问题。</p><p>在这一部分，对于数组的处理主要是避免 length 多次被触发，只有在值真正被改变了才去 trigger 这个 length</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">    <span class="keyword">let</span> oldLength = target.length;</span><br><span class="line">    <span class="keyword">let</span> oldValue = target[key];</span><br><span class="line">    <span class="keyword">if</span>(hasChanged(oldValue,value))&#123;</span><br><span class="line">        <span class="keyword">if</span>(isArray(target)&amp;&amp;hasChanged(oldLength,target.length))&#123;</span><br><span class="line">            trigger(target,<span class="string">&#x27;length&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        trigger(target, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isObject(res)?reactive(res):res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observed = (<span class="built_in">window</span>.observed = reactiv([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));</span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;index 4 is:&quot;</span>, observed[<span class="number">4</span>]);</span><br><span class="line">&#125;);</span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;length is:&quot;</span>, observed.length);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="嵌套-effect"><a href="#嵌套-effect" class="headerlink" title="嵌套 effect"></a>嵌套 effect</h2><p>说完了这些，剩下一个嵌套 effect 的部分，见例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observed = (<span class="built_in">window</span>.observed = reactive(&#123;</span><br><span class="line">  <span class="attr">count1</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">count2</span>: <span class="number">10</span>,</span><br><span class="line">&#125;));</span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;count2 is:&quot;</span>, observed.count2);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;count1 is:&quot;</span>, observed.count1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们可以来测试一下目前写的例子，会发现我们触发<code>count2</code>是正常的，触发<code>count1</code>是不正常的,没有打印出<code>count2</code>。</p><p>换句话说，就是内层依赖正常触发更新，但是外层依赖没有正确触发。这是为什么呢？这是因为，我们在执行副作用函数的时候，先执行了外层，之后再执行内层，此时外层的 effect 已经丢失了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = effectFn;</span><br><span class="line">      <span class="keyword">return</span> fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      activeEffect = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  effectFn();</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们要换个角度来说，就是要用数据结构去保存我们的<code>activeEffect</code>然后再结束的时候去弹出末尾的<code>activeEffect</code>并还原<code>activeEffect</code>为新的末尾项。</p><p>于是可以想到栈结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="keyword">const</span> effectStack = [];</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = effectFn;</span><br><span class="line">      effectStack.push(activeEffect);</span><br><span class="line">      <span class="keyword">return</span> fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      effectStack.pop();</span><br><span class="line">      activeEffect = effectStack[effectStack.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  effectFn();</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就解决了嵌套 effect 的问题</p><h2 id="完整-reactive"><a href="#完整-reactive" class="headerlink" title="完整 reactive"></a>完整 reactive</h2><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject, hasChanged, isArray &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"><span class="comment">// 存储proxy对象</span></span><br><span class="line"><span class="keyword">const</span> proxyMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 类型判断是否需要做响应式代理</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只能代理一次</span></span><br><span class="line">  <span class="keyword">if</span> (isReactive(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果已经有这个代理对象 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (proxyMap.get(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy</span></span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&quot;__isReactive&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      track(target, key);</span><br><span class="line">      <span class="comment">// 不需要对每层对象进行劫持，只对需要的对象进行。</span></span><br><span class="line">      <span class="keyword">return</span> isObject(res) ? reactive(res) : res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> oldLength = target.length;</span><br><span class="line">      <span class="keyword">const</span> oldValue = target[key];</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">      <span class="keyword">if</span> (hasChanged(oldValue, value)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isArray(target) &amp;&amp; hasChanged(oldLength, target.length)) &#123;</span><br><span class="line">          trigger(target, <span class="string">&quot;length&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        trigger(target, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  proxyMap.set(target, proxy);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isReactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(target &amp;&amp; target.__isReactive);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整 effect</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录当前正在执行的副作用函数</span></span><br><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="comment">// 使用一个栈记录当前正在执行的副作用</span></span><br><span class="line"><span class="keyword">const</span> effectStack = [];</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 因为是用户输入的fn可能有错要包裹</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = effectFn;</span><br><span class="line">      effectStack.push(activeEffect);</span><br><span class="line">      <span class="keyword">return</span> fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 执行完函数之后还原当前副作用</span></span><br><span class="line">      effectStack.pop();</span><br><span class="line">      <span class="comment">// 将外层副作用记录下来</span></span><br><span class="line">      activeEffect = effectStack[effectStack.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集依赖</span></span><br><span class="line"><span class="comment">// 存储我们的依赖</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// target是响应式对象 key是对象的属性</span></span><br><span class="line">  <span class="keyword">if</span> (!activeEffect) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> deps = depsMap.get(key);</span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    depsMap.set(key, (deps = <span class="keyword">new</span> <span class="built_in">Set</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  deps.add(activeEffect);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触发更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> deps = depsMap.get(key);</span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  deps.forEach(<span class="function">(<span class="params">effectFn</span>) =&gt;</span> &#123;</span><br><span class="line">    effectFn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>至此，我们的响应式就都已经处理完了，下面进入<code>ref</code>章节</p></div><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><p><code>ref</code>是 vue3 的一个新 api，目的是为了处理基本数据类型的响应式，访问<code>ref</code>处理过的数据需要使用<code>.value</code></p><p>有了前面<code>reactive</code>的基础，下面我们要实现<code>ref</code>api 就容易多了，例子如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = ref(<span class="number">1</span>);</span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo: &quot;</span>, foo.value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>首先<code>ref</code>返回的是一个<code>RefImpl</code>对象,这个对象接收的是<code>value</code>，拥有<code>get</code>和<code>set</code>两个方法，这之中它也是使用到了<code>track</code>和<code>trigger</code>去跟踪和更新值</p><p>其次它只对基础类型进行处理，其他情况交给<code>reactive</code>去做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&quot;./reactive&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回RefImpl对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RefImpl(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = convert(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    track(<span class="built_in">this</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = newValue;</span><br><span class="line">    trigger(<span class="built_in">this</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对不同类型的数据 使用reative或者ref</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isObject(value) ? reactive(value) : value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两点优化"><a href="#两点优化" class="headerlink" title="两点优化"></a>两点优化</h2><p>到了这一步其实已经做好了一个<code>ref</code>api，但是我们还需要对以下两点优化:</p><ol><li>已经 ref 过的数据不需要再进行响应式处理</li><li>如果前一次的值和后一次的值一样，不触发更新</li></ol><p>对于第一点，我们设置一个<code>isRef</code>函数即可。处理的方式和之前<code>isReactive</code>类似</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isRef</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(value &amp;&amp; value.__isRef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第二点，我们也是照样使用<code>hasChanged</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasChanged(newValue, <span class="built_in">this</span>._value)) &#123;</span><br><span class="line">        <span class="built_in">this</span>._value = convert(newValue);</span><br><span class="line">        <span class="comment">// trigger后置 因为值改变了才切换</span></span><br><span class="line">        trigger(<span class="built_in">this</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整-ref"><a href="#完整-ref" class="headerlink" title="完整 ref"></a>完整 ref</h2><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    hasChanged,</span><br><span class="line">    isObject</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    reactive</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./reactive&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    track,</span><br><span class="line">    trigger</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isRef(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RefImpl(value);·</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isRef</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !!(value &amp;&amp; value.__isRef)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.__isRef = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>._value = convert(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">        track(<span class="built_in">this</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasChanged(newValue, <span class="built_in">this</span>._value)) &#123;</span><br><span class="line">            <span class="built_in">this</span>._value = convert(newValue);</span><br><span class="line">            <span class="comment">// trigger后置 因为值改变了才切换</span></span><br><span class="line">            trigger(<span class="built_in">this</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isObject(value) ? reactive(value) : value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>那么至此对<code>ref</code>的处理也结束了，下面轮到<code>computed</code></p></div><h1 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h1><p>在这个模块开始我们不再详细的一步步写方法,以分析代码的方式走会比较容易理解.</p><p>在 vue3 中计算属性被归为了一个 api，因为不再像 vue2 一样，将<code>method</code>和<code>computed</code>分开，而是都组合在了一起，有点像又回到了一开始 js 编程的时候了。</p><p>例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = ref(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> sum = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="computed-机制"><a href="#computed-机制" class="headerlink" title="computed 机制"></a>computed 机制</h2><p>写这个 <code>computed</code> 之前,我们要明白 <code>computed</code> 的机制<br>使用了什么?</p><ol><li><code>computed</code> 使用了和 <code>effect</code> 相同的一套机制,但不同在于 <code>computed</code> 不会立刻触发</li><li><code>computed</code> 使用了 <code>track</code> 和 <code>trigger</code> 收集依赖和触发更新</li></ol><p>做了什么?</p><ol><li>调用了 <code>computed</code>,才返回更新值</li><li><code>computed</code> 中的依赖更新,computed 才能更新</li></ol><p>那么对于第一点,<code>computed</code> 不会立刻触发,那么触发的权力就是交给了调用 <code>computed</code> 的变量,这里拿 <code>sum</code> 作为例子.</p><p>本来我们的 <code>effect</code>,是在函数内部直接调用 <code>effectFn</code> 这个方法,返回触发的依赖,现在我们不需要直接调用 <code>effectFn</code>,我们需要将调用 <code>effectFn</code> 的权力交给我们的 <code>computed</code>,让他去调用然后获取更新值.所以我们需要一个变量去标识这个情况.</p><h2 id="lazy-懒处理-effectFn"><a href="#lazy-懒处理-effectFn" class="headerlink" title="lazy 懒处理 effectFn"></a>lazy 懒处理 effectFn</h2><p>也就是要在 <code>effect</code> 中增加一个 <code>option</code> 对象,传入的变量是 <code>lazy</code>,<code>lazy</code> 为真的时候,直接返回 <code>effectFn</code> 方法(<code>computed</code> 使用),<code>lazy</code> 为假或者不存在的时候,直接触发.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本来effect会直接执行,现在传入配置项让他根据配置项执行</span></span><br><span class="line"><span class="comment">// 增加option选项</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn, option = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = effectFn;</span><br><span class="line">      effectStack.push(activeEffect);</span><br><span class="line">      <span class="keyword">return</span> fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      effectStack.pop();</span><br><span class="line">      activeEffect = effectStack[effectStack.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// lazy为false的时候执行,否则就直接返回effectFn给computed自行操作</span></span><br><span class="line">  <span class="keyword">if</span> (!option.lazy) &#123;</span><br><span class="line">    effectFn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dirty-标识内部依赖是否更新"><a href="#dirty-标识内部依赖是否更新" class="headerlink" title="dirty 标识内部依赖是否更新"></a>dirty 标识内部依赖是否更新</h2><p>对于第二点,首先,<code>computed</code> 设计了一个 <code>dirty</code> 变量,用于标识内部依赖是否更新,默认为 <code>true</code>,所以我们第一次调用的时候他会拿到 <code>effect</code> 返回的 <code>effectFn</code> 并触发给<code>_value</code> 去缓存.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputedImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">getter</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存它的值</span></span><br><span class="line">    <span class="built_in">this</span>._value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 标识依赖是否更新</span></span><br><span class="line">    <span class="built_in">this</span>._dirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 区别在于computed不会立刻执行 effect会</span></span><br><span class="line">    <span class="comment">// 所以要拓展一下effect</span></span><br><span class="line">    <span class="built_in">this</span>.effect = effect(getter, &#123;</span><br><span class="line">      <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="comment">// 如果依赖更新了就要重新计算</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">      <span class="built_in">this</span>._value = <span class="built_in">this</span>.effect();</span><br><span class="line">      <span class="built_in">this</span>._dirty = <span class="literal">false</span>;</span><br><span class="line">      track(<span class="built_in">this</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="value-缓存依赖数据"><a href="#value-缓存依赖数据" class="headerlink" title="value 缓存依赖数据"></a>value 缓存依赖数据</h2><p>如果下次依赖没有更新我们直接返回<code>_value</code> 缓存的值.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">        <span class="built_in">this</span>._value = <span class="built_in">this</span>.effect();</span><br><span class="line">        <span class="built_in">this</span>._dirty = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接走_value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们下次内部依赖更新了之后怎么继续获得 <code>effectFn</code> 呢?</p><h2 id="scheduler-调度函数"><a href="#scheduler-调度函数" class="headerlink" title="scheduler 调度函数"></a>scheduler 调度函数</h2><p>这就要使用到调度函数,他的作用就是,当 <code>computed</code> 内部的依赖发生更新的时候,去通知 <code>computed</code> 改变 <code>dirty</code>,在下次调用 <code>sum</code> 的时候触发更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.effect = effect(getter, &#123;</span><br><span class="line">  <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 还要将dirty变为true 所以要用一个调度机制</span></span><br><span class="line">  <span class="comment">// 让他去触发更新的时候不是立即去执行getter,而是去执行调度程序</span></span><br><span class="line">  <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">      <span class="built_in">this</span>._dirty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>effect</code> 挂载这个 <code>scheduler</code> 并优先触发 <code>scheduler</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn,options=&#123;&#125;</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(!options.lazy)&#123;</span><br><span class="line">        effectFn();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 挂载在副作用函数上</span></span><br><span class="line">    effectFn.scheduler = options.scheduler;</span><br><span class="line">    <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target,key</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    deps.forEach(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 如果它有调度程序 优先执行 否则才去执行副作用函数本身</span></span><br><span class="line">        <span class="keyword">if</span>(effectFn.scheduler)&#123;</span><br><span class="line">            effectFn.scheduler(effectFn)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            effectFn();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决嵌套-effect"><a href="#解决嵌套-effect" class="headerlink" title="解决嵌套 effect"></a>解决嵌套 effect</h2><p>这下一个完整的 <code>computed</code> 已经做好了,但还是有一些不足的地方.比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sumRes = computed(<span class="function">() =&gt;</span> obj.foo + obj.bar);</span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在该副作用函数中读取 sumRes.value</span></span><br><span class="line">  <span class="built_in">console</span>.log(sumRes.value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改obj.foo的值</span></span><br><span class="line">obj.foo++;</span><br></pre></td></tr></table></figure><p>我们原意是修改 <code>obj</code> 的 <code>foo</code> 然后副作用函数重新执行,但做到这里,会发现修改 <code>foo</code> 的值并不会触发副作用函数的渲染.</p><p>回想一下我们的依赖数据结构,响应式对象的属性可以被多个副作用依赖,那么这个问题就很简单了,就是 <code>effect</code> 嵌套的问题,我们 <code>computed</code> 只收集了内部的 <code>effect</code> 作为依赖,并没有外层的这个 <code>effect</code>,自然就不触发更新了</p><p>解决办法也很简单,就是通过手动触发的方式,在我们计算属性所依赖的响应式数据发生变化的时候手动调用 <code>trigger</code> 触发更新,在每次读取结束就手动 <code>track</code> 响应式数据.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">getter, setter</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="built_in">this</span>.effect = effect(getter, &#123;</span><br><span class="line">        <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 还要将dirty变为true 所以要用一个调度机制</span></span><br><span class="line">        <span class="comment">// 让他去触发更新的时候不是立即去执行getter,而是去执行调度程序</span></span><br><span class="line">        <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">                <span class="built_in">this</span>._dirty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 手动trigger</span></span><br><span class="line">                trigger(<span class="built_in">this</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="comment">// 如果依赖更新了就要重新计算</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">        <span class="built_in">this</span>._value = <span class="built_in">this</span>.effect();</span><br><span class="line">        <span class="built_in">this</span>._dirty = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 手动track</span></span><br><span class="line">        track(<span class="built_in">this</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此综上所述,<code>computed</code> 比较关键的几个变量,<code>_value</code>,<code>lazy</code>,<code>_dirty</code> 和 <code>scheduler</code></p><h2 id="完整-computed"><a href="#完整-computed" class="headerlink" title="完整 computed"></a>完整 computed</h2><p>完整的 <code>computed</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isFunction &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; effect, track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">computed</span>(<span class="params">getterOrOption</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> getter, setter;</span><br><span class="line">  <span class="comment">// 判断是否是函数</span></span><br><span class="line">  <span class="keyword">if</span> (isFunction(getterOrOption)) &#123;</span><br><span class="line">    getter = getterOrOption;</span><br><span class="line">    setter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">&quot;computed is readonly&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = getterOrOption.get;</span><br><span class="line">    setter = getterOrOption.set;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ComputedImpl(getter, setter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputedImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">getter, setter</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存setter</span></span><br><span class="line">    <span class="built_in">this</span>._setter = setter;</span><br><span class="line">    <span class="comment">// 缓存它的值</span></span><br><span class="line">    <span class="built_in">this</span>._value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 标识依赖是否更新</span></span><br><span class="line">    <span class="built_in">this</span>._dirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 区别在于computed不会立刻执行 effect会</span></span><br><span class="line">    <span class="comment">// 所以要拓展一下effect</span></span><br><span class="line">    <span class="built_in">this</span>.effect = effect(getter, &#123;</span><br><span class="line">      <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 还要将dirty变为true 所以要用一个调度机制</span></span><br><span class="line">      <span class="comment">// 让他去触发更新的时候不是立即去执行getter,而是去执行调度程序</span></span><br><span class="line">      <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">          <span class="built_in">this</span>._dirty = <span class="literal">true</span>;</span><br><span class="line">          trigger(<span class="built_in">this</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="comment">// 如果依赖更新了就要重新计算</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">      <span class="built_in">this</span>._value = <span class="built_in">this</span>.effect();</span><br><span class="line">      <span class="built_in">this</span>._dirty = <span class="literal">false</span>;</span><br><span class="line">      track(<span class="built_in">this</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">    <span class="built_in">this</span>._setter(newValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="note primary flat"><p>那么至此reactive篇幅的全部内容都已经讲完，接下来会进入patch篇章研究vue是怎么设计并挂载节点到虚拟dom的</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>快速上手mongoose</title>
    <link href="https://zlinni.github.io/posts/1323151960/"/>
    <id>https://zlinni.github.io/posts/1323151960/</id>
    <published>2022-05-30T01:10:28.000Z</published>
    <updated>2022-05-30T02:19:21.444Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>Mongoose 是 MongoDB 的一个对象模型工具，是基于 node-mongodb-native 开发的 MongoDB nodejs 驱动，可以在异步的环境下执行。同时它也是针对 MongoDB 操作的一个对象模型库，封装了MongoDB 对文档的的一些增删改查等常用方法，让 NodeJS 操作 Mongodb 数据库变得更加灵活简单。<br>记录使用MongoDB非关系型数据库时，使用Express+Mongoose的操作。</p></div><h1 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h1><p>初始化项目之后复制如下到package.json安装即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;body-parser&quot;</span>: <span class="string">&quot;^1.20.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cors&quot;</span>: <span class="string">&quot;^2.8.5&quot;</span>,</span><br><span class="line">  <span class="string">&quot;express&quot;</span>: <span class="string">&quot;^4.18.1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;mongoose&quot;</span>: <span class="string">&quot;^6.3.4&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="express模板"><a href="#express模板" class="headerlink" title="express模板"></a>express模板</h1><p>由于只是演示操作，下列全部都写在了app.js中，具体使用按业务场景划分文件模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>); <span class="comment">// 引入body-parser模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>); <span class="comment">// 引入express模块</span></span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>); <span class="comment">// 引入cors模块</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(bodyParser.json()); <span class="comment">// 解析json数据格式</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;</span><br><span class="line">    <span class="attr">extended</span>: <span class="literal">true</span></span><br><span class="line">&#125;)); <span class="comment">// 解析form表单提交的数据application/x-www-form-urlencoded</span></span><br><span class="line">app.use(cors()); <span class="comment">// 注入cors模块解决跨域</span></span><br></pre></td></tr></table></figure></p><h1 id="mongoose模板"><a href="#mongoose模板" class="headerlink" title="mongoose模板"></a>mongoose模板</h1><p>分为几部分：</p><ol><li>引入mongoose</li><li>定义连接的数据库</li><li>连接数据库</li></ol><p>代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入mongoose</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br><span class="line"><span class="comment">//定义字符串常量</span></span><br><span class="line"><span class="keyword">const</span> db_url = <span class="string">&quot;mongodb://localhost:27017/miniprogram&quot;</span></span><br><span class="line"><span class="comment">//1.连接数据库</span></span><br><span class="line">mongoose.connect(db_url, &#123;</span><br><span class="line">    <span class="attr">useNewUrlParser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">useUnifiedTopology</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//2.连接成功</span></span><br><span class="line">mongoose.connection.on(<span class="string">&#x27;connected&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;连接成功：&#x27;</span>, db_url);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//3.连接失败</span></span><br><span class="line">mongoose.connection.on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;连接错误：&#x27;</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//4.断开连接</span></span><br><span class="line">mongoose.connection.on(<span class="string">&#x27;disconnection&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;断开连接&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="新建schema"><a href="#新建schema" class="headerlink" title="新建schema"></a>新建schema</h2><p>mongoose是封装过后的mongodb指令，它需要我们先新建一个schema，内部是所需的字段名称和类型。</p><p>下面是schema的介绍<br><div class="note primary flat"><p>Schema是一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力，仅仅只是定义数据库模型在程序片段中的一种表现，可以说是数据属性模型(传统意义的表结构)，又或着是“集合”的模型骨架。</p></div></p><p>代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> commoditiesSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    <span class="attr">_id</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">goods</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">Object</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">typeID</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">typeImage</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">typeTitle</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h2><p>模型的定义<br><div class="note primary flat"><p>模型(Model)是由Schema构造生成的模型，除了Schema定义的数据库骨架以外，还具有数据库操作的行为，类似于管理数据库属性、行为的类</p></div><br>第二步需要创建模型，如果数据库中没有这张表(复数名称)，则新建一张。</p><p>创建表名的规则是：传入的单词的复数，如果已经是复数，则使用复数</p><p>eg<br><code>food</code> -&gt; <code>foods</code></p><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引号内传入的是表名 自动转为复数</span></span><br><span class="line"><span class="keyword">const</span> commodities = mongoose.model(<span class="string">&#x27;commodities&#x27;</span>, commoditiesSchema);</span><br></pre></td></tr></table></figure></p><div class="note warning flat"><p>schema和model最好不要在接口里面写<br>原因1: 请求多次会由于利用了重复的模型报错(模型不允许overwrite)<br>原因2: 全局可复用</p></div><h1 id="查询find"><a href="#查询find" class="headerlink" title="查询find"></a>查询find</h1><p>mongoose中提供了几种查询方法，<code>find</code>、<code>findById</code>、<code>findOne</code>。都是模型的api，所以一定要新建模型</p><p><code>findById</code> 返回的结果是数组<br>需要传入两个参数，一个是对象包裹的id，可以是<code>_id</code>,第二个是一个回调函数，其中有两个参数<code>err</code>和<code>data</code>，返回查询的结果或者异常情况。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">commodities.findById(&#123;</span><br><span class="line">    _id</span><br><span class="line">&#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 一般返回三个值 code msg 和 result</span></span><br><span class="line">        res.json(&#123;</span><br><span class="line">            <span class="attr">code</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">result</span>: data</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><code>find</code> 返回的结果是数组<br>两种情况<br>第一种只传一个回调函数，则返回对应模型的全部字段值</p><p>第二种：<br>需要传入三个参数，第一个是对象包裹的查询条件，第二个是对象包裹的返回结果(用于筛选),key是模型的字段，value是1或者0，如果是1则返回该结果，如果是0则不返回，第三个是回调函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">commodities.find(&#123;</span><br><span class="line">    _id,</span><br><span class="line">&#125;,&#123;<span class="attr">goods</span>:<span class="number">1</span>&#125;,<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;查找异常&#x27;</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;data&#x27;</span>,data)</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            <span class="attr">result</span>:data</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>findOne</code>返回单个结果，是一个数据对象。也是可以传入三个参数，依据是否大量查询使用不同的指令对性能的影响可能不一样</p><h1 id="新增-创建实体"><a href="#新增-创建实体" class="headerlink" title="新增(创建实体)"></a>新增(创建实体)</h1><p>实体的定义如下<br><div class="note primary flat"><p>实体(Entity)是由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性。</p></div></p><p>新增需要建立实体，实体是根据模型建立的。实体中有save方法，可以让我们对数据库进行插入操作，也是传递一个回调参数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取query参数</span></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    addr,</span><br><span class="line">    name,</span><br><span class="line">    phone,</span><br><span class="line">    time</span><br><span class="line">&#125; = req.query;</span><br><span class="line"><span class="comment">//创建实体</span></span><br><span class="line"><span class="keyword">let</span> AddEntity = <span class="keyword">new</span> address(&#123;</span><br><span class="line">    addr,</span><br><span class="line">    name,</span><br><span class="line">    phone,</span><br><span class="line">    time</span><br><span class="line">&#125;)</span><br><span class="line">AddEntity.save(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;插入失败：&#x27;</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            <span class="attr">code</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">msg</span>: <span class="string">&#x27;插入成功&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="删除delete"><a href="#删除delete" class="headerlink" title="删除delete"></a>删除delete</h1><p>删除的操作是基于模型的，是模型中的方法<br>删除有两个方法，一个是<code>deleteOne</code>和<code>remove</code></p><p><code>deleteOne</code>传递两个参数，一个是查找条件，一个是回调函数</p><p>代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">address.deleteOne(&#123;</span><br><span class="line">    _id</span><br><span class="line">&#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;删除失败：&#x27;</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            <span class="attr">code</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">msg</span>: <span class="string">&#x27;删除成功&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="更新update"><a href="#更新update" class="headerlink" title="更新update"></a>更新update</h1><p>更新的操作是基于模型的，是模型的api</p><p><code>updateOne</code>方法，传入三个参数</p><ol><li>对象包裹的查询条件</li><li>对象包裹的更新数据</li><li>回调参数</li></ol><p>代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">address.updateOne(&#123;</span><br><span class="line">    _id</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    addr,</span><br><span class="line">    name,</span><br><span class="line">    phone,</span><br><span class="line">    time</span><br><span class="line">&#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;修改失败：&#x27;</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            <span class="attr">code</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">msg</span>: <span class="string">&#x27;修改成功&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>另外还有<code>findByIdAndUpdate</code>,<code>findOneAndUpdate</code>方法</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在mongoose操作中需要注意如果数据库中没有该表，会新建为复数名称的表，所以导入数据的时候应该在库建立好之后再考虑导入</p><p>如果已经有表，对应的规则在schema中也不能出错，否则返回错误类型的约束</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="nodejs" scheme="https://zlinni.github.io/tags/nodejs/"/>
    
    <category term="nosql" scheme="https://zlinni.github.io/tags/nosql/"/>
    
  </entry>
  
</feed>
