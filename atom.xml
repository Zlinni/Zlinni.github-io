<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鱼与前端🐟</title>
  
  <subtitle>摸鱼和工作不可得兼~</subtitle>
  <link href="https://zlinni.github.io/atom.xml" rel="self"/>
  
  <link href="https://zlinni.github.io/"/>
  <updated>2022-06-08T08:43:33.824Z</updated>
  <id>https://zlinni.github.io/</id>
  
  <author>
    <name>Zlinni</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从零开始的mini-vue②虚拟DOM篇</title>
    <link href="https://zlinni.github.io/posts/2797606246/"/>
    <id>https://zlinni.github.io/posts/2797606246/</id>
    <published>2022-06-06T02:26:33.000Z</published>
    <updated>2022-06-08T08:43:33.824Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是虚拟 DOM 篇，是关于 Vue3 中响应式的篇章，包含了<code>vnode</code>,<code>patch</code>,<code>diff</code>的实现</p></div><h1 id="vnode"><a href="#vnode" class="headerlink" title="vnode"></a>vnode</h1><p>本节中我们将会实现这样的例子(注意 html 中使用 <code>defer</code> 挂载 js，以及使用样式)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render, h, Text &#125; <span class="keyword">from</span> <span class="string">&quot;./runtime&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用h生成vnode</span></span><br><span class="line"><span class="keyword">const</span> vnode = h(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">class</span>: <span class="string">&quot;a b&quot;</span>,</span><br><span class="line">    <span class="attr">style</span>: &#123;</span><br><span class="line">      <span class="attr">border</span>: <span class="string">&quot;1px solid&quot;</span>,</span><br><span class="line">      <span class="attr">fontSize</span>: <span class="string">&quot;14px&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;click&quot;</span>),</span><br><span class="line">    <span class="attr">checked</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">custom</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  [</span><br><span class="line">    h(<span class="string">&quot;ul&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">      h(<span class="string">&quot;li&quot;</span>, &#123; <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span> &#125; &#125;, <span class="number">1</span>),</span><br><span class="line">      h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="number">2</span>),</span><br><span class="line">      h(<span class="string">&quot;li&quot;</span>, &#123; <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">&quot;blue&quot;</span> &#125; &#125;, <span class="number">3</span>),</span><br><span class="line">      h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, [h(Text, <span class="literal">null</span>, <span class="string">&quot;hello world&quot;</span>)]),</span><br><span class="line">    ]),</span><br><span class="line">  ]</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 将生成的vnode挂载到body上</span></span><br><span class="line">render(vnode, <span class="built_in">document</span>.body);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* &lt;style&gt;</span></span><br><span class="line"><span class="comment">  .a &#123;</span></span><br><span class="line"><span class="comment">    background-color: aqua;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  .b &#123;</span></span><br><span class="line"><span class="comment">    padding: 20px;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&lt;/style&gt; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们在完成这个例子之前，还是有必要了解一下虚拟 DOM 的种类</p><h1 id="虚拟-DOM-的种类"><a href="#虚拟-DOM-的种类" class="headerlink" title="虚拟 DOM 的种类"></a>虚拟 DOM 的种类</h1><ol><li>Element<br>element 对应普通元素，原理是使用 <code>document.createElement()</code>创建的。<code>type</code> 指的是标签名，<code>props</code> 指的是元素属性，<code>children</code> 指子元素，可以为字符串或者数组，为字符串的时候代表只有一个文本节点。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">props</span>:<span class="built_in">Object</span>,</span><br><span class="line">  <span class="attr">children</span>:<span class="built_in">string</span> | VNode[]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>:&#123;<span class="attr">class</span>:<span class="string">&#x27;a&#x27;</span>&#125;,</span><br><span class="line">  <span class="attr">children</span>:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Text<br>text 对应文本节点，原理是使用 <code>document.createTextNode()</code>创建的。<code>type</code> 定义为一个 <code>Symbol</code>，<code>props</code> 为空，<code>children</code> 为字符串，指具体的文本内容</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="built_in">Symbol</span>,</span><br><span class="line">  <span class="attr">props</span>:<span class="literal">null</span>,</span><br><span class="line">  <span class="attr">children</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Fragment<br>Fragment 为一个不会真实渲染的节点。相当于 <code>template</code> 或 <code>react</code> 的 Fragment。<code>type</code> 为一个 <code>Symbol</code>，<code>props</code> 为空，<code>children</code> 为一个数组，表示子节点。最后渲染的时候会挂载到 Fragment 的父节点上面。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="built_in">Symbol</span>,</span><br><span class="line">  <span class="attr">props</span>:<span class="literal">null</span>,</span><br><span class="line">  <span class="attr">children</span>:[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Component<br>Component 是组件，组件有自己的一套特殊的渲染方法，但组件最终的产物也是上面三种 VNode 的集合。组件的 <code>type</code>，就是定义组件的对象，<code>props</code> 即是外部传入组件的 <code>props</code> 数据，<code>children</code> 即是组件的 <code>slot</code>(不准备实现 <code>slot</code> 跳过)</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="built_in">Object</span>,</span><br><span class="line">  <span class="attr">props</span>:<span class="built_in">Object</span>,</span><br><span class="line">  <span class="attr">children</span>:<span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:&#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`&#123;&#123;msg&#125;&#125;&#123;&#123;name&#125;&#125;`</span>,</span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">props</span>:&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;world&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ShapeFlags-快速标识-VNode-的类型"><a href="#ShapeFlags-快速标识-VNode-的类型" class="headerlink" title="ShapeFlags 快速标识 VNode 的类型"></a>ShapeFlags 快速标识 VNode 的类型</h1><p><code>ShapeFlags</code> 是一组标记，用于快速辨识 VNode 的类型</p><h2 id="复习位运算"><a href="#复习位运算" class="headerlink" title="复习位运算"></a>复习位运算</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按位与运算 相同的不变 不同的为0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">&amp;</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// 按位或运算 相同的不变 不同的为1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">|</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="ShapeFlags-的生成"><a href="#ShapeFlags-的生成" class="headerlink" title="ShapeFlags 的生成"></a>ShapeFlags 的生成</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ShapeFlags = &#123;</span><br><span class="line">  <span class="attr">ELEMENT</span>: <span class="number">1</span>, <span class="comment">// 00000001</span></span><br><span class="line">  <span class="attr">TEXT</span>: <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">// 00000010</span></span><br><span class="line">  <span class="attr">FRAGMENT</span>: <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">// 00000100</span></span><br><span class="line">  <span class="attr">COMPONENT</span>: <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">// 00001000</span></span><br><span class="line">  <span class="attr">TEXT_CHILDREN</span>: <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">// 00010000</span></span><br><span class="line">  <span class="attr">ARRAY_CHILDREN</span>: <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">// 00100000</span></span><br><span class="line">  <span class="attr">CHILDREN</span>: (<span class="number">1</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">5</span>), <span class="comment">//00110000</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以发现他利用了二进制位运算<code>&lt;&lt;</code>和<code>|</code>生成，使用的时候用<code>&amp;</code>判断，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag &amp; ShapeFlags.ELEMENT)</span><br></pre></td></tr></table></figure><p>再例如，一个值为 33 的 flag，它的二进制值为 00100001，那么它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="number">33</span>;</span><br><span class="line">flag &amp; ShapeFlags.ELEMENT; <span class="comment">// true</span></span><br><span class="line">flag &amp; ShapeFlags.ARRAY_CHILDREN; <span class="comment">// true</span></span><br><span class="line">flag &amp; ShapeFlags.CHILDREN; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>它的生成还可以用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = ShapeFlags.ELEMENT | ShapeFlags.ARRAY_CHILDREN;</span><br></pre></td></tr></table></figure><h1 id="VNode-初步形态"><a href="#VNode-初步形态" class="headerlink" title="VNode 初步形态"></a>VNode 初步形态</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type,</span><br><span class="line">  props,</span><br><span class="line">  children,</span><br><span class="line">  shapeFlag,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="h-函数—生成-VNode"><a href="#h-函数—生成-VNode" class="headerlink" title="h 函数—生成 VNode"></a>h 函数—生成 VNode</h1><p><code>h</code> 函数的用途就是生成 VNode。<br>它接收三个参数：<code>type</code>, <code>props</code>, <code>children</code>, 返回一个 VNode</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isArray, isNumber, isString &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ShapeFlags = &#123;</span><br><span class="line">  <span class="attr">ELEMENT</span>: <span class="number">1</span>, <span class="comment">// 00000001</span></span><br><span class="line">  <span class="attr">TEXT</span>: <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">// 00000010</span></span><br><span class="line">  <span class="attr">FRAGMENT</span>: <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">// 00000100</span></span><br><span class="line">  <span class="attr">COMPONENT</span>: <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">// 00001000</span></span><br><span class="line">  <span class="attr">TEXT_CHILDREN</span>: <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">// 00010000</span></span><br><span class="line">  <span class="attr">ARRAY_CHILDREN</span>: <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">// 00100000</span></span><br><span class="line">  <span class="attr">CHILDREN</span>: (<span class="number">1</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">5</span>), <span class="comment">//00110000</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Text = <span class="built_in">Symbol</span>(<span class="string">&quot;Text&quot;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Fragment = <span class="built_in">Symbol</span>(<span class="string">&quot;Fragment&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String | Object | Text | Fragment&#125;</span> <span class="variable">type</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object | null&#125;</span> <span class="variable">props</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String | Number | Array | null&#125;</span> <span class="variable">children</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="variable">VNode</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">type, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断shapeFlag得到它的类型</span></span><br><span class="line">  <span class="keyword">let</span> shapeFlag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (isString(type)) &#123;</span><br><span class="line">    shapeFlag = ShapeFlags.ELEMENT;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === Text) &#123;</span><br><span class="line">    shapeFlag = ShapeFlags.TEXT;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === Fragment) &#123;</span><br><span class="line">    shapeFlag = ShapeFlags.FRAGMENT;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    shapeFlag = ShapeFlags.COMPONENT;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 再判断children</span></span><br><span class="line">  <span class="keyword">if</span> (isString(children) || isNumber(children)) &#123;</span><br><span class="line">    shapeFlag |= ShapeFlags.TEXT_CHILDREN;</span><br><span class="line">    <span class="comment">// 数字转字符串</span></span><br><span class="line">    children = children.toString();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(children)) &#123;</span><br><span class="line">    shapeFlag |= ShapeFlags.ARRAY_CHILDREN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    props,</span><br><span class="line">    children,</span><br><span class="line">    shapeFlag,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="render-挂载虚拟-DOM"><a href="#render-挂载虚拟-DOM" class="headerlink" title="render 挂载虚拟 DOM"></a>render 挂载虚拟 DOM</h1><p>这一步我们要将 <code>vnode</code> 中的 shapeFlag 解析并判断节点类型，根据不同的节点类型进行不同的挂载操作</p><p><code>render</code> 需要接收两个参数，一个是节点 <code>vnode</code>，一个是挂载的容器 <code>container</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isBoolean &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ShapeFlags &#125; <span class="keyword">from</span> <span class="string">&quot;./vnode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  mount(vnode, container);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 挂载虚拟dom</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 解析shapeFlag</span></span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ELEMENT) &#123;</span><br><span class="line">    mountElement(vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT) &#123;</span><br><span class="line">    mountTextNode(vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.FRAGMENT) &#123;</span><br><span class="line">    mountFragment(vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountComponent(vnode, container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，我们还要操作四种类型的挂载，分别是</p><ol><li>元素挂载 <code>mountElement</code></li><li>文本节点挂载 <code>mountTextNode</code></li><li>虚拟节点挂载 <code>mountFragment</code></li><li>组件挂载 <code>mountComponent</code></li></ol><h2 id="mountElement"><a href="#mountElement" class="headerlink" title="mountElement"></a>mountElement</h2><p>对于我们的 element 类型，我们也知道了他的底层是靠 <code>document.createElement</code> 方法来生成元素的，生成之后我们需要将 <code>props</code> 挂载到该元素上，再将子节点挂载到元素上，然后挂载到容器内。</p><p>综上所述分为以下几个步骤：</p><ol><li>生成元素 el</li><li>挂载 <code>props</code> 到 el <code>mountProps</code></li><li>挂载子节点到 el <code>mountChildren</code></li><li>挂载 el 到 <code>container</code></li></ol><p>代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountElement</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出元素 挂载元素 挂载props children</span></span><br><span class="line">  <span class="keyword">const</span> &#123; type, props &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">  <span class="comment">// 将props挂载到el上</span></span><br><span class="line">  mountProps(props, el);</span><br><span class="line">  <span class="comment">// 把节点挂载到el上</span></span><br><span class="line">  mountChildren(vnode, el);</span><br><span class="line">  container.appendChild(el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>mountProps</code> 和 <code>mountChildren</code>，我们先来做后者</p><h3 id="mountChildren"><a href="#mountChildren" class="headerlink" title="mountChildren"></a>mountChildren</h3><p>前面介绍 element 的时候我们讲到：</p><div class="note primary flat"><p>children 指子元素，可以为字符串或者数组，为字符串的时候代表只有一个文本节点。</p></div><p>所以我们就要对子元素的两种情况进行判断并挂载</p><p><code>mountChildren</code> 也是接收两个参数，一个是节点 <code>vnode</code>，一个是容器 <code>container</code></p><p>对于数组的操作我们递归调用挂载即可。对于字符串我们还需要编写挂载文本节点的情况，这个下面会讲到文本节点所以先掠过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountChildren</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag, children &#125; = vnode;</span><br><span class="line">  <span class="comment">// 文本节点</span></span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">    mountTextNode(vnode, container);</span><br><span class="line">    <span class="comment">// 数组的时候</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    <span class="comment">// 递归调用挂载</span></span><br><span class="line">    children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">      mount(child, container);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mountProps"><a href="#mountProps" class="headerlink" title="mountProps"></a>mountProps</h3><p><code>mountProps</code> 接收两个参数，一个是 <code>props</code> 渲染器，一个是生成的元素 <code>el</code></p><p>对于我们的 <code>props</code> 有以下几个种类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">class</span>: <span class="string">&#x27;a b&#x27;</span>,</span><br><span class="line">  <span class="attr">style</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    <span class="attr">fontSize</span>: <span class="string">&#x27;14px&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>),</span><br><span class="line">  <span class="attr">checked</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">custom</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先要分析一下我们有几种情况</p><ol><li><code>class</code> 字符串</li><li><code>style</code> 对象</li><li><code>event</code> 事件</li><li>其他属性</li></ol><p>那么来按点分析：</p><h4 id="class-字符串"><a href="#class-字符串" class="headerlink" title="class 字符串"></a>class 字符串</h4><p>如果是 <code>class</code>，直接赋 <code>className</code> 即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;class&#x27;</span>:</span><br><span class="line">    el.className = value;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h4 id="style-对象"><a href="#style-对象" class="headerlink" title="style 对象"></a>style 对象</h4><p>如果是 <code>style</code>，因为他是一个对象，所以我们要遍历这个 <code>style</code>，把对应的值赋给<code>el.style[styleName]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是style 遍历赋值value值</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;style&quot;</span>:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> styleName <span class="keyword">in</span> value) &#123;</span><br><span class="line">    el.style[styleName] = value[styleName];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h4 id="event-事件"><a href="#event-事件" class="headerlink" title="event 事件"></a>event 事件</h4><p>如果是事件，这里偷懒一下，只触发以 <code>on</code> 开头的事件，利用正则我们很快可以匹配上，再把 <code>Click</code> 变小写，然后利用<code>el.addEventListener(eventName, value);</code>这个 api 即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="regexp">/^on[^a-z]/</span>.test(key)) &#123;</span><br><span class="line">  <span class="keyword">const</span> eventName = key.slice(<span class="number">2</span>).toLowerCase();</span><br><span class="line">  el.addEventListener(eventName, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><p>如果是其他属性，这时候我们就要注意了，虽然一般情况下我们用<code>setAttribute</code>这个 <code>api</code>，就可以帮助我们设置属性以及属性对应的值，但是如果我们的属性是<code>value|checked|selected|muted|disabled</code>这几种，那么我们设置<code>true|false</code>的时候，他会被转换成字符串导致赋值失效。所以，我们要正则匹配这种情况，单独给他赋值这个属性<code>el[key] = value;</code></p><p>另外不仅如此,也可能存在没有赋值的情况，比如我只想让多选框选中，那么就给他<code>checked</code>，我们需要将他处理成 true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (domPropsRE.test(key)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (value === <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    value = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  el[key] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，我们设置成 <code>false</code> 或者 <code>null</code> 的时候，代表我们希望移除掉这个属性，所以要利用到 <code>removeAttribute</code>，最后的情况就是 <code>setAttribute</code> 了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span> || value === <span class="literal">false</span>) &#123;</span><br><span class="line">  el.removeAttribute(key);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  el.setAttribute(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> domPropsRE = <span class="regexp">/[A-Z]|^(value|checked|selected|muted|disabled)$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountProps</span>(<span class="params">props, el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = props[key];</span><br><span class="line">    <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">      <span class="comment">// 如果是class 直接赋className</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;class&quot;</span>:</span><br><span class="line">        el.className = value;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 如果是style 遍历赋值value值</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;style&quot;</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> styleName <span class="keyword">in</span> value) &#123;</span><br><span class="line">          el.style[styleName] = value[styleName];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 如果是事件，正则匹配on开头，并将后面的转为小写单词 然后添加事件</span></span><br><span class="line">      <span class="comment">// 如果是别的属性，分类判断，不能统一设置attribute</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/^on[^a-z]/</span>.test(key)) &#123;</span><br><span class="line">          <span class="keyword">const</span> eventName = key.slice(<span class="number">2</span>).toLowerCase();</span><br><span class="line">          el.addEventListener(eventName, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (domPropsRE.test(key)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (value === <span class="string">&quot;&quot;</span> &amp;&amp; isBoolean(el[key])) &#123;</span><br><span class="line">            value = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          el[key] = value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (value == <span class="literal">null</span> || value === <span class="literal">false</span>) &#123;</span><br><span class="line">            el.removeAttribute(key);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            el.setAttribute(key, value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>至此处理完了 <code>mountElement</code>，我们知道了 <code>element</code> 中对于子元素的处理为数组遍历和文本挂载，对于 <code>props</code> 的处理按四种大情况讨论，其中对于其他属性我们还要按照一般的属性和特殊的几种属性讨论，以及赋值的情况下给移除还是挂载。下面进入 <code>mountTextNode</code> 环节</p></div><h2 id="mountTextNode"><a href="#mountTextNode" class="headerlink" title="mountTextNode"></a>mountTextNode</h2><div class="note primary flat"><p>上面我们遗留了一个问题，就是关于子元素的文本节点处理的问题。</p></div><p>其实 <code>mountTextNode</code> 原理就是 <code>document.createTextNode()</code>，具体传入的内容是 <code>vnode</code>.<code>children</code>,因为我们前面讲到,<code>TEXT</code> 节点他的孩子就是具体的文本内容。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="built_in">Symbol</span>,</span><br><span class="line">  <span class="attr">props</span>:<span class="literal">null</span>,</span><br><span class="line">  <span class="attr">children</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountTextNode</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(vnode.children);</span><br><span class="line">  container.appendChild(textNode);</span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mountFragment"><a href="#mountFragment" class="headerlink" title="mountFragment"></a>mountFragment</h2><p>他本身不渲染，直接把父节点挂载上去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountFragment</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 本身不渲染 直接把父节点挂载上去</span></span><br><span class="line">  mountChildren(vnode, container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a>mountComponent</h2><p>暂时不写</p><div class="note primary flat"><p>至此我们的挂载虚拟 DOM 暂时完成，下面看我们的 <code>patch</code> 部分</p></div><h1 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/patch.png" alt=""></p><p><code>patch</code> 是对比新旧节点的算法，当新节点不存在的时候，执行卸载操作，当新节点存在的时候，进行对比</p><p>卸载操作需要判断对应节点的类型，如果是组件执行组件的卸载，如果是 <code>Fragment</code> 执行 <code>Fragment</code> 的卸载，最后到 <code>Text</code> 和 <code>Element</code> 执行 <code>removeChild</code></p><p><code>patch</code> 操作需要判断新旧节点的类型是否相同，不同的话就要卸载旧的节点将原有的节点树完全卸载掉。</p><p>然后再判断新节点<br>新节点是否是组件，如果是则进行 <code>processComponent</code>；</p><p>新节点如果是 <code>Text</code> 类型，执行 <code>processText</code>。之后再来判断旧节点是否存在，如果存在说明之前已经创建过旧的文本内容了，直接复用这个文本节点，更新他的 <code>textContent</code>，如果不存在旧节点，直接使用 <code>mountTextNode</code> 挂载文本节点</p><p>新节点如果是 <code>Fragment</code> 类型，就执行 <code>processFragment</code>，如果此时旧节点不存在，直接使用 <code>mountChildren</code>，如果旧节点存在就要进行 <code>diff</code></p><p>新节点最后就判断为 <code>Element</code> 类型，执行 <code>processElement</code>。之后来判断旧节点是否存在，如果不存在，直接使用 <code>mountElement</code> 对新节点进行挂载。如果存在，则要对他进行 <code>diff</code> 操作了。</p><p>因为此时新旧节点的 <code>type</code> 一样，就直接复用 <code>type</code>，只要对 <code>props</code> 和 <code>children</code> 进行 <code>diff</code></p><p>分析完了之后就开始准备写新的 <code>render</code> 函数了</p><h1 id="render"><a href="#render" class="headerlink" title="render"></a>render</h1><p>我们之前的 <code>render</code> 是挂载了一个节点，怎么才能产生新旧节点呢？</p><p>实际上我们只要将 <code>vnode</code> 挂载在 <code>container</code> 上面，下次进入的时候获取 <code>container</code> 上面的 <code>vnode</code>，此时这个 <code>vnode</code> 就是旧节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prevNode = container._vnode;</span><br><span class="line">  container._vnode = vnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来进行判断了，我们首先判断新节点存不存在。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prevNode = container._vnode;</span><br><span class="line">  <span class="keyword">if</span> (!vnode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevNode) &#123;</span><br><span class="line">      unmount(prevNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    patch(prevNode, vnode, container);</span><br><span class="line">  &#125;</span><br><span class="line">  container._vnode = vnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就要编写 <code>unmount</code> 和 <code>patch</code></p><h2 id="unmount"><a href="#unmount" class="headerlink" title="unmount"></a>unmount</h2><p>前面的情况就是利用 shapeflag 判断组件的卸载或 <code>fragment</code> 的卸载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params">vnode</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;shapeFlag,el&#125; = vnode;</span><br><span class="line">    <span class="keyword">if</span>(shapeFlag&amp;ShapeFlags.COMPONENT)&#123;</span><br><span class="line">        unmountComponent(vnode)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shapeFlag&amp;ShapeFlags.FRAGMENT)&#123;</span><br><span class="line">        unmountFragment(vnode)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      ...?</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们发现最后一种情况：对 <code>Text</code> 或 <code>Element</code> 进行 <code>removeChild</code> 的时候，没有获取到具体的 el，所以我们要从 <code>vnode</code> 里面拿 el，也就是要在 <code>vnode</code> 的返回值里面添加一个 el</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  type,</span><br><span class="line">  props,</span><br><span class="line">  children,</span><br><span class="line">  shapeFlag,</span><br><span class="line">  <span class="attr">el</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>且在挂载 <code>element</code> 和 <code>textnode</code> 之后需要将 el 挂载到 <code>vnode</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountElement</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出元素 挂载元素 挂载props children</span></span><br><span class="line">  <span class="keyword">const</span> &#123; type, props &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">  <span class="comment">// 将props挂载到el上</span></span><br><span class="line">  mountProps(props, el);</span><br><span class="line">  <span class="comment">// 把节点挂载到el上</span></span><br><span class="line">  mountChildren(vnode, el);</span><br><span class="line">  container.appendChild(el);</span><br><span class="line">  <span class="comment">// 保存el</span></span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountTextNode</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(vnode.children);</span><br><span class="line">  container.appendChild(textNode);</span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以现在最后一种情况应该这样写了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag, el &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.COMPONENT) &#123;</span><br><span class="line">    unmountComponent(vnode);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.FRAGMENT) &#123;</span><br><span class="line">    unmountFragment(vnode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其次是Text或者Element 但要拿到child节点</span></span><br><span class="line">    <span class="comment">// 所以要在vnode里面初始化一个el</span></span><br><span class="line">    el.parentNode.removeChild(el);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="patch-1"><a href="#patch-1" class="headerlink" title="patch"></a>patch</h2><p>接下来是实现 <code>patch</code> 的部分，要通过他判断新旧节点的类型是否相同，设置一个函数。然后分情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">prevVNode, vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode &amp;&amp; !isSameVNode(prevVNode,vnode)) &#123;</span><br><span class="line">    unmount(prevVNode);</span><br><span class="line">    <span class="comment">// 注意卸载之后要将节点设置为null</span></span><br><span class="line">    prevVNode = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.COMPONENT) &#123;</span><br><span class="line">    processComponent(prevVNode, vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT) &#123;</span><br><span class="line">    processText(prevVNode, vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.FRAGMENT) &#123;</span><br><span class="line">    processFragment(prevVNode, vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    processElement(prevVNode, vnode, container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSameVNode</span>(<span class="params">prevVNode, vnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prevVNode.type === vnode.type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后要处理剩下的四个函数 <code>processComponent，processText，processFragment，processElement</code></p><h3 id="processText"><a href="#processText" class="headerlink" title="processText"></a>processText</h3><p>存在旧节点的时候，复用旧节点的 <code>textContent</code>。否则执行 <code>mountTextNode</code>，这个前面也写过了。直接 cv 即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processText</span>(<span class="params">prevVNode, vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    vnode.el = prevVNode.el;</span><br><span class="line">    prevVNode.el.textContent = vnode.children;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountTextNode(vnode, container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountTextNode</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(vnode.children);</span><br><span class="line">  container.appendChild(textNode);</span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="processElement"><a href="#processElement" class="headerlink" title="processElement"></a>processElement</h3><p>对于存在旧节点的情况下调用 <code>patchElement</code> 进行 <code>diff</code> 比较，不存在的情况则调用原先写过的 <code>mountElement</code> 进行挂载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processElement</span>(<span class="params">prevVNode, vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    patchElement(prevVNode, vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountElement(vnode, container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的一点是 <code>mountChildren</code> 中我们之前是没有实现 <code>mount</code> 的，其实在这里用 <code>patch</code> 实现即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountChildren</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag, children &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">    mountTextNode(vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    <span class="comment">// 递归调用挂载</span></span><br><span class="line">    children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">      patch(<span class="literal">null</span>, child, container);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外就是 <code>patchElement</code>，因为此时新旧节点的 <code>type</code> 都是一样的，所以将旧节点的 el 赋值给新节点的 el，然后对比它们之间的 <code>props</code> 和 <code>children</code> 的异同。</p><h4 id="patchProps"><a href="#patchProps" class="headerlink" title="patchProps"></a>patchProps</h4><p>其中包含了两个函数一个是 <code>patchProps</code> 一个是 <code>patchChildren</code></p><p>对于 <code>patchProps</code>，回顾一下 <code>props</code> 的内容,他是一个对象里面有很多属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">class</span>: <span class="string">&#x27;a b&#x27;</span>,</span><br><span class="line">  <span class="attr">style</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    <span class="attr">fontSize</span>: <span class="string">&#x27;14px&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>),</span><br><span class="line">  <span class="attr">checked</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">custom</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们对于新旧节点的 <code>props</code>，需要取出对应的 <code>value</code> 值，对比是否相同，如果相同我们才去进行重新赋值。并且我们还要遍历旧属性，移除旧属性中有的，新属性中没有的。遍历新属性，添加旧属性没有的新属性有的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchProps</span>(<span class="params">oldProps, newProps, el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (oldProps === newProps) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 防止传过来的props是空 注意这里没有用到es6赋默认值的写法是因为他有可能传递的是null，es6默认值只能处理undefined的情况</span></span><br><span class="line">  oldProps = oldProps || &#123;&#125;;</span><br><span class="line">  newProps = newProps || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除旧属性有的，新属性没有的</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">    <span class="comment">// 当前属性是 &#x27;key&#x27; 则跳过</span></span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&quot;key&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newProps[key] == <span class="literal">null</span>) &#123;</span><br><span class="line">      patchDomProp(oldProps[key], <span class="literal">null</span>, key, el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加旧属性没有的，新属性有的</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&quot;key&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldProps[key] !== newProps[key]) &#123;</span><br><span class="line">      patchDomProp(oldProps[key], newProps[key], key, el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="patchDomProp"><a href="#patchDomProp" class="headerlink" title="patchDomProp"></a>patchDomProp</h5><p><code>patchDomProp</code> 这一步操作和我们之前写的 <code>mountProps</code> 有点类似。不过有几个细节要注意：</p><p>如果 <code>next</code> 是 <code>false</code> 或者是 <code>null</code> 的话，他就会变成字符串，而不是去掉，我们希望的是去掉。所以要写<code>el.className = next || &#39;&#39;</code></p><p>如果新旧属性中的 <code>style</code> 有不一致的，我们添加新的 <code>styleName</code>，移除不需要的 <code>styleName</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next为空直接移除</span></span><br><span class="line"><span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">  el.removeAttribute(<span class="string">&quot;style&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 我们添加新的 styleName</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> styleName <span class="keyword">in</span> next) &#123;</span><br><span class="line">    el.style[styleName] = next[styleName];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除不需要的 `styleName`。</span></span><br><span class="line">  <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> styleName <span class="keyword">in</span> prev) &#123;</span><br><span class="line">      <span class="keyword">if</span> (next[styleName] == <span class="literal">null</span>) &#123;</span><br><span class="line">        el.style[styleName] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果事件中存在旧事件，移除旧事件，如果存在新事件，添加新事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="regexp">/^on[^a-z]/</span>.test(key)) &#123;</span><br><span class="line">  <span class="keyword">const</span> eventName = key.slice(<span class="number">2</span>).toLowerCase();</span><br><span class="line">  <span class="comment">// 移除旧事件</span></span><br><span class="line">  <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">    el.removeEventListener(eventName, prev);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加新事件</span></span><br><span class="line">  <span class="keyword">if</span> (next) &#123;</span><br><span class="line">    el.addEventListener(eventName, next);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line">  <span class="comment">// 如果是class 直接赋className</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;class&quot;</span>:</span><br><span class="line">    el.className = next;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">// 如果是style 遍历赋值value值</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;style&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> styleName <span class="keyword">in</span> next) &#123;</span><br><span class="line">      el.style[styleName] = next[styleName];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> styleName <span class="keyword">in</span> prev) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next[styleName] == <span class="literal">null</span>) &#123;</span><br><span class="line">          el.style[styleName] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">// 如果是事件，正则匹配on开头，并将后面的转为小写单词 然后添加事件</span></span><br><span class="line">  <span class="comment">// 如果是别的属性，分类判断，不能统一设置attribute</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^on[^a-z]/</span>.test(key)) &#123;</span><br><span class="line">      <span class="keyword">const</span> eventName = key.slice(<span class="number">2</span>).toLowerCase();</span><br><span class="line">      <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">        el.removeEventListener(eventName, prev);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (next) &#123;</span><br><span class="line">        el.addEventListener(eventName, next);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (domPropsRE.test(key)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (next === <span class="string">&quot;&quot;</span> || isBoolean(el[key])) &#123;</span><br><span class="line">        next = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      el[key] = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (next == <span class="literal">null</span> || next === <span class="literal">false</span>) &#123;</span><br><span class="line">        el.removeAttribute(key);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el.setAttribute(key, next);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意此时我们已经可以利用 <code>patchProps</code> 取代 <code>mountProps</code> 了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountElement</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出元素 挂载元素 挂载props children</span></span><br><span class="line">  <span class="keyword">const</span> &#123; type, props &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">  <span class="comment">// 将props挂载到el上</span></span><br><span class="line">  <span class="comment">// mountProps(props, el);</span></span><br><span class="line">  <span class="keyword">if</span>(props)&#123;</span><br><span class="line">    patchProps(<span class="literal">null</span>, props, el);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把节点挂载到el上</span></span><br><span class="line">  mountChildren(vnode, el);</span><br><span class="line">  container.appendChild(el);</span><br><span class="line">  <span class="comment">// 保存el</span></span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="patchChildren"><a href="#patchChildren" class="headerlink" title="patchChildren"></a>patchChildren</h4><p>我们重新修改一下 mountChildren，让他的职责更加单一</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountElement</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出元素 挂载元素 挂载props children</span></span><br><span class="line">  <span class="keyword">const</span> &#123; type, props, shapeFlag, children &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">  <span class="comment">// 将props挂载到el上</span></span><br><span class="line">  <span class="comment">// mountProps(props, el);</span></span><br><span class="line">  patchProps(<span class="literal">null</span>, props, el);</span><br><span class="line">  <span class="comment">// 把节点挂载到el上</span></span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">    mountTextNode(vnode, el);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    mountChildren(children, el);</span><br><span class="line">  &#125;</span><br><span class="line">  container.appendChild(el);</span><br><span class="line">  <span class="comment">// 保存el</span></span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountChildren</span>(<span class="params">children, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归调用挂载</span></span><br><span class="line">  children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">    patch(<span class="literal">null</span>, child, container);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后开始写 patchChildren，这一部分中，我们需要对九种情况进行判断<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/patchChildren.jpg" alt=""></p><p>简单写一下模板大致如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchChildren</span>(<span class="params">prevVNode, vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">shapeFlag</span>: prevShapeFlag, <span class="attr">children</span>: c1 &#125; = prevVNode;</span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag, <span class="attr">children</span>: c2 &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">      container.textContent = c2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      unmountChildren(c1);</span><br><span class="line">      container.textContent = c2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      container.textContent = c2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">      container.textContent = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      mountChildren(c2, container);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      patchArrayChildren(c1, c2, container);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mountChildren(c2, container);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">      container.textContent = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      unmountChildren(c1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时剩下的 <code>unmountChildren</code> 和 <code>patchArrayChildren</code> 两个函数暂未实现，但是我们发现可以对这个模板做一个合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    unmountChildren(c1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c1 !== c2) &#123;</span><br><span class="line">    container.textContent = c2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面一段是 vue 源码的合并结构，虽然简介但是还是分情况比较好理解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    unmountChildren(c1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c2 !== c1) &#123;</span><br><span class="line">    container.textContent = c2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// c2 is array or null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    <span class="comment">// c1 was array</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      <span class="comment">// c2 is array</span></span><br><span class="line">      <span class="comment">// patchArrayChildren()</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// c2 is null</span></span><br><span class="line">      unmountChildren(c1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// c1 was text or null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">      container.textContent = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      mountChildren(c2, container, anchor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们编写 unmountChildren，其实他也就是遍历 children 然后卸载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unmountChildren</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">    unmount(child);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就到了 patchArrayChildren，这个部分</p><h5 id="patchArrayChildren"><a href="#patchArrayChildren" class="headerlink" title="patchArrayChildren"></a>patchArrayChildren</h5><p>举个例子，我们看他如何实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> n1 = h(<span class="string">&quot;ul&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">  h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;a&quot;</span>),</span><br><span class="line">  h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;b&quot;</span>),</span><br><span class="line">  h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;c&quot;</span>),</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> n2 = h(<span class="string">&quot;ul&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">  h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;d&quot;</span>),</span><br><span class="line">  h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;e&quot;</span>),</span><br><span class="line">  h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;f&quot;</span>),</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><blockquote><p>c1: a b c<br>c2: d e f</p><p>c1: a b c<br>c2: d e f g h</p><p>c1: a b c g h<br>c2: d e f</p></blockquote><p>对比新旧孩子，如果长度相同则执行 patch 对比，如果新孩子比旧孩子长则挂载新孩子多出来的部分，如果旧孩子比新孩子长则删除旧孩子多出来的部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchArrayChildren</span>(<span class="params">c1, c2, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldLength = c1.length;</span><br><span class="line">  <span class="keyword">const</span> newLength = c2.length;</span><br><span class="line">  <span class="keyword">const</span> commonLength = <span class="built_in">Math</span>.min(oldLength, newLength);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; commonLength; i++) &#123;</span><br><span class="line">    patch(c1[i], c2[i], container);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (oldLength &gt; newLength) &#123;</span><br><span class="line">    unmountChildren(c1.slice(commonLength));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldLength &lt; newLength) &#123;</span><br><span class="line">    mountChildren(c2.slice(commonLength), container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是处理 processFragment 了</p><h3 id="processFragment"><a href="#processFragment" class="headerlink" title="processFragment"></a>processFragment</h3><p>旧节点存在的时候对比新旧的孩子，不存在时候直接挂载新节点的孩子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processFragment</span>(<span class="params">prevVNode, vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    patchChildren(prevVNode, vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountChildren(vnode.children, container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render, Fragment, h &#125; <span class="keyword">from</span> <span class="string">&quot;./runtime&quot;</span>;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  h(<span class="string">&quot;ul&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;first&quot;</span>),</span><br><span class="line">    h(Fragment, <span class="literal">null</span>, []),</span><br><span class="line">    h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;last&quot;</span>),</span><br><span class="line">  ]),</span><br><span class="line">  <span class="built_in">document</span>.body</span><br><span class="line">);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  render(</span><br><span class="line">    h(<span class="string">&quot;ul&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">      h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;first&quot;</span>),</span><br><span class="line">      h(Fragment, <span class="literal">null</span>, [h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;middle&quot;</span>)]),</span><br><span class="line">      h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;last&quot;</span>),</span><br><span class="line">    ]),</span><br><span class="line">    <span class="built_in">document</span>.body</span><br><span class="line">  );</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>我们跑这个例子之前，知道这个 Fragment 节点应该是 2s 加入到 first 和 last 中间的，而实际的结果却是他到了最后面。</p><p>我们先分析一下原因：首先 patch 新旧节点，它们类型是相同的，是 Fragment，则进入 processFragment。此时旧节点不存在，执行 mountChildren，然后执行 patch，传的值是(null, child, container)，到 patch，此时孩子是一个元素节点，所以执行 processElement。之后 mountElement。</p><p>这一步就是问题所在了，mountElement 中，我们的 el 是直接挂载到 container 中的，也就是<code>container.appendChild(el);</code>代码。所以他被加到了最后面</p><p>为了解决这个问题我们要使用 anchor 属性。</p><h4 id="Anchor"><a href="#Anchor" class="headerlink" title="Anchor"></a>Anchor</h4><p>anchor 属性和 el 类似，因为 Fragment 节点之前挂载到的是容器，所以我们不知道应该在何处插入或者删除我们的 Fragment 节点，就要使用 el 和 anchor 生成节点然后就可以在这两个节点中间插入 Fragment。</p><p>所以我们要在 vnode 返回值里面添加 anchor</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  type,</span><br><span class="line">  props,</span><br><span class="line">  children,</span><br><span class="line">  shapeFlag,</span><br><span class="line">  <span class="attr">el</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">anchor</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后重新写一下 processFragment</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processFragment</span>(<span class="params">prevVNode, vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果旧节点的el存在就复用，anchor也是一样</span></span><br><span class="line">  <span class="keyword">const</span> fragmentStartAnchor = (vnode.el = prevVNode</span><br><span class="line">    ? prevVNode.el</span><br><span class="line">    : <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>));</span><br><span class="line">  <span class="keyword">const</span> fragmentEndAnchor = (vnode.anchor = prevVNode</span><br><span class="line">    ? prevVNode.anchor</span><br><span class="line">    : <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    patchChildren(prevVNode, vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    container.appendChild(fragmentStartAnchor);</span><br><span class="line">    container.appendChild(fragmentEndAnchor);</span><br><span class="line">    <span class="comment">// 传递anchor</span></span><br><span class="line">    mountChildren(vnode.children, container, fragmentEndAnchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，就需要在后续的地方增加 anchor 属性了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountChildren</span>(<span class="params">children, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归调用挂载</span></span><br><span class="line">  children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">    patch(<span class="literal">null</span>, child, container,anchor);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">prevVNode, vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode &amp;&amp; !isSameVNode(prevVNode,vnode)) &#123;</span><br><span class="line">    unmount(prevVNode);</span><br><span class="line">    prevVNode = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    shapeFlag</span><br><span class="line">  &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.COMPONENT) &#123;</span><br><span class="line">    processComponent(prevVNode, vnode, container,anchor);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT) &#123;</span><br><span class="line">    processText(prevVNode, vnode, container,anchor);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.FRAGMENT) &#123;</span><br><span class="line">    processFragment(prevVNode, vnode, container,anchor);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    processElement(prevVNode, vnode, container,anchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processElement</span>(<span class="params">prevVNode, vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    patchElement(prevVNode, vnode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountElement(vnode, container,anchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountElement</span>(<span class="params">vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出元素 挂载元素 挂载props children</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    props,</span><br><span class="line">    shapeFlag,</span><br><span class="line">    children</span><br><span class="line">  &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">  <span class="comment">// 将props挂载到el上</span></span><br><span class="line">  <span class="comment">// mountProps(props, el);</span></span><br><span class="line">  patchProps(<span class="literal">null</span>, props, el);</span><br><span class="line">  <span class="comment">// 把节点挂载到el上</span></span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">    mountTextNode(vnode, el);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    mountChildren(children, el);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// container.appendChild(el);</span></span><br><span class="line">  container.insertBefore(el,anchor);</span><br><span class="line">  <span class="comment">// 保存el</span></span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processText</span>(<span class="params">prevVNode, vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    vnode.el = prevVNode.el;</span><br><span class="line">    prevVNode.el.textContent = vnode.children;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountTextNode(vnode, container,anchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountTextNode</span>(<span class="params">vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(vnode.children);</span><br><span class="line">  <span class="comment">// container.appendChild(textNode);</span></span><br><span class="line">  container.insertBefore(textNode,anchor);</span><br><span class="line">  vnode.el = textNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processFragment</span>(<span class="params">prevVNode, vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fragmentStartAnchor = vnode.el = prevVNode ? prevVNode.el : <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> fragmentEndAnchor = vnode.anchor = prevVNode ? prevVNode.anchor : <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    <span class="comment">// 用fragmentEndAnchor作为他的anchor</span></span><br><span class="line">    patchChildren(prevVNode, vnode, container,fragmentEndAnchor);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 此处也要insertuu</span></span><br><span class="line">    container.insertBefore(fragmentStartAnchor,anchor)</span><br><span class="line">    container.insertBefore(fragmentEndAnchor,anchor)</span><br><span class="line">    mountChildren(vnode.children, container,fragmentEndAnchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>总之在需要 anchor 的节点都需要添加 anchor 属性，并且最后的时候需要替换 appendChild 为 insertBefore</p><p>之后我们编写遗留的 unmountFragment，这个函数本身我们可以用 unmountChildren 的形式来写，但是现在由于添加了 el 和 anchor 两个文本节点，所以我们要换种方式了。</p><p>思路大概就是将他们循环删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unmountFragment</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; <span class="attr">el</span>: cur, <span class="attr">anchor</span>: end &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> &#123; parentNode &#125; = cur;</span><br><span class="line">  <span class="keyword">while</span> (cur != end) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = cur.nextSibling;</span><br><span class="line">    parentNode.removeChild(cur);</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  parentNode.removeChild(end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时回去测试我们的用例，发现可以成功 patch 了。</p><p>最后还有一个小问题，就是关于 patchArrayChildren 里面的。我们看这么个例子</p><blockquote><p>h1, h1, h1<br>h1, h2, h1</p></blockquote><p>例如，对上面这个例子进行 patchChildren 第一次 patch 时，n2.el = n1.el，没有创建元素，anchor 没有用。 第二次 patch 时，先删除了 n1，对 n2 进行创建，执行 insertBefore，anchor 就需要设置为 n1 的下一个兄弟节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">prevVNode, vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode &amp;&amp; !isSameVNode(prevVNode,vnode)) &#123;</span><br><span class="line">    anchor = prevVNode.el.nextSibling;</span><br><span class="line">    unmount(prevVNode);</span><br><span class="line">    prevVNode = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果是</p><blockquote><p>h1, “” h1 “”,<br>h1 h1, h2, h1</p></blockquote><p>如果 n1 是 Fragment，那么 anchor 应该设置为 n1 的 anchor 的下一个兄弟节点。</p><p>所以不妨将两个情况合并为以下的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anchor = (prevVNode.anchor || prevVNode.el).nextSibling;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个部分的篇幅有点长，我们学到了初步的编写一个虚拟DOM并生成虚拟节点然后挂载，后面又学习了简单的patch方法来进行diff，下节进行核心diff的学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的mini-vue①--reactive篇</title>
    <link href="https://zlinni.github.io/posts/3451170570/"/>
    <id>https://zlinni.github.io/posts/3451170570/</id>
    <published>2022-05-30T02:33:04.000Z</published>
    <updated>2022-06-06T01:12:39.357Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是 reactive 篇，是关于 Vue3 中响应式的篇章，包含了<code>reactive</code>,<code>ref</code>,<code>computed</code>的实现</p></div><h1 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h1><p>项目使用 webpack 构建，demo 的代码放在<code>index.js</code>之中，将其打包成为<code>mini-vue.js</code>,之后<code>index.html</code>引入，控制台查看 demo 输出。</p><h1 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h1><p>Vue3 中的<code>reactive</code>用于处理对象数据，将引用类型的数据转化为响应式。其实它是由两个部分组成的，见例子。我们知道它由 <code>reactive</code> 和 <code>effect</code> 组成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observed = reactive(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">&#125;);</span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;observed.count is:&quot;</span>, observed.count);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们把这个 effect 叫做副作用函数，副作用函数的执行会影响其他变量或者函数的执行。这里它是作用是收集依赖，在依赖发生改变的时候触发更新。</p><p>它们两个是怎么产生联系的呢?核心是进行依赖收集 track 和触发依赖更新 trigger</p><p>依赖收集就是保存依赖和副作用之间的关系.</p><p>触发依赖更新就是当依赖变更的时候,找到并执行依赖它的副作用</p><p>我们知道了上述的操作，将它们分为两个部分进行编写，一是<code>reactive.js</code> 二是<code>effect.js</code></p><h2 id="reactive-部分"><a href="#reactive-部分" class="headerlink" title="reactive 部分"></a>reactive 部分</h2><p>刚才提及到，reactive 处理的是对象类型的数据，所以我们要编写一个方法判断对象</p><p>所以我们新建<code>utils</code>文件夹，写入<code>index.js</code>,用于编写我们的工具类方法</p><p>判断对象类型的数据的方法,需要注意的是由于<code>null</code>也会被判断为 object，所以要多加判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> funtcion <span class="function"><span class="title">isObject</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们要考虑怎么去将数据变为响应式。</p><p>学过 vue3 基础的都知道，vue3 使用的是 Proxy 来对响应式数据进行 track 和 trigger</p><p>proxy 接收两个参数，一个是 target 一个是 handler，前者是拦截的对象，后者是分为了 get 和 set 两步操作。</p><p>同时 get 接收三个参数，对象，需要拦截的属性 key，接收者 receiver</p><p>这个 receiver 指向原始读操作所在的对象，一般指的是 Proxy 实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, property, receiver</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> receiver;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">d.a === d; <span class="comment">// true</span></span><br><span class="line"><span class="comment">//d对象本身没有a属性，所以读取d.a的时候，会去d的原型proxy对象找。这时，receiver就指向d，代表原始的读操作所在的那个对象。</span></span><br></pre></td></tr></table></figure><p>set 接收四个参数，对象，需要拦截的属性，改变的 value 值，接收者 receiver。最后返回一个布尔值</p><p>我们还需要反射对象 Reflect，我们通过它可以获取对象上的某个指定属性的方法(get)，也可以去修改对象属性上的值(set)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">      track(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">      trigger(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们入手<code>effect.js</code></p><h2 id="effect-部分"><a href="#effect-部分" class="headerlink" title="effect 部分"></a>effect 部分</h2><p>我们在这个部分需要对副作用函数进行处理和剖析，以及对我们的 track 和 trigger 进行编写</p><p>首先我们需要拿到并执行这个副作用函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//todo</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  effectFn();</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是用户写的 effect，可能会报错，所以要用 try 来包裹住,且我们的 track 要收集我们的依赖，就要知道依赖有没有被执行，也就是有没有调用 effect 中的方法，所以我们要设计一个标识记录该方法。这里就用到全局变量<code>activeEffect</code>,去缓存我们的 effect，然后在执行完之后给它还原回去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = effectFn;</span><br><span class="line">      <span class="keyword">return</span> fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      activeEffect = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  effectFn();</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们要来写 track 和 trigger 部分，但我们得先考虑一下，我们依赖的数据结构应该怎么设计</p><p>先了解一下这样的一个执行过程：</p><p>副作用执行=&gt;副作用依赖的响应式对象改变=&gt;响应式对象改变=&gt;响应式对象的属性改变</p><p>且响应式对象的属性可以由多个副作用依赖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  响应式对象<span class="number">1</span>:&#123;</span><br><span class="line">    属性<span class="number">1</span>:[副作用<span class="number">1</span>，副作用<span class="number">2</span>，副作用<span class="number">3.</span>..],</span><br><span class="line">    属性<span class="number">2</span>:[副作用<span class="number">1</span>，副作用<span class="number">2</span>，副作用<span class="number">3.</span>..],</span><br><span class="line">  &#125;,</span><br><span class="line">  响应式对象<span class="number">2</span>:&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们就知道得先存储响应式对象，这里就使用<code>WeakMap</code>作为它的数据结构，这样的好处是里面的响应式对象在不被使用的时候会被垃圾回收。命名为<code>targetMap</code></p><p>再考虑响应式对象的属性，我们将他存放在一个<code>map</code>中，命名为<code>depsMap</code></p><p>接着是它的副作用，副作用存放在一个<code>set</code>中，因为可能有多个副作用依赖同样的属性，命名为<code>deps</code></p><p>这样，我们的结构就是如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">targetMap:&#123;</span><br><span class="line">  响应式对象(target):&#123;</span><br><span class="line">    <span class="attr">depsMap</span>:&#123;</span><br><span class="line">      属性(key):&#123;</span><br><span class="line">        <span class="attr">deps</span>:&#123;</span><br><span class="line">          副作用(activeEffect)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完依赖的数据结构之后，就可以开始写 track 了</p><p>我们现在再次了解一下 track 的作用:添加依赖，也就是要找到层级结构中的依赖，对此，我们进行下面写法。</p><h3 id="track-部分"><a href="#track-部分" class="headerlink" title="track 部分"></a>track 部分</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="comment">// track的作用是收集依赖</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果不是正在执行的依赖 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!activeEffect) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构建depsMap</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构建deps</span></span><br><span class="line">  <span class="keyword">let</span> deps = depsMap.get(key);</span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    depsMap.set(key, (deps = <span class="keyword">new</span> <span class="built_in">Set</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加依赖</span></span><br><span class="line">  deps.add(activeEffect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trigger-部分"><a href="#trigger-部分" class="headerlink" title="trigger 部分"></a>trigger 部分</h3><p>对于 trigger 部分，其实就是 track 的逆运算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trigger用于触发更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果它有副作用,才执行</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> deps = depsMap.get(key);</span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  deps.forEach(<span class="function">(<span class="params">effectFn</span>) =&gt;</span> &#123;</span><br><span class="line">    effectFn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此一个最简单的响应式已经设计好了,接下来我们通过一些特例,来处理特殊情况以及优化</p><h1 id="特例处理与优化"><a href="#特例处理与优化" class="headerlink" title="特例处理与优化"></a>特例处理与优化</h1><div class="note primary flat"><p>下面有六个特例，对应处理 reactive 的六种情况</p></div><ol><li><code>reactive(reactive(obj))</code></li><li><code>let a = reactive(obj), b = reactive(obj)</code></li><li><code>hasChanged</code></li><li>深层对象代理</li><li>数组</li><li>嵌套 effect</li></ol><h2 id="嵌套-reactive"><a href="#嵌套-reactive" class="headerlink" title="嵌套 reactive"></a>嵌套 reactive</h2><p><code>reactive(reactive(obj))</code></p><p>对于第一种情况，是同一个对象被多次响应式处理了。正常的情况应该是只处理一次。</p><p>我们可以给响应式对象添加一个<code>_isReactive</code>属性，依此来判断.</p><p>注意这里用了<code>!!</code>将结果转为 boolean</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isReactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(target &amp;&amp; target._isReactive);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断是否已经是响应式对象</span></span><br><span class="line">  <span class="keyword">if</span> (isReactive(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">      <span class="comment">//判断key是否为__isReactive</span></span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&quot;__isReactive&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      track(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">      trigger(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isReactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(target &amp;&amp; target.__isReactive);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多次对同个对象进行响应式处理"><a href="#多次对同个对象进行响应式处理" class="headerlink" title="多次对同个对象进行响应式处理"></a>多次对同个对象进行响应式处理</h2><div class="note primary flat"><p><code>let a = reactive(obj), b = reactive(obj)</code></p><p>这个可以说是和上面的特例优点类似，但是实际上的处理却不太一样。</p></div><p>对于第一个特例，我们是通过判断标识<code>__isReactive</code>来判断它是否被代理过，然后如果已经存在这个属性，则将其拦截为 true。</p><p>对于第二个特例，我们要通过一个数据结构来存储我们的响应式对象，当目标对象下次被响应式处理的时候，判断数据结构中是否有该响应式对象，有则直接返回该响应式对象。</p><!-- 所以这两个处理主要的区别在于，是否返回同样的响应式，对于第一种，多次嵌套，它返回的是嵌套内容，对于第二种，它返回的是处理过的响应式对象。 --><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"><span class="comment">// 创建proxyMap</span></span><br><span class="line"><span class="keyword">const</span> proxyMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isReactive(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有则直接返回该响应式对象</span></span><br><span class="line">  <span class="keyword">if</span> (proxyMap.get(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&quot;__isReative&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      track(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">      trigger(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 设置</span></span><br><span class="line">  proxyMap.set(target, proxy);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isReactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(target &amp;&amp; target.__isReative);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="响应式内容是否改变-懒处理不触发更新"><a href="#响应式内容是否改变-懒处理不触发更新" class="headerlink" title="响应式内容是否改变(懒处理不触发更新)"></a>响应式内容是否改变(懒处理不触发更新)</h2><p><code>hasChanged</code>是代表着响应式对象是否被改变的操作。在 vue3 中，如果响应式的数据和上一次的没有改变，则不触发更新</p><p>那么很快就知道入手点在 proxy 的 set 中了。不过在此之前我们得编写<code>hasChanged</code>函数,它需要对我们此次的值和上一次的值比较。</p><p>不过光是对比，很容易就遗留一个特殊情况，就是<code>NaN</code>和<code>NaN</code>的情况，看起来是一样的值，实际上的比较是 false 的，所以要对这个特殊值进行处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">hasChanged</span>(<span class="params">oldValue, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> oldValue !== value &amp;&amp; !(<span class="built_in">Number</span>.isNaN(oldValue) &amp;&amp; <span class="built_in">Number</span>.isNaN(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们开始处理 set 了，我们就还要搞清楚<code>oldValue</code>和<code>value</code>是怎么处理的。对于前者，它就是我们现在响应式对象中的属性值，<code>target[key]</code>，value 则是本次传入的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hasChanged, isObject &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxyMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isReactive(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (proxyMap.get(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&quot;__isReative&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      track(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">      <span class="comment">// 处理hasChanged</span></span><br><span class="line">      <span class="keyword">let</span> oldValue = target[key];</span><br><span class="line">      <span class="keyword">if</span> (hasChanged(oldValue, value)) &#123;</span><br><span class="line">        trigger(target, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  proxyMap.set(target, proxy);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isReactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(target &amp;&amp; target.__isReative);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深层对象代理"><a href="#深层对象代理" class="headerlink" title="深层对象代理"></a>深层对象代理</h2><p>我们的响应式对象可能是多层嵌套的，首先这个在 vue2 中，它对于深层对象的处理方式是暴力遍历然后为每个对象赋上响应式。但在 vue3 中，对于这些深层对象是进行一个懒处理。也就是它没有对每个对象进行响应式处理，只对当前层次的对象进行响应式处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&quot;__isReative&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    track(target, key);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">    <span class="keyword">let</span> oldValue = target[key];</span><br><span class="line">    <span class="keyword">if</span> (hasChanged(oldValue, value)) &#123;</span><br><span class="line">      trigger(target, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是对象继续响应式处理，如果不是，就只处理当前层次</span></span><br><span class="line">    <span class="keyword">return</span> isObject(res) ? reactive(res) : res;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxyMap.set(target, proxy);</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observed1 = reactive(&#123;</span><br><span class="line">  <span class="attr">count1</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">count2</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">obj</span>: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observed2 = reactive(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">100</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;sum is:&quot;</span>, observed1.count1 + observed1.count2 + observed2.count);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;sum is:&quot;</span>, observed1.count1 + observed1.count2 + observed2.count);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="数组处理"><a href="#数组处理" class="headerlink" title="数组处理"></a>数组处理</h2><p>在 vue2 中，我们知道它是重写了数据的几个 api，然后拦截了数组进行处理，且因为 vue2 对<code>defineProperty</code>处理，性能的原因，我们修改数组下标和长度是没办法被检测的，但在 vue3 中 proxy 解决了这个问题。</p><p>在这一部分，对于数组的处理主要是避免 length 多次被触发，只有在值真正被改变了才去 trigger 这个 length</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">    <span class="keyword">let</span> oldLength = target.length;</span><br><span class="line">    <span class="keyword">let</span> oldValue = target[key];</span><br><span class="line">    <span class="keyword">if</span>(hasChanged(oldValue,value))&#123;</span><br><span class="line">        <span class="keyword">if</span>(isArray(target)&amp;&amp;hasChanged(oldLength,target.length))&#123;</span><br><span class="line">            trigger(target,<span class="string">&#x27;length&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        trigger(target, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isObject(res)?reactive(res):res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observed = (<span class="built_in">window</span>.observed = reactiv([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));</span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;index 4 is:&quot;</span>, observed[<span class="number">4</span>]);</span><br><span class="line">&#125;);</span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;length is:&quot;</span>, observed.length);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="嵌套-effect"><a href="#嵌套-effect" class="headerlink" title="嵌套 effect"></a>嵌套 effect</h2><p>说完了这些，剩下一个嵌套 effect 的部分，见例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observed = (<span class="built_in">window</span>.observed = reactive(&#123;</span><br><span class="line">  <span class="attr">count1</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">count2</span>: <span class="number">10</span>,</span><br><span class="line">&#125;));</span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;count2 is:&quot;</span>, observed.count2);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;count1 is:&quot;</span>, observed.count1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们可以来测试一下目前写的例子，会发现我们触发<code>count2</code>是正常的，触发<code>count1</code>是不正常的,没有打印出<code>count2</code>。</p><p>换句话说，就是内层依赖正常触发更新，但是外层依赖没有正确触发。这是为什么呢？这是因为，我们在执行副作用函数的时候，先执行了外层，之后再执行内层，此时外层的 effect 已经丢失了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = effectFn;</span><br><span class="line">      <span class="keyword">return</span> fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      activeEffect = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  effectFn();</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们要换个角度来说，就是要用数据结构去保存我们的<code>activeEffect</code>然后再结束的时候去弹出末尾的<code>activeEffect</code>并还原<code>activeEffect</code>为新的末尾项。</p><p>于是可以想到栈结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="keyword">const</span> effectStack = [];</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = effectFn;</span><br><span class="line">      effectStack.push(activeEffect);</span><br><span class="line">      <span class="keyword">return</span> fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      effectStack.pop();</span><br><span class="line">      activeEffect = effectStack[effectStack.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  effectFn();</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就解决了嵌套 effect 的问题</p><h2 id="完整-reactive"><a href="#完整-reactive" class="headerlink" title="完整 reactive"></a>完整 reactive</h2><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject, hasChanged, isArray &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"><span class="comment">// 存储proxy对象</span></span><br><span class="line"><span class="keyword">const</span> proxyMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 类型判断是否需要做响应式代理</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只能代理一次</span></span><br><span class="line">  <span class="keyword">if</span> (isReactive(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果已经有这个代理对象 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (proxyMap.get(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy</span></span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&quot;__isReactive&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      track(target, key);</span><br><span class="line">      <span class="comment">// 不需要对每层对象进行劫持，只对需要的对象进行。</span></span><br><span class="line">      <span class="keyword">return</span> isObject(res) ? reactive(res) : res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> oldLength = target.length;</span><br><span class="line">      <span class="keyword">const</span> oldValue = target[key];</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">      <span class="keyword">if</span> (hasChanged(oldValue, value)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isArray(target) &amp;&amp; hasChanged(oldLength, target.length)) &#123;</span><br><span class="line">          trigger(target, <span class="string">&quot;length&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        trigger(target, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  proxyMap.set(target, proxy);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isReactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(target &amp;&amp; target.__isReactive);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整 effect</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录当前正在执行的副作用函数</span></span><br><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="comment">// 使用一个栈记录当前正在执行的副作用</span></span><br><span class="line"><span class="keyword">const</span> effectStack = [];</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 因为是用户输入的fn可能有错要包裹</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = effectFn;</span><br><span class="line">      effectStack.push(activeEffect);</span><br><span class="line">      <span class="keyword">return</span> fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 执行完函数之后还原当前副作用</span></span><br><span class="line">      effectStack.pop();</span><br><span class="line">      <span class="comment">// 将外层副作用记录下来</span></span><br><span class="line">      activeEffect = effectStack[effectStack.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集依赖</span></span><br><span class="line"><span class="comment">// 存储我们的依赖</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// target是响应式对象 key是对象的属性</span></span><br><span class="line">  <span class="keyword">if</span> (!activeEffect) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> deps = depsMap.get(key);</span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    depsMap.set(key, (deps = <span class="keyword">new</span> <span class="built_in">Set</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  deps.add(activeEffect);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触发更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> deps = depsMap.get(key);</span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  deps.forEach(<span class="function">(<span class="params">effectFn</span>) =&gt;</span> &#123;</span><br><span class="line">    effectFn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>至此，我们的响应式就都已经处理完了，下面进入<code>ref</code>章节</p></div><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><p><code>ref</code>是 vue3 的一个新 api，目的是为了处理基本数据类型的响应式，访问<code>ref</code>处理过的数据需要使用<code>.value</code></p><p>有了前面<code>reactive</code>的基础，下面我们要实现<code>ref</code>api 就容易多了，例子如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = ref(<span class="number">1</span>);</span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo: &quot;</span>, foo.value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>首先<code>ref</code>返回的是一个<code>RefImpl</code>对象,这个对象接收的是<code>value</code>，拥有<code>get</code>和<code>set</code>两个方法，这之中它也是使用到了<code>track</code>和<code>trigger</code>去跟踪和更新值</p><p>其次它只对基础类型进行处理，其他情况交给<code>reactive</code>去做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&quot;./reactive&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回RefImpl对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RefImpl(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = convert(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    track(<span class="built_in">this</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = newValue;</span><br><span class="line">    trigger(<span class="built_in">this</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对不同类型的数据 使用reative或者ref</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isObject(value) ? reactive(value) : value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两点优化"><a href="#两点优化" class="headerlink" title="两点优化"></a>两点优化</h2><p>到了这一步其实已经做好了一个<code>ref</code>api，但是我们还需要对以下两点优化:</p><ol><li>已经 ref 过的数据不需要再进行响应式处理</li><li>如果前一次的值和后一次的值一样，不触发更新</li></ol><p>对于第一点，我们设置一个<code>isRef</code>函数即可。处理的方式和之前<code>isReactive</code>类似</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isRef</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(value &amp;&amp; value.__isRef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第二点，我们也是照样使用<code>hasChanged</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasChanged(newValue, <span class="built_in">this</span>._value)) &#123;</span><br><span class="line">        <span class="built_in">this</span>._value = convert(newValue);</span><br><span class="line">        <span class="comment">// trigger后置 因为值改变了才切换</span></span><br><span class="line">        trigger(<span class="built_in">this</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整-ref"><a href="#完整-ref" class="headerlink" title="完整 ref"></a>完整 ref</h2><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    hasChanged,</span><br><span class="line">    isObject</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    reactive</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./reactive&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    track,</span><br><span class="line">    trigger</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isRef(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RefImpl(value);·</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isRef</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !!(value &amp;&amp; value.__isRef)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.__isRef = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>._value = convert(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">        track(<span class="built_in">this</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasChanged(newValue, <span class="built_in">this</span>._value)) &#123;</span><br><span class="line">            <span class="built_in">this</span>._value = convert(newValue);</span><br><span class="line">            <span class="comment">// trigger后置 因为值改变了才切换</span></span><br><span class="line">            trigger(<span class="built_in">this</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isObject(value) ? reactive(value) : value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>那么至此对<code>ref</code>的处理也结束了，下面轮到<code>computed</code></p></div><h1 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h1><p>在这个模块开始我们不再详细的一步步写方法,以分析代码的方式走会比较容易理解.</p><p>在 vue3 中计算属性被归为了一个 api，因为不再像 vue2 一样，将<code>method</code>和<code>computed</code>分开，而是都组合在了一起，有点像又回到了一开始 js 编程的时候了。</p><p>例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = ref(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> sum = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="computed-机制"><a href="#computed-机制" class="headerlink" title="computed 机制"></a>computed 机制</h2><p>写这个 <code>computed</code> 之前,我们要明白 <code>computed</code> 的机制<br>使用了什么?</p><ol><li><code>computed</code> 使用了和 <code>effect</code> 相同的一套机制,但不同在于 <code>computed</code> 不会立刻触发</li><li><code>computed</code> 使用了 <code>track</code> 和 <code>trigger</code> 收集依赖和触发更新</li></ol><p>做了什么?</p><ol><li>调用了 <code>computed</code>,才返回更新值</li><li><code>computed</code> 中的依赖更新,computed 才能更新</li></ol><p>那么对于第一点,<code>computed</code> 不会立刻触发,那么触发的权力就是交给了调用 <code>computed</code> 的变量,这里拿 <code>sum</code> 作为例子.</p><p>本来我们的 <code>effect</code>,是在函数内部直接调用 <code>effectFn</code> 这个方法,返回触发的依赖,现在我们不需要直接调用 <code>effectFn</code>,我们需要将调用 <code>effectFn</code> 的权力交给我们的 <code>computed</code>,让他去调用然后获取更新值.所以我们需要一个变量去标识这个情况.</p><h2 id="lazy-懒处理-effectFn"><a href="#lazy-懒处理-effectFn" class="headerlink" title="lazy 懒处理 effectFn"></a>lazy 懒处理 effectFn</h2><p>也就是要在 <code>effect</code> 中增加一个 <code>option</code> 对象,传入的变量是 <code>lazy</code>,<code>lazy</code> 为真的时候,直接返回 <code>effectFn</code> 方法(<code>computed</code> 使用),<code>lazy</code> 为假或者不存在的时候,直接触发.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本来effect会直接执行,现在传入配置项让他根据配置项执行</span></span><br><span class="line"><span class="comment">// 增加option选项</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn, option = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = effectFn;</span><br><span class="line">      effectStack.push(activeEffect);</span><br><span class="line">      <span class="keyword">return</span> fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      effectStack.pop();</span><br><span class="line">      activeEffect = effectStack[effectStack.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// lazy为false的时候执行,否则就直接返回effectFn给computed自行操作</span></span><br><span class="line">  <span class="keyword">if</span> (!option.lazy) &#123;</span><br><span class="line">    effectFn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dirty-标识内部依赖是否更新"><a href="#dirty-标识内部依赖是否更新" class="headerlink" title="dirty 标识内部依赖是否更新"></a>dirty 标识内部依赖是否更新</h2><p>对于第二点,首先,<code>computed</code> 设计了一个 <code>dirty</code> 变量,用于标识内部依赖是否更新,默认为 <code>true</code>,所以我们第一次调用的时候他会拿到 <code>effect</code> 返回的 <code>effectFn</code> 并触发给<code>_value</code> 去缓存.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputedImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">getter</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存它的值</span></span><br><span class="line">    <span class="built_in">this</span>._value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 标识依赖是否更新</span></span><br><span class="line">    <span class="built_in">this</span>._dirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 区别在于computed不会立刻执行 effect会</span></span><br><span class="line">    <span class="comment">// 所以要拓展一下effect</span></span><br><span class="line">    <span class="built_in">this</span>.effect = effect(getter, &#123;</span><br><span class="line">      <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="comment">// 如果依赖更新了就要重新计算</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">      <span class="built_in">this</span>._value = <span class="built_in">this</span>.effect();</span><br><span class="line">      <span class="built_in">this</span>._dirty = <span class="literal">false</span>;</span><br><span class="line">      track(<span class="built_in">this</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="value-缓存依赖数据"><a href="#value-缓存依赖数据" class="headerlink" title="value 缓存依赖数据"></a>value 缓存依赖数据</h2><p>如果下次依赖没有更新我们直接返回<code>_value</code> 缓存的值.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">        <span class="built_in">this</span>._value = <span class="built_in">this</span>.effect();</span><br><span class="line">        <span class="built_in">this</span>._dirty = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接走_value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们下次内部依赖更新了之后怎么继续获得 <code>effectFn</code> 呢?</p><h2 id="scheduler-调度函数"><a href="#scheduler-调度函数" class="headerlink" title="scheduler 调度函数"></a>scheduler 调度函数</h2><p>这就要使用到调度函数,他的作用就是,当 <code>computed</code> 内部的依赖发生更新的时候,去通知 <code>computed</code> 改变 <code>dirty</code>,在下次调用 <code>sum</code> 的时候触发更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.effect = effect(getter, &#123;</span><br><span class="line">  <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 还要将dirty变为true 所以要用一个调度机制</span></span><br><span class="line">  <span class="comment">// 让他去触发更新的时候不是立即去执行getter,而是去执行调度程序</span></span><br><span class="line">  <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">      <span class="built_in">this</span>._dirty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>effect</code> 挂载这个 <code>scheduler</code> 并优先触发 <code>scheduler</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn,options=&#123;&#125;</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(!options.lazy)&#123;</span><br><span class="line">        effectFn();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 挂载在副作用函数上</span></span><br><span class="line">    effectFn.scheduler = options.scheduler;</span><br><span class="line">    <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target,key</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    deps.forEach(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 如果它有调度程序 优先执行 否则才去执行副作用函数本身</span></span><br><span class="line">        <span class="keyword">if</span>(effectFn.scheduler)&#123;</span><br><span class="line">            effectFn.scheduler(effectFn)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            effectFn();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决嵌套-effect"><a href="#解决嵌套-effect" class="headerlink" title="解决嵌套 effect"></a>解决嵌套 effect</h2><p>这下一个完整的 <code>computed</code> 已经做好了,但还是有一些不足的地方.比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sumRes = computed(<span class="function">() =&gt;</span> obj.foo + obj.bar);</span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在该副作用函数中读取 sumRes.value</span></span><br><span class="line">  <span class="built_in">console</span>.log(sumRes.value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改obj.foo的值</span></span><br><span class="line">obj.foo++;</span><br></pre></td></tr></table></figure><p>我们原意是修改 <code>obj</code> 的 <code>foo</code> 然后副作用函数重新执行,但做到这里,会发现修改 <code>foo</code> 的值并不会触发副作用函数的渲染.</p><p>回想一下我们的依赖数据结构,响应式对象的属性可以被多个副作用依赖,那么这个问题就很简单了,就是 <code>effect</code> 嵌套的问题,我们 <code>computed</code> 只收集了内部的 <code>effect</code> 作为依赖,并没有外层的这个 <code>effect</code>,自然就不触发更新了</p><p>解决办法也很简单,就是通过手动触发的方式,在我们计算属性所依赖的响应式数据发生变化的时候手动调用 <code>trigger</code> 触发更新,在每次读取结束就手动 <code>track</code> 响应式数据.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">getter, setter</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="built_in">this</span>.effect = effect(getter, &#123;</span><br><span class="line">        <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 还要将dirty变为true 所以要用一个调度机制</span></span><br><span class="line">        <span class="comment">// 让他去触发更新的时候不是立即去执行getter,而是去执行调度程序</span></span><br><span class="line">        <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">                <span class="built_in">this</span>._dirty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 手动trigger</span></span><br><span class="line">                trigger(<span class="built_in">this</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="comment">// 如果依赖更新了就要重新计算</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">        <span class="built_in">this</span>._value = <span class="built_in">this</span>.effect();</span><br><span class="line">        <span class="built_in">this</span>._dirty = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 手动track</span></span><br><span class="line">        track(<span class="built_in">this</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此综上所述,<code>computed</code> 比较关键的几个变量,<code>_value</code>,<code>lazy</code>,<code>_dirty</code> 和 <code>scheduler</code></p><h2 id="完整-computed"><a href="#完整-computed" class="headerlink" title="完整 computed"></a>完整 computed</h2><p>完整的 <code>computed</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isFunction &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; effect, track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">computed</span>(<span class="params">getterOrOption</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> getter, setter;</span><br><span class="line">  <span class="comment">// 判断是否是函数</span></span><br><span class="line">  <span class="keyword">if</span> (isFunction(getterOrOption)) &#123;</span><br><span class="line">    getter = getterOrOption;</span><br><span class="line">    setter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">&quot;computed is readonly&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = getterOrOption.get;</span><br><span class="line">    setter = getterOrOption.set;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ComputedImpl(getter, setter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputedImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">getter, setter</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存setter</span></span><br><span class="line">    <span class="built_in">this</span>._setter = setter;</span><br><span class="line">    <span class="comment">// 缓存它的值</span></span><br><span class="line">    <span class="built_in">this</span>._value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 标识依赖是否更新</span></span><br><span class="line">    <span class="built_in">this</span>._dirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 区别在于computed不会立刻执行 effect会</span></span><br><span class="line">    <span class="comment">// 所以要拓展一下effect</span></span><br><span class="line">    <span class="built_in">this</span>.effect = effect(getter, &#123;</span><br><span class="line">      <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 还要将dirty变为true 所以要用一个调度机制</span></span><br><span class="line">      <span class="comment">// 让他去触发更新的时候不是立即去执行getter,而是去执行调度程序</span></span><br><span class="line">      <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">          <span class="built_in">this</span>._dirty = <span class="literal">true</span>;</span><br><span class="line">          trigger(<span class="built_in">this</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="comment">// 如果依赖更新了就要重新计算</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">      <span class="built_in">this</span>._value = <span class="built_in">this</span>.effect();</span><br><span class="line">      <span class="built_in">this</span>._dirty = <span class="literal">false</span>;</span><br><span class="line">      track(<span class="built_in">this</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">    <span class="built_in">this</span>._setter(newValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="note primary flat"><p>那么至此reactive篇幅的全部内容都已经讲完，接下来会进入patch篇章研究vue是怎么设计并挂载节点到虚拟dom的</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>快速上手mongoose</title>
    <link href="https://zlinni.github.io/posts/1323151960/"/>
    <id>https://zlinni.github.io/posts/1323151960/</id>
    <published>2022-05-30T01:10:28.000Z</published>
    <updated>2022-05-30T02:19:21.444Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>Mongoose 是 MongoDB 的一个对象模型工具，是基于 node-mongodb-native 开发的 MongoDB nodejs 驱动，可以在异步的环境下执行。同时它也是针对 MongoDB 操作的一个对象模型库，封装了MongoDB 对文档的的一些增删改查等常用方法，让 NodeJS 操作 Mongodb 数据库变得更加灵活简单。<br>记录使用MongoDB非关系型数据库时，使用Express+Mongoose的操作。</p></div><h1 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h1><p>初始化项目之后复制如下到package.json安装即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;body-parser&quot;</span>: <span class="string">&quot;^1.20.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cors&quot;</span>: <span class="string">&quot;^2.8.5&quot;</span>,</span><br><span class="line">  <span class="string">&quot;express&quot;</span>: <span class="string">&quot;^4.18.1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;mongoose&quot;</span>: <span class="string">&quot;^6.3.4&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="express模板"><a href="#express模板" class="headerlink" title="express模板"></a>express模板</h1><p>由于只是演示操作，下列全部都写在了app.js中，具体使用按业务场景划分文件模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>); <span class="comment">// 引入body-parser模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>); <span class="comment">// 引入express模块</span></span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>); <span class="comment">// 引入cors模块</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(bodyParser.json()); <span class="comment">// 解析json数据格式</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;</span><br><span class="line">    <span class="attr">extended</span>: <span class="literal">true</span></span><br><span class="line">&#125;)); <span class="comment">// 解析form表单提交的数据application/x-www-form-urlencoded</span></span><br><span class="line">app.use(cors()); <span class="comment">// 注入cors模块解决跨域</span></span><br></pre></td></tr></table></figure></p><h1 id="mongoose模板"><a href="#mongoose模板" class="headerlink" title="mongoose模板"></a>mongoose模板</h1><p>分为几部分：</p><ol><li>引入mongoose</li><li>定义连接的数据库</li><li>连接数据库</li></ol><p>代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入mongoose</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br><span class="line"><span class="comment">//定义字符串常量</span></span><br><span class="line"><span class="keyword">const</span> db_url = <span class="string">&quot;mongodb://localhost:27017/miniprogram&quot;</span></span><br><span class="line"><span class="comment">//1.连接数据库</span></span><br><span class="line">mongoose.connect(db_url, &#123;</span><br><span class="line">    <span class="attr">useNewUrlParser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">useUnifiedTopology</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//2.连接成功</span></span><br><span class="line">mongoose.connection.on(<span class="string">&#x27;connected&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;连接成功：&#x27;</span>, db_url);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//3.连接失败</span></span><br><span class="line">mongoose.connection.on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;连接错误：&#x27;</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//4.断开连接</span></span><br><span class="line">mongoose.connection.on(<span class="string">&#x27;disconnection&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;断开连接&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="新建schema"><a href="#新建schema" class="headerlink" title="新建schema"></a>新建schema</h2><p>mongoose是封装过后的mongodb指令，它需要我们先新建一个schema，内部是所需的字段名称和类型。</p><p>下面是schema的介绍<br><div class="note primary flat"><p>Schema是一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力，仅仅只是定义数据库模型在程序片段中的一种表现，可以说是数据属性模型(传统意义的表结构)，又或着是“集合”的模型骨架。</p></div></p><p>代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> commoditiesSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    <span class="attr">_id</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">goods</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">Object</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">typeID</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">typeImage</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">typeTitle</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h2><p>模型的定义<br><div class="note primary flat"><p>模型(Model)是由Schema构造生成的模型，除了Schema定义的数据库骨架以外，还具有数据库操作的行为，类似于管理数据库属性、行为的类</p></div><br>第二步需要创建模型，如果数据库中没有这张表(复数名称)，则新建一张。</p><p>创建表名的规则是：传入的单词的复数，如果已经是复数，则使用复数</p><p>eg<br><code>food</code> -&gt; <code>foods</code></p><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引号内传入的是表名 自动转为复数</span></span><br><span class="line"><span class="keyword">const</span> commodities = mongoose.model(<span class="string">&#x27;commodities&#x27;</span>, commoditiesSchema);</span><br></pre></td></tr></table></figure></p><div class="note warning flat"><p>schema和model最好不要在接口里面写<br>原因1: 请求多次会由于利用了重复的模型报错(模型不允许overwrite)<br>原因2: 全局可复用</p></div><h1 id="查询find"><a href="#查询find" class="headerlink" title="查询find"></a>查询find</h1><p>mongoose中提供了几种查询方法，<code>find</code>、<code>findById</code>、<code>findOne</code>。都是模型的api，所以一定要新建模型</p><p><code>findById</code> 返回的结果是数组<br>需要传入两个参数，一个是对象包裹的id，可以是<code>_id</code>,第二个是一个回调函数，其中有两个参数<code>err</code>和<code>data</code>，返回查询的结果或者异常情况。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">commodities.findById(&#123;</span><br><span class="line">    _id</span><br><span class="line">&#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 一般返回三个值 code msg 和 result</span></span><br><span class="line">        res.json(&#123;</span><br><span class="line">            <span class="attr">code</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">result</span>: data</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><code>find</code> 返回的结果是数组<br>两种情况<br>第一种只传一个回调函数，则返回对应模型的全部字段值</p><p>第二种：<br>需要传入三个参数，第一个是对象包裹的查询条件，第二个是对象包裹的返回结果(用于筛选),key是模型的字段，value是1或者0，如果是1则返回该结果，如果是0则不返回，第三个是回调函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">commodities.find(&#123;</span><br><span class="line">    _id,</span><br><span class="line">&#125;,&#123;<span class="attr">goods</span>:<span class="number">1</span>&#125;,<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;查找异常&#x27;</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;data&#x27;</span>,data)</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            <span class="attr">result</span>:data</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>findOne</code>返回单个结果，是一个数据对象。也是可以传入三个参数，依据是否大量查询使用不同的指令对性能的影响可能不一样</p><h1 id="新增-创建实体"><a href="#新增-创建实体" class="headerlink" title="新增(创建实体)"></a>新增(创建实体)</h1><p>实体的定义如下<br><div class="note primary flat"><p>实体(Entity)是由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性。</p></div></p><p>新增需要建立实体，实体是根据模型建立的。实体中有save方法，可以让我们对数据库进行插入操作，也是传递一个回调参数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取query参数</span></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    addr,</span><br><span class="line">    name,</span><br><span class="line">    phone,</span><br><span class="line">    time</span><br><span class="line">&#125; = req.query;</span><br><span class="line"><span class="comment">//创建实体</span></span><br><span class="line"><span class="keyword">let</span> AddEntity = <span class="keyword">new</span> address(&#123;</span><br><span class="line">    addr,</span><br><span class="line">    name,</span><br><span class="line">    phone,</span><br><span class="line">    time</span><br><span class="line">&#125;)</span><br><span class="line">AddEntity.save(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;插入失败：&#x27;</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            <span class="attr">code</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">msg</span>: <span class="string">&#x27;插入成功&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="删除delete"><a href="#删除delete" class="headerlink" title="删除delete"></a>删除delete</h1><p>删除的操作是基于模型的，是模型中的方法<br>删除有两个方法，一个是<code>deleteOne</code>和<code>remove</code></p><p><code>deleteOne</code>传递两个参数，一个是查找条件，一个是回调函数</p><p>代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">address.deleteOne(&#123;</span><br><span class="line">    _id</span><br><span class="line">&#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;删除失败：&#x27;</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            <span class="attr">code</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">msg</span>: <span class="string">&#x27;删除成功&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="更新update"><a href="#更新update" class="headerlink" title="更新update"></a>更新update</h1><p>更新的操作是基于模型的，是模型的api</p><p><code>updateOne</code>方法，传入三个参数</p><ol><li>对象包裹的查询条件</li><li>对象包裹的更新数据</li><li>回调参数</li></ol><p>代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">address.updateOne(&#123;</span><br><span class="line">    _id</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    addr,</span><br><span class="line">    name,</span><br><span class="line">    phone,</span><br><span class="line">    time</span><br><span class="line">&#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;修改失败：&#x27;</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            <span class="attr">code</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">msg</span>: <span class="string">&#x27;修改成功&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>另外还有<code>findByIdAndUpdate</code>,<code>findOneAndUpdate</code>方法</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在mongoose操作中需要注意如果数据库中没有该表，会新建为复数名称的表，所以导入数据的时候应该在库建立好之后再考虑导入</p><p>如果已经有表，对应的规则在schema中也不能出错，否则返回错误类型的约束</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="nodejs" scheme="https://zlinni.github.io/tags/nodejs/"/>
    
    <category term="nosql" scheme="https://zlinni.github.io/tags/nosql/"/>
    
  </entry>
  
  <entry>
    <title>Http打怪升级1.0-3.0</title>
    <link href="https://zlinni.github.io/posts/1703341700/"/>
    <id>https://zlinni.github.io/posts/1703341700/</id>
    <published>2022-05-21T01:49:01.000Z</published>
    <updated>2022-06-01T07:32:43.369Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>介绍http1.0-3.0的版本优缺点</p></div><h1 id="Http1-0"><a href="#Http1-0" class="headerlink" title="Http1.0"></a>Http1.0</h1><div class="note warning flat"><p>http1.0之前还有别的版本吗？<br>答:http0.9</p></div><p>特点：</p><ul><li>可以传输任何格式的内容 0.9只能文本</li><li>引入了POST和HEAD 0.9只有GET</li><li>每次通信都得携带头信息 0.9没有标记信息的手段</li><li>增加了响应状态码</li><li>缓存的标准是<code>Expires</code>和<code>If-Modified-Since</code></li></ul><p>缺点：</p><ul><li>不支持断点续传</li><li>没有传递主机名hostname</li></ul><h2 id="没有解决的问题"><a href="#没有解决的问题" class="headerlink" title="没有解决的问题"></a>没有解决的问题</h2><p>服务器发送完响应就关闭了TCP连接。</p><p>http连接是在TCP连接里面的，如果这样做，后面再次请求，就要重新建立连接，然鹅我们知道TCP三次握手的成本是比较高的</p><p>1.0缓解的方法：</p><p>1.0可以使用headers发送信息，其中<code>Connection：keep-alive</code>，就能告诉服务器，客户端后面可能还会请求，先不要关闭TCP连接，从而达到了类似于TCP复用的目的。</p><p>为什么说是缓解的方法呢？<br>因为这个头部字段不是标准的，不同的实现可能导致表现得不一致，因此不能从根本上解决这个问题。</p><h1 id="Http1-1"><a href="#Http1-1" class="headerlink" title="Http1.1"></a>Http1.1</h1><p>解决了上个版本的问题：</p><ol><li>引入长连接，默认TCP不关闭，可以被多个请求复用</li><li>支持断点续传</li></ol><p>特点：</p><ol><li>引入并发连接</li><li>管道机制(一个TCP连接里可以同时发送多个请求，但是响应的顺序和请求的顺序一致，因此不常用)</li><li>增加了PUT、DELETE、OPTIONS、PATCH等方法</li><li>允许响应数据分块chunked，利于传输大文件</li><li>强制要求host头，让主机托管成为可能</li></ol><p>缺点：</p><ol><li>队头阻塞(长连接带来)</li><li>无状态</li><li>明文传输</li><li>不支持服务器端推送</li></ol><h1 id="队头阻塞的思考"><a href="#队头阻塞的思考" class="headerlink" title="队头阻塞的思考"></a>队头阻塞的思考</h1><p>队头阻塞特点：顺序发送的请求因为某些原因被阻塞的时候，后面排队的请求也会一并被阻塞，导致服务端收不到数据。</p><p>HTTP1.1为了解决这个问题，有两个方案：</p><ol><li>域名分片+并发连接</li><li>管道机制</li></ol><h2 id="域名分片-并发连接"><a href="#域名分片-并发连接" class="headerlink" title="域名分片+并发连接"></a>域名分片+并发连接</h2><p>在chrome中，允许一个域名拥有6个TCP持久连接，那么当拥有多级域名的时候，就能将更多的资源分配出来。</p><p>但是也会引起一些别的问题，因为TCP的连接需要经过dns，三次握手，慢启动等操作，所以对于服务器来说连接太多容易造成网络拥挤。</p><h2 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h2><p>指的是在一个TCP连接里面，多个HTTP请求可以并行，客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务端内必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能区分每次响应的内容</p><p>简单来说就是客户端可以一直发，但服务端要按顺序回</p><p>一定程度上能解决队头阻塞的问题，但治标不治本，因为如果前面的一个请求很耗费时间，比如大图片的处理，那么后面的即使服务器处理完了也只能等待这个请求处理完才能返回</p><h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h2><ul><li>合并小文件减小资源数。精灵图</li><li>内联资源。图片放到css的url里面，减少请求次数</li><li>减小请求数量。拼接，将多个体积较小的js打包成一个大js，但如果其中一个文件改动就会导致大量数据被重新下载和传输</li></ul><h1 id="无状态特性—巨大的HTTP头部"><a href="#无状态特性—巨大的HTTP头部" class="headerlink" title="无状态特性—巨大的HTTP头部"></a>无状态特性—巨大的HTTP头部</h1><p>无状态指的是对于连接状态没有记忆能力。纯净的http是没有cookie等机制的，每个连接都是新的连接。</p><p>但是由于新增了header标识信息的操作，每次收发都会携带大量的header字段到服务端，这样就逐渐的增加了传输的成本</p><p>所以2.0设计的Hpack算法就是为了解决这个问题诞生的。</p><h1 id="明文传输—不安全性"><a href="#明文传输—不安全性" class="headerlink" title="明文传输—不安全性"></a>明文传输—不安全性</h1><p>1.1在传输数据的时候，所有的内容都是明文的，这样意味着客户端和服务端没办法验证对方的身份，一定程度上无法保证数据的安全性</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>http1.1因为引入了长连接带来了队头阻塞的问题，使用了域名分片和管道机制缓解，但是没有从根本上解决问题，且引入了header头字段标识信息，但是没有压缩以及存储导致头部信息很大，最后是明文传输的问题，不安全。</p><h1 id="SPDY-改进版Http1-1"><a href="#SPDY-改进版Http1-1" class="headerlink" title="SPDY 改进版Http1.1"></a>SPDY 改进版Http1.1</h1><p>SPDY：speedy 迅速的。SPDY协议是2012年谷歌提出的方案，优化了http1.x的请求延迟，解决了http的安全性。</p><ol><li>针对http高延迟的问题,speedy采用了多路复用.它通过多个请求stream共享一个tcp连接的方式,解决了http队头阻塞的问题.</li><li>设置了请求优先级,重要的请求优先响应</li><li>header压缩</li><li>加密传输</li><li>服务端推送</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220525114043.png" alt=""></p><p>如上图所示,SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。</p><p>后面的http2.0就是基于speedy协议操作的</p><h1 id="Http2"><a href="#Http2" class="headerlink" title="Http2"></a>Http2</h1><p>解决了上版本什么问题：</p><ol><li>HTTP队头阻塞(流)(多路复用)</li><li>头部过大的问题(头部压缩)</li></ol><p>特性：</p><ol><li>二进制分帧</li><li>头部压缩</li><li>多路复用</li><li>服务端推送</li><li>流</li></ol><h2 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h2><p>HTTP2传输的数据量减少，两个原因，一个是二进制分帧一个是头部压缩。</p><p>首先二进制分帧就是采用二进制的形式传输数据，比起1.x的时候采用的纯文本的形式，更容易解析。</p><p>详细的来讲，它将Headers+Body的报文形式拆分成一个个二进制的帧，用Headers帧存放头部字段，用Data帧存放请求体数据。</p><p>分帧带来的影响就是，服务器接收到的是一堆乱序的二进制帧，所以也就是不存在先后的问题，也就解决了HTTP队头阻塞的问题。（但是TCP队头阻塞还没有解决）</p><p>乱序的帧。指的是对于不同ID的流是乱序的，但是同一个ID的流还是顺序的。到达服务端后将顺序的ID组合成完整的报文。</p><p>有其他的字段可以实现优先级和流量控制</p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>废弃了1.x中的管道。同一个TCP连接里面客户端和服务端可以同时发送多个请求和多个响应，且不用按照顺序来。</p><h2 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h2><p>HPACK算法，在服务端和客户端之间建立哈希表，用到的字段存放在这张表里面，传输过程中已经出现过的字段就穿索引给对方即可。</p><p>对于整数和字符串进行哈夫曼编码，原理是将所有出现的字符建立一张索引表，让出现次数多的字符对于的索引尽可能短，传输的时候也是传输这样的索引序列，可以达到非常高的压缩效率。</p><h2 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h2><p>另外值得一说的是HTTP2的服务器推送Server Push。在HTTP2中，服务器已经不再是被动的接收请求，响应请求，他也能新建Stream来给客户端发送信息，当TCP连接建立之后，比如浏览器请求一个HTML文件，服务器就可以在返回HTML的基础上，将HTML中引用到的一些其他资源文件一起返回给客户端，减少客户端等待。</p><h1 id="2-0缺点"><a href="#2-0缺点" class="headerlink" title="2.0缺点"></a>2.0缺点</h1><p>2.0没有解决TCP队头阻塞问题，而TCP仍然是web的构建基础，当TCP传输的数据包在传输过程中丢失的时候，在服务端重新发送丢失的数据包之前，接收方无法确认传入的数据包。由于TCP在设计上不遵循HTTP之类的高级协议，因此单个丢失的数据包将阻塞所有正在进行的HTTP请求中的流，直到重新发送丢失的数据为止。这个问题在不可靠的连接上尤为突出。</p><p>多路复用导致服务器压力上升</p><p>多路复用没有限制同时请求数，请求的平均数量与往常相同，但实际上会有很多请求短暂爆发，造成瞬时QPS暴增</p><p>多路复用容易timeout<br>大批量的请求同时发送，由于HTTP2连接内存在多个并行的流，而网络请求和服务器资源有限，每个流的资源都会被稀释，虽然它们开始相差更短，但都可能超时</p><p>即使是使用NGINX这样的负载均衡器，想正确的进行节流也可能很棘手。 其次，就算你向应用程序引入或调整排队机制，但一次能处理的连接也是有限的。如果对请求进行排队，还要注意在响应超时后丢弃请求，以避免浪费不必要的资源。</p><h1 id="HTTP3-0"><a href="#HTTP3-0" class="headerlink" title="HTTP3.0"></a>HTTP3.0</h1><p>解决了上个版本的问题：</p><ol><li>TCP队头阻塞</li></ol><h2 id="面向UDP寻找新可能"><a href="#面向UDP寻找新可能" class="headerlink" title="面向UDP寻找新可能"></a>面向UDP寻找新可能</h2><p>HTTP2由于采用二进制分帧进行多路复用，通常只使用一个TCP连接进行传输，丢包或者网络中断的情况下后面所有的数据都会被阻塞。</p><p>HTTP/2 的问题不能仅靠应用程序层来解决，因此协议的新迭代必须更新传输层。但是，创建新的传输层协议并非易事。传输协议需要硬件供应商的支持，并且需要大多数网络运营商的部署才能普及。<br>幸运的是还有另一种选择。UDP 协议与 TCP 一样得到广泛支持，但前者足够简单，可以作为在其之上运行的自定义协议的基础。UDP 数据包是一劳永逸的：没有握手、持久连接或错误校正。HTTP3 背后的主要思想是放弃 TCP，转而使用基于 UDP 的 QUIC （快速UDP互联网连接）协议。</p><p>与 HTTP2 在技术上允许未加密的通信不同，QUIC 严格要求加密后才能建立连接。此外，加密不仅适用于 HTTP 负载，还适用于流经连接的所有数据，从而避免了一大堆安全问题。建立持久连接、协商加密协议，甚至发送第一批数据都被合并到 QUIC 中的单个请求/响应周期中，从而大大减少了连接等待时间。如果客户端具有本地缓存的密码参数，则可以通过简化的握手重新建立与已知主机的连接。<br>为了解决传输级别的线头阻塞问题，通过 QUIC 连接传输的数据被分为一些流。流是持久性 QUIC 连接中短暂、独立的“子连接”。每个流都处理自己的错误纠正和传递保证，但使用连接全局压缩和加密属性。每个客户端发起的 HTTP 请求都在单独的流上运行，因此丢失数据包不会影响其他流/请求的数据传输。</p><h2 id="实现了快速握手功能"><a href="#实现了快速握手功能" class="headerlink" title="实现了快速握手功能"></a>实现了快速握手功能</h2><p>由于QUIC是基于UDP的，所以QUIC可以实现使用0RTT或1RTT来建立连接，意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。</p><h2 id="集成了TLS加密功能"><a href="#集成了TLS加密功能" class="headerlink" title="集成了TLS加密功能"></a>集成了TLS加密功能</h2><p>目前QUIC使用的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。<br>在完全握手情况下，需要 1-RTT 建立连接。 TLS1.3 恢复会话可以直接发送加密后的应用数据，不需要额外的 TLS 握手，也就是 0-RTT。<br>但是 TLS1.3 也并不完美。TLS 1.3 的 0-RTT 无法保证前向安全性(Forward secrecy)。简单讲就是，如果当攻击者通过某种手段获取到了 Session Ticket Key，那么该攻击者可以解密以前的加密数据。<br>要缓解该问题可以通过设置使得与 Session Ticket Key 相关的 DH 静态参数在短时间内过期（一般几个小时）。</p><h2 id="多路复用，彻底解决TCP中队头阻塞的问题"><a href="#多路复用，彻底解决TCP中队头阻塞的问题" class="headerlink" title="多路复用，彻底解决TCP中队头阻塞的问题"></a>多路复用，彻底解决TCP中队头阻塞的问题</h2><p>和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e114f32c7404a4fab04b17910453111~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt=""></p><h2 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h2><p>TCP 是按照 4 要素（客户端 IP、端口, 服务器 IP、端口）确定一个连接的。而 QUIC 则是让客户端生成一个 Connection ID （64 位）来区别不同连接。只要 Connection ID 不变，连接就不需要重新建立，即便是客户端的网络发生变化。由于迁移客户端继续使用相同的会话密钥来加密和解密数据包，QUIC 还提供了迁移客户端的自动加密验证。</p><h1 id="Http0-9"><a href="#Http0-9" class="headerlink" title="Http0.9"></a>Http0.9</h1><p>1991年由W3C制定的标准，诞生之初是为了传输HTML，并且支持GET请求。</p><p>当时的请求报文只有一行，GET+请求的路径。服务器在收到请求之后会返回一个以ASCII编码的HTML文档。</p><p>缺点：</p><ol><li>没有描述数据的信息，1.0引入了headers</li><li>也只有一个命令</li><li>发送完就关闭TCP连接</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="网络系列" scheme="https://zlinni.github.io/categories/%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="计算机网络" scheme="https://zlinni.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP" scheme="https://zlinni.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Node.js结合express-jwt的实战教程</title>
    <link href="https://zlinni.github.io/posts/2906490375/"/>
    <id>https://zlinni.github.io/posts/2906490375/</id>
    <published>2022-05-15T08:42:29.000Z</published>
    <updated>2022-05-15T13:58:32.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>本文记录node使用express-jwt校验token以及前端发送token的全过程</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220515191529.png" alt=""></p><h1 id="什么是Token-什么是JWT"><a href="#什么是Token-什么是JWT" class="headerlink" title="什么是Token?什么是JWT?"></a>什么是Token?什么是JWT?</h1><p>Token产生原因:常规模式的session存放用户登录态导致服务器压力大,服务器多的时候,需要同步session,于是诞生了token,存到客户端,由服务端被动验证</p><p>缺点:</p><ol><li>被动验证,导致收回权限稍微困难.</li><li>每次请求都要携带,增加性能开销</li></ol><p>JWT: Json Web Token,一种token的验证方式,本质上是带有前面的json数据.</p><p>JWT由三部分组成:</p><ol><li>Header:描述JWT的元数据,定义了生成签名的算法以及Token的类型</li><li>Payload:用于存放实际需要传递的数据</li><li>Signature:签名,服务器通过Payload、Header和一个密钥(secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。</li></ol><h1 id="后端职责"><a href="#后端职责" class="headerlink" title="后端职责"></a>后端职责</h1><p>使用md5对密码进行加盐加密放入数据库,使用jwt在合适的时机发放token以及token的校验,模块化以及代码复用.</p><h1 id="后端项目目录"><a href="#后端项目目录" class="headerlink" title="后端项目目录"></a>后端项目目录</h1><div class="note primary flat"><p>vscode的project-tree插件生成</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">footok</span><br><span class="line">├─ app.js</span><br><span class="line">├─ db</span><br><span class="line">│  └─ dbConfig.js</span><br><span class="line">├─ package-lock.json</span><br><span class="line">├─ package.json</span><br><span class="line">├─ routes</span><br><span class="line">│  ├─ index.js //路由初始化+自定义状态异常</span><br><span class="line">│  ├─ tasks.js //任务模块</span><br><span class="line">│  └─ user.js //用户模块</span><br><span class="line">├─ services</span><br><span class="line">│  ├─ taskService.js //业务逻辑层 任务接口</span><br><span class="line">│  └─ userService.js //用户接口</span><br><span class="line">├─ utils</span><br><span class="line">│  ├─ constant.js //自定义常量</span><br><span class="line">│  ├─ index.js //封装连接mysql</span><br><span class="line">│  ├─ md5.js //md5</span><br><span class="line">│  └─ user-jwt.js //jwt验证和解析函数</span><br><span class="line">└─ views</span><br></pre></td></tr></table></figure><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm i --save express</span><br><span class="line">npm i --save body-parser</span><br><span class="line">npm i --save express-validator</span><br><span class="line">npm i --save cors</span><br><span class="line">npm i --save jsonwebtoken</span><br><span class="line">npm i --save express-jwt</span><br><span class="line">npm i --save mysql</span><br></pre></td></tr></table></figure><h1 id="db部分-数据库的配置"><a href="#db部分-数据库的配置" class="headerlink" title="db部分(数据库的配置)"></a>db部分(数据库的配置)</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>, <span class="comment">// 主机名称，一般是本机</span></span><br><span class="line">    <span class="attr">port</span>: <span class="string">&#x27;3306&#x27;</span>, <span class="comment">// 数据库的端口号，如果不设置，默认是3306</span></span><br><span class="line">    <span class="attr">user</span>: <span class="string">&#x27;yourname&#x27;</span>, <span class="comment">// 创建数据库时设置用户名</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;yourpassword&#x27;</span>, <span class="comment">// 创建数据库时设置的密码</span></span><br><span class="line">    <span class="attr">database</span>: <span class="string">&#x27;yourdatabase&#x27;</span>, <span class="comment">// 创建的数据库</span></span><br><span class="line">    <span class="attr">connectTimeout</span>: <span class="number">5000</span> <span class="comment">// 连接超时</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = mysql;</span><br></pre></td></tr></table></figure><h1 id="utils部分"><a href="#utils部分" class="headerlink" title="utils部分"></a>utils部分</h1><div class="note primary flat"><p>该部分负责md5.jwt和mysql的连接配置</p></div><h2 id="constant-js-定义固定参数"><a href="#constant-js-定义固定参数" class="headerlink" title="constant.js 定义固定参数"></a><code>constant.js</code> 定义固定参数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">CODE_ERROR</span>: -<span class="number">1</span>, <span class="comment">// 请求响应失败code码</span></span><br><span class="line">  <span class="attr">CODE_SUCCESS</span>: <span class="number">0</span>, <span class="comment">// 请求响应成功code码</span></span><br><span class="line">  <span class="attr">CODE_TOKEN_EXPIRED</span>: <span class="number">401</span>, <span class="comment">// 授权失败</span></span><br><span class="line">  <span class="attr">PRIVATE_KEY</span>: <span class="string">&#x27;yourKey&#x27;</span>, <span class="comment">// 自定义jwt加密的私钥</span></span><br><span class="line">  <span class="attr">JWT_EXPIRED</span>: <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>, <span class="comment">// 过期时间24小时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是定义参数的地方,还有些成功和失败的响应码可以和前端协商.</p><h2 id="user-jwt-js-定义jwt校验规则"><a href="#user-jwt-js-定义jwt校验规则" class="headerlink" title="user-jwt.js 定义jwt校验规则"></a><code>user-jwt.js</code> 定义jwt校验规则</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>); <span class="comment">// 引入验证jsonwebtoken模块</span></span><br><span class="line"><span class="keyword">const</span> expressJwt = <span class="built_in">require</span>(<span class="string">&#x27;express-jwt&#x27;</span>); <span class="comment">// 引入express-jwt模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; PRIVATE_KEY &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./constant&#x27;</span>); <span class="comment">// 引入自定义的jwt密钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证token是否过期</span></span><br><span class="line"><span class="keyword">const</span> jwtAuth = expressJwt(&#123;</span><br><span class="line">  <span class="comment">// 设置密钥</span></span><br><span class="line">  <span class="attr">secret</span>: PRIVATE_KEY,</span><br><span class="line">  <span class="comment">// 设置为true表示校验，false表示不校验</span></span><br><span class="line">  <span class="attr">credentialsRequired</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 加入算法 </span></span><br><span class="line">  <span class="attr">algorithms</span>:[<span class="string">&#x27;HS256&#x27;</span>],</span><br><span class="line">  <span class="comment">// 自定义获取token的函数</span></span><br><span class="line">  <span class="attr">getToken</span>: <span class="function">(<span class="params">req</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (req.headers.authorization &amp;&amp; req.headers.authorization.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>] === <span class="string">&#x27;Bearer&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> req.headers.authorization.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.query &amp;&amp; req.query.token) &#123;</span><br><span class="line">      <span class="keyword">return</span> req.query.token</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置jwt认证白名单，比如/login登录接口不需要拦截</span></span><br><span class="line">&#125;).unless(&#123;</span><br><span class="line">  <span class="attr">path</span>: [</span><br><span class="line">    <span class="string">&#x27;/register&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/login&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  jwtAuth,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里比较容易踩坑的地方是这个Bearer,这里分两种情况:</p><ol><li>前端请求发送token的时候,自己添加了Bearer,组成<code>Bearer token</code></li><li>后端响应发送token的时候,自己添加了Bearer,组成<code>Bearer token</code></li></ol><p>不管是上面哪一种签发,验证都需要去掉Bearer,用后面的东西进行校验.</p><p>这个unless也比较容易踩坑,一般来说,登陆和注册是不需要权限的,所以默认会有这两个.</p><h2 id="md5-js-定义md5"><a href="#md5-js-定义md5" class="headerlink" title="md5.js 定义md5"></a><code>md5.js</code> 定义md5</h2><p>这部分就不用多说了,常规操作<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>); <span class="comment">// 引入crypto加密模块</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">md5</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> crypto.createHash(<span class="string">&#x27;md5&#x27;</span>).update(<span class="string">&#x27;&#x27;</span> + s).digest(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = md5;</span><br></pre></td></tr></table></figure></p><h2 id="index-js-封装数据库的查询"><a href="#index-js-封装数据库的查询" class="headerlink" title="index.js 封装数据库的查询"></a>index.js 封装数据库的查询</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;../db/dbConfig&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接mysql</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; host, user, password, database &#125; = config;</span><br><span class="line">  <span class="keyword">return</span> mysql.createConnection(&#123;</span><br><span class="line">    host,</span><br><span class="line">    user,</span><br><span class="line">    password,</span><br><span class="line">    database</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建查询连接</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">querySql</span>(<span class="params">sql</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">const</span> conn = connect();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      conn.query(sql, <span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//释放连接</span></span><br><span class="line">      conn.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询一条语句</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryOne</span>(<span class="params">sql</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    querySql(sql).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;res===&#x27;</span>,res)</span><br><span class="line">      <span class="keyword">if</span> (res &amp;&amp; res.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        resolve(res[<span class="number">0</span>]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(<span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  querySql,</span><br><span class="line">  queryOne</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="services层"><a href="#services层" class="headerlink" title="services层"></a>services层</h1><p>对于很久没有使用node的小伙伴,这里提醒一下,node获取get请求的请求体使用的方法是<code>req.query.xxx</code>,获取post的请求体的方法是<code>req.body.xxx</code>(前提是装了body-parser),以及单条数据查询的时候,最好使用解构的方式,比如说对于下面的sql查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> count <span class="keyword">from</span> foodData <span class="keyword">where</span> tag <span class="operator">=</span> <span class="string">&#x27;炒&#x27;</span></span><br></pre></td></tr></table></figure></p><p>那么获取的时候,就应该是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;count&#125; = result[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></p><p>如果下面的代码测试不行,可以将代码写在app.js里面测试,因为很大程度上是你的路径没有写对.</p><h2 id="userService"><a href="#userService" class="headerlink" title="userService"></a>userService</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    querySql,</span><br><span class="line">    queryOne</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../utils/index&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> md5 = <span class="built_in">require</span>(<span class="string">&#x27;../utils/md5&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    CODE_ERROR,</span><br><span class="line">    CODE_SUCCESS,</span><br><span class="line">    PRIVATE_KEY,</span><br><span class="line">    JWT_EXPIRED</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../utils/constant&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">        username,</span><br><span class="line">        password</span><br><span class="line">    &#125; = req.body;</span><br><span class="line">    <span class="comment">// md5加盐加密</span></span><br><span class="line">    password = md5(md5(username + md5(password))) <span class="comment">//储存密码</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;psw&#x27;</span>, password);</span><br><span class="line">    <span class="keyword">const</span> query = <span class="string">`select * from userdata where username=&#x27;<span class="subst">$&#123;username&#125;</span>&#x27; and password=&#x27;<span class="subst">$&#123;password&#125;</span>&#x27;`</span>;</span><br><span class="line">    querySql(query)</span><br><span class="line">        .then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!user || user.length === <span class="number">0</span>) &#123;</span><br><span class="line">                res.json(&#123;</span><br><span class="line">                    <span class="attr">code</span>: CODE_ERROR,</span><br><span class="line">                    <span class="attr">msg</span>: <span class="string">&#x27;用户名或密码错误&#x27;</span>,</span><br><span class="line">                    <span class="attr">records</span>: <span class="literal">null</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 登录成功，签发一个token并返回给前端</span></span><br><span class="line">                <span class="keyword">const</span> tokenStr = jwt.sign(</span><br><span class="line">                    <span class="comment">// payload：签发的 token 里面要包含的一些数据。</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        username</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">// 私钥</span></span><br><span class="line">                    PRIVATE_KEY,</span><br><span class="line">                    <span class="comment">// 设置过期时间</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">expiresIn</span>: JWT_EXPIRED</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> userData = &#123;</span><br><span class="line">                    <span class="attr">id</span>: user[<span class="number">0</span>].id,</span><br><span class="line">                    <span class="attr">username</span>: user[<span class="number">0</span>].username,</span><br><span class="line">                    <span class="attr">nickname</span>: user[<span class="number">0</span>].nickname,</span><br><span class="line">                    <span class="attr">avator</span>: user[<span class="number">0</span>].avator,</span><br><span class="line">                    <span class="attr">sex</span>: user[<span class="number">0</span>].sex,</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                res.json(&#123;</span><br><span class="line">                    <span class="attr">code</span>: CODE_SUCCESS,</span><br><span class="line">                    <span class="attr">msg</span>: <span class="string">&#x27;登录成功&#x27;</span>,</span><br><span class="line">                    <span class="attr">records</span>: &#123;</span><br><span class="line">                        <span class="attr">token</span>: <span class="string">&#x27;Bearer &#x27;</span> + tokenStr,</span><br><span class="line">                        userData</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">        username,</span><br><span class="line">        password</span><br><span class="line">    &#125; = req.body;</span><br><span class="line">    findUser(username)</span><br><span class="line">        .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data) &#123;</span><br><span class="line">                res.json(&#123;</span><br><span class="line">                    <span class="attr">code</span>: CODE_ERROR,</span><br><span class="line">                    <span class="attr">msg</span>: <span class="string">&#x27;用户已存在&#x27;</span>,</span><br><span class="line">                    <span class="attr">records</span>: <span class="literal">null</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// md5加盐加密</span></span><br><span class="line">                password = md5(md5(username + md5(password)));</span><br><span class="line">                <span class="keyword">const</span> query = <span class="string">`insert into userdata(username, password) values(&#x27;<span class="subst">$&#123;username&#125;</span>&#x27;, &#x27;<span class="subst">$&#123;password&#125;</span>&#x27;)`</span>;</span><br><span class="line">                querySql(query)</span><br><span class="line">                    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!result || result.length === <span class="number">0</span>) &#123;</span><br><span class="line">                            res.json(&#123;</span><br><span class="line">                                <span class="attr">code</span>: CODE_ERROR,</span><br><span class="line">                                <span class="attr">msg</span>: <span class="string">&#x27;注册失败&#x27;</span>,</span><br><span class="line">                                <span class="attr">records</span>: <span class="literal">null</span></span><br><span class="line">                            &#125;)</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> queryUser = <span class="string">`select * from userdata where username=&#x27;<span class="subst">$&#123;username&#125;</span>&#x27; and password=&#x27;<span class="subst">$&#123;password&#125;</span>&#x27;`</span>;</span><br><span class="line">                            querySql(queryUser)</span><br><span class="line">                                .then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">                                    <span class="keyword">const</span> tokenStr = jwt.sign(&#123;</span><br><span class="line">                                            username</span><br><span class="line">                                        &#125;,</span><br><span class="line">                                        PRIVATE_KEY, &#123;</span><br><span class="line">                                            <span class="attr">expiresIn</span>: JWT_EXPIRED</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    )</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">let</span> userData = &#123;</span><br><span class="line">                                        <span class="attr">id</span>: user[<span class="number">0</span>].id,</span><br><span class="line">                                        <span class="attr">username</span>: user[<span class="number">0</span>].username,</span><br><span class="line">                                        <span class="attr">nickname</span>: user[<span class="number">0</span>].nickname,</span><br><span class="line">                                        <span class="attr">avator</span>: user[<span class="number">0</span>].avator,</span><br><span class="line">                                        <span class="attr">sex</span>: user[<span class="number">0</span>].sex,</span><br><span class="line">                                    &#125;;</span><br><span class="line"></span><br><span class="line">                                    res.json(&#123;</span><br><span class="line">                                        <span class="attr">code</span>: CODE_SUCCESS,</span><br><span class="line">                                        <span class="attr">msg</span>: <span class="string">&#x27;注册成功&#x27;</span>,</span><br><span class="line">                                        <span class="attr">records</span>: &#123;</span><br><span class="line">                                            <span class="attr">token</span>: <span class="string">&#x27;Bearer &#x27;</span> + tokenStr,</span><br><span class="line">                                            userData</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;)</span><br><span class="line">                                &#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过用户名查询用户信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findUser</span>(<span class="params">username</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> query = <span class="string">`select id, username from userdata where username=&#x27;<span class="subst">$&#123;username&#125;</span>&#x27;`</span>;</span><br><span class="line">    <span class="keyword">return</span> queryOne(query);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    login,</span><br><span class="line">    register,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>md5的加盐可以自己定义,比如一个<code>secret key</code>或者是什么别的常量,层级也可以相应深一点</p><p>这里的token我选择了在后端加上Bearer返回给前端</p><h1 id="routes层"><a href="#routes层" class="headerlink" title="routes层"></a>routes层</h1><h2 id="users"><a href="#users" class="headerlink" title="users"></a>users</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../services/userService&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户登录路由</span></span><br><span class="line">router.post(<span class="string">&#x27;/login&#x27;</span>,service.login);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户注册路由</span></span><br><span class="line">router.post(<span class="string">&#x27;/register&#x27;</span>,service.register);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure><h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&#x27;./user.js&#x27;</span>); <span class="comment">// 引入user路由模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; jwtAuth,decode &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../utils/user-jwt&#x27;</span>); <span class="comment">// 引入jwt认证函数</span></span><br><span class="line"><span class="keyword">const</span> router = express.Router(); <span class="comment">// 注册路由 </span></span><br><span class="line"></span><br><span class="line">router.use(jwtAuth); <span class="comment">// 注入认证模块</span></span><br><span class="line"></span><br><span class="line">router.use(<span class="string">&#x27;/&#x27;</span>, userRouter); <span class="comment">// 注入用户路由模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义统一异常处理中间件，需要放在代码最后</span></span><br><span class="line">router.use(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 自定义用户认证失败的错误返回</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;err===&#x27;</span>, err);</span><br><span class="line">  <span class="keyword">if</span> (err &amp;&amp; err.name === <span class="string">&#x27;UnauthorizedError&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; status = <span class="number">401</span>, message &#125; = err;</span><br><span class="line">    <span class="comment">// 抛出401异常</span></span><br><span class="line">    res.status(status).json(&#123;</span><br><span class="line">      <span class="attr">code</span>: status,</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&#x27;token失效，请重新登录&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: <span class="literal">null</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; output &#125; = err || &#123;&#125;;</span><br><span class="line">    <span class="comment">// 错误码和错误信息</span></span><br><span class="line">    <span class="keyword">const</span> errCode = (output &amp;&amp; output.statusCode) || <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">const</span> errMsg = (output &amp;&amp; output.payload &amp;&amp; output.payload.error) || err.message;</span><br><span class="line">    res.status(errCode).json(&#123;</span><br><span class="line">      <span class="attr">code</span>: errCode,</span><br><span class="line">      <span class="attr">msg</span>: errMsg</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里有一点比较重要,如果没有分类的话,那么这里的<code>router.use(&#39;/&#39;, userRouter);</code>路径直接写斜杠即可</p><h1 id="app层"><a href="#app层" class="headerlink" title="app层"></a>app层</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>); <span class="comment">// 引入body-parser模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>); <span class="comment">// 引入express模块</span></span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>); <span class="comment">// 引入cors模块</span></span><br><span class="line"><span class="keyword">const</span> routes = <span class="built_in">require</span>(<span class="string">&#x27;./routes/index&#x27;</span>); <span class="comment">//导入自定义路由文件，创建模块化路由</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.json()); <span class="comment">// 解析json数据格式</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>: <span class="literal">true</span>&#125;)); <span class="comment">// 解析form表单提交的数据application/x-www-form-urlencoded</span></span><br><span class="line"></span><br><span class="line">app.use(cors()); <span class="comment">// 注入cors模块解决跨域</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/&#x27;</span>, routes);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8081</span>, <span class="function">() =&gt;</span> &#123; <span class="comment">// 监听8081端口</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;服务已启动 http://localhost:8081&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>依然是路径需要注意</p><p>至此后端的部分就已经写完了,接下来是前端的部分</p><h1 id="前端职责"><a href="#前端职责" class="headerlink" title="前端职责"></a>前端职责</h1><p>前端负责登陆和注册的页面编写,请求的编写,axios的封装</p><h1 id="前端目录"><a href="#前端目录" class="headerlink" title="前端目录"></a>前端目录</h1><p>这里比较多,简单说一下几个模块<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- components</span><br><span class="line">    - userLogin.vue //登陆模块</span><br><span class="line">    - userRegister.vue //注册模块</span><br><span class="line">- api</span><br><span class="line">    - apiInfo.js //接口信息</span><br><span class="line">    - axios.js /封装axios</span><br><span class="line">- vite.config.js //vite配置</span><br></pre></td></tr></table></figure></p><h1 id="vite配置"><a href="#vite配置" class="headerlink" title="vite配置"></a>vite配置</h1><p>这一部分主要是解决跨域的问题,然后起别名方便后续的代码路径编写<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    defineConfig</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; resolve &#125; <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pathResolve</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> resolve(__dirname, <span class="string">&quot;.&quot;</span>, dir)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">    <span class="attr">plugins</span>: [vue()],</span><br><span class="line">    <span class="attr">resolve</span>:&#123;</span><br><span class="line">        <span class="attr">alias</span>:&#123;</span><br><span class="line">            <span class="string">&quot;@&quot;</span>:pathResolve(<span class="string">&quot;src/&quot;</span>),</span><br><span class="line">            <span class="string">&quot;assets&quot;</span>:pathResolve(<span class="string">&quot;src/assets&quot;</span>),</span><br><span class="line">            <span class="string">&quot;common&quot;</span>:pathResolve(<span class="string">&quot;src/components/common&quot;</span>),</span><br><span class="line">            <span class="string">&quot;userLogin&quot;</span>:pathResolve(<span class="string">&quot;src/components/userLogin&quot;</span>),</span><br><span class="line">            <span class="string">&quot;swiper&quot;</span>:pathResolve(<span class="string">&quot;src/components/swiper&quot;</span>),</span><br><span class="line">            <span class="string">&quot;share&quot;</span>:pathResolve(<span class="string">&quot;src/components/share&quot;</span>),</span><br><span class="line">            <span class="string">&quot;category&quot;</span>:pathResolve(<span class="string">&quot;src/components/category&quot;</span>),</span><br><span class="line">            <span class="string">&quot;map&quot;</span>:pathResolve(<span class="string">&quot;src/components/map&quot;</span>),</span><br><span class="line">            <span class="string">&quot;person&quot;</span>:pathResolve(<span class="string">&quot;src/components/person&quot;</span>),</span><br><span class="line">            <span class="string">&quot;store&quot;</span>:pathResolve(<span class="string">&quot;src/stores&quot;</span>),</span><br><span class="line">            <span class="string">&quot;plugins&quot;</span>:pathResolve(<span class="string">&quot;src/plugins&quot;</span>),</span><br><span class="line">            <span class="string">&quot;myApi&quot;</span>:pathResolve(<span class="string">&quot;src/api&quot;</span>),</span><br><span class="line">            <span class="string">&quot;utils&quot;</span>:pathResolve(<span class="string">&quot;src/utils&quot;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">extensions</span>:[<span class="string">&#x27;.js&#x27;</span>,<span class="string">&#x27;.json&#x27;</span>,<span class="string">&#x27;.ts&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">base</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">    <span class="attr">build</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;modules&#x27;</span>,</span><br><span class="line">        <span class="attr">outDir</span>: <span class="string">&#x27;dist&#x27;</span>, <span class="comment">//指定输出路径</span></span><br><span class="line">        <span class="attr">assetsDir</span>: <span class="string">&#x27;assets&#x27;</span>, <span class="comment">// 指定生成静态资源的存放路径</span></span><br><span class="line">        <span class="attr">minify</span>: <span class="string">&#x27;terser&#x27;</span> <span class="comment">// 混淆器，terser构建后文件体积更小</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">server</span>: &#123;</span><br><span class="line">        <span class="attr">cors</span>: <span class="literal">true</span>, <span class="comment">// 默认启用并允许任何源</span></span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">// 在服务器启动时自动在浏览器中打开应用程序</span></span><br><span class="line">        <span class="comment">//反向代理配置，注意rewrite写法，开始没看文档在这里踩了坑</span></span><br><span class="line">        <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">        <span class="attr">https</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&#x27;http://localhost:8081&#x27;</span>,</span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">rewrite</span>: <span class="function">(<span class="params">path</span>) =&gt;</span> path.replace(<span class="regexp">/^\/api/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&#x27;/ipApi&#x27;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&#x27;http://pv.sohu.com&#x27;</span>,</span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">rewrite</span>: <span class="function">(<span class="params">path</span>) =&gt;</span> path.replace(<span class="regexp">/^\/ipApi/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="axios的封装"><a href="#axios的封装" class="headerlink" title="axios的封装"></a>axios的封装</h1><p>先讲一下axios的封装,这个对于后续的token发送特别重要,如果你已经会设置拦截器,这一部分可以跳过</p><p>目的:通过请求拦截器,对需要权限的接口自动携带token验证.</p><p>分为以下几个part:</p><ol><li>基础配置</li><li>取消重复请求</li><li>自动携带token</li></ol><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>就是配置统一的url和超时配置<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAxios</span>(<span class="params">axiosConfig</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> service = axios.create(&#123;</span><br><span class="line">        <span class="attr">baseURL</span>:<span class="string">&#x27;http://localhost:3000&#x27;</span>,<span class="comment">//设置统一url</span></span><br><span class="line">        <span class="attr">timeout</span>:<span class="number">10000</span> <span class="comment">//十秒超时</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myAxios;</span><br></pre></td></tr></table></figure></p><h2 id="取消重复请求"><a href="#取消重复请求" class="headerlink" title="取消重复请求"></a>取消重复请求</h2><p>这个部分不是本文的重点,可以适当跳过</p><h2 id="自动携带token"><a href="#自动携带token" class="headerlink" title="自动携带token"></a>自动携带token</h2><p>为了照顾ssr,这里要做一次判断然后再获取,发送token我们采取的方案是后端设置Bearer,所以这里前端直接发送即可.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">service.interceptors.request.use(</span><br><span class="line">       <span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">           removePending(config);</span><br><span class="line">           <span class="comment">// 自动携带token</span></span><br><span class="line">           <span class="keyword">if</span>(getTokenAuth()&amp;&amp;<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span>)&#123;</span><br><span class="line">               config.headers.Authorization = getTokenAuth();</span><br><span class="line">           &#125;</span><br><span class="line">           options.repeat_request_cancel&amp;&amp;addPending(config);</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">&#x27;config&#x27;</span>,config)</span><br><span class="line">           <span class="keyword">return</span> config;</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">       &#125;</span><br><span class="line">   )</span><br></pre></td></tr></table></figure></p><p>完整代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;getTokenAuth&#125; <span class="keyword">from</span> <span class="string">&#x27;utils/auth&#x27;</span>;</span><br><span class="line"><span class="comment">// 拦截器</span></span><br><span class="line"><span class="comment">// customOption:boolean 是否开启取消重复请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAxios</span>(<span class="params">axiosConfig,customOption</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> service = axios.create(&#123;</span><br><span class="line">        <span class="attr">baseURL</span>:<span class="string">&#x27;http://localhost:3000&#x27;</span>,<span class="comment">//设置统一url</span></span><br><span class="line">        <span class="attr">timeout</span>:<span class="number">10000</span> <span class="comment">//十秒超时</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> options = <span class="built_in">Object</span>.assign(&#123;<span class="attr">repeat_request_cancel</span>:<span class="literal">false</span>&#125;,customOption);</span><br><span class="line">    service.interceptors.request.use(</span><br><span class="line">        <span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">            removePending(config);</span><br><span class="line">            <span class="comment">// 自动携带token</span></span><br><span class="line">            <span class="keyword">if</span>(getTokenAuth()&amp;&amp;<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span>)&#123;</span><br><span class="line">                config.headers.Authorization = getTokenAuth();</span><br><span class="line">            &#125;</span><br><span class="line">            options.repeat_request_cancel&amp;&amp;addPending(config);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;config&#x27;</span>,config)</span><br><span class="line">            <span class="keyword">return</span> config;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    service.interceptors.response.use(</span><br><span class="line">        <span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">            removePending(response);</span><br><span class="line">            <span class="keyword">return</span> response</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">            error.config&amp;&amp;removePending(error.config);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> service(axiosConfig);<span class="comment">//返回的是一个promsie对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取消重复请求</span></span><br><span class="line"><span class="comment">// 判断重复请求并存入队列</span></span><br><span class="line"><span class="keyword">const</span> pendingMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成每个请求唯一的键</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPendingKey</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;url,method,params,data&#125; = config;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> data === <span class="string">&#x27;string&#x27;</span>)data=<span class="built_in">JSON</span>.parse(data)<span class="comment">//响应回来的config data是一个字符串</span></span><br><span class="line">    <span class="keyword">return</span> [url,method,<span class="built_in">JSON</span>.stringify(params),<span class="built_in">JSON</span>.stringify(data)].join(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储每个请求的值，也就是cancel方法，用于取消请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addPending</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> pendingKey = getPendingKey(config);</span><br><span class="line">    config.cancelToken = config.cancelToken || <span class="keyword">new</span> axios.CancelToken(<span class="function">(<span class="params">cancel</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pendingMap.has(pendingKey))&#123;</span><br><span class="line">            pendingMap.set(pendingKey,cancel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除重复的请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removePending</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> pendingKey = getPendingKey(config);</span><br><span class="line">    <span class="keyword">if</span>(pendingMap.has(pendingKey))&#123;</span><br><span class="line">        <span class="keyword">const</span> cancelToken = pendingMap.get(pendingKey);</span><br><span class="line">        cancelToken(pendingKey);</span><br><span class="line">        pendingMap.delete(pendingKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myAxios;</span><br></pre></td></tr></table></figure></p><h1 id="接口信息"><a href="#接口信息" class="headerlink" title="接口信息"></a>接口信息</h1><p>这一部分是为了方便后期接口的管理而写<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> myAxios <span class="keyword">from</span> <span class="string">&#x27;./axios&#x27;</span>;</span><br><span class="line"><span class="comment">// 用户登陆</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">userLoginAPI</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> myAxios(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/api/login&#x27;</span>,</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        data</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用户注册</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">userRegisterAPI</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> myAxios(&#123;</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&#x27;/api/register&#x27;</span>,</span><br><span class="line">        <span class="attr">method</span>:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        data</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="登陆模块逻辑"><a href="#登陆模块逻辑" class="headerlink" title="登陆模块逻辑"></a>登陆模块逻辑</h1><p>页面的代码就不放了,大致的请求逻辑如下<br>将数据发送到后端,得到成功的响应后将token放置在前端的localStorage中,或者cookie中.这里选择了localStorage</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;userLoginAPI&#125; <span class="keyword">from</span> <span class="string">&quot;myApi/apiInfo&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> rawData = toRaw(userData);</span><br><span class="line">userLoginAPI(rawData)</span><br><span class="line">  .then(</span><br><span class="line">    <span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">      data: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        code,</span></span></span><br><span class="line"><span class="params"><span class="function">        msg,</span></span></span><br><span class="line"><span class="params"><span class="function">        records: &#123; token, userData &#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">      &#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (code === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">localStorage</span>.setItem(<span class="string">&quot;token&quot;</span>,token);<span class="comment">//将token存放到</span></span><br><span class="line">        router.push(&#123; <span class="attr">name</span>: <span class="string">&quot;index&quot;</span> &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        loginTips.passwordTips = <span class="string">&quot;&quot;</span>;<span class="comment">//清空密码提示</span></span><br><span class="line">        loginTips.userNameTips = msg;<span class="comment">//回显错误内容</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    loginTips.passwordTips = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    loginTips.userNameTips = <span class="string">&quot;该用户不存在&quot;</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h1 id="注册模块逻辑"><a href="#注册模块逻辑" class="headerlink" title="注册模块逻辑"></a>注册模块逻辑</h1><p>页面的代码就不放了,注册的逻辑大概如下</p><ol><li>做密码的校验,比如限制长度,大小写等.</li><li>发送用户信息,成功后设置token到本地,跳转到主页</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;userRegisterAPI&#125; <span class="keyword">from</span> <span class="string">&#x27;myApi/apiInfo&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> userRegister = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    isSuccess.userNameSuccess &amp;&amp;</span><br><span class="line">    isSuccess.passWordSuccess &amp;&amp;</span><br><span class="line">    isSuccess.commitpswSuccess</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> rawData = toRaw(userData);</span><br><span class="line">    userRegisterAPI(rawData)</span><br><span class="line">      .then(<span class="function">(<span class="params">&#123; data: &#123; code, msg,records &#125; &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (code === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">let</span> &#123;token,userData&#125; = records;</span><br><span class="line">          <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;token&#x27;</span>,token);</span><br><span class="line">          router.push(&#123; <span class="attr">name</span>: <span class="string">&quot;index&quot;</span> &#125;);</span><br><span class="line">          </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resgisterTips.userNameTips = <span class="string">&quot;用户名已存在&quot;</span>;</span><br><span class="line">          isSuccess.userNameSuccess = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        resgisterTips.userNameTips = <span class="string">&quot;用户名已存在&quot;</span>;</span><br><span class="line">        isSuccess.userNameSuccess = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="keyword">if</span> (!userData.username) &#123;</span><br><span class="line">      resgisterTips.userNameTips = <span class="string">&quot;用户名不能为空&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!userData.password) &#123;</span><br><span class="line">      resgisterTips.passwordTips = <span class="string">&quot;密码不能为空&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TOKEN_KEY = <span class="string">&#x27;token&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getTokenAuth</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">localStorage</span>.getItem(TOKEN_KEY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次对jwt和md5加密的登陆注册进行了一次编写,还有一些没有了解到的,比如以下问题:</p><ol><li>吊销token(了解到是express-jwt里面的isRevoked)</li><li>是否需要每次访问有权限的接口都携带token(需要,因为只有这样才能判断)</li><li>token的续签</li></ol><p>关联知识点:<br>web网络安全XSS,CSRF<br>token,cookie,session</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="nodejs" scheme="https://zlinni.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>代码之美JS篇</title>
    <link href="https://zlinni.github.io/posts/811989321/"/>
    <id>https://zlinni.github.io/posts/811989321/</id>
    <published>2022-05-08T11:40:08.000Z</published>
    <updated>2022-05-09T01:31:58.168Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>本篇文章讲述如何编写高效美丽的JavaScript代码，让你在开发中有更多的选择而不是停留在基础编码环节。</p></div><h1 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h1><div class="note primary flat"><p>纯函数指的是在给定相同输入的情况下始终返回相同输出的函数。除了他提供的输入以外，他不依赖于任何外部变量，也不更改任何外部变量。拥有纯函数使得测试更加容易，因为可以随时模拟并测试输入的值,如下：</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plusAbc</span>(<span class="params">a, b, c</span>) </span>&#123;  <span class="comment">// 这个函数的输出将变化无常，因为api返回的值一旦改变，同样输入函数的a，b,c的值，但函数返回的结果却不一定相同。</span></span><br><span class="line">  <span class="keyword">var</span> c = fetch(<span class="string">&#x27;../api&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上面的代码看起来很合理，但是该函数本身依赖一个外部变量，所以如果这个变量他被修改，就会有不同的输出，在我们排查错误的时候就比较不方便。如果写了纯函数，确保他没有引入和修改外部的变量，那么就能降低错误的发生。下面是经过改造后的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plusAbc</span>(<span class="params">a, b, c</span>) </span>&#123;  <span class="comment">// 同样输入函数的a，b,c的值，但函数返回的结果永远相同。</span></span><br><span class="line">  <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参数传递与解析"><a href="#参数传递与解析" class="headerlink" title="参数传递与解析"></a>参数传递与解析</h1><p>使用函数的时候，如果我们需要大量的传入参数，那么这会在调用的时候变成一件非常可怕的事情<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createButton = <span class="function">(<span class="params">title, color, disabled, padding, margin, border, shadow</span>)  =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(title, color, disabled, padding, margin, border, shadow)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">createButton(<span class="string">&#x27;Sudongyu er&#x27;</span>, <span class="literal">undefined</span> <span class="comment">/* optional color */</span>, <span class="literal">true</span> ,<span class="string">&#x27;2px....&#x27;</span>, <span class="literal">undefined</span>  <span class="comment">/* optional margin*/</span>);</span><br></pre></td></tr></table></figure></p><p>使用对象的形式来传入数据也许会变得更容易观看<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createButton = <span class="function">(<span class="params">&#123;title, color, disabled, padding, margin, border, shadow&#125;</span>)  =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(title, color, disabled, padding, margin, border, shadow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createButton(&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Sudongyu er&#x27;</span>,</span><br><span class="line">  <span class="attr">disabled</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">shadow</span>: <span class="string">&#x27;2px....&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>不知道大家有没有在用异步请求的时候，写过下面的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;/api/xxx&#x27;</span>,<span class="attr">params</span>:&#123;</span><br><span class="line">    mydata</span><br><span class="line">&#125;,<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = res.data;</span><br><span class="line">    <span class="keyword">if</span>(res.code === <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="comment">//doSomething</span></span><br><span class="line">        res.data.records...    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>使用数据解构的方式让代码更加清晰<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;/api/xxx&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">        mydata</span><br><span class="line">&#125;,<span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    data:&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        code,</span></span></span><br><span class="line"><span class="params"><span class="function">        msg,</span></span></span><br><span class="line"><span class="params"><span class="function">        foodData:&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            records</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(code === <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="comment">//doSomething...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h1 id="对象数组解构"><a href="#对象数组解构" class="headerlink" title="对象数组解构"></a>对象数组解构</h1><p>也许大家都知道这样的解构<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Sudongyu&#x27;</span>,</span><br><span class="line">  <span class="attr">email</span>: <span class="string">&#x27;hi@xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">designation</span>: <span class="string">&#x27;Software Architect&#x27;</span>,</span><br><span class="line">  <span class="attr">loves</span>: <span class="string">&#x27;The Code&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;name, email, loves&#125; = user;</span><br></pre></td></tr></table></figure></p><p>另外一个例子，能显示很多问题<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getDetails = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;sudongyu&#x27;</span>, <span class="string">&#x27;Some Street&#x27;</span>, <span class="string">&#x27;Some City&#x27;</span>, <span class="string">&#x27;Some Zip&#x27;</span>, <span class="string">&#x27;Some Country&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> details = getDetails();</span><br><span class="line"><span class="keyword">const</span> uName = details[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> uEmail = details[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> uAddress = <span class="string">`<span class="subst">$&#123;details[<span class="number">2</span>]&#125;</span>, <span class="subst">$&#123;details[<span class="number">3</span>]&#125;</span>, <span class="subst">$&#123;details[<span class="number">4</span>]&#125;</span>, <span class="subst">$&#123;details[<span class="number">5</span>]&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">const</span> uFirstName = uName.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> uLastName = uName.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>非常的恶心，下面来看解构代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getDetails = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;sudongyu&#x27;</span>, <span class="string">&#x27;Some Street&#x27;</span>, <span class="string">&#x27;Some City&#x27;</span>, <span class="string">&#x27;Some Zip&#x27;</span>, <span class="string">&#x27;Some Country&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [uName, uEmail, ...uAddressArr] = getDetails();</span><br><span class="line"><span class="keyword">const</span> uAddress = uAddressArr.join(<span class="string">&#x27;, &#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> [uFirstName, uLastName] = uName.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(&#123;</span><br><span class="line">  uFirstName,</span><br><span class="line">  uLastName,</span><br><span class="line">  uEmail,</span><br><span class="line">  uAddress</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>我们可以通过上面的代码了解到对于一条数据的解构时机</p><ol><li>需要直接获取就能使用的数据，直接解构</li><li>需要获取之后通过相同功能加工的数据，用剩余参数解构出来加工</li><li>split之后的数据，建议直接用数组解构</li></ol><p>总之就是减少数组下标的访问</p><h1 id="避免硬编码"><a href="#避免硬编码" class="headerlink" title="避免硬编码"></a>避免硬编码</h1><p>看例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, <span class="number">86400000</span>);</span><br><span class="line"><span class="comment">// WHAT IS THIS 86400000 ??? 🤔</span></span><br></pre></td></tr></table></figure></p><p>看代码的人可能不知道这个数字代表什么以及他是如何计算的，以及他背后的业务逻辑是什么，我们可以创建一个常量来代替它。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DAY_IN_MILLISECONDS = <span class="number">3600</span> * <span class="number">24</span> * <span class="number">1000</span>; <span class="comment">// 86400000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, DAY_IN_MILLISECONDS);</span><br><span class="line"><span class="comment">// now this makes sense</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>看另外一个例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createUser = <span class="function">(<span class="params">name, designation, type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(&#123;name, designation, type&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createUser(<span class="string">&#x27;SudongYu&#x27;</span>, <span class="string">&#x27;Software Architect&#x27;</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="comment">// WHAT IS this &#x27;1&#x27;? 🤔</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>这里这个1很难让人理解代表的含义是什么，即type这是什么用户。因此，我们可以创建一个我们拥有的用户类型的对象映射，而不是在这里对值进行硬编码’1’，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> USER_TYPES = &#123;</span><br><span class="line">  <span class="attr">REGULAR_EMPLOYEE</span>: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createUser = <span class="function">(<span class="params">name, designation, type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(&#123;name, designation, type&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createUser(<span class="string">&#x27;Sudongyu&#x27;</span>, <span class="string">&#x27;Software Architect&#x27;</span>, USER_TYPES.REGULAR_EMPLOYEE);</span><br><span class="line"><span class="comment">// smoooooooth 😎</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="避免使用简写变量名"><a href="#避免使用简写变量名" class="headerlink" title="避免使用简写变量名"></a>避免使用简写变量名</h1><p>速记变量在需要它们的地方才有意义。就像如果你有像xand这样的位置坐标y，那是可行的。p但是，如果我们在没有上下文的情况下创建像,t之类的变量c，那么真的很难阅读、跟踪和维护这样的代码。例如看这个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> t = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> users = [<span class="string">&#x27;Sudongyuer&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>];</span><br><span class="line"></span><br><span class="line">users = users.map(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...user,</span><br><span class="line">    <span class="attr">tax</span>: user.salary * t / <span class="number">100</span> <span class="comment">// WHAT IS `t` again? 🤔</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>上面的例子表明，现在开发人员/读者必须一直向上滚动或转到定义来尝试理解这个变量是什么。因此是不干净的代码😠。这也称为对变量进行思维导图，其中只有作者知道它们的含义。因此，我们可以给它一个适当的名称，而不是简写变量名称，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> taxFactor = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> users = [<span class="string">&#x27;Sudongyuer&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>];</span><br><span class="line"></span><br><span class="line">users = users.map(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...user,</span><br><span class="line">    <span class="attr">tax</span>: user.salary * taxFactor / <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="设置默认对象值"><a href="#设置默认对象值" class="headerlink" title="设置默认对象值"></a>设置默认对象值</h1><p>在某些情况下，你可能希望你的对象能够提供一些默认值，如果没有就使用传入的值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createButton = <span class="function">(<span class="params">&#123;title, color, disabled, padding&#125;</span>)  =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> button = &#123;&#125;;</span><br><span class="line">  button.color = color || <span class="string">&#x27;#333&#x27;</span>;</span><br><span class="line">  button.disabled = disabled || <span class="literal">false</span>;</span><br><span class="line">  button.title = title || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  button.padding = padding || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> button;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buttonConfig = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Click me!&#x27;</span>,</span><br><span class="line">  <span class="attr">disabled</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newButton = createButton(buttonConfig);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;newButton&#x27;</span>, newButton)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>修改后<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createButton = <span class="function">(<span class="params">config</span>)  =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...&#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&#x27;#dcdcdc&#x27;</span>,</span><br><span class="line">      <span class="attr">disabled</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">padding</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...config </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buttonConfig = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Click me!&#x27;</span>,</span><br><span class="line">  <span class="attr">disabled</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newButton = createButton(buttonConfig);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;newButton&#x27;</span>, newButton)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="使用方法链"><a href="#使用方法链" class="headerlink" title="使用方法链"></a>使用方法链</h1><p>如果我们知道类/对象的用户将一起使用多个函数，则方法链接是一种很有用的技术。您可能已经在诸如 moment.js 之类的库中看到了这一点。让我们看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name, score, position</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.position = position;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setName</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setPosition</span>(<span class="params">position</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.position = position;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setScore</span>(<span class="params">score</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> player = <span class="keyword">new</span> Player();</span><br><span class="line">player.setScore(<span class="number">0</span>);</span><br><span class="line">player.setName(<span class="string">&#x27;Sudongyuer&#x27;</span>);</span><br><span class="line">player..setPosition([<span class="number">2</span>, <span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(player)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>你可以看到我们需要为这个实例调用一系列的函数，这看起来有点不太美观，修改后的代码如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name, score, position</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.position = position;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setName</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// &lt;-- THIS</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setPosition</span>(<span class="params">position</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.position = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// &lt;-- THIS</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setScore</span>(<span class="params">score</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// &lt;-- THIS</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> player = <span class="keyword">new</span> Player();</span><br><span class="line">player.setScore(<span class="number">0</span>).setName(<span class="string">&#x27;Sudongyuer&#x27;</span>).setPosition([<span class="number">2</span>, <span class="number">0</span>]);</span><br><span class="line"><span class="comment">// SUPER COOL 😎</span></span><br><span class="line"><span class="built_in">console</span>.log(player)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>该方法的核心是每个方法都返回this对象，让他能够链式调用</p><h1 id="在回调上使用Promise"><a href="#在回调上使用Promise" class="headerlink" title="在回调上使用Promise"></a>在回调上使用Promise</h1><p>回调地狱.jpg<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220508202356.png" alt=""></p><p>看例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> getSocials = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      callback(&#123;<span class="attr">socials</span>: &#123;<span class="attr">youtube</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="attr">twitter</span>: <span class="string">&#x27;xxx&#x27;</span>&#125;&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getBooks = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    callback(&#123;<span class="attr">books</span>: [<span class="string">&#x27;React Cookbook&#x27;</span>]&#125;);</span><br><span class="line">  &#125;, <span class="number">1500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getDesignation = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    callback(&#123;<span class="attr">designation</span>: <span class="string">&#x27;Software Architect&#x27;</span>&#125;);</span><br><span class="line">  &#125;, <span class="number">1500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    callback(&#123;<span class="attr">user</span>: <span class="string">&#x27;Sudongyuer&#x27;</span>&#125;);</span><br><span class="line">  &#125;, <span class="number">1500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> getUser(<span class="function">(<span class="params">&#123;user&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;user retrieved&#x27;</span>, user)</span><br><span class="line">    getDesignation(<span class="function">(<span class="params">&#123;designation&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;designation retrieved&#x27;</span>, designation)</span><br><span class="line">      getBooks(<span class="function">(<span class="params">&#123;books&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;books retrieved&#x27;</span>, books)</span><br><span class="line">        getSocials(<span class="function">(<span class="params">&#123;socials&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;socials retrieved&#x27;</span>, socials)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>这代码看起来非常不顺眼，如果有大量的异步任务，写起来会更加难看，特别是缩进。为了更好的可读性，我们使用Promise包装<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getSocials = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">socials</span>: &#123;<span class="attr">youtube</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="attr">twitter</span>: <span class="string">&#x27;xxx&#x27;</span>&#125;&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getBooks = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">books</span>: [<span class="string">&#x27;React Cookbook&#x27;</span>]&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getDesignation = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">designation</span>: <span class="string">&#x27;Software Architect&#x27;</span>&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">user</span>: <span class="string">&#x27;Sudongyuer&#x27;</span>&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  getUser()</span><br><span class="line">    .then(<span class="function">(<span class="params">&#123;user&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;user retrieved&#x27;</span>, user);</span><br><span class="line">      <span class="keyword">return</span> getDesignation();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">&#123;designation&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;designation retrieved&#x27;</span>, designation)</span><br><span class="line">      <span class="keyword">return</span> getBooks();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">&#123;books&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;books retrieved&#x27;</span>, books);</span><br><span class="line">      <span class="keyword">return</span> getSocials();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">&#123;socials&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;socials retrieved&#x27;</span>, socials)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>这样的话，很大程度就解决了缩进的问题，而且也比较美观，当然我们还有更具可读性的方法,利用到async和await</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getSocials = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">socials</span>: &#123;<span class="attr">youtube</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="attr">twitter</span>: <span class="string">&#x27;xxx&#x27;</span>&#125;&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getBooks = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">books</span>: [<span class="string">&#x27;React Cookbook&#x27;</span>]&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getDesignation = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">designation</span>: <span class="string">&#x27;Software Architect&#x27;</span>&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">user</span>: <span class="string">&#x27;Sudongyuer&#x27;</span>&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> performTasks = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;user&#125; = <span class="keyword">await</span> getUser();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;user retrieved&#x27;</span>, user);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;designation&#125; = <span class="keyword">await</span> getDesignation();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;designation retrieved&#x27;</span>, designation);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;books&#125; = <span class="keyword">await</span> getBooks();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;books retrieved&#x27;</span>, books);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;socials&#125; = <span class="keyword">await</span> getSocials();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;socials retrieved&#x27;</span>, socials);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`     </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 明确函数意图</span></span><br><span class="line"><span class="string">对于返回的是true/false的函数,最好以should/can/is/has开头</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="comment">// 👎 自我感觉良好的缩写:</span></span><br><span class="line"><span class="keyword">let</span> rContent = <span class="string">&#x27;willen&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 👍 无需对每个变量都写注释，从名字上就看懂</span></span><br><span class="line"><span class="keyword">let</span> firstName = <span class="string">&#x27;jackie&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 👎 从命名无法知道返回值类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showFriendsList</span>(<span class="params"></span>) </span>&#123;....&#125; <span class="comment">// // 无法辨别函数意图,返回的是一个数组，还是一个对象，还是true or false?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 👍 明确函数意图，对于返回true or false的函数，最好以should/is/can/has开头</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldShowFriendsList</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmpty</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canCreateDocuments</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasLicense</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendEmailToUser</span>(<span class="params">user</span>) </span>&#123;.... &#125; <span class="comment">//动词开头，函数意图就很明显</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="变量兜底"><a href="#变量兜底" class="headerlink" title="变量兜底"></a>变量兜底</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 👎 对于求值获取的变量，没有兜底</span></span><br><span class="line"><span class="keyword">const</span> &#123; data &#125; = getApiRequest();</span><br><span class="line">data.map(<span class="function">(<span class="params">s</span>) =&gt;</span> s.id); <span class="comment">//没有考虑data异常的情况，代码一跑就爆炸</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 👍 对于求值变量，做好兜底</span></span><br><span class="line"><span class="keyword">const</span> &#123; data = [] &#125; = getApiRequest();</span><br><span class="line">data.map(<span class="function">(<span class="params">s</span>) =&gt;</span> s?.id); <span class="comment">//没有考虑data异常的情况，代码一跑就爆炸</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Tree二叉搜索树笔记⑧--构造篇</title>
    <link href="https://zlinni.github.io/posts/3090245434/"/>
    <id>https://zlinni.github.io/posts/3090245434/</id>
    <published>2022-05-08T06:57:01.000Z</published>
    <updated>2022-05-08T11:13:29.306Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在上一篇基操篇我们讲述了BST的判断合法性和增删改查，下面来学习BST的构造，读完本文你对下面的题目会有更深入的了解。</p></div><p>Leetcode<br><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96.不同的二叉搜索树</a><br><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95.不同的二叉搜索树 II</a></p><h1 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220508155308.png" alt=""></p><p>这是一道穷举的题目，首先我们做个例子:比如输入<code>n=3</code>，那么就有以下几个情况</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220508155735.png" alt=""></p><p>这个是一个正宗的穷举问题，那么有什么方法可以正确的穷举BST的数量呢？</p><p>再看一个例子 比如给算法输入<code>n=5</code>也就是要求他从<code>1,2,3,4,5</code>里面找数字构成BST</p><p>显然会有五种情况，因为每个数字都可以作为根节点，那么我们固定3为根节点，看到底能构成多少个BST</p><p>因为BST左小右大的性质，很明显3为根节点的时候，左子树节点就是<code>1,2</code>右子树节点就是<code>4,5</code></p><p>那么左子树的组合数和右子树的组合数的乘积就是3作为根节点的时候的BST个数</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220508160416.png" alt=""></p><p>在代码方面，其实我们只需要递归就可以了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算闭区间[1,n]组成的BST数量</span></span><br><span class="line"><span class="keyword">const</span> numTree = <span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> count(<span class="number">1</span>,n);</span><br><span class="line">  <span class="keyword">const</span> count = <span class="function">(<span class="params">start,end</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">// base case</span></span><br><span class="line">      <span class="keyword">if</span>(start&gt;end)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">          <span class="keyword">let</span> left = count(start,i-<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">let</span> right = count(i+<span class="number">1</span>,end);</span><br><span class="line">          res += left*right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是这样做显然是不行的，因为会存在很多重叠子问题，我们可以利用一个memo备忘录来解决这个问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numTrees = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> memo = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">const</span> count = <span class="function">(<span class="params">lo,hi</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(lo&gt;hi)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> memoKey = <span class="string">`<span class="subst">$&#123;lo&#125;</span>&amp;<span class="subst">$&#123;hi&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo.has(memoKey))&#123;</span><br><span class="line">          <span class="keyword">return</span> memo.get(memoKey)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> mid = lo;mid&lt;=hi;mid++)&#123;</span><br><span class="line">          <span class="keyword">let</span> left = count(lo,mid-<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">let</span> right = count(mid+<span class="number">1</span>,hi);</span><br><span class="line">          res += left*right;</span><br><span class="line">        &#125;</span><br><span class="line">        memo.set(memoKey,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不同的二叉搜索树II"><a href="#不同的二叉搜索树II" class="headerlink" title="不同的二叉搜索树II"></a>不同的二叉搜索树II</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220508163630.png" alt=""></p><p>题目类似，但是最后要返回全部组合的BST</p><p>我们不难想到还是要用memo去记录我们的子问题，并且这里还存在一个关键，就是我们可以用简单的memoKey来帮助我们记录<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generateTrees = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">0</span>)<span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> memo = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> count = <span class="function">(<span class="params">lo,hi</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res = [];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(lo&gt;hi)&#123;</span><br><span class="line">            res.push(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义memoKey</span></span><br><span class="line">        <span class="keyword">let</span> memoKey = <span class="string">`<span class="subst">$&#123;lo&#125;</span>&amp;<span class="subst">$&#123;hi&#125;</span>`</span>;</span><br><span class="line">        <span class="comment">//查找备忘录</span></span><br><span class="line">        <span class="keyword">if</span>(memo.has(memoKey))&#123;</span><br><span class="line">            <span class="keyword">return</span> memo.get(memoKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 穷举root节点的所有BST可能</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=lo;i&lt;=hi;i++)&#123;</span><br><span class="line">            <span class="comment">// i作为根节点</span></span><br><span class="line">            <span class="keyword">let</span> leftTree = count(lo,i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">let</span> rightTree = count(i+<span class="number">1</span>,hi);</span><br><span class="line">            <span class="comment">// 穷举root的所有左右子树组合</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> left <span class="keyword">of</span> leftTree) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> right <span class="keyword">of</span> rightTree) &#123;</span><br><span class="line">                    res.push(<span class="keyword">new</span> TreeNode(i,left,right))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存放res</span></span><br><span class="line">        memo.set(memoKey,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>BST的构造核心还是BT的构造，但是不同的是，我们可以根据BST的root划分左右去穷举并构造。穷举的过程就是看左右子树有多少种可能的过程，最后可能性相乘就是组合。还学习到了memo的记录方式来排除重复子问题，以及用简单的memoKey。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Tree二叉搜索树笔记⑦--基操篇</title>
    <link href="https://zlinni.github.io/posts/3737568820/"/>
    <id>https://zlinni.github.io/posts/3737568820/</id>
    <published>2022-05-07T08:49:21.000Z</published>
    <updated>2022-05-08T07:51:33.430Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在前面的文章我们学习了BST二叉搜索树的性质，以及结合中序遍历的性质，可以实现树的升序和降序，以及累加树的操作。下面这篇文章深入讲解BST的性质，判断BST的合法性，增删改查，读完本文你对下面的算法题会有更深入的了解</p></div><p>Leetcode<br><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450.删除二叉搜索树的节点</a><br><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701.二叉搜索树中的插入操作</a><br><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700.二叉搜索树中的搜索</a><br><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98.验证二叉搜索树</a></p><h1 id="BST简介"><a href="#BST简介" class="headerlink" title="BST简介"></a>BST简介</h1><div class="note primary flat"><p>所谓的二叉搜索树，就是左小右大的二叉树。利用他的性质，我们可以做到类似二分搜索的操作，搜索一个元素的效率很高，</p></div><p>对于BST相关的问题，我们经常会看到以下代码逻辑<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BST = <span class="function">(<span class="params">root,target</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.val===target)&#123;</span><br><span class="line">        <span class="comment">//do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.val&lt;target)&#123;</span><br><span class="line">        BST(root.right,target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.val&gt;target)&#123;</span><br><span class="line">        BST(root.left,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个代码框架其实和二叉树遍历差不多，无非就是利用了BST左小右大的特性</p><p>下面来讲几道BST必会的题目</p><h1 id="判断BST的合法性"><a href="#判断BST的合法性" class="headerlink" title="判断BST的合法性"></a>判断BST的合法性</h1><p>这里存在了坑点，按照我们之前思考的二叉树节点应该做什么的做法，这里会写出以下的code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> judgeBST = <span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(n.left!==<span class="literal">null</span>&amp;&amp;n.val&lt;n.left.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n.right!==<span class="literal">null</span>&amp;n.val&gt;n.right.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> judgeBST(n.left)&amp;&amp;judgeBST(n.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看似好像没什么问题，但是实际上这个算法出现了错误，原因在于BST的性质。对于这个算法来说，他判断的是每个节点的值要大于左边小于右边，但是BST的性质是对于每个节点，他的值都要小于右子树的全部值，大于左子树的全部值，看图：</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220507182900.png" alt=""></p><p>该图不是BST，但是他会被这个算法判定为BST</p><p>那么我们应该怎么做呢？既然要满足当前节点大于左子树全部值，小于右子树全部值，我们不妨设个变量max和min，分别来代替左右子树的最大值，一旦没有满足这个条件就视为非BST</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果满足max&gt;root.val&gt;min就正确</span></span><br><span class="line"><span class="keyword">const</span> isValidBST = <span class="function">(<span class="params">n,max,min</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//注意这里是判断子树不为空</span></span><br><span class="line">    <span class="keyword">if</span>(min!==<span class="literal">null</span>&amp;&amp;n.val&lt;=min.val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(max!==<span class="literal">null</span>&amp;&amp;n.val&gt;=max.val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//对于左子树来说，最大值是n，对于右子树来说，最小值是n</span></span><br><span class="line">    <span class="keyword">return</span> isValidBST(n.left,n,min)&amp;&amp;isValidBST(n.right,max,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isValidBST(root,<span class="literal">null</span>,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h1 id="在BST中搜索元素"><a href="#在BST中搜索元素" class="headerlink" title="在BST中搜索元素"></a>在BST中搜索元素</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220507184411.png" alt=""></p><p>如果是一颗普通的二叉树可以写如下的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> searchBST = <span class="function">(<span class="params">n,target</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(n.val === target) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">let</span> left = searchBST(n.left,target);</span><br><span class="line">    <span class="keyword">let</span> right = searchBST(n.right,target); </span><br><span class="line">    <span class="keyword">return</span> left!==<span class="literal">null</span>?left:right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码相当于穷举了二叉树中的所有节点，如果找的到就返回对应的子树.</p><p>但我们拥有BST的性质，就应该利用起来，比较root和target的值，将其中的一边舍去。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> searchBST = <span class="function">(<span class="params">n,target</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(n.val&lt;target)<span class="keyword">return</span> searchBST(n.right,target);</span><br><span class="line">    <span class="keyword">if</span>(n.val&gt;target)<span class="keyword">return</span> searchBST(n.left,target);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="在BST中插入一个数"><a href="#在BST中插入一个数" class="headerlink" title="在BST中插入一个数"></a>在BST中插入一个数</h1><div class="note primary flat"><p>对于数据结构的操作无非就是遍历+访问，其中遍历就是找，访问就是改。具体而言，插入一个数据就首先要找到插入的位置，然后进行插入操作。</p></div><p>上一个问题，我们总结了BST的遍历框架，也就是找的问题，直接套框架，然后我们只要进行改的操作就可以了。但是要注意的是，一旦涉及到改，函数就要返回treenode类型，并且对递归调用的返回值进行接收</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertIntoBST = <span class="function"><span class="keyword">function</span>(<span class="params">root, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    <span class="keyword">if</span>(root.val&lt;val)&#123;</span><br><span class="line">        root.right = insertIntoBST(root.right,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.val&gt;val)&#123;</span><br><span class="line">        root.left = insertIntoBST(root.left,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在BST中删除一个数"><a href="#在BST中删除一个数" class="headerlink" title="在BST中删除一个数"></a>在BST中删除一个数</h1><p>这个问题比较复杂，但是思路也差不多，先找到再改，框架如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">root, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.val === key)&#123;</span><br><span class="line">        <span class="comment">//delete</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;key)&#123;</span><br><span class="line">        root.left = deleteNode(root.left,key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        root.right = deleteNode(root.right,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于如何删除这个节点，有下面的几种情况：</p><p>情况一：A这个节点恰好是末端节点，两个子节点为空，那么他就可以当场去世了。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220507194014.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root.left&amp;&amp;!root.right)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况二：A只有一个非空字节点，那么就要让这子节点替代自己的位置<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220507194203.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root.left)<span class="keyword">return</span> root.right;</span><br><span class="line"><span class="keyword">if</span>(!root.right)<span class="keyword">return</span> root.left;</span><br></pre></td></tr></table></figure><p>情况三：A有两个子节点，那么就比较复杂了，需要找到右子树最小的节点来替代自己<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220507194517.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root.left&amp;&amp;root.right)&#123;</span><br><span class="line">    <span class="keyword">let</span> minNode = getMin(root.right);</span><br><span class="line">    root.val = minNode.val;</span><br><span class="line">    root.right = deleteNode(root.right,minNode.val)</span><br><span class="line">    minNode.left = root.left;</span><br><span class="line">    minNode.right = root.right;</span><br><span class="line">    root = minNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span> (<span class="params">root, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.val === key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root.left)<span class="keyword">return</span> root.right;</span><br><span class="line">        <span class="keyword">if</span>(!root.right)<span class="keyword">return</span> root.left;</span><br><span class="line">        <span class="keyword">if</span>(root.left&amp;&amp;root.right)&#123;</span><br><span class="line">            <span class="keyword">let</span> minNode = root.right;</span><br><span class="line">            <span class="keyword">while</span>(minNode.left)&#123;</span><br><span class="line">                minNode = minNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root.right = deleteNode(root.right,minNode.val);</span><br><span class="line">            minNode.left = root.left;</span><br><span class="line">            minNode.right = root.right;</span><br><span class="line">            root = minNode</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key)&#123;</span><br><span class="line">        root.right = deleteNode(root.right,key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        root.left = deleteNode(root.left,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就完成了删除的操作，但是有人可能在这一步会好奇，为什么修改root节点这么麻烦，直接修改val值不是更方便吗<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">minNode.left = root.left;</span><br><span class="line">minNode.right = root.right;</span><br><span class="line">root = minNode</span><br><span class="line"></span><br><span class="line">=》</span><br><span class="line"></span><br><span class="line">root.val = minNode.val;</span><br></pre></td></tr></table></figure></p><p>对于这道题来说是可以这么做的，但是不提倡，因为在实际应用中，BST 节点内部的数据域是用户自定义的，可以非常复杂，而 BST 作为数据结构（一个工具人），其操作应该和内部存储的数据域解耦，所以我们更倾向于使用指针操作来交换节点，根本没必要关心内部数据。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><div class="note primary flat"><p>通过这篇文章，我们能学会几个关键的操作，BST的增删改查，和合法性判断。</p></div><p>技巧如下：<br>根据二叉树的递归得到BST的代码框架<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BST = <span class="function">(<span class="params">n,target</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.val===target)&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;val)&#123;</span><br><span class="line">        BST(root.right,target);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&gt;val)&#123;</span><br><span class="line">        BST(root.left,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Pinia大菠萝--新一代状态管理</title>
    <link href="https://zlinni.github.io/posts/3383846748/"/>
    <id>https://zlinni.github.io/posts/3383846748/</id>
    <published>2022-05-06T09:57:23.000Z</published>
    <updated>2022-05-08T11:30:35.545Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>如今已经是vue3+ts的时代，但对于我们的状态管理工具vuex来说，他也是存在一定的缺陷的，下文讲解pinia的由来和基础的用法，用于构建个人的轻量级项目。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220506181436.png" alt=""></p><h1 id="Pinia大菠萝"><a href="#Pinia大菠萝" class="headerlink" title="Pinia大菠萝"></a>Pinia大菠萝</h1><div class="note primary flat"><p>pinia是新的一门状态管理工具，他是vue官方推荐的替代vuex的产品。特点如下：</p></div><ul><li>拥有完整的ts支持，这点和vuex比起来更舒适。</li><li>更小的体积(约1kb)</li><li>没有muatation，只有action</li><li>store可以直接使用，不需要辅助函数</li></ul><h1 id="pinia为什么体积小于vuex"><a href="#pinia为什么体积小于vuex" class="headerlink" title="pinia为什么体积小于vuex"></a>pinia为什么体积小于vuex</h1><p>这得从它们两者的代码分割机制来讲：</p><div class="note primary flat"><p>举个例子：某项目有3个store「user、job、pay」，另外有2个路由页面「首页、个人中心页」，首页用到job store，个人中心页用到了user store，分别用Pinia和Vuex对其状态管理。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220506183109.png" alt=""></p><p>先看Vuex的代码分割： 打包时，vuex会把3个store合并打包，当首页用到Vuex时，这个包会引入到首页一起打包，最后输出1个js chunk。这样的问题是，其实首页只需要其中1个store，但其他2个无关的store也被打包进来，造成资源浪费。</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220506183122.png" alt=""></p><p>Pinia的代码分割： 打包时，Pinia会检查引用依赖，当首页用到job store，打包只会把用到的store和页面合并输出1个js chunk，其他2个store不耦合在其中。Pinia能做到这点，是因为它的设计就是store分离的，解决了项目的耦合问题。</p><p>总结：pinia根据引用打包store文件，但vuex就是全部打包。</p><h1 id="安装pinia"><a href="#安装pinia" class="headerlink" title="安装pinia"></a>安装pinia</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pinia</span><br></pre></td></tr></table></figure><h1 id="挂载实例"><a href="#挂载实例" class="headerlink" title="挂载实例"></a>挂载实例</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createPinia&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> pinia = createPinia();</span><br><span class="line">app.use(pinia);</span><br></pre></td></tr></table></figure><h1 id="创建第一个store"><a href="#创建第一个store" class="headerlink" title="创建第一个store"></a>创建第一个store</h1><p>在<code>src/store/index.ts</code>里面创建你的store，其中定义store的方式有两种 </p><ul><li><p>使用optionAPI模式定义，这种方式和vue2的类似</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mainStore = defineStore(<span class="string">&#x27;main&#x27;</span>,&#123;</span><br><span class="line">  <span class="attr">state</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      <span class="attr">count</span>:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.count++:</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">getters</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">doubleCount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>使用setup模式定义，符合Vue3 setup的编程模式，让结构更加扁平化，更推荐使用这种方式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mainStore = defineStore(<span class="string">&#x27;main&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = ref&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> increment:<span class="built_in">number</span> = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    count.value++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> doubleCount:<span class="built_in">number</span> = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count.value*<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;count,increment,doubleCount&#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><div class="note primary flat"><p>state定义数据，action放同步或者异步的方法，getters获取state的计算结果</p></div><p>上面两个的方式效果都是一样的，区别在于使用了setup的方式更贴近于vue3，然后我们不用在意action和getters关键字。而第一种方式的话，我们还是需要写getters和actions等来区分我们的代码</p><h1 id="调用store的数据"><a href="#调用store的数据" class="headerlink" title="调用store的数据"></a>调用store的数据</h1><div class="note primary flat"><p>这一部分讲解怎么调用store的数据,主要是解析响应式数据，对于ref我们需要引入<code>storeToRefs</code>再解构，否则丢失响应</p></div><p>code 使用setup的格式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mainStore&#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/mainStore.ts&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;storeToRefs&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = mainStore();</span><br><span class="line">  <span class="comment">//解析数据 可以解构reactive的</span></span><br><span class="line">  <span class="keyword">const</span> &#123; data &#125; = store;</span><br><span class="line">  <span class="comment">//ref类型需要这样</span></span><br><span class="line">  <span class="keyword">const</span> &#123; refData &#125; = storeToRefs(store); </span><br><span class="line">  <span class="keyword">const</span> &#123; fun1,fun2 &#125; = store;</span><br><span class="line">  <span class="comment">//使用ref的数据 </span></span><br><span class="line">  <span class="built_in">console</span>.log(refData.value);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p><h1 id="创建多个store"><a href="#创建多个store" class="headerlink" title="创建多个store"></a>创建多个store</h1><p>项目复杂了就需要多个store管理。其实pinia创建新的store方式很简单，就是export的时候命名和文件名一致就行了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> index = defineStore(<span class="string">&#x27;index&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> map = defineStore(<span class="string">&#x27;map&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Tree二叉搜索树笔记⑥--特性篇</title>
    <link href="https://zlinni.github.io/posts/2732070170/"/>
    <id>https://zlinni.github.io/posts/2732070170/</id>
    <published>2022-05-05T08:38:38.000Z</published>
    <updated>2022-05-08T03:37:53.742Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在前面的文章我们学习了寻找一颗二叉树的重复子树，这个问题结合了第四章节的序列化内容加第三章节的构造内容，接下来我们学习二叉搜索树的知识，读完本文你对以下的题目有更深刻的了解：</p></div><p>Leetcode<br><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230.二叉树中的第k小元素</a><br><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538.把二叉搜索树转为累加树</a><br><a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">1038.把二叉搜索树转为累加树</a></p><h1 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h1><div class="note primary flat"><p>全称二叉搜索树，简写BST，特性如下：</p></div><ol><li>BST的每个节点，左子树节点的值都比他小，右子树节点的值都比他大。</li><li>对于BST的每一个节点，他的左侧子树和右侧子树都是BST</li></ol><div class="note primary flat"><p>labuladong原话：二叉搜索树并不算复杂，但我觉得它可以算是数据结构领域的半壁江山，直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。</p></div><p>从算法题的角度来讲，中序遍历一个BST，是升序的，因为他先构造了左子树再构造右子树，所以如果是以一个数组的形式显示，就是从小到大的。</p><h1 id="寻找第-K-小的元素"><a href="#寻找第-K-小的元素" class="headerlink" title="寻找第 K 小的元素"></a>寻找第 K 小的元素</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505183122.png" alt=""><br>按照上面的思路，我们只要中序遍历这个二叉树然后找第k个就行了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kthSmallest = <span class="function"><span class="keyword">function</span>(<span class="params">root, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res;</span><br><span class="line">    <span class="keyword">const</span> inorder = <span class="function"><span class="params">root</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span>(k===<span class="number">0</span>)res = root.val;</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然这道题做完了，但是这个解法在目前来说并不是最高效的。下面引自labuladong</p><div class="note primary flat"><p>如果按照我们刚才说的方法，利用「BST 中序遍历就是升序排序结果」这个性质，每次寻找第 k 小的元素都要中序遍历一次，最坏的时间复杂度是 O(N)，N 是 BST 的节点个数。</p><p>要知道 BST 性质是非常牛逼的，像红黑树这种改良的自平衡 BST，增删查改都是 O(logN) 的复杂度，让你算一个第 k 小元素，时间复杂度竟然要 O(N)，有点低效了。</p><p>所以说，计算第 k 小元素，最好的算法肯定也是对数级别的复杂度，不过这个依赖于 BST 节点记录的信息有多少。</p><p>我们想一下 BST 的操作为什么这么高效？就拿搜索某一个元素来说，BST 能够在对数时间找到该元素的根本原因还是在 BST 的定义里，左子树小右子树大嘛，所以每个节点都可以通过对比自身的值判断去左子树还是右子树搜索目标值，从而避免了全树遍历，达到对数级复杂度。</p><p>那么回到这个问题，想找到第 k 小的元素，或者说找到排名为 k 的元素，如果想达到对数级复杂度，关键也在于每个节点得知道他自己排第几。</p><p>比如说你让我查找排名为 k 的元素，当前节点知道自己排名第 m，那么我可以比较 m 和 k 的大小：</p><p>1、如果 m == k，显然就是找到了第 k 个元素，返回当前节点就行了。</p><p>2、如果 k &lt; m，那说明排名第 k 的元素在左子树，所以可以去左子树搜索第 k 个元素。</p><p>3、如果 k &gt; m，那说明排名第 k 的元素在右子树，所以可以去右子树搜索第 k - m - 1 个元素。</p><p>这样就可以将时间复杂度降到 O(logN) 了。</p><p>那么，如何让每一个节点知道自己的排名呢？</p><p>这就是我们之前说的，需要在二叉树节点中维护额外信息。每个节点需要记录，以自己为根的这棵二叉树有多少个节点。</p><p>也就是说，我们 TreeNode 中的字段应该如下：</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    int val;</span><br><span class="line">    <span class="comment">// 以该节点为根的树的节点总数</span></span><br><span class="line">    int size;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 size 字段，外加 BST 节点左小右大的性质，对于每个节点 node 就可以通过 node.left 推导出 node 的排名，从而做到我们刚才说到的对数级算法。</p><p>当然，size 字段需要在增删元素的时候需要被正确维护，力扣提供的 TreeNode 是没有 size 这个字段的，所以我们这道题就只能利用 BST 中序遍历的特性实现了，但是我们上面说到的优化思路是 BST 的常见操作，还是有必要理解的。</p><h1 id="BST转累加树"><a href="#BST转累加树" class="headerlink" title="BST转累加树"></a>BST转累加树</h1><p>力扣538和1038题都是这一道，可以一起做了。</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220507162402.png" alt=""></p><p>按照二叉树的通用思路，我们要思考每个节点本身应该做什么，但是这道题很难想到什么思路。</p><p>但是我们可以这样想，我们的目的是什么，是将节点进行一个累加然后赋值到这个节点，中序遍历的性质就是能将BST变成升序。</p><p>不过一般的中序可做不到这个特点，因为是左根右，只能打印出升序的，我们现在需要从右子树开始计算，所以可以使用右根左，打印出降序的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> convertBST = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> inorder = <span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    inorder(n.right);</span><br><span class="line">    sum+=n.val;</span><br><span class="line">    n.val = sum;</span><br><span class="line">    inorder(n.left);</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inorder(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>BST可以结合中序遍历的特性去帮助我们完成树的升序或者降序，这一点需要牢记。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree二叉树笔记--合集（更新中）</title>
    <link href="https://zlinni.github.io/posts/3500150157/"/>
    <id>https://zlinni.github.io/posts/3500150157/</id>
    <published>2022-05-05T07:06:00.000Z</published>
    <updated>2022-05-07T12:44:47.052Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>根据这五篇的二叉树学习，你将从一个只会根左右，左根右和左右根的算法小白中领略二叉树的核心算法。</p><h1 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h1><p><a href="https://zlinni.github.io/posts/1410341477">手把手二叉树笔记①—纲领篇</a><br><a href="https://zlinni.github.io/posts/1410341478">手把手二叉树笔记②—思路篇</a><br><a href="https://zlinni.github.io/posts/686027467">手把手二叉树笔记③—构造篇</a><br><a href="https://zlinni.github.io/posts/3440987103">手把手二叉树笔记④—序列化篇</a><br><a href="https://zlinni.github.io/posts/3318597918">手把手二叉树笔记⑤—后序篇</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree二叉树笔记⑤--后序篇</title>
    <link href="https://zlinni.github.io/posts/732690854/"/>
    <id>https://zlinni.github.io/posts/732690854/</id>
    <published>2022-05-05T07:05:40.000Z</published>
    <updated>2022-05-08T03:34:51.372Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在上一篇我们学习了用js解决二叉树的序列化和反序列化的问题，其实序列化的过程就是考察二叉树遍历的过程，反序列化的过程就是考察了二叉树的构造过程，结合了前几章的知识。本篇文章深入学习二叉树后序的妙用，带你了解以下题目：</p></div><p>Leetcode<br>652.寻找重复的子树</p><h1 id="寻找重复的子树"><a href="#寻找重复的子树" class="headerlink" title="寻找重复的子树"></a>寻找重复的子树</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505151327.png" alt=""></p><p>这道题实际上就是找子树的问题，看下图<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505151425.png" alt=""></p><p>首先节点4可以作为一颗子树，二叉树中有多个节点4<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505151457.png" alt=""></p><p>类似的还存在两颗以2为根的重复子树<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505151521.png" alt=""></p><p>那么我们返回的list就应该有两个treenode，2和4 </p><p>具体这道题要怎么做呢？先思考对于一个节点他应该做什么？</p><p>我们拿这个2节点作为例子，他是不是重复的子树，是不是就要先知道自己是一颗怎么样的子树，再去找别的子树进行对比？<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505152207.png" alt=""></p><p>那么我们解题的关键就来了：</p><ol><li>先知道自己长什么样</li><li>去看看别人有没有和自己一样的</li></ol><p>那么对于第一个问题，根据本文你可以知道我们要用后序遍历的操作去做，其实前序中序都可以，只不过后序在这个阶段看的东西更明显，怎么知道自己是谁呢？其实就是自身加左右子树<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postoreder = <span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> left = postoreder(n.left);</span><br><span class="line">  <span class="keyword">let</span> right = postoreder(n.right);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;left&#125;</span>,<span class="subst">$&#123;right&#125;</span>,<span class="subst">$&#123;n.val&#125;</span>`</span>;</span><br><span class="line">  <span class="comment">//n 就是一颗树了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样不就能知道自己是谁了吗？一看这个问题，你就会发现，和之前的序列化二叉树及其相似，其实知道自己是谁的这个过程，就是经历了一次序列化。</p><p>那么现在怎么解决找同伴的问题呢？其实很简单，我们运用js的set或者map，考量这两个api用哪个的时候，我们先看我们需要什么？我们需要记录出现次数超过一次的子树，也就是记录子树+子树出现次数，所以用map更好。完整代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findDuplicateSubtrees = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//定义map集合和存放的数组</span></span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(),res = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> tranverse = <span class="function"><span class="params">root</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">const</span> left = tranverse(root.left);</span><br><span class="line">        <span class="keyword">const</span> right = tranverse(root.right);</span><br><span class="line">        <span class="keyword">const</span> str = <span class="string">`<span class="subst">$&#123;left&#125;</span>,<span class="subst">$&#123;right&#125;</span>,<span class="subst">$&#123;root.val&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">const</span> count = map.get(str);</span><br><span class="line">        <span class="keyword">if</span>(count===<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//等于1就存放子树</span></span><br><span class="line">            res.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(str,(count||<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tranverse(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>寻找重复子树的过程就是后序序列化+搜索的过程，注意序列化的时候要放入的是val，搜索的时候结合map和满足一次加入res的条件优化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree二叉树笔记④--序列化篇</title>
    <link href="https://zlinni.github.io/posts/3440987103/"/>
    <id>https://zlinni.github.io/posts/3440987103/</id>
    <published>2022-05-04T11:44:11.000Z</published>
    <updated>2022-05-08T03:19:58.608Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在上一期我们对二叉树的构造进行了深入的了解，重点掌握了构造的核心原理以及一些细节上面的问题。下面来学习二叉树的序列化，通过本篇文章你可以学会以下的题目</p></div><p>Leetcode<br><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297.二叉树的序列化与反序列化</a></p><h1 id="二叉树的序列化与反序列化"><a href="#二叉树的序列化与反序列化" class="headerlink" title="二叉树的序列化与反序列化"></a>二叉树的序列化与反序列化</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505111425.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505145026.png" alt=""></p><p>该题目本质上，就是把二叉树转换为字符串，再从字符串转为二叉树的过程。</p><p>至于我们序列化的过程，使用什么符号定义并不重要，只要最后能够反序列化出来即可。</p><p>eg<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505145259.png" alt=""></p><p>对于一颗这样的树，我们可以将他序列化成<code>2,1,#,6,3,#,#</code>其实他考察的就是如何对二叉树进行遍历。</p><p>二叉树的递归遍历有三种，前序中序后序，迭代遍历有层序，那么就从层序开始，看如何解题</p><h1 id="前序遍历解法"><a href="#前序遍历解法" class="headerlink" title="前序遍历解法"></a>前序遍历解法</h1><p>我们知道，前序遍历的代码就是在递归之前写的，那么就有以下的逻辑<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">traverse(root.left);</span><br><span class="line">traverse(root.right);</span><br></pre></td></tr></table></figure></p><p>那么我们就很容易得出序列化的过程了，就是字符串的连接<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serialize = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;root&#125;</span>,<span class="subst">$&#123;serialize(root.left)&#125;</span>,<span class="subst">$&#123;serialize(root.right)&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>那么其实反序列化，就是把序列化的这一串字符串转换为treenode。</p><p>对于一个字符串来说，js提供了split方法帮我们进行分割，也就是说以下的逻辑，会分割出一个数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nodeArr = data.split(<span class="string">&quot;,&quot;</span>);</span><br></pre></td></tr></table></figure></p><p>我们拿到了这个数组，因为他是前序的序列化而来的，那么我们根据前序的特性可以得到以下条件<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505145931.png" alt=""></p><p>第一个值是根，这就是我们的递归关键，回想一下前序构造二叉树，我们可以得到如下的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> build = <span class="function">(<span class="params">preorder</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> val = preorder.shift();</span><br><span class="line">  <span class="keyword">if</span>(val === <span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">  root.left = build(preorder);</span><br><span class="line">  root.right = build(preorder);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么我们的反序列化就能写出来了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deserialize = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nodearr = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!nodearr.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> build = <span class="function">(<span class="params">nodearr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> val = nodearr.shift();</span><br><span class="line">        <span class="keyword">if</span> (val === <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root.left = build(nodearr);</span><br><span class="line">        root.right = build(nodearr);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(nodearr);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>完整代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serialize = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;root.val&#125;</span>,<span class="subst">$&#123;serialize(root.left)&#125;</span>,<span class="subst">$&#123;serialize(root.right)&#125;</span>`</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deserialize = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nodearr = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!nodearr.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> build = <span class="function">(<span class="params">nodearr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> val = nodearr.shift();</span><br><span class="line">        <span class="keyword">if</span> (val === <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root.left = build(nodearr);</span><br><span class="line">        root.right = build(nodearr);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(nodearr);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>序列化就是转字符串的过程，这个过程用什么符号代替并不重要，只要最后能解析即可。一般是利用前序空节点返回#然后模板字符串拼接根+递归的左右</p><p>反序列化的就是解析字符串重构树的过程，注意需要用split分割字符串为数组，遇到#就返回null。</p><p>重构树的过程，由于他是数组转树，我们递归的时候就要注意递归的是数组，我们取节点就应该使用shift</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree二叉树笔记③--构造篇</title>
    <link href="https://zlinni.github.io/posts/686027467/"/>
    <id>https://zlinni.github.io/posts/686027467/</id>
    <published>2022-05-04T11:43:28.000Z</published>
    <updated>2022-05-08T03:01:55.154Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在上一篇笔记里面，我们深入了解了前序和后序遍历的本质，学会了翻转二叉树，将二叉树转为链表和填充二叉树右侧指针三道问题。接下来进一步学习，在本篇能理解并运用以下题目：</p></div><p>Leetcode<br><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654.最大二叉树</a><br><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105.从前序遍历和中序遍历构造二叉树</a><br><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106.从中序和后序遍历构造二叉树</a><br><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889.根据前序和后序遍历构造二叉树</a></p><h1 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220504201032.png" alt=""></p><p>我们细分这道题，其实他在做这样的事情<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constructMaximumBinaryTree = <span class="function"><span class="keyword">function</span> (<span class="params">[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">5</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 找到数组的最大值</span></span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(<span class="number">6</span>)</span><br><span class="line">    <span class="comment">// 递归调用构造左右子树</span></span><br><span class="line">    root.left = constructMaximumBinaryTree([<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]);</span><br><span class="line">    root.right = constructMaximumBinaryTree([<span class="number">0</span>,<span class="number">5</span>]);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再详细一点就是如下的思路：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constructMaximumBinaryTree = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> build = <span class="function">(<span class="params">nums,start,end</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//查找最大值和他的下标</span></span><br><span class="line">        <span class="keyword">let</span> max = -<span class="literal">Infinity</span>,index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;max)&#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构造二叉树</span></span><br><span class="line">        <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(max);</span><br><span class="line">        root.left = build(nums,start,index-<span class="number">1</span>);</span><br><span class="line">        root.right = build(nums,index+<span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(nums,<span class="number">0</span>,len);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 或者可以这样</span></span><br><span class="line"><span class="keyword">var</span> constructMaximumBinaryTree = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//查找最大值和他的下标</span></span><br><span class="line">    <span class="keyword">if</span>(!nums.length)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> max = -<span class="literal">Infinity</span>, index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; max) &#123;</span><br><span class="line">            max = nums[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造二叉树</span></span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(max);</span><br><span class="line">    root.left = constructMaximumBinaryTree(nums.slice(<span class="number">0</span>, index));</span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    root.right = constructMaximumBinaryTree(nums.slice(index + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>至此第一道构造二叉树的题目就做完了，接下看看另外两道题目</p><h1 id="通过前序和中序遍历结果构造二叉树"><a href="#通过前序和中序遍历结果构造二叉树" class="headerlink" title="通过前序和中序遍历结果构造二叉树"></a>通过前序和中序遍历结果构造二叉树</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220504201525.png" alt=""></p><p>我们知道前序遍历的第一个节点就是整个树的根，那么中序遍历的根节点前面就是左子树，后面就是右子树，利用这个特性，自然而然的会想出以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> build = <span class="function">(<span class="params">preorder, inorder</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//找到根节点</span></span><br><span class="line">    <span class="keyword">const</span> root = preorder.shift();</span><br><span class="line">    <span class="comment">// 中序找到该节点的下标</span></span><br><span class="line">    <span class="keyword">const</span> rootIndex = inorder.indexOf(root);</span><br><span class="line">    <span class="keyword">const</span> tree = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">    <span class="comment">//递归调用构造左右子树</span></span><br><span class="line">    tree.left = fun(...);</span><br><span class="line">    tree.right = fun(...);</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，我们这里要创建一个什么样的函数去递归呢？<br>其实我们只要利用我们的中序数组就可以了，因为能依靠他查找，就能依靠他构造</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> build = <span class="function">(<span class="params">inorder</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inorder||!inorder.length)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> root = preorder.shift();</span><br><span class="line">        <span class="keyword">const</span> rootIndex = inorder.indexOf(root);</span><br><span class="line">        <span class="keyword">const</span> tree = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">        tree.left = build(inorder.slice(<span class="number">0</span>,rootIndex));</span><br><span class="line">        tree.right = build(inorder.slice(rootIndex+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(inorder);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者我们可以这样,我们知道了其实前序的左子树终止边界就是中序到根节点的长度+1，那么我们也就可以带入前序递归<br><img src="https://labuladong.github.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/6.jpeg" alt=""><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!preorder.length) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> root = preorder.shift();</span><br><span class="line">    <span class="keyword">const</span> tree = <span class="keyword">new</span> TreeNode(root)</span><br><span class="line">    <span class="keyword">const</span> rootIndex = inorder.indexOf(root)</span><br><span class="line">    tree.left = buildTree(preorder.slice(<span class="number">0</span>, rootIndex), inorder.slice(<span class="number">0</span>,rootIndex))</span><br><span class="line">    tree.right = buildTree(preorder.slice(rootIndex), inorder.slice(rootIndex+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="通过后序和中序遍历结果构造二叉树"><a href="#通过后序和中序遍历结果构造二叉树" class="headerlink" title="通过后序和中序遍历结果构造二叉树"></a>通过后序和中序遍历结果构造二叉树</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220504204143.png" alt=""></p><p>后序遍历的最后一个节点是root，那么我们知道了这个道理，其实就把shift的操作变成pop即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">inorder, postorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!postorder.length)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> root = postorder.pop();</span><br><span class="line">    <span class="keyword">const</span> rootIndex = inorder.indexOf(root);</span><br><span class="line">    <span class="keyword">const</span> tree = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">    tree.left = buildTree(inorder.slice(<span class="number">0</span>,rootIndex),postorder.slice(<span class="number">0</span>,rootIndex));</span><br><span class="line">    tree.right = buildTree(inorder.slice(rootIndex+<span class="number">1</span>),postorder.slice(rootIndex));</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="通过前序和后序构造二叉树"><a href="#通过前序和后序构造二叉树" class="headerlink" title="通过前序和后序构造二叉树"></a>通过前序和后序构造二叉树</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220508105922.png" alt=""><br>我们知道了结合中序构造的方法，就是从中序中找到对应的index然后分离左右，最后递归。</p><p>那么前序和后序怎么构造呢？</p><p>实际上，拿前序当参照物，第一个就是根节点，第二个就是左子树的根节点，那么我们就可以同样的在后序中找到这个左子树根节点，去分离我们的左右子树。</p><p><img src="https://labuladong.github.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/8.jpeg" alt=""><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constructFromPrePost = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, postorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!preorder.length||!postorder.length)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(preorder.length===<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> root = preorder[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> index = postorder.indexOf(root);</span><br><span class="line">    <span class="keyword">const</span> tree = <span class="keyword">new</span> TreeNode(preorder.shift());</span><br><span class="line">    <span class="comment">//之前找的是根节点前面的一段，所以是index，现在找的是左子树根节点，所以index+1</span></span><br><span class="line">    tree.left = constructFromPrePost(preorder.slice(<span class="number">0</span>,index+<span class="number">1</span>),postorder.slice(<span class="number">0</span>,index+<span class="number">1</span>),)</span><br><span class="line">    tree.right = constructFromPrePost(preorder.slice(index+<span class="number">1</span>),postorder.slice(index+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后总结一下，构造二叉树实际上就是找到根节点+构造左子树+构造右子树。根节点使用indexof和遍历的性质寻找，左右子树的构造使用递归的方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree二叉树笔记②--思路篇</title>
    <link href="https://zlinni.github.io/posts/1410341478/"/>
    <id>https://zlinni.github.io/posts/1410341478/</id>
    <published>2022-05-03T12:34:45.683Z</published>
    <updated>2022-05-07T12:43:31.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在上一篇手把手二叉树的笔记中，我们解决了三道问题，二叉树最大深度，二叉树最大直径，和层序遍历。而读完本文，你可以解决以下问题：</p></div><p>Leetcode<br>226.翻转二叉树<br>114.将二叉树展开为链表<br>116.填充二叉树节点的右侧指针</p><h1 id="再谈二叉树的重要性"><a href="#再谈二叉树的重要性" class="headerlink" title="再谈二叉树的重要性"></a>再谈二叉树的重要性</h1><p>对于经典的算法快速排序和归并排序来说，如果你知道二叉树的前序遍历就是快速排序，后序遍历就是归并排序，那么你对二叉树就有比较深入的了解了。</p><p>快速排序的逻辑是先找到一个基准点，根据这个基准点，去对我们左侧的数据划分，使得左侧的数据都小于这个基准点，右侧的数据都大于这个基准点，然后在左侧和右侧进行递归这个过程，最后的数组就是被排序的</p><p>代码逻辑过程：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function">(<span class="params">arr,i,j</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);</span><br><span class="line">    ...</span><br><span class="line">    quickSort(arr,i,p-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr,p+<span class="number">1</span>,j);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先构造分界点，再根据左右子数组去构造分界点，这不就是二叉树的前序遍历吗</p><p>再谈谈归并排序的逻辑，先分割数组，到最小规模后逐步合并子数组，直到完全有序</p><p>代码逻辑过程：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeSort = <span class="function">(<span class="params">arr</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//分割</span></span><br><span class="line">    left = mergeSort(arr.slice(<span class="number">0</span>,mid));</span><br><span class="line">    right = mergeSort(arr.slice(mid,len));</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    arr = mergeArr(left,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是不是发现了他很像后序遍历，先对左右数组排序然后合并。</p><p>所以接下来做几道比较有意思的二叉树算法题</p><h1 id="递归的诀窍"><a href="#递归的诀窍" class="headerlink" title="递归的诀窍"></a>递归的诀窍</h1><div class="note primary flat"><p>写递归算法的诀窍就是明确函数定义的是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要试图跳入递归。</p></div><p>用个具体的例子来解释：求一颗二叉树有多少节点<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + count(n.left) + count(n.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子非常简单，用根节点加左右子树的节点就是总节点。那左右子树的节点怎么计算？就是调用递归的count计算出来的。</p><p>写树相关的算法，简单来说就是搞清楚当前root节点要做什么，然后根据函数定义递归子节点，递归调用会让孩子做相同的事情。</p><h1 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h1><h2 id="题目一：翻转二叉树-226"><a href="#题目一：翻转二叉树-226" class="headerlink" title="题目一：翻转二叉树-226"></a>题目一：翻转二叉树-226</h2><p>eg<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>我们发现只要将二叉树的左右节点都交换就可以完成这个过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> root;</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    [root.left,root.right] = [root.right,root.left];</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//前序</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    [root.left,root.right] = [root.right,root.left];</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这道题你会发现前序和后序都能做，但是中序就不行。因为中序的遍历是一边先结束再另一边，所以做不到反转。边界条件的话，因为前序可能是一开始就无，所以是null，而后序最后是根，所以是root</p><h2 id="题目二：填充二叉树节点的右侧指针-116"><a href="#题目二：填充二叉树节点的右侧指针-116" class="headerlink" title="题目二：填充二叉树节点的右侧指针-116"></a>题目二：填充二叉树节点的右侧指针-116</h2><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220503224625.png" alt=""></p><p>我们仿造上面的思路其实可以这样做<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> connect = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root||!root.left)<span class="keyword">return</span> root;</span><br><span class="line">    root.left.next = root.right;</span><br><span class="line">    connect(root.left);</span><br><span class="line">    connect(root.right);</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过这样其实有很大的问题<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220503224912.png" alt=""></p><p>我们发现跨越父节点的值并没有被连接起来。</p><p>稍微改造一下代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> connect = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> connectTwo = <span class="function">(<span class="params">n1,n2</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//其中一者没有直接返回上一步</span></span><br><span class="line">        <span class="keyword">if</span>(!n1||!n2)<span class="keyword">return</span>;</span><br><span class="line">        n1.next = n2;</span><br><span class="line">        <span class="comment">// 相同父节点的左右连接</span></span><br><span class="line">        connectTwo(n1.left,n1.right);</span><br><span class="line">        connectTwo(n2.left,n2.right);</span><br><span class="line">        <span class="comment">// 跨越父节点的左右连接</span></span><br><span class="line">        connectTwo(n1.right,n2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    connectTwo(root.left,root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样使用connectTwo递归就可以无死角的覆盖整颗二叉树，将所有相邻的节点连接起来了。</p><h2 id="题目三：将二叉树展开为链表-114"><a href="#题目三：将二叉树展开为链表-114" class="headerlink" title="题目三：将二叉树展开为链表-114"></a>题目三：将二叉树展开为链表-114</h2><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220503225946.png" alt=""></p><p>那么我们要怎么做才能拉平这个数组呢？</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220503230236.png" alt=""></p><p>可以看出，我们首先需要将左子树拉平，然后将右子树拉平，然后再把左子树接到右子树上。</p><p>那么就第一步怎么拉平左右子树呢？</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714efce7db2cdff~tplv-t2oaga2asx-watermark.awebp" alt=""></p><p>我们根据后序遍历动画可以知道，只要经过后序遍历，就能拉平左右子树，那么第一步的问题就解决了。</p><p>随后是怎么把左子树接到右子树上面呢？</p><p>首先我们要清楚，这个左子树不是中途就能插入的，我们必须先把左右子树保存，然后删掉左子树，将保存的左子树放到右子树，再将保存的右子树插入到右子树。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flatten = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//拉平</span></span><br><span class="line">    flatten(root.left);</span><br><span class="line">    flatten(root.right);</span><br><span class="line">    <span class="comment">//暂存左右子树</span></span><br><span class="line">    <span class="keyword">let</span> left = root.left;</span><br><span class="line">    <span class="keyword">let</span> right = root.right;</span><br><span class="line">    <span class="comment">//删除原左子树，将暂存的左子树放在原右子树上</span></span><br><span class="line">    root.left = <span class="literal">null</span>;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="comment">//类似于链表 遍历右子树找到他末尾节点 然后插入暂存右子树</span></span><br><span class="line">    <span class="keyword">let</span> p = root;</span><br><span class="line">    <span class="keyword">while</span>(p.right!==<span class="literal">null</span>)&#123;</span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">    p.right = right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>根据labuladong所说，递归的算法真谛就是相信递归的定义，不要去纠里面的细节所在。然后二叉树方面其实很多递归的问题，并且我们还要考虑边界情况，一般来说我们后序遍历不需要root的话，遍历到末尾节点就可以直接返回，或者返回null，一般我们在计算节点深度或者直径的时候，就要返回0。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree二叉树笔记①--纲领篇</title>
    <link href="https://zlinni.github.io/posts/1410341477/"/>
    <id>https://zlinni.github.io/posts/1410341477/</id>
    <published>2022-05-03T10:41:00.167Z</published>
    <updated>2022-05-22T06:33:00.817Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>labuladong的二叉树算法入门第一章，这段时间的算法确实没什么长进，只停留在会做针对性的题目的阶段，如果出现了变体就很难解决了，所以下决心从算法基础再开始修炼算法。由于labuladong的代码大多数是c++，本文便修改为js进行学习。</p></div><p>读完本文，你可以解决以下问题：<br>104.二叉树的最大深度<br>543.二叉树的直径<br>102.二叉树的层序遍历</p><h1 id="二叉树学习的必要性"><a href="#二叉树学习的必要性" class="headerlink" title="二叉树学习的必要性"></a>二叉树学习的必要性</h1><div class="note primary flat"><p>二叉树是所有高级算法的基础，他涉及了递归，回溯，所以算法入门最好就从二叉树开始。</p></div><h1 id="深入理解前中后序"><a href="#深入理解前中后序" class="headerlink" title="深入理解前中后序"></a>深入理解前中后序</h1><div class="note primary flat"><p>根左右，左根右，左右根…可能很多人在学习数据结构的时候，老师教过这样的判断过程。这三句话对应着二叉树的前中后序，但实际上你真的理解这三种遍历顺序吗</p></div><p>从前序开始看，我们知道，有这样的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">console</span>.log(root);</span><br><span class="line">traverse(root.left);</span><br><span class="line">traverse(root.right);</span><br></pre></td></tr></table></figure></p><p>其实这个就是一个一次遍历，和遍历数组链表的方式大同小异，而所谓的前序遍历，只不过进入第一个节点就开始遍历，而后序遍历是离开一个节点的时候才开始遍历,中序遍历是在遍历完左子树，即将遍历右子树的时候才执行。</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220503185141.png" alt=""></p><p>这之中利用到了递归和回溯的这个特性，我们规定了遍历到最后才返回的时机，就能实现后序遍历，</p><h1 id="解题的思路"><a href="#解题的思路" class="headerlink" title="解题的思路"></a>解题的思路</h1><div class="note primary flat"><p>二叉树题目的递归解法可以分为两类，一类是一次遍历实现的结果，第二类是分解问题得到答案，这两类思路分别对应着回溯算法核心框架和动态规划核心框架</p></div><p>在leetcode第104题中，求二叉树的最大深度，这道题很明显，思路就是遍历一次二叉树，记录每个节点的深度，取叶子节点深度的最大值即可，这就是一次遍历完成的结果。</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220503185822.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> deep = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">            max = <span class="built_in">Math</span>.max(max, depth);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">        deep(n.left);</span><br><span class="line">        deep(n.right);</span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line">    deep(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这道题无关遍历的顺序，有关系的只是什么时机去刷新这个max。并且我们知道前序的条件是进入一个节点之前，所以我们使用了depth++，后序是在离开一个节点的时候，所以depth—，这个depth记录了当前递归的节点深度，所以要这样维护他。</p><p>除此之外，我们也很容易知道，二叉树的最大高度可以通过子树的最大高度计算出来，这就是分解问题的关键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> deep = <span class="function">(<span class="params">n,l</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> left = deep(n.left,l+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">let</span> right = deep(n.right,l+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(left,right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep(root,<span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个思路的核心在于，要使用递归先获得子树的最大高度，那么要获得这个最大高度，就需要遍历完这个子树，这个时候，代码逻辑写在后序的部分就显得尤为重要，因为此时一个完整的子树已经被遍历了，我们只需要在这个阶段获取最大高度刷新即可。</p><h1 id="后序的特殊之处"><a href="#后序的特殊之处" class="headerlink" title="后序的特殊之处"></a>后序的特殊之处</h1><p>我们知道前序是刚刚进入节点的时刻，后序是即将离开节点的时刻，前序自顶向下，后序自底向上。那么就意味着，前序的代码只能获取父节点传递过来的数据。后序的代码不仅可以获取数据，还能拿到子树通过函数返回的数据</p><p>举个例子，现有一颗二叉树，处理以下两个问题：</p><ol><li>如果把根节点看成第一层，如何知道每个节点的层数</li><li>如何打印每个节点的左右子树有多少个节点？并返回节点总数</li></ol><p>首先第一个代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> traverse = <span class="function">(<span class="params">root,level</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(root,level);</span><br><span class="line">    traverse(root.left,level+<span class="number">1</span>);</span><br><span class="line">    traverse(root.right,level+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">traverse(root,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>第二个代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> traverse = <span class="function">(<span class="params">root,level</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = traverse(root.left,level+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> right = traverse(root.right,level+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(root,left,right);</span><br><span class="line">    <span class="keyword">return</span> left+right+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此我们发现，只有后序才能够帮助我们获取子树的信息，所以一旦发现题目和子树有关，大概率代码的位置要写在后序的部分。</p><p>那么后序在二叉树刷题中是如何发挥作用的，这里看一道leetcode的543题，二叉树直径，计算出二叉树直径的最大长度。</p><p>所谓的二叉树的直径，就是两个任意节点之间的路径长度。最大路径长度不一定是要穿过根节点，看下图</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220503193254.png" alt=""></p><p>这个图片中，最大的路径长度有两条，1是[4,2,1,3],2是[5,2,1,3]</p><p>这道题的关键在于，每一条二叉树的直径就是一个节点的左右子树最大深度之和，比如说这个节点1 左子树最大深度2，右子树最大深度1 加起来就是3 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> diameterOfBinaryTree = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> deep = <span class="function">(<span class="params">n,l</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//注意深度问题边界是0</span></span><br><span class="line">        <span class="keyword">let</span> left = deep(n.left,l+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">let</span> right = deep(n.right,l+<span class="number">1</span>);</span><br><span class="line">        max = <span class="built_in">Math</span>.max(left+right,max);<span class="comment">//刷新最大深度之和,这步才是重点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(left,right)+<span class="number">1</span>;<span class="comment">//返回最大深度+1；让下一次递归知道长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    deep(root,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220522143237.png" alt=""></p><p>层序便利的思路是使用队列。代码框架如下；<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220522143224.png" alt=""></p><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> q = [root];</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">while</span> (q.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> len = q.length</span><br><span class="line">        <span class="keyword">const</span> temp = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> n = q.shift();</span><br><span class="line">            temp.push(n.val);</span><br><span class="line">            <span class="keyword">if</span> (n.left) q.push(n.left);</span><br><span class="line">            <span class="keyword">if</span> (n.right) q.push(n.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220503203233.png" alt=""></p><p>其实BFS算法就是从二叉树的层序遍历衍生出来的，常用于求无权图的最短路径问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>前端必须知道的浏览器性能指标</title>
    <link href="https://zlinni.github.io/posts/2062480448/"/>
    <id>https://zlinni.github.io/posts/2062480448/</id>
    <published>2022-05-01T14:40:21.000Z</published>
    <updated>2022-05-03T10:39:50.366Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>上周一面腾讯云智的时候，面试官问我这么个问题：“你知道浏览器的首屏时间怎么查看吗？”我回答进入页面到最后一个请求回收所用的时间，然后他又问：具体有什么指标来表明呢？于是就有了下文</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/性能指标.png" alt=""></p><h1 id="浏览器性能指标"><a href="#浏览器性能指标" class="headerlink" title="浏览器性能指标"></a>浏览器性能指标</h1><p>为了描述web页面的性能，开发人员提供了很多可量化的指标来进行分析。比如TTFB、FP、FCP等。指标之间也是有联系的，其中还有部分指标专门为了描述用户交互体验，比如FP、FCP、FSP、FCI、TTI等。下面就来从用户核心指标开始讲述内容。</p><h1 id="核心指标"><a href="#核心指标" class="headerlink" title="核心指标"></a>核心指标</h1><div class="note primary flat"><p>当用户打开一个页面，会经历一个这样的视觉过程：白屏-&gt;底图-&gt;出现部分内容-&gt;首屏内容出现，但图片还在加载中-&gt;首屏内容和图片都加载完毕</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220502163126.png" alt=""></p><p>一般在这个首屏的内容大部分被加载的时候，用户才能开始和页面进行交互等操作，所以如果这段响应的时间很长，就会导致用户的体验很差，下面的几个核心指标描述这些过程的关键变化点，通过它们我们可以来了解用户体验。</p><ul><li>LCP 最大内容绘制</li><li>FID 第一次交互的延迟</li><li>CLS 累计位移偏差</li></ul><h1 id="Largest-Contentful-Paint-LCP"><a href="#Largest-Contentful-Paint-LCP" class="headerlink" title="Largest Contentful Paint(LCP)"></a>Largest Contentful Paint(LCP)</h1><div class="note primary flat"><p>最大内容绘制，用于记录视窗内最大元素的绘制时间，这个可能随着页面的渲染发生变化。且在用户第一次交互后停止记录。</p></div><p>LCP会持续更新，因此在页面的骨架屏或者loading动画存在的时候，FCP已经记录完了，而LCP因为这个特性，可以让我们知道后续页面的主要内容是什么时候呈现的</p><p>最优时间在2.5s内</p><h2 id="LCP关注什么元素"><a href="#LCP关注什么元素" class="headerlink" title="LCP关注什么元素"></a>LCP关注什么元素</h2><ol><li><code>&lt;img&gt;</code> 元素</li><li><code>&lt;image&gt;</code>元素内的<code>&lt;svg&gt;</code>元素</li><li><code>&lt;video&gt;</code> 元素</li><li>通过 <code>url()</code> 函数加载背景图片的元素</li><li>包含文本节点或其他内联文本元素子级的块级元素。</li></ol><h2 id="改善LCP"><a href="#改善LCP" class="headerlink" title="改善LCP"></a>改善LCP</h2><div class="note primary flat"><p>改善LCP就要从为什么会造成LCP开始说明</p></div><ul><li>服务器响应时间慢 </li><li>阻断渲染的JS和CSS</li><li>资源加载时间慢</li><li>客户端渲染</li></ul><p>从以上的角度去改善LCP</p><h3 id="服务器优化"><a href="#服务器优化" class="headerlink" title="服务器优化"></a>服务器优化</h3><div class="note primary flat"><p>服务器涉及到TTFB这个指标，可以从以下几个方面来优化</p></div><ul><li>缓存HTML离线页面，缓存页面资源，减小浏览器对资源的请求(不是首次)</li><li>压缩HTML</li><li>使用preconnect尽快与服务器建立连接，使用dns-prefetch尽快进行DNS查找</li><li>使用CDN</li></ul><h3 id="优化阻断渲染的资源"><a href="#优化阻断渲染的资源" class="headerlink" title="优化阻断渲染的资源"></a>优化阻断渲染的资源</h3><div class="note primary flat"><p>JS和CSS阻断页面的渲染是无可避免的，我们只能通过CSS和JS压缩合并级联内联来减少</p></div><h3 id="优化资源加载时间"><a href="#优化资源加载时间" class="headerlink" title="优化资源加载时间"></a>优化资源加载时间</h3><div class="note primary flat"><p>上述我们知道LCP只和几个标签有关，那我们就从标签入手优化</p></div><ul><li>对图片进行优化，转WEBP</li><li>对重要的资源进行预加载，比如为 <code>style</code> 标签添加 <code>rel=&quot;preload&quot;</code> 属性</li><li>gzip压缩</li><li>service worker缓存资源</li></ul><h3 id="转服务端渲染"><a href="#转服务端渲染" class="headerlink" title="转服务端渲染"></a>转服务端渲染</h3><p>SSR</p><h1 id="First-Input-Delay-FID"><a href="#First-Input-Delay-FID" class="headerlink" title="First Input Delay(FID)"></a>First Input Delay(FID)</h1><div class="note primary flat"><p>首次输入延迟，记录了FCP和TTI之间用户首次与页面交互的时候响应的延迟。</p></div><p>这个指标衡量响应的延迟，也是表明长任务的一个指标。</p><h2 id="改善FID"><a href="#改善FID" class="headerlink" title="改善FID"></a>改善FID</h2><h3 id="减少JS执行时间"><a href="#减少JS执行时间" class="headerlink" title="减少JS执行时间"></a>减少JS执行时间</h3><p>同上LCP的方法</p><ul><li>缩小并压缩js</li><li>延迟加载首屏不需要的js</li><li>尽量减少未使用的polyfill</li></ul><h3 id="分解耗时任务"><a href="#分解耗时任务" class="headerlink" title="分解耗时任务"></a>分解耗时任务</h3><p>超过50ms的任务都称之为长任务，所以我们可以通过将长任务拆解称为较小的异步任务。</p><h3 id="使用Web-Worker"><a href="#使用Web-Worker" class="headerlink" title="使用Web Worker"></a>使用Web Worker</h3><p>主线程阻塞是FID的根本原因，所以使用Web Worker帮助你在和主线程分离的后台线程上运行js，从而改善FID</p><h1 id="Cumulative-Layout-Shift-CLS"><a href="#Cumulative-Layout-Shift-CLS" class="headerlink" title="Cumulative Layout Shift(CLS)"></a>Cumulative Layout Shift(CLS)</h1><div class="note primary flat"><p>累计位移偏差。也可以理解为视觉稳定性。这个指标是为了记录有些动态插入的内容影响用户的体验诞生的。计算的方法是：位移影响的面积*位移距离</p></div><p>期望值低于0.1是比较好的，说明页面跳来跳去的情况比较少。如果有广告插入对用户的体验也不是很好</p><h2 id="改善CLS"><a href="#改善CLS" class="headerlink" title="改善CLS"></a>改善CLS</h2><p>位移会造成CLS变大，那么就从这个方面开始改善。</p><h3 id="不使用无尺寸的元素"><a href="#不使用无尺寸的元素" class="headerlink" title="不使用无尺寸的元素"></a>不使用无尺寸的元素</h3><p>这方面的知识可能很多人都不是很清楚，我们除了要设置图片的长宽之外，还可以指定他的长宽比<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">  aspect-ratio: <span class="built_in">attr</span>(width)/ <span class="built_in">attr</span>(height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于响应式的图片，我们可以这样设置<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">img</span> </span><br><span class="line">    <span class="attribute">width</span>=&quot;<span class="number">1000</span>&quot; </span><br><span class="line">    <span class="attribute">height</span>=&quot;<span class="number">1000</span>&quot;</span><br><span class="line">    <span class="attribute">src</span>=&quot;puppy-<span class="number">1000</span><span class="selector-class">.jpg</span>&quot;</span><br><span class="line">    srcset=&quot;puppy-<span class="number">1000</span><span class="selector-class">.jpg</span> <span class="number">1000</span>w,</span><br><span class="line">            puppy-<span class="number">2000</span><span class="selector-class">.jpg</span> <span class="number">2000</span>w,</span><br><span class="line">            puppy-<span class="number">3000</span><span class="selector-class">.jpg</span> <span class="number">3000</span>w&quot;</span><br><span class="line">    alt=&quot;ConardLi&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p><ul><li>不要在现有的内容之上插入内容，除非是响应式的用户交互。</li><li>宁可转换动画，也不要转换触发布局变化的属性的动画</li></ul><h3 id="提前给广告位预留空间"><a href="#提前给广告位预留空间" class="headerlink" title="提前给广告位预留空间"></a>提前给广告位预留空间</h3><p>很多页面的广告都是动态插入的，所以要为广告位预留空间</p><h3 id="字体变化"><a href="#字体变化" class="headerlink" title="字体变化"></a>字体变化</h3><p>字体变化可以采用<code>font-display:swap</code>和<code>preload</code>的方式提前加载，还有转格式并压缩的方式。</p><h1 id="First-Paint-FP"><a href="#First-Paint-FP" class="headerlink" title="First Paint (FP)"></a>First Paint (FP)</h1><div class="note primary flat"><p>从开始加载到浏览器首次绘制像素到屏幕上的时间，也就是页面在屏幕上首次发生视觉变化的时间。但此变化可能是简单的背景色更新或者不引人注意的内容，她并不代表页面的完整性，可能会报告没有任何可见内容被绘制的时间</p></div><h2 id="测量方式"><a href="#测量方式" class="headerlink" title="测量方式"></a>测量方式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstPaint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> firstPaints = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> performance.getEntriesByType === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> performanceEntries = performance.getEntriesByType(<span class="string">&#x27;paint&#x27;</span>) || [];</span><br><span class="line">    performanceEntries.forEach(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry.name === <span class="string">&#x27;first-paint&#x27;</span>) &#123;</span><br><span class="line">        firstPaints.firstPaint = entry.startTime;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.name === <span class="string">&#x27;first-contentful-paint&#x27;</span>) &#123;</span><br><span class="line">        firstPaints.firstContentfulPaint = entry.startTime;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (chrome &amp;&amp; chrome.loadTimes) &#123;</span><br><span class="line">      <span class="keyword">let</span> loadTimes = <span class="built_in">window</span>.chrome.loadTimes();</span><br><span class="line">      <span class="keyword">let</span> &#123;firstPaintTime, startLoadTime&#125; = loadTimes;</span><br><span class="line">      firstPaints.firstPaint = (firstPaintTime - startLoadTime) * <span class="number">1000</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (performance.timing &amp;&amp; <span class="keyword">typeof</span> performance.timing.msFirstPaint === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123;msFirstPaint, navigationStart&#125; = performance.timing;</span><br><span class="line">      firstPaints.firstPaint = msFirstPaint - navigationStart;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> firstPaints;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="First-Contentful-Paint-FCP"><a href="#First-Contentful-Paint-FCP" class="headerlink" title="First Contentful Paint (FCP)"></a>First Contentful Paint (FCP)</h1><div class="note primary flat"><p>这个指标用于记录浏览器首次绘制来自DOM内容的时间，内容必须是文本、图片(包含背景图)、非白色的canvas或SVG、也包含正在加载中的Web字体的文本。</p></div><p>该阶段用户看到的可能是一个header或者导航栏，并不一定是用户值得消费的内容</p><p>且字体对FCP影响比较大，我们可以使用<code>font-display:swap</code>的方式让浏览器一开始就使用系统的字体，等字体更新好再使用自定义的字体</p><p>字体的优化还可以从格式上，比如将：</p><p>FCP的测量方式见FP</p><p>最优时间<br>关于这两个指标，有如下的时间体验<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220502170159.png" alt=""></p><p>我们可以看出在2s以内能完成就算体验优秀，详细的也可以在LightHouse中查看</p><h1 id="Time-to-Interactive-TTI"><a href="#Time-to-Interactive-TTI" class="headerlink" title="Time to Interactive(TTI)"></a>Time to Interactive(TTI)</h1><div class="note primary flat"><p>首次可交互时间，计算比较复杂，需要满足以下几个条件</p></div><ol><li>FCP指标之后开始计算</li><li>持续五秒没有长任务（执行时间超过50ms）且无两个以上正在进行的GET请求<br>3， 往前回溯至5s前的最后一个长任务结束时间。</li></ol><p>50ms是谷歌定义的，推荐的响应时间是100ms以内，如果超过了这个时间，用户会有延迟感。</p><p>这个指标衡量了响应交互。</p><h1 id="Total-Blocking-Time-TBT"><a href="#Total-Blocking-Time-TBT" class="headerlink" title="Total Blocking Time(TBT)"></a>Total Blocking Time(TBT)</h1><div class="note primary flat"><p>阻塞总时间，记录了FCP到TTI之间所有长任务的阻塞时间总和。</p></div><h1 id="Time-to-First-Byte-TTFB"><a href="#Time-to-First-Byte-TTFB" class="headerlink" title="Time to First Byte(TTFB)"></a>Time to First Byte(TTFB)</h1><p>服务器有关<br><div class="note primary flat"><p>浏览器从请求页面开始到接收第一字节的时间，这个时间段内包括 DNS 查找、TCP 连接和 SSL 连接。</p></div></p><h1 id="DomContentLoaded（DCL）"><a href="#DomContentLoaded（DCL）" class="headerlink" title="DomContentLoaded（DCL）"></a>DomContentLoaded（DCL）</h1><div class="note primary flat"><p>DomContentLoaded 事件触发的时间。当 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架加载完成。</p></div><h1 id="Load-L"><a href="#Load-L" class="headerlink" title="Load(L)"></a>Load(L)</h1><div class="note primary flat"><p>onLoad 事件触发的时间。页面所有资源都加载完毕后（比如图片，CSS），onLoad 事件才被触发。</p></div><h1 id="关于核心指标"><a href="#关于核心指标" class="headerlink" title="关于核心指标"></a>关于核心指标</h1><p>LCP代表了页面的速度，且LCP在目前流行loading和骨架屏的情况下，能体现的东西就更多了。他的指标实时更新，数据更精确，且代表着页面最大元素的渲染时间，通常来说最大元素的快速加载能让用户感觉性能还好。</p><p>FID表示页面的交互体验指标，如果他快说明交互的延迟低，会让用户觉得网页流畅。</p><p>CLS代表了页面的稳定性，尤其在手机上更为重要。因为收集屏幕小的原因，偏移差越多导致视觉交互越差，降低用户体验。</p><h1 id="关于指标收集"><a href="#关于指标收集" class="headerlink" title="关于指标收集"></a>关于指标收集</h1><h2 id="Lighthouse"><a href="#Lighthouse" class="headerlink" title="Lighthouse"></a>Lighthouse</h2><p>使用到了Lighthouse，这个是Chrome自带的性能指标获取器，会显示出具体的指标名称和时间，以及分数。</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220502193259.png" alt=""></p><h2 id="web-vitals-extension"><a href="#web-vitals-extension" class="headerlink" title="web-vitals-extension"></a>web-vitals-extension</h2><p>可以用这个插件来获取三大核心指标：LCP、FID、CLS</p><h2 id="web-vitals-库"><a href="#web-vitals-库" class="headerlink" title="web-vitals 库"></a>web-vitals 库</h2><p>使用这个库可以获取CLS、FID、LCP以及FCP、TTFB</p><p>使用方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;getCLS, getFID, getLCP&#125; <span class="keyword">from</span> <span class="string">&#x27;web-vitals&#x27;</span>;</span><br><span class="line"></span><br><span class="line">getCLS(<span class="built_in">console</span>.log);</span><br><span class="line">getFID(<span class="built_in">console</span>.log);</span><br><span class="line">getLCP(<span class="built_in">console</span>.log);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="Chrome-DevTools"><a href="#Chrome-DevTools" class="headerlink" title="Chrome DevTools"></a>Chrome DevTools</h2><p>打开performance就可以获取指标</p><h2 id="代码收集"><a href="#代码收集" class="headerlink" title="代码收集"></a>代码收集</h2><p>使用<code>window.performance</code>或其他第三方的库</p><h1 id="关于测试"><a href="#关于测试" class="headerlink" title="关于测试"></a>关于测试</h1><p>资源加载方面的延迟：使用sleep的方式人为的控制资源的加载时长。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./css/index.css?sleep=3000&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>网络方面的延迟：使用chrome的网速调节，可以方便我们测试占位图，骨架屏的情况。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="浏览器系列" scheme="https://zlinni.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="浏览器" scheme="https://zlinni.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>从0到1TypeScript</title>
    <link href="https://zlinni.github.io/posts/2090815300/"/>
    <id>https://zlinni.github.io/posts/2090815300/</id>
    <published>2022-04-26T14:23:37.000Z</published>
    <updated>2022-05-09T01:59:39.730Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>TS入门教程，从0到1</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/ts.png" alt=""></p><h1 id="TS介绍"><a href="#TS介绍" class="headerlink" title="TS介绍"></a>TS介绍</h1><h2 id="TS是什么？"><a href="#TS是什么？" class="headerlink" title="TS是什么？"></a>TS是什么？</h2><div class="note primary flat"><p>ts是js的超集，超集指的是他包含了es前面所有版本的内容并有自己的拓展。</p></div><h2 id="TS做到了什么？"><a href="#TS做到了什么？" class="headerlink" title="TS做到了什么？"></a>TS做到了什么？</h2><div class="note primary flat"><p>首先js是弱类型，很多错误在运行的时候才能发现。<br>ts使用了他的静态类型检测机制（后面提及）帮助我们提早发现错误。</p></div><h2 id="TS特点"><a href="#TS特点" class="headerlink" title="TS特点"></a>TS特点</h2><ol><li>支持最新的js特性（超集）</li><li>静态代码检查（解决弱类型）</li><li>有其他后端语言的特性（枚举，泛型，类型转化，命名空间，声明文件…)</li></ol><h1 id="静态类型检测"><a href="#静态类型检测" class="headerlink" title="静态类型检测"></a>静态类型检测</h1><p>为什么会产生这个问题？</p><div class="note primary flat"><p>js在运行代码的时候，需要我们人为的知道代码的返回值是什么，才能做出响应的操作（执行函数才能知道）。不能在我们书写的过程就立刻给出编译错误的反馈。<br>ts就能在（编译之前）告诉我们</p></div><h2 id="非异常故障"><a href="#非异常故障" class="headerlink" title="非异常故障"></a>非异常故障</h2><p>ts不仅能告诉我们哪些函数的值错误，还能识别类似于错别字，未调用函数和基本逻辑错误<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;ber&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">user.location</span><br></pre></td></tr></table></figure><br>上面这段代码在js中返回<code>undefined</code>,而在ts中提前告诉你这个变量没有定义不能使用</p><p><code>错别字</code>：告诉你对象上面某个方法拼写错误等</p><p><code>未调用函数</code>：函数没有加括号就使用，会提示未调用错误</p><p><code>逻辑错误</code>：比如只有两种条件的情况下，if一个条件又elseif另外一个条件，就会报错</p><h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><h2 id="安装ts"><a href="#安装ts" class="headerlink" title="安装ts"></a>安装ts</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g typescript</span><br></pre></td></tr></table></figure><h2 id="安装ts-node"><a href="#安装ts-node" class="headerlink" title="安装ts-node"></a>安装ts-node</h2><p>可以直接编译ts文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i -g ts-node</span><br><span class="line">//使用</span><br><span class="line">npx ts-node xxx.ts</span><br></pre></td></tr></table></figure></p><h2 id="创建一个tsconfig-json"><a href="#创建一个tsconfig-json" class="headerlink" title="创建一个tsconfig.json"></a>创建一个<code>tsconfig.json</code></h2><p>解决变量名or函数名相同报错的问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure></p><h2 id="官方playground"><a href="#官方playground" class="headerlink" title="官方playground"></a>官方playground</h2><p>官方提供的ts在线编译云环境—<a href="">playground</a></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>在对应的目录终端运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure></p><p>得到对应的js文件,执行node命令就可以执行js代码</p><h2 id="ts和js的冲突"><a href="#ts和js的冲突" class="headerlink" title="ts和js的冲突"></a>ts和js的冲突</h2><div class="note primary flat"><p>当我们将ts代码修改为一个函数并调用的时候，再次编译运行js文件，会产生冲突</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220430175814.png" alt=""></p><p>原因：函数名or变量名相同，重复定义</p><p>解决方法：</p><ol><li><code>tsc --init</code>生成配置文件</li><li>注释掉<code>&quot;strict&quot;: true,  o9</code></li></ol><h2 id="自动编译"><a href="#自动编译" class="headerlink" title="自动编译"></a>自动编译</h2><p><code>tsc --watch</code></p><h2 id="发出错误"><a href="#发出错误" class="headerlink" title="发出错误"></a>发出错误</h2><div class="note primary flat"><p>我们在ts里面报了错，但是在编译完之后，还是能运行js文件，如果我们要优化这个过程，结果为：ts编译报错就不生成js文件的话，需要如下：</p></div><p><code>tsc -noEmitOnError hello.ts</code></p><p>or</p><p><code>tsc -noEmitOnError --watch</code></p><h2 id="降级编译"><a href="#降级编译" class="headerlink" title="降级编译"></a>降级编译</h2><p>设置json里面的target为<code>es5</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220430195603.png" alt=""></p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><div class="note primary flat"><p>不同的用户希望在ts里面检查的严格程度是不一样的，配置如下</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220430195741.png" alt=""></p><p><code>strict</code>是包含了下面两个类型的模式</p><p><code>noImplicitAny</code>是指不可以忽略any，也就是要定义类型</p><p><code>strictNullChecks</code>意思是<code>null undefined</code>只能赋值给对应的类型</p><h1 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h1><h2 id="显式类型"><a href="#显式类型" class="headerlink" title="显式类型"></a>显式类型</h2><p>ts给我们提供了类型定义的注释，比如说<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">conflit</span>(<span class="params">person:<span class="built_in">string</span>,date:<span class="built_in">Date</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello,<span class="subst">$&#123;person&#125;</span>,<span class="subst">$&#123;date&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">conflit(<span class="string">&#x27;jojo&#x27;</span>,<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br></pre></td></tr></table></figure></p><p>但是在编译成js之后就会删去，可以方便程序员查看。</p><p>根据上面显式类型的说法我们知道了ts可以定义很多数据类型，比如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: string = <span class="string">&quot;jimmy&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> num: number = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">let</span> bool: boolean = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> obj: object = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> big: bigint = <span class="number">100n</span>;</span><br><span class="line"><span class="keyword">let</span> sym: symbol = <span class="built_in">Symbol</span>(<span class="string">&quot;me&quot;</span>); </span><br></pre></td></tr></table></figure></p><h2 id="几个需要留意的数据"><a href="#几个需要留意的数据" class="headerlink" title="几个需要留意的数据"></a>几个需要留意的数据</h2><div class="note primary flat"><p>当我们定义好类型的时候，如果给变量赋值别的类型是会报错提示的，但是有两个类型不一样</p></div><h3 id="null-amp-undefined"><a href="#null-amp-undefined" class="headerlink" title="null&amp;undefined"></a><code>null&amp;undefined</code></h3><p><code>null undefined</code>这两个类型可以作为其他所有类型的子类型,也就是可以把它们赋给别的值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// null和undefined赋值给string</span></span><br><span class="line"><span class="keyword">let</span> str:<span class="built_in">string</span> = <span class="string">&quot;666&quot;</span>;</span><br><span class="line">str = <span class="literal">null</span></span><br><span class="line">str= <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined赋值给number</span></span><br><span class="line"><span class="keyword">let</span> num:<span class="built_in">number</span> = <span class="number">666</span>;</span><br><span class="line">num = <span class="literal">null</span></span><br><span class="line">num= <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined赋值给object</span></span><br><span class="line"><span class="keyword">let</span> obj:<span class="built_in">object</span> =&#123;&#125;;</span><br><span class="line">obj = <span class="literal">null</span></span><br><span class="line">obj= <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined赋值给Symbol</span></span><br><span class="line"><span class="keyword">let</span> sym: symbol = <span class="built_in">Symbol</span>(<span class="string">&quot;me&quot;</span>); </span><br><span class="line">sym = <span class="literal">null</span></span><br><span class="line">sym= <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined赋值给boolean</span></span><br><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">isDone = <span class="literal">null</span></span><br><span class="line">isDone= <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined赋值给bigint</span></span><br><span class="line"><span class="keyword">let</span> big: bigint =  <span class="number">100n</span>;</span><br><span class="line">big = <span class="literal">null</span></span><br><span class="line">big= <span class="literal">undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>但如果在<code>tsconfig.json</code>里面指定了<code>&quot;strictNullChecks&quot;:true</code>那么它们只能被赋值给自己的类型或者void</p></div><h3 id="number-amp-bigint"><a href="#number-amp-bigint" class="headerlink" title="number&amp;bigint"></a><code>number&amp;bigint</code></h3><div class="note primary flat"><p>这两个值互不兼容，也就是说不能相互赋值，会报错</p></div><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><div class="note primary flat"><p>对数组的定义有两种方式</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arr:type[]</span></span><br><span class="line"><span class="keyword">let</span> arr:<span class="built_in">string</span>[] = [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>];</span><br><span class="line"><span class="comment">//arr:Array&lt;type&gt;这是泛型的定义方法</span></span><br><span class="line"><span class="keyword">let</span> arr2:<span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>]</span><br></pre></td></tr></table></figure><p>定义联合类型数组<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arr:(type1|type2)[]</span></span><br><span class="line"><span class="keyword">let</span> arr3:(<span class="built_in">number</span> | <span class="built_in">string</span>)[];</span><br><span class="line">arr3 = [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;sdcas&quot;</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br></pre></td></tr></table></figure></p><p>定义对象类型数组<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Arrobj &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr4:Arrobj[] = [&#123;<span class="attr">name</span>:<span class="string">&#x27;jojo&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;]</span><br></pre></td></tr></table></figure></p><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>定义成any类型的时候表示你不希望某个特定值导致类型错误的产生。</p><div class="note warning flat"><p>注意避免使用any 这样会丢失ts的保护机制</p></div><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>具名函数<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>,y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="note primary flat"><p>这个是告诉我们函数的返回值也可以指定类型，但一般不需要，因为ts会给我们自动判断返回值的类型</p></div><p>匿名函数：会自动根据上下文判断读取的数据类型是什么。</p><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用接口定义函数类型"><a href="#用接口定义函数类型" class="headerlink" title="用接口定义函数类型"></a>用接口定义函数类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc&#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用函数表达式接口定义函数类型的数据的时候，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数，参数类型，返回值类型不变。</p><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>使用<code>变量名?: type</code>的形式<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">number</span>,y?: <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y)&#123;</span><br><span class="line">      <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myFun(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(myFun(<span class="number">33</span>))</span><br></pre></td></tr></table></figure></p><div class="note warning flat"><p>注意可选参数后面不能再跟必需参数</p></div><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><p>在type后面加<code>= 默认值</code><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span> = <span class="number">22</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myFun(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(myFun(<span class="number">33</span>))</span><br></pre></td></tr></table></figure></p><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>注意需要用any来指定rest<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;, ...items: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">        arr.push(item);</span><br><span class="line">    &#125;)    </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(myFun(arr,<span class="number">3</span>,<span class="number">4</span>,<span class="number">543414</span>,<span class="number">123</span>))</span><br></pre></td></tr></table></figure></p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>js是动态语言，会根据不同的参数返回不同类型的调用结果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line">add(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>); <span class="comment">//&quot;12&quot;</span></span><br></pre></td></tr></table></figure></p><p>but如果开启了noImplicitAny的话，ts不能用上述代码，因为需要指定类型，所以就诞生了联合类型帮助我们根据不同的情况返回不同的结果</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Combination = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: Combination, y: Combination</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> y === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.toString() + y.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myFun(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(myFun(<span class="number">1</span>,<span class="string">&quot;3&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但其实到这一步，看似没有问题了，实际上新的问题又产生了<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Combination = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: Combination, y: Combination</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> y === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.toString() + y.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = myFun(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line">result.split(<span class="string">&quot; &quot;</span>);<span class="comment">//报错</span></span><br></pre></td></tr></table></figure></p><p>查看提示可以知道number类型上面没有方法split，为什么是number类型呢？因为我们这个参数虽然定义了组合类型，但是我们的ts并不知道返回值是什么类型，所以产生了函数重载</p><div class="note primary flat"><p>函数重载就是使用相同函数名称和不同参数类型或不同参数个数创建方法的一种能力</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Combination = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">number</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: Combination, y: Combination</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> y === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.toString() + y.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = myFun(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="keyword">const</span> res = result.split(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure><p>上述实现了函数的重载</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintCoord</span>(<span class="params">pt:&#123;x: <span class="built_in">number</span>,y: <span class="built_in">number</span>&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pt.x,pt.y);</span><br><span class="line">&#125;</span><br><span class="line">PrintCoord(&#123;<span class="attr">x</span>:<span class="number">333</span>,<span class="attr">y</span>:<span class="number">44</span>&#125;)</span><br></pre></td></tr></table></figure><p>配合可选参数+可选链的例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintCoord</span>(<span class="params">pt:&#123;x: <span class="built_in">number</span>,y?: <span class="built_in">string</span>&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pt.y?.toUpperCase())</span><br><span class="line">&#125;</span><br><span class="line">PrintCoord(&#123;<span class="attr">x</span>:<span class="number">333</span>,<span class="attr">y</span>:<span class="string">&#x27;jojo&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>我们定义接口可以用于类型的后续拓展，看基础应用如下<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">pt:Point</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pt.x+pt.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myFun(&#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>&#125;))</span><br></pre></td></tr></table></figure></p><p>拓展接口如下：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Bear <span class="keyword">extends</span> Animal&#123;</span><br><span class="line">    <span class="attr">honey</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bear: Bear = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;jobear&#x27;</span>,</span><br><span class="line">    <span class="attr">honey</span>:<span class="string">&#x27;蜂蜜&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bear)</span><br></pre></td></tr></table></figure></p><p>type的拓展 通过&amp;符号<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bear = Animal &amp;&#123;</span><br><span class="line">    <span class="attr">honey</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bear: Bear = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;jobear&#x27;</span>,</span><br><span class="line">    <span class="attr">honey</span>:<span class="string">&#x27;蜂蜜&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bear)</span><br></pre></td></tr></table></figure></p><p>向现有的类型添加字段(重复定义接口名字添加)<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> jojo &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> jojo &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> j: jojo = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;jojo&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(j)</span><br></pre></td></tr></table></figure></p><p>类型创建后不能更改<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> jojo = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> jojo = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//报错</span></span><br></pre></td></tr></table></figure></p><h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>void表示没有任何类型，一般的用处是函数没有返回值的时候定义为void<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>): <span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is a void function&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">myFunc()</span><br></pre></td></tr></table></figure></p><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p>never表示永不存在值的类型</p><p>比方说当函数遇到异常的时候，那么这个函数永远都不会有返回值，因为抛出异常直接中断了程序运行，不会到最后一步。</p><p>或者说代码中遇到无限循环的时候，程序永远到不了执行函数返回值的那一步，永不存在返回</p><p>使用的场景是：<br>针对于我们的代码来说，如果我们定义的联合类型被修改了，那么会因为我们事先在条件判断中写了never从而报错，因此在代码的安全性来讲never是比较可靠的使用。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">controlFlowAnalysisWithNever</span>(<span class="params">foo: Foo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里 foo 被收窄为 string 类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里 foo 被收窄为 number 类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// foo 在这里是 never</span></span><br><span class="line">    <span class="keyword">const</span> check: <span class="built_in">never</span> = foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果有人修改了type的类型 将报错</span></span><br></pre></td></tr></table></figure></p><h2 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h2><p>unknown定义的类型和any一样可以赋全部值</p><h2 id="不要弄混原始类型和对象类型"><a href="#不要弄混原始类型和对象类型" class="headerlink" title="不要弄混原始类型和对象类型"></a>不要弄混原始类型和对象类型</h2><div class="note primary flat"><p>我们在初学ts的时候，很容易把number，boolean这一类和<code>Number Boolean</code>搞混，实际上前者属于原始类型，后者属于原始类型的包装对象，在使用上面，前者可以赋值给后者，后者不能赋值给前者</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> Num: <span class="built_in">Number</span>;</span><br><span class="line">Num = num; <span class="comment">// ok</span></span><br><span class="line">num = Num; <span class="comment">// ts(2322)报错</span></span><br></pre></td></tr></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><div class="note primary flat"><p>元组用来限制数组元素的个数和类型，是ts独有的机制，适合用于多值返回</p></div><p>元组定义的数据必须类型和个数都要匹配<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>]; </span><br><span class="line"><span class="comment">// 类型必须匹配且个数必须为2</span></span><br><span class="line"></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]; <span class="comment">// OK </span></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>,<span class="number">10</span>]; <span class="comment">// Error </span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure></p><h3 id="元组的解构赋值"><a href="#元组的解构赋值" class="headerlink" title="元组的解构赋值"></a>元组的解构赋值</h3><div class="note primary flat"><p>元组也是支持解构赋值的</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> employee: [<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">1</span>, <span class="string">&quot;Semlinker&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> [id, username] = employee;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`id: <span class="subst">$&#123;id&#125;</span>`</span>);<span class="comment">//id 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`username: <span class="subst">$&#123;username&#125;</span>`</span>);<span class="comment">// username Semlinker</span></span><br></pre></td></tr></table></figure><h3 id="元组类型的可选元素"><a href="#元组类型的可选元素" class="headerlink" title="元组类型的可选元素"></a>元组类型的可选元素</h3><p>见例子知用法<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point = [<span class="built_in">number</span>, <span class="built_in">number</span>?, <span class="built_in">number</span>?];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x: Point = [<span class="number">10</span>]; <span class="comment">// 一维坐标点</span></span><br><span class="line"><span class="keyword">const</span> xy: Point = [<span class="number">10</span>, <span class="number">20</span>]; <span class="comment">// 二维坐标点</span></span><br><span class="line"><span class="keyword">const</span> xyz: Point = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">10</span>]; <span class="comment">// 三维坐标点</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x.length); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(xy.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(xyz.length); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><h3 id="元组的剩余元素"><a href="#元组的剩余元素" class="headerlink" title="元组的剩余元素"></a>元组的剩余元素</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RestTupleType = [<span class="built_in">number</span>, ...string[]];</span><br><span class="line"><span class="keyword">let</span> restTuple: RestTupleType = [<span class="number">666</span>, <span class="string">&quot;Semlinker&quot;</span>, <span class="string">&quot;Kakuqo&quot;</span>, <span class="string">&quot;Lolo&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(restTuple[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(restTuple[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h3 id="元组的只读类型"><a href="#元组的只读类型" class="headerlink" title="元组的只读类型"></a>元组的只读类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point: <span class="keyword">readonly</span> [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cannot assign to &#x27;0&#x27; because it is a read-only property.</span></span><br><span class="line">point[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// Property &#x27;push&#x27; does not exist on type &#x27;readonly [number, number]&#x27;.</span></span><br><span class="line">point.push(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// Property &#x27;pop&#x27; does not exist on type &#x27;readonly [number, number]&#x27;.</span></span><br><span class="line">point.pop();</span><br><span class="line"><span class="comment">// Property &#x27;splice&#x27; does not exist on type &#x27;readonly [number, number]&#x27;.</span></span><br><span class="line">point.splice(<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h1 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h1><p>ts提供了as xxx进行类型的断言，这样子我们在自身清楚实际的类型的情况下，让编译器不要干扰你的类型值，就好比any，但是使用了any就完全指定不了了，下面是一个例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayNumber: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> greaterThan2: <span class="built_in">number</span> = arrayNumber.find(<span class="function"><span class="params">num</span> =&gt;</span> num &gt; <span class="number">2</span>) <span class="keyword">as</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="built_in">console</span>.log(greaterThan2)</span><br></pre></td></tr></table></figure></p><p>告诉编译器我要编译出来的结果是什么类型</p><p>语法如下：两种类型<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尖括号 语法</span></span><br><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// as 语法</span></span><br><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure></p><p>尖括号语法会和react中的JSX冲突，所以更推荐使用as</p><h2 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h2><div class="note primary flat"><p>在上下文中ts的类型检查器无法判断类型的时候，使用<code>!</code>就可以用于断言操作对象是非null和非undefined类型<br>举例，x!将从x的值域排除null和undefined</p></div><p>eg<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumGenerator = <span class="function">() =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">numGenerator: NumGenerator | <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Object is possibly &#x27;undefined&#x27;.(2532)</span></span><br><span class="line">  <span class="comment">// Cannot invoke an object which is possibly &#x27;undefined&#x27;.(2722)</span></span><br><span class="line">  <span class="keyword">const</span> num1 = numGenerator(); <span class="comment">// Error</span></span><br><span class="line">  <span class="keyword">const</span> num2 = numGenerator!(); <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="确定赋值断言"><a href="#确定赋值断言" class="headerlink" title="确定赋值断言"></a>确定赋值断言</h2><div class="note primary flat"><p>在变量声明后面使用<code>!</code>这个断言,告诉ts这个变量会被明确的赋值</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x!: <span class="built_in">number</span>;</span><br><span class="line">initialize();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> * x); <span class="comment">// Ok</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不写该断言，则会报错为该数在赋值前被使用了。</p><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><div class="note primary flat"><p>ts独有的定义方式，js中没有，通过enum来进行定义</p></div><p>枚举会自动帮我们递增<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direaction&#123;</span><br><span class="line">    UP=<span class="number">1</span>,</span><br><span class="line">    DOWN,</span><br><span class="line">    LEFT,</span><br><span class="line">    RIGHT</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Direaction.UP);</span><br><span class="line"><span class="built_in">console</span>.log(Direaction.RIGHT);</span><br><span class="line"><span class="built_in">console</span>.log(Direaction.DOWN);</span><br><span class="line"><span class="built_in">console</span>.log(Direaction.LEFT);</span><br><span class="line"><span class="comment">//1 4 2 3</span></span><br></pre></td></tr></table></figure></p><p>场景：我们知道数值，但不知道它映射到的枚举类型的哪个名字，就可以使用<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color &#123;Red = <span class="number">1</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> colorName: <span class="built_in">string</span> = Color[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">alert(colorName);  <span class="comment">// 显示&#x27;Green&#x27;因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure></p><h1 id="类型拓宽"><a href="#类型拓宽" class="headerlink" title="类型拓宽"></a>类型拓宽</h1><div class="note primary flat"><p>通过ts推断出来的类型就是字面量拓宽</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;this is string&#x27;</span>; <span class="comment">// 类型是 string</span></span><br><span class="line"><span class="keyword">let</span> strFun = <span class="function">(<span class="params">str = <span class="string">&#x27;this is string&#x27;</span></span>) =&gt;</span> str; <span class="comment">// 类型是 (str?: string) =&gt; string;</span></span><br><span class="line"><span class="keyword">const</span> specifiedStr = <span class="string">&#x27;this is string&#x27;</span>; <span class="comment">// 类型是 &#x27;this is string&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = specifiedStr; <span class="comment">// 类型是 &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">let</span> strFun2 = <span class="function">(<span class="params">str = specifiedStr</span>) =&gt;</span> str; <span class="comment">// 类型是 (str?: string) =&gt; string;</span></span><br></pre></td></tr></table></figure><h1 id="类型缩小"><a href="#类型缩小" class="headerlink" title="类型缩小"></a>类型缩小</h1><div class="note primary flat"><p>将类型声明细化为更具体的类型的过程我们称之为类型缩小</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span>, input: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>) + input;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> padding + input</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="真值缩小"><a href="#真值缩小" class="headerlink" title="真值缩小"></a>真值缩小</h2><div class="note primary flat"><p>使用条件、<code>&amp;&amp;、||</code>、if语句，布尔否定<code>!</code>进行缩小的方式称为真值缩小，常见如下：</p></div><ol><li>强制类型转换</li><li>使用Boolean</li><li>使用<code>!!</code>，第一个叹号将文字转换为布尔类型，再通过另外一个叹号转成真正的true或者false</li></ol><h2 id="等值缩小"><a href="#等值缩小" class="headerlink" title="等值缩小"></a>等值缩小</h2><div class="note primary flat"><p>ts可以通过真值判断类型，如下</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">x: <span class="built_in">number</span>|<span class="built_in">string</span>, y:<span class="built_in">boolean</span>|<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x===y)&#123;</span><br><span class="line">        x.toUpperCase;</span><br><span class="line">        y.toUpperCase;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="in缩小"><a href="#in缩小" class="headerlink" title="in缩小"></a>in缩小</h2><div class="note primary flat"><p>js的in操作符用于确定某个对象是否拥有该名称的属性</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220501210341.png" alt=""></p><h2 id="instanceof缩小"><a href="#instanceof缩小" class="headerlink" title="instanceof缩小"></a>instanceof缩小</h2><p>略</p><h2 id="分配缩小"><a href="#分配缩小" class="headerlink" title="分配缩小"></a>分配缩小</h2><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220501210631.png" alt=""></p><h2 id="类型谓词"><a href="#类型谓词" class="headerlink" title="类型谓词"></a>类型谓词</h2><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220501210749.png" alt=""></p><h1 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h1><div class="note primary flat"><p>ts支持三种字面量类型：字符串字面量、数字字面量、布尔字面量</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> specifiedStr: <span class="string">&#x27;this is string&#x27;</span> = <span class="string">&#x27;this is string&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> specifiedNum: <span class="number">1</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> specifiedBoolean: <span class="literal">true</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h1><div class="note primary flat"><p>使用|符号 </p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">&#x27;seven&#x27;</span>; <span class="comment">// OK</span></span><br><span class="line">myFavoriteNumber = <span class="number">7</span>; <span class="comment">// OK</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h1><div class="note primary flat"><p>和联合类型差不多，不过这里的符号用的是&amp;，可以理解为是所有类型都要有,类似于求并集</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntersectionType = &#123; <span class="attr">id</span>: <span class="built_in">number</span>; name: <span class="built_in">string</span>; &#125; &amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> mixed: IntersectionType = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>这里引申出一个问题，如果合并的是同名的属性类型会怎么样呢？</p></div><p>情况1 两个同名key 但是类型不同<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntersectionTypeConfict = &#123; <span class="attr">id</span>: <span class="built_in">number</span>; name: <span class="built_in">string</span>; &#125; </span><br><span class="line">&amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span>; name: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">const</span> mixedConflict: IntersectionTypeConfict = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="number">2</span>, <span class="comment">// ts(2322) 错误，&#x27;number&#x27; 类型不能赋给 &#x27;never&#x27; 类型</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这种情况下直接pass</p><p>情况2 两个同名key 类型相同， 但其中一个是另一个是子类型<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntersectionTypeConfict = &#123; <span class="attr">id</span>: <span class="built_in">number</span>; name: <span class="number">2</span>; &#125; </span><br><span class="line">&amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span>; name: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mixedConflict: IntersectionTypeConfict = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="number">2</span>, <span class="comment">// ok</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">mixedConflict = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="number">22</span>, <span class="comment">// &#x27;22&#x27; 类型不能赋给 &#x27;2&#x27; 类型</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>这种情况以子类型为主</p><p>情况3 两个同名key 类型不是基本类型<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>:&#123;<span class="attr">d</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  <span class="attr">x</span>:&#123;<span class="attr">e</span>:<span class="built_in">string</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> C &#123;</span><br><span class="line">  <span class="attr">x</span>:&#123;<span class="attr">f</span>:<span class="built_in">number</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ABC = A &amp; B &amp; C</span><br><span class="line"><span class="keyword">let</span> abc:ABC = &#123;</span><br><span class="line">  <span class="attr">x</span>:&#123;</span><br><span class="line">    <span class="attr">d</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">e</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">f</span>:<span class="number">666</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果是可以合并</p><h1 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h1><div class="note primary flat"><p>泛型可以帮助我们关联参数的值和返回值之间的关系，见下面的例子。</p></div><p>需求：如果我们要实现一个函数 identity，函数的参数可以是任何值，返回值就是将参数原样返回，并且其只能接受一个参数，你会怎么做？</p><p>由于其可以接受任意值，也就是说你的函数的入参和返回值都应该可以是任意类型。 现在让我们给代码增加类型声明：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> idBoolean = <span class="function">(<span class="params">arg: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">type</span> idNumber = <span class="function">(<span class="params">arg: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> idString = <span class="function">(<span class="params">arg: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>这样下来你每次都要写无穷无尽的代码，很明显是不太合理的，所以引出了泛型这个概念，下面看看泛型的用法：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中T是一个抽象类型type，只有在调用它的时候才确定它的值。</p><p>除了T以外，还有其他的泛型代表：</p><ol><li>K key 表示对象中的键类型</li><li>V value 表示对象中的值类型</li><li>E element 表示元素类型</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220501211814.png" alt=""></p><p>其实并不是只能定义一个类型变量，我们可以引入自定义的类型变量如下<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span> &lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">value: T, message: U</span>) : <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(identity&lt;<span class="built_in">Number</span>, <span class="built_in">string</span>&gt;(<span class="number">68</span>, <span class="string">&quot;Semlinker&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>也可以简略的调用,编译器会帮我们自动识别。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(identity(<span class="number">68</span>, <span class="string">&quot;Semlinker&quot;</span>));</span><br></pre></td></tr></table></figure></p><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><div class="note primary flat"><p>如果想打印出参数的size，直接使用是不行的，因为T只是类型，并不是所有方法的集合</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trace</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.size); <span class="comment">// Error: Property &#x27;size doesn&#x27;t exist on type &#x27;T&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何操作使得他能拥有这个size类型呢？其实很简单，只要你自己定义一个接口，让T去继承即可<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Sizeable&#123;</span><br><span class="line">    <span class="attr">size</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trace</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Sizeable</span>&gt;(<span class="params">args:T</span>): <span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(args.size);</span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="泛型工具类型"><a href="#泛型工具类型" class="headerlink" title="泛型工具类型"></a>泛型工具类型</h2><div class="note primary flat"><p>为了方便开发者，ts设置了一些工具类比如Partial、Required、Readonly等。但我们需要知道一些基础知识方便我们后续用这些工具类</p></div><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><div class="note primary flat"><p>关于typeof我们知道是用于判断类型的，但你可能不会做下面这样的事情</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> jojo: Person = &#123;<span class="attr">name</span>:<span class="string">&#x27;jojo&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">type</span> JOJO = <span class="keyword">typeof</span> jojo;<span class="comment">//type JOJO = Person</span></span><br></pre></td></tr></table></figure><p>在上述代码用了typeof获取了变量的类型并赋给了JOJO，后面我们就可以用到JOJO类型</p><p>除此之外，typeof还可以用来获取函数的类型、对象的结构类型<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Message = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;jimmy&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">      <span class="attr">province</span>: <span class="string">&#x27;四川&#x27;</span>,</span><br><span class="line">      <span class="attr">city</span>: <span class="string">&#x27;成都&#x27;</span>   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> message = <span class="keyword">typeof</span> Message;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> type message = &#123;</span></span><br><span class="line"><span class="comment">    name: string;</span></span><br><span class="line"><span class="comment">    age: number;</span></span><br><span class="line"><span class="comment">    address: &#123;</span></span><br><span class="line"><span class="comment">        province: string;</span></span><br><span class="line"><span class="comment">        city: string;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">Array</span>&lt;<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Func = <span class="keyword">typeof</span> toArray; <span class="comment">// -&gt; (x: number) =&gt; number[]</span></span><br></pre></td></tr></table></figure></p><h3 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h3><div class="note primary flat"><p>该方法返回类型的所有键，返回值是联合类型</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> K1 = keyof Person; <span class="comment">// &quot;name&quot; | &quot;age&quot;</span></span><br><span class="line"><span class="keyword">type</span> K2 = keyof Person[]; <span class="comment">// &quot;length&quot; | &quot;toString&quot; | &quot;pop&quot; | &quot;push&quot; | &quot;concat&quot; | &quot;join&quot; </span></span><br><span class="line"><span class="keyword">type</span> K3 = keyof &#123; [x: <span class="built_in">string</span>]: Person &#125;;  <span class="comment">// string | number</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>keyof的作用<br><div class="note primary flat"><p>js是一门高度动态的语言，所以有些时候在我们的ts里面想要捕获到某些操作可能很麻烦，比如</p></div></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prop</span>(<span class="params">obj:<span class="built_in">object</span>,key:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Element implicitly has an &#x27;any&#x27; type because expression of type &#x27;string&#x27; can&#x27;t be used to index type &#x27;&#123;&#125;&#x27;.</span></span><br></pre></td></tr></table></figure><p>元素隐式的拥有any类型，所以string类型不能用于索引{}类型，因此我们需要利用到keyof和泛型来帮助我们解决这个问题</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prop</span>&lt;<span class="title">T</span> <span class="title">extend</span> <span class="title">object</span>,<span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T,key: K</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述的代码中，T约束了object，K约束了T的所有键，所以非常的合理，此时访问不存在的属性的时候，也会提示错误了。</p><h3 id="in-具体场景？"><a href="#in-具体场景？" class="headerlink" title="in(具体场景？)"></a>in(具体场景？)</h3><div class="note primary flat"><p>in用来遍历枚举类型</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Keys = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Obj =  &#123;</span><br><span class="line">  [p <span class="keyword">in</span> Keys]: <span class="built_in">any</span></span><br><span class="line">&#125; <span class="comment">// -&gt; &#123; a: any, b: any, c: any &#125;</span></span><br></pre></td></tr></table></figure><h3 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h3><div class="note primary flat"><p>infer就是取到函数值的返回类型，方便后续使用</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...args: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><div class="note primary flat"><p>添加约束，上面已经讲到了用法和场景，略</p></div><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><div class="note primary flat"><p>在实际开发中，我们经常需要在对象中获取一些值然后建立对应的集合</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;musion&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">35</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValues</span>(<span class="params">person: <span class="built_in">any</span>, keys: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keys.map(<span class="function"><span class="params">key</span> =&gt;</span> person[key])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getValues(person, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])) <span class="comment">// [&#x27;musion&#x27;, 35]</span></span><br><span class="line"><span class="built_in">console</span>.log(getValues(person, [<span class="string">&#x27;gender&#x27;</span>])) <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure><p>但此时ts并没有对不存在的值进行报错，通过这里我们想到了keyof+extends,结合我们的索引类型操作符[]</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValues</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">person: T, keys: K[]</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> keys.map(<span class="function"><span class="params">key</span> =&gt;</span> person[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;musion&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">35</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getValues(person, [<span class="string">&#x27;name&#x27;</span>]) <span class="comment">// [&#x27;musion&#x27;]</span></span><br><span class="line">getValues(person, [<span class="string">&#x27;gender&#x27;</span>]) <span class="comment">// 报错：</span></span><br><span class="line"><span class="comment">// Argument of Type &#x27;&quot;gender&quot;[]&#x27; is not assignable to parameter of type &#x27;(&quot;name&quot; | &quot;age&quot;)[]&#x27;.</span></span><br><span class="line"><span class="comment">// Type &quot;gender&quot; is not assignable to type &quot;name&quot; | &quot;age&quot;.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码中，<code>T[K]</code>表示对象T的属性K所表示的类型，那么<code>T[K][]</code>就是对象T的属性K所表示类型的数组。</p><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><div class="note primary flat"><p>根据旧的类型创造出新的类型，称之为映射类型</p></div><p>映射类型的用法非常巧妙，如下例子将接口的所有属性变成可选<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> TestInterface&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//希望将接口的所有属性变成可选</span></span><br><span class="line"><span class="comment">//在ts中可以通过+/-添加或者删除</span></span><br><span class="line"><span class="keyword">type</span> OptionTestInterface&lt;T&gt; = &#123;</span><br><span class="line">    [p <span class="keyword">in</span> keyof T]+?:T[p]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> newTestInterface = OptionTestInterface&lt;TestInterface&gt;</span><br><span class="line"><span class="comment">// type newTestInterface = &#123;</span></span><br><span class="line"><span class="comment">//    name?:string,</span></span><br><span class="line"><span class="comment">//    age?:number</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>将接口的所有属性变成只读<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> OptionalTestInterface&lt;T&gt; = &#123;</span><br><span class="line"> +<span class="keyword">readonly</span> [p <span class="keyword">in</span> keyof T]+?:T[p]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> newTestInterface = OptionalTestInterface&lt;TestInterface&gt;</span><br><span class="line"><span class="comment">// type newTestInterface = &#123;</span></span><br><span class="line"><span class="comment">//   readonly name?:string,</span></span><br><span class="line"><span class="comment">//   readonly age?:number</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>由于生成只读和可选属性比较常用，ts已经内置了Readonly和Partial工具类型</p><h3 id="Partial-可选"><a href="#Partial-可选" class="headerlink" title="Partial 可选"></a>Partial 可选</h3><p>我们看例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInfo&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变成可选</span></span><br><span class="line"><span class="keyword">type</span> newUserInfo = Partial&lt;UserInfo&gt;;</span><br><span class="line"><span class="comment">//interface newUserInfo &#123;</span></span><br><span class="line"><span class="comment">//    id?: string;</span></span><br><span class="line"><span class="comment">//    name?: string;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><div class="note warning flat"><p>Partial有局限性，他只负责第一层的数据，如果多层就要自己实现了。</p></div><h3 id="DeepPartial-深度可选"><a href="#DeepPartial-深度可选" class="headerlink" title="DeepPartial 深度可选"></a>DeepPartial 深度可选</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeepPartial&lt;T&gt; = &#123;</span><br><span class="line">    [U <span class="keyword">in</span> keyof T]?: T[U] <span class="keyword">extends</span> <span class="built_in">object</span></span><br><span class="line">    ? DeepPartial&lt;T[U]&gt;</span><br><span class="line">    : T[U]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> PartialedWindow = DeepPartial&lt;T&gt;; </span><br><span class="line"><span class="comment">//所有属性都变成可选了</span></span><br></pre></td></tr></table></figure><h3 id="Required-必选"><a href="#Required-必选" class="headerlink" title="Required 必选"></a>Required 必选</h3><div class="note primary flat"><p>将所有属性变成必选</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123; </span><br><span class="line">    [P <span class="keyword">in</span> keyof T]-?: T[P] </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中<code>-?</code>是为了移除可选</p><h3 id="Readonly-只读"><a href="#Readonly-只读" class="headerlink" title="Readonly 只读"></a>Readonly 只读</h3><div class="note primary flat"><p>只读，不可修改</p></div><p>原理<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line"> <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>eg<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line"> <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo: Readonly&lt;Todo&gt; = &#123;</span><br><span class="line"> <span class="attr">title</span>: <span class="string">&quot;Delete inactive users&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">todo.title = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// Error: cannot reassign a readonly property</span></span><br></pre></td></tr></table></figure></p><h3 id="Pick-挑选属性"><a href="#Pick-挑选属性" class="headerlink" title="Pick 挑选属性"></a>Pick 挑选属性</h3><p>原理<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  description: <span class="built_in">string</span>;</span><br><span class="line">  completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TodoPreview = Pick&lt;Todo, <span class="string">&quot;title&quot;</span> | <span class="string">&quot;completed&quot;</span>&gt;;</span><br><span class="line"><span class="comment">//TodoPreview 只有title和completed了</span></span><br><span class="line"><span class="keyword">const</span> todo: TodoPreview = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Clean room&quot;</span>,</span><br><span class="line">  <span class="attr">completed</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><div class="note primary flat"><p>将K中所有属性值转换为T类型</p></div><p>原理<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PageInfo &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Page = <span class="string">&quot;home&quot;</span> | <span class="string">&quot;about&quot;</span> | <span class="string">&quot;contact&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x: Record&lt;Page, PageInfo&gt; = &#123;</span><br><span class="line">  <span class="attr">about</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;about&quot;</span> &#125;,</span><br><span class="line">  <span class="attr">contact</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;contact&quot;</span> &#125;,</span><br><span class="line">  <span class="attr">home</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;home&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="ReturnType-获取返回类型"><a href="#ReturnType-获取返回类型" class="headerlink" title="ReturnType 获取返回类型"></a>ReturnType 获取返回类型</h3><div class="note primary flat"><p>得到函数的返回值类型</p></div><p>原理<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...args: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Func = <span class="function">(<span class="params">value: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">const</span> foo: ReturnType&lt;Func&gt; = <span class="string">&quot;1&quot;</span>;</span><br></pre></td></tr></table></figure><br><code>ReturnType</code>获取到Func的类型是字符串，所以foo也只能被赋为字符串了</p><h3 id="Exclude-移除"><a href="#Exclude-移除" class="headerlink" title="Exclude 移除"></a>Exclude 移除</h3><div class="note primary flat"><p>将某个类型中属于另外一个的类型移除，类似于类型去重</p></div><p>原理<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T0 = Exclude&lt;<span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>&gt;; <span class="comment">// &quot;b&quot; | &quot;c&quot;</span></span><br><span class="line"><span class="keyword">type</span> T1 = Exclude&lt;<span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span>&gt;; <span class="comment">// &quot;c&quot;</span></span><br><span class="line"><span class="keyword">type</span> T2 = Exclude&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | (<span class="function">() =&gt;</span> <span class="built_in">void</span>), <span class="built_in">Function</span>&gt;; <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure></p><h3 id="Extract-提取"><a href="#Extract-提取" class="headerlink" title="Extract 提取"></a>Extract 提取</h3><div class="note primary flat"><p>从T中提取U,类似于找到唯一值</p></div><p>原理<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Extract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T0 = Extract&lt;<span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span> | <span class="string">&quot;f&quot;</span>&gt;; <span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="keyword">type</span> T1 = Extract&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | (<span class="function">() =&gt;</span> <span class="built_in">void</span>), <span class="built_in">Function</span>&gt;; <span class="comment">// () =&gt;void</span></span><br></pre></td></tr></table></figure></p><h3 id="Omit-排他"><a href="#Omit-排他" class="headerlink" title="Omit 排他"></a>Omit 排他</h3><div class="note primary flat"><p>Omit类似于排他思想 除了自己之外的都能用</p></div><p>原理<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Omit&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  description: <span class="built_in">string</span>;</span><br><span class="line">  completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TodoPreview = Omit&lt;Todo, <span class="string">&quot;description&quot;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo: TodoPreview = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Clean room&quot;</span>,</span><br><span class="line">  <span class="attr">completed</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="NonNullable-排null-amp-undefined"><a href="#NonNullable-排null-amp-undefined" class="headerlink" title="NonNullable 排null&amp;undefined"></a>NonNullable 排null&amp;undefined</h3><div class="note primary flat"><p>NonNullable用于过滤null和undefined</p></div><p>原理<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NonNullable&lt;T&gt; = T extendsnull | <span class="literal">undefined</span> ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T0 = NonNullable&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">undefined</span>&gt;; <span class="comment">// string | number</span></span><br><span class="line"><span class="keyword">type</span> T1 = NonNullable&lt;<span class="built_in">string</span>[] | <span class="literal">null</span> | <span class="literal">undefined</span>&gt;; <span class="comment">// string[]</span></span><br></pre></td></tr></table></figure></p><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><div class="note primary flat"><p>用于获取参数类型组成的元组类型</p></div><p>原理<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Parameters&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: infer P) =&gt; <span class="built_in">any</span></span><br><span class="line">? P : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = Parameters&lt;<span class="function">() =&gt;</span><span class="built_in">void</span>&gt;; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">type</span> B = Parameters&lt;typeofArray.isArray&gt;; <span class="comment">// [any]</span></span><br><span class="line"><span class="keyword">type</span> C = Parameters&lt;typeofparseInt&gt;; <span class="comment">// [string, (number | undefined)?]</span></span><br><span class="line"><span class="keyword">type</span> D = Parameters&lt;typeofMath.max&gt;; <span class="comment">// number[]</span></span><br></pre></td></tr></table></figure></p><h1 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a><code>tsconfig.json</code></h1><div class="note primary flat"><p>他是ts的重要配置文件，相当于<code>vue.config.js</code>，在这里讲几个重要的配置</p></div><p>files -设置要编译的文件名字<br>include -设置需要进行编译的文件，支持路径模式匹配<br>exclude -设置无需编译的文件，支持路径模式匹配<br>compilerOptions -设置与编译流程相关的选项</p><h2 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a>compilerOptions</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 基本选项 */</span></span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>,                       <span class="comment">// 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span></span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span>,                  <span class="comment">// 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span></span><br><span class="line">    <span class="string">&quot;lib&quot;</span>: [],                             <span class="comment">// 指定要包含在编译中的库文件</span></span><br><span class="line">    <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span>,                       <span class="comment">// 允许编译 javascript 文件</span></span><br><span class="line">    <span class="string">&quot;checkJs&quot;</span>: <span class="literal">true</span>,                       <span class="comment">// 报告 javascript 文件中的错误</span></span><br><span class="line">    <span class="string">&quot;jsx&quot;</span>: <span class="string">&quot;preserve&quot;</span>,                     <span class="comment">// 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span></span><br><span class="line">    <span class="string">&quot;declaration&quot;</span>: <span class="literal">true</span>,                   <span class="comment">// 生成相应的 &#x27;.d.ts&#x27; 文件</span></span><br><span class="line">    <span class="string">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,                     <span class="comment">// 生成相应的 &#x27;.map&#x27; 文件</span></span><br><span class="line">    <span class="string">&quot;outFile&quot;</span>: <span class="string">&quot;./&quot;</span>,                       <span class="comment">// 将输出文件合并为一个文件</span></span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;./&quot;</span>,                        <span class="comment">// 指定输出目录</span></span><br><span class="line">    <span class="string">&quot;rootDir&quot;</span>: <span class="string">&quot;./&quot;</span>,                       <span class="comment">// 用来控制输出目录结构 --outDir.</span></span><br><span class="line">    <span class="string">&quot;removeComments&quot;</span>: <span class="literal">true</span>,                <span class="comment">// 删除编译后的所有的注释</span></span><br><span class="line">    <span class="string">&quot;noEmit&quot;</span>: <span class="literal">true</span>,                        <span class="comment">// 不生成输出文件</span></span><br><span class="line">    <span class="string">&quot;importHelpers&quot;</span>: <span class="literal">true</span>,                 <span class="comment">// 从 tslib 导入辅助工具函数</span></span><br><span class="line">    <span class="string">&quot;isolatedModules&quot;</span>: <span class="literal">true</span>,               <span class="comment">// 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 严格的类型检查选项 */</span></span><br><span class="line">    <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span>,                        <span class="comment">// 启用所有严格类型检查选项</span></span><br><span class="line">    <span class="string">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>,                 <span class="comment">// 在表达式和声明上有隐含的 any类型时报错</span></span><br><span class="line">    <span class="string">&quot;strictNullChecks&quot;</span>: <span class="literal">true</span>,              <span class="comment">// 启用严格的 null 检查</span></span><br><span class="line">    <span class="string">&quot;noImplicitThis&quot;</span>: <span class="literal">true</span>,                <span class="comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span></span><br><span class="line">    <span class="string">&quot;alwaysStrict&quot;</span>: <span class="literal">true</span>,                  <span class="comment">// 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 额外的检查 */</span></span><br><span class="line">    <span class="string">&quot;noUnusedLocals&quot;</span>: <span class="literal">true</span>,                <span class="comment">// 有未使用的变量时，抛出错误</span></span><br><span class="line">    <span class="string">&quot;noUnusedParameters&quot;</span>: <span class="literal">true</span>,            <span class="comment">// 有未使用的参数时，抛出错误</span></span><br><span class="line">    <span class="string">&quot;noImplicitReturns&quot;</span>: <span class="literal">true</span>,             <span class="comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span></span><br><span class="line">    <span class="string">&quot;noFallthroughCasesInSwitch&quot;</span>: <span class="literal">true</span>,    <span class="comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 模块解析选项 */</span></span><br><span class="line">    <span class="string">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>,            <span class="comment">// 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span></span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>,                       <span class="comment">// 用于解析非相对模块名称的基目录</span></span><br><span class="line">    <span class="string">&quot;paths&quot;</span>: &#123;&#125;,                           <span class="comment">// 模块名到基于 baseUrl 的路径映射的列表</span></span><br><span class="line">    <span class="string">&quot;rootDirs&quot;</span>: [],                        <span class="comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span></span><br><span class="line">    <span class="string">&quot;typeRoots&quot;</span>: [],                       <span class="comment">// 包含类型声明的文件列表</span></span><br><span class="line">    <span class="string">&quot;types&quot;</span>: [],                           <span class="comment">// 需要包含的类型声明文件名列表</span></span><br><span class="line">    <span class="string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,  <span class="comment">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="string">&quot;sourceRoot&quot;</span>: <span class="string">&quot;./&quot;</span>,                    <span class="comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span></span><br><span class="line">    <span class="string">&quot;mapRoot&quot;</span>: <span class="string">&quot;./&quot;</span>,                       <span class="comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span></span><br><span class="line">    <span class="string">&quot;inlineSourceMap&quot;</span>: <span class="literal">true</span>,               <span class="comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span></span><br><span class="line">    <span class="string">&quot;inlineSources&quot;</span>: <span class="literal">true</span>,                 <span class="comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他选项 */</span></span><br><span class="line">    <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>,        <span class="comment">// 启用装饰器</span></span><br><span class="line">    <span class="string">&quot;emitDecoratorMetadata&quot;</span>: <span class="literal">true</span>          <span class="comment">// 为装饰器提供元数据的支持</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="ts" scheme="https://zlinni.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>前端登陆指南</title>
    <link href="https://zlinni.github.io/posts/3355969119/"/>
    <id>https://zlinni.github.io/posts/3355969119/</id>
    <published>2022-04-24T02:15:14.000Z</published>
    <updated>2022-04-25T02:41:30.129Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>前端登陆的四种方式介绍以及应用</p></div><p>关键词：Cookie/Session、Token、SSO单点登录、OAuth第三方登陆<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220424211445.png" alt=""></p><h1 id="验证登陆"><a href="#验证登陆" class="headerlink" title="验证登陆"></a>验证登陆</h1><ul><li>Cookie/Session</li><li>Token </li><li>SSO 单点登陆</li><li>OAuth第三方登陆</li></ul><h1 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie session"></a>cookie session</h1><p>登陆流程：首次登陆<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414092439.png" alt=""></p><ol><li>用户访问<code>a.com/pageA</code>并输入密码登陆</li><li>服务器验证密码无误后，会创建Session ID并将其保存起来</li><li>服务端响应这个请求，并通过Set-Cookie将Session ID写入Cookie中</li></ol><p>再次登陆：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414092643.png" alt=""></p><ol><li>用户访问<code>a.com/pageB</code>自动带上第一次登陆写入的Cookie</li><li>服务端对比Cookie中的SessionID和保存在服务端的SessionID是否一致</li><li>一致则成功</li></ol><h2 id="cookie-session存在的问题"><a href="#cookie-session存在的问题" class="headerlink" title="cookie session存在的问题"></a>cookie session存在的问题</h2><ul><li>服务器需要对接大量的客户端，导致服务器压力大。</li><li>如果服务器是一个集群，为了同步登陆态，就需要将SessionID同步到每一台机器上，无形中增加了服务器的维护成本。</li><li>由于SessionID存放在Cookie中所以无法避免CSRF攻击</li></ul><h1 id="token登陆"><a href="#token登陆" class="headerlink" title="token登陆"></a>token登陆</h1><p>为了解决cookie+session暴露出来的问题，我们可以使用token的登陆方式<br><div class="note primary flat"><p>token是服务端生成的一串字符串，以作为客户端请求的一个令牌。当第一次登陆完成后，服务器会生成一个token并返回给客户端，客户端后续访问只要带上这个token就可以完成身份验证。</p></div></p><h2 id="token机制实现流程"><a href="#token机制实现流程" class="headerlink" title="token机制实现流程"></a>token机制实现流程</h2><p>首次登陆：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414102745.png" alt=""></p><ol><li>用户输入账号密码，并点击登录。</li><li>服务器端验证账号密码无误，创建 Token。</li><li>服务器端将 Token 返回给客户端，由客户端自由保存。</li></ol><p>后续页面访问时：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414102830.png" alt=""></p><ol><li>用户访问 a.com/pageB 时，带上第一次登录时获取的 Token。</li><li>服务器端验证 Token ，有效则身份验证成功。</li></ol><h2 id="Token-机制的特点"><a href="#Token-机制的特点" class="headerlink" title="Token 机制的特点"></a>Token 机制的特点</h2><p>根据上面的案例，我们可以分析出Token的优缺点：</p><ul><li>服务器端不需要存放token，所以不会对服务器造成压力，即使服务器集群，也不需要增加维护成本。</li><li>Token可以存放在前端的任何地方，可以不用保存在Cookie中，提升了页面的安全性。</li><li>Token下发之后，只要在生效时间内，就一直有效，如果服务器想收回此token的权限，并不容易。</li></ul><h2 id="Token的生成方式"><a href="#Token的生成方式" class="headerlink" title="Token的生成方式"></a>Token的生成方式</h2><p>最常见的Token生成方式是使用JWT，他是一种简洁的，自包含的方法用于通信双方之间以JSON对象的形式安全的传递信息。</p><p>上文中我们说到，使用Token后，服务器端并不会存储Token，那怎么判断客户端的token是否合法有效？</p><p>答案其实就在Token字符串中，其实Token并不是一串杂乱无章的字符串，而是通过多种算法拼接组合而成的字符串。如下：</p><p>JWT算法主要分成了三个部分 </p><ul><li>header 头信息</li><li>payload 消息体</li><li>signature 签名</li></ul><p>header部分指定了JWT使用的签名算法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header = <span class="string">&#x27;&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;&#x27;</span>   <span class="comment">// `HS256` 表示使用了 HMAC-SHA256 来生成签名。</span></span><br></pre></td></tr></table></figure></p><p>payload部分指明了JWT的使用意图<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;&#123;&quot;loggedInAs&quot;:&quot;admin&quot;,&quot;iat&quot;:1422779638&#125;&#x27;</span>     <span class="comment">//iat 表示令牌生成的时间</span></span><br></pre></td></tr></table></figure></p><p>signature部分为JWT的签名 主要为了让JWT不能随意更改，签名的方法分为两个步骤</p><ol><li>输入base64url编码的header部分，base64url编码的payload部分，输出unsignedToken</li><li>输入服务器端私钥，unsignedToken,输出signature签名</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base64Header = encodeBase64(header)</span><br><span class="line"><span class="keyword">const</span> base64Payload = encodeBase64(payload)</span><br><span class="line"><span class="keyword">const</span> unsignedToken = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;服务器私钥&#x27;</span></span><br><span class="line"></span><br><span class="line">signature = HMAC(key, unsignedToken)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后Token计算如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base64Header = encodeBase64(header)</span><br><span class="line"><span class="keyword">const</span> base64Payload = encodeBase64(payload)</span><br><span class="line"><span class="keyword">const</span> base64Signature = encodeBase64(signature)</span><br><span class="line"></span><br><span class="line">token = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>.<span class="subst">$&#123;base64Signature&#125;</span>`</span></span><br></pre></td></tr></table></figure></p><p>服务器在判断token的时候<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [base64Header, base64Payload, base64Signature] = token.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> signature1 = decodeBase64(base64Signature)</span><br><span class="line"><span class="keyword">const</span> unsignedToken = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> signature2 = HMAC(<span class="string">&#x27;服务器私钥&#x27;</span>, unsignedToken)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(signature1 === signature2) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;签名验证成功，token 没有被篡改&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> payload =  decodeBase64(base64Payload)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Date</span>() - payload.iat &lt; <span class="string">&#x27;token 有效期&#x27;</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;token 有效&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有了 Token 之后，登录方式已经变得非常高效，接下来我们介绍另外两种登录方式。</p><h1 id="SSO单点登陆"><a href="#SSO单点登陆" class="headerlink" title="SSO单点登陆"></a>SSO单点登陆</h1><div class="note primary flat"><p>单点登陆指的是在公司内部搭建一个公共的认证中心，公司下的所有产品的登陆都可以在认证中心中完成，一个产品在认证中心登陆后，再去访问另外一个产品，可以不用再次登陆，即可获取登陆状态。</p></div><h2 id="SSO机制实现流程"><a href="#SSO机制实现流程" class="headerlink" title="SSO机制实现流程"></a>SSO机制实现流程</h2><p>分为同域和不同域。</p><h3 id="同域的单点登陆"><a href="#同域的单点登陆" class="headerlink" title="同域的单点登陆"></a>同域的单点登陆</h3><p>比如现在有一个域名叫<code>zlinni.cn</code>,然后我的其他页面分别为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.zlinni.cn</span><br><span class="line">b.zlinni.cn</span><br><span class="line">c.zlinni.cn</span><br><span class="line">login.zlinni.cn<span class="comment">//sso登陆系统</span></span><br></pre></td></tr></table></figure></p><p>那么此时我们只要满足在login中登陆，然后abc三个都登陆就完成了sso</p><p>实现的方式就是利用了cookie的path和domain，我们设置domain为<code>.zlinni.cn</code>，然后path为<code>/</code>就能实现所有的域名都共享login的cookie，就实现了单点登陆。</p><h3 id="不同域的单点登陆"><a href="#不同域的单点登陆" class="headerlink" title="不同域的单点登陆"></a>不同域的单点登陆</h3><p>用户首次访问需要在认证中心登陆：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220424182851.png" alt=""></p><ol><li>用户先访问<code>a.com</code>下面的pageA页面，然后系统发现它未登陆，给它重定向到sso认证中心</li><li>在sso中注册，提交登陆</li><li>sso验证账号密码有效，重定向到<code>a.com</code>并带上授权码ticket，再将sso的登录态写入cookie</li><li>此时a就拿着ticket去sso中验证是否有效。</li><li>在a的服务器中拿着ticket向sso验证确认真实性</li><li>验证成功后，服务器将写入两个信息到cookie，一个是ticket作为a的登录态，一个是sso的token记录sso的登录态</li></ol><p>抛出疑问：为什么要用ticket？这个问题我们后面再讲</p><p>然后登陆完成访问a下面的其他页面<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220424192857.png" alt=""></p><p>此时我们的cookie中携带了ticket，只要到服务端验证是否在有效的时间内即可。</p><p>访问b页面的时候（这个b页面是认证中心下面的不同产品，如果要做例子的话，可以认为a是新浪微博，b是新浪博客）<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220424193220.png" alt=""><br>此时由于我们的b是不同源的页面，所以cookie中是没有ticket的（！！！！非常重要），但是它重定向到sso中，sso中我们的cookie是存在登录态的，所以此时不需要再注册等操作，验证token之后，直接给b下发ticket即可。b再去验证ticket真实性即可完成登陆。</p><h2 id="为什么需要Ticket"><a href="#为什么需要Ticket" class="headerlink" title="为什么需要Ticket"></a>为什么需要Ticket</h2><p>ticket的存在是为了解决不同域携带的cookie不一样的问题</p><p>以上过程就解释了我们要用ticket的理由，因为a和b不是同源页面所以不会携带同样的ticket，但是sso中拥有登录态token所以我们会下发ticket到b中验证。</p><h2 id="SSO单点登陆退出"><a href="#SSO单点登陆退出" class="headerlink" title="SSO单点登陆退出"></a>SSO单点登陆退出</h2><p>单点登陆使得多个产品共享登录态，但是怎么做到在一个产品中退出登陆，其他的产品也退出呢？</p><p>这里其实要做的事情很简单，比如说退出这个bcom的登陆：</p><ol><li>首先我们要清除掉b中的ticket</li><li>认证中心sso中清除对应的cookie</li><li>sso遍历所有对应cookie下发了ticket的产品并删除。</li></ol><h2 id="总结sso"><a href="#总结sso" class="headerlink" title="总结sso"></a>总结sso</h2><p>sso就是类似于<code>Nginx+ticket+token</code>的组合.其中，我们利用它的重定向规则，可以将token存在sso的cookie中，将ticket返回到具体的页面存在cookie中，然后再认证完成登陆</p><h1 id="OAuth第三方登陆"><a href="#OAuth第三方登陆" class="headerlink" title="OAuth第三方登陆"></a>OAuth第三方登陆</h1><p>由于sso实际上还是比较麻烦的，所以我们可以利用大厂提供的第三方登陆系统实现登陆</p><p>我们不关心这个完成授权的过程，但是要知道用户点击到返回登陆的这个过程发生了什么</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220424204420.png" alt=""></p><ol><li>首先用户在acom点击用户登陆，跳转到OAuth，并带上回调地址acom</li><li>用户二维码验证之后，微信返回临时票据code</li><li>a带着code和自己申请的appid、appsecret，向微信的服务器申请token，验证成功微信下发token</li><li>有了token之后，a就可以向微信服务器获取用户的头像和昵称等信息。并将用户的登录态写入cookie以便下一次登陆。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试指南" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>融会贯通八大排序</title>
    <link href="https://zlinni.github.io/posts/3106196216/"/>
    <id>https://zlinni.github.io/posts/3106196216/</id>
    <published>2022-04-23T06:37:29.000Z</published>
    <updated>2022-05-04T11:38:32.153Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>记录常用排序算法的算法思想和实现，力争基础达标，往后深入的点分开补充~</p></div><p>关键词：常用算法、sort排序、冒泡排序、插入排序、选择排序、快速排序、归并排序、桶排序、希尔排序</p><h1 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h1><p>直接使用api就能进行排序，注意的点是：<br>不传参，默认是unicode排序，所以常用来排序字母<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;asbcascacsac&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> sortArr = arr.sort();</span><br><span class="line"><span class="built_in">console</span>.log(sortArr)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">    &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;b&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;c&#x27;, &#x27;s&#x27;, &#x27;s&#x27;, &#x27;s&#x27;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>传参，默认两个参，名字无所谓，这里举例是a和b，看返回值来决定升序降序<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">116516</span>,<span class="number">1213</span>,<span class="number">123</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr))</span><br><span class="line"><span class="keyword">let</span> upArr = arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);</span><br><span class="line"><span class="keyword">let</span> downArr = arr2.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>b-a);</span><br><span class="line"><span class="built_in">console</span>.log(upArr)</span><br><span class="line"><span class="built_in">console</span>.log(downArr)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">     1,      4,   5,</span></span><br><span class="line"><span class="comment">     8,      8, 123,</span></span><br><span class="line"><span class="comment">  1213, 116516</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  116516, 1213, 123,</span></span><br><span class="line"><span class="comment">       8,    8,   5,</span></span><br><span class="line"><span class="comment">       4,    1</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>思想：从第一个元素开始比较相邻的元素大小，大则交换(升序)<br>时间复杂度：O(n²)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">116516</span>,<span class="number">1213</span>,<span class="number">123</span>]</span><br><span class="line"><span class="keyword">const</span> bubblesort = (<span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;len-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j+<span class="number">1</span>]&lt;arr[j])&#123;</span><br><span class="line">                [arr[j],arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>],arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(bubblesort(arr))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">     1,      4,   5,</span></span><br><span class="line"><span class="comment">     8,      8, 123,</span></span><br><span class="line"><span class="comment">  1213, 116516</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>优化：如果原数组已经是排序数组，就不必再排，用flag<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bubblesort = (<span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)<span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(bubblesort(arr))</span><br></pre></td></tr></table></figure></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>思想：每次都找到最小值放在头部，然后缩小范围继续操作 直到完全有序<br>时间复杂度：O(n²)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectsort = (<span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[minIndex]&gt;arr[j])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minIndex!==i)&#123;</span><br><span class="line">            [arr[minIndex],arr[i]] = [arr[i],arr[minIndex]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(selectsort(arr))</span><br></pre></td></tr></table></figure></p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>原理：当每次排序的时候，如果前面的元素大于当前的元素，那么将前面的元素转换成当前元素，继续比较，最后替换回最开始转换的元素<br>时间复杂度：O(n²)<br>eg<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line">经过第一轮（单个元素可以当成有序的数列所以忽略第一个元素） 从index1开始保存变量，也就是temp3和<span class="number">5</span>对比</span><br><span class="line">如果<span class="number">3</span>&lt;<span class="number">5</span>，<span class="number">5</span>就在前面腾出一个位置给<span class="number">3</span><span class="string">&#x27;5 5 2 4 1&#x27;</span> （arr[j-<span class="number">1</span>]=arr[j]）;</span><br><span class="line">最后还原temp就变成</span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line">第二轮 对比<span class="number">5</span>和<span class="number">2</span> 此时<span class="number">5</span>前面需要腾出一个位置给<span class="number">2</span>(<span class="number">2</span>&lt;<span class="number">5</span>)此时变成<span class="string">&#x27;3 5 5 4 1&#x27;</span> 然后又发现<span class="number">2</span>&lt;<span class="number">3</span>(j--) 则继续腾位置<span class="string">&#x27;3 3 5 4 1&#x27;</span>(使用<span class="keyword">while</span>的原因)最后</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> j=i;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (j&gt;<span class="number">0</span>&amp;&amp;arr[j-<span class="number">1</span>]&gt;temp) &#123;</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];<span class="comment">//arr[1]3-&gt;5</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;<span class="comment">//arr[0]5-&gt;3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>原理：采用分治思想，分解每个子问题，整个数组可以对半分割，一直到分割最小的状态，然后开始逐渐合并，从规模1到规模2一直到还原回整个数组。</p><p>时间复杂度：O(nlog(n))</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220504151812.png" alt=""></p><p>例子：<code>[8, 7, 6, 5, 4, 3, 2, 1]</code>;</p><p>首先分割，我们利用递归的方法，注意边界小于等于1直接返回arr<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, | <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">7</span>,| <span class="number">6</span>, <span class="number">5</span>, | <span class="number">4</span>, <span class="number">3</span>, |<span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">8</span>,| <span class="number">7</span>,| <span class="number">6</span>, | <span class="number">5</span>, | <span class="number">4</span>,|  <span class="number">3</span>, |<span class="number">2</span>,|  <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>此时的规模已经到了最小状态，那么开始两两合并,这里利用数组的push<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7</span>,| <span class="number">8</span>,| <span class="number">5</span>, | <span class="number">6</span>, | <span class="number">3</span>,|  <span class="number">4</span>, |<span class="number">1</span>,|  <span class="number">2</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">8</span>,| <span class="number">5</span>, <span class="number">6</span>, | <span class="number">3</span>, <span class="number">4</span>, |<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>,  | <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure></p><p>如果已经有一方的合并完全了，那么直接concat另一边剩下的</p><p>具体代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分解</span></span><br><span class="line"><span class="keyword">const</span> mergeSort = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">2</span>)<span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">const</span> mid = len/<span class="number">2</span>,</span><br><span class="line">        left = mergeSort(arr.slice(<span class="number">0</span>,mid)),</span><br><span class="line">        right = mergeSort(arr.slice(mid));</span><br><span class="line">    <span class="keyword">return</span> mergeArr(left,right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="keyword">const</span> mergeArr = <span class="function">(<span class="params">left,right</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">while</span>(left.length &amp;&amp; right.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left[<span class="number">0</span>]&lt;=right[<span class="number">0</span>])&#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(...left,...right);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(mergeSort([<span class="number">4</span>,<span class="number">54</span>,<span class="number">654</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">45</span>,<span class="number">1</span>,<span class="number">2</span>]))</span><br></pre></td></tr></table></figure></p><h2 id="归并排序是原地排序吗？"><a href="#归并排序是原地排序吗？" class="headerlink" title="归并排序是原地排序吗？"></a>归并排序是原地排序吗？</h2><div class="note primary flat"><p>实际上它在合并的时候，借助了额外的空间，但是合并完成之后额外的空间又被释放了。所以不是原地排序</p></div><h2 id="归并排序稳定吗？"><a href="#归并排序稳定吗？" class="headerlink" title="归并排序稳定吗？"></a>归并排序稳定吗？</h2><div class="note primary flat"><p>merge方法里面的<code>left[0]&lt;=right[0]</code>保证了值相同的元素在合并前后的顺序不变，所以他是一种稳定的排序</p></div><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>从效率上看，归并排序可算是排序算法中的佼佼者。假设数组长度为 n，那么拆分数组共需 logn 步, 又每步都是一个普通的合并子数组的过程，时间复杂度为 O(n)，故其综合时间复杂度为 O(nlogn)。<br>最佳情况：T(n) = O(nlogn)。<br>最差情况：T(n) = O(nlogn)。<br>平均情况：T(n) = O(nlogn)。</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>原理：</p><ol><li>找到一个基准值，一般是数组中间</li><li>创建新的左右空数组，分别存放比基准值小的和比基准值大的数据<br>3，递归上述操作，直到数组长度小于等于1</li></ol><p>特点：</p><ol><li>快速、常用</li></ol><p>缺点：<br>需要新建两个数组浪费空间资源</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">1</span>)<span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//取出基准值</span></span><br><span class="line">    <span class="keyword">const</span> midVal = arr.splice(mid,<span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">const</span> left = [],right = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;midVal)&#123;</span><br><span class="line">            left.push(arr[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat(midVal,right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(quickSort([<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure><h2 id="快速排序是原地排序吗？"><a href="#快速排序是原地排序吗？" class="headerlink" title="快速排序是原地排序吗？"></a>快速排序是原地排序吗？</h2><p>在分区的时候，他不需要很多额外的空间，所以是原地排序操作。</p><h2 id="快速排序稳定吗？"><a href="#快速排序稳定吗？" class="headerlink" title="快速排序稳定吗？"></a>快速排序稳定吗？</h2><p>和选择排序类似，快速排序可能不是相邻的，因此他有可能打破原来相同元素之间的顺序，所以是不稳定的。</p><h2 id="快速排序的时间复杂度"><a href="#快速排序的时间复杂度" class="headerlink" title="快速排序的时间复杂度"></a>快速排序的时间复杂度</h2><p>快速排序的时间复杂度是多少 ？<br>极端的例子：如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n / 2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)。<br>最佳情况：T(n) = O(nlogn)。<br>最差情况：T(n) = O(n2)。<br>平均情况：T(n) = O(nlogn)。</p><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
