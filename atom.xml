<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zlinni&#39;s Blog For Study</title>
  
  <subtitle>一个专门做笔记的博客</subtitle>
  <link href="https://zlinni.github.io/atom.xml" rel="self"/>
  
  <link href="https://zlinni.github.io/"/>
  <updated>2022-04-19T15:16:14.166Z</updated>
  <id>https://zlinni.github.io/</id>
  
  <author>
    <name>Zlinni</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>春招落幕，暑期已至---日常篇①</title>
    <link href="https://zlinni.github.io/posts/9a9b91333798/"/>
    <id>https://zlinni.github.io/posts/9a9b91333798/</id>
    <published>2022-04-19T14:31:19.000Z</published>
    <updated>2022-04-19T15:16:14.166Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>emm,最近都在忙活八股算法,没什么时间去梳理一下最近发生的事情,以此来做个记录吧.</p></div><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>时至四月,春招可以说是完完全全的走掉了,这个春招里我就拿到过一个小厂的offer,由于自己自信后面能够拿到更好的就拒掉了(事实证明并没有),所以这段时间是没有好好把握住的,有点可惜.不过实际上八股文加算法总共的学习时间也就从3月份开始的一个半月,这一个半月的知识浓度比之前大特别多.每天都在消化吸收,挑战自己不熟练的,没有见过的一些新事物,比如算法,比如计网.这两个东西应该是很多人不想面对的吧.好在我坚持了下来,这段时间陆陆续续的刷了一百多道中等加简单难度的leetcode,感悟非常的深,其实部分算法题也不见得特别困难,可能是我做的难度原因.甚至有些题目能让我回想起以前OJ刷题时候的记忆,除开比较用智商的题目,大多数的题都有专门的方法去解决,也算是比较套路化.截到目前为止,我能罗列出来的算法有滑动窗口,动态规划,dfs,bfs,贪心,回溯以及部分排序,虽然不能说完全熟悉他的做题方法,但是碰到类似的题目也知道该用什么方法去解决了.算是这段时间的一点小进步.数据结构方面大概就是一些简单题显露出来的,常考的二叉树,链表,栈.这些题好像也会出现在面经中,但是基本不会出现在笔试中,经过前一段时间的笔试(腾讯+字节),深刻的明白了,动态规划和贪心才是笔试的重点,所以后面要多刷这方面的题目.</p><p>然后说一件比较痛苦的事情,就是字节的笔试用的是acm模式,导致数据没办法读出来,然后就寄掉了…</p><p>这段时间八股文方面写了JS的知识点总结,HTTP灵魂之问,Vue灵魂之问,手撕Javascript合集,其中特别有意思的是,在HTTP灵魂之问中,讲到数字证书和数字签名的这个部分,我居然和女朋友争辩了半个晚上才明白具体的原理,虽然大部分是我的问题,不过也算是一种收获了.写完了这些之后,特别是Vue的部分,因为没有手写源码的关系吧,其实对于他的面试题还是有点虚的,得多找些面经再补一补,最后感觉还是得根据一些点,细致的写一篇文章来理解.比如之后想写的关于Object的方法详解,数组api的方法详解,map和weakmap..等.但不知道排期到什么时候,毕竟人的消化吸收能力是有限的,目前我想先找到一份实习,空余之下再去补充这些知识点.</p><p>前不久还想着看webpack,但是冗长的网络视频让我失去了学习的兴趣,大致看了个开头到css抽离压缩的部分就没看下去了.虽然我也知道面试的时候会问相关的问题,只能说亡羊补牢吧,或者说面向面经学习.</p><p>现在的形式真是一言难尽啊,互联网大厂裁员,hc少,今年还是当初研究生扩招最大的一年,大家都抢着一个饭碗,导致旱的旱死涝的涝死,投出去的简历一封封也都石沉大海.远没有想到19年的疫情对我们而言影响这么大.</p><p>在牛客上面看到一个评论:”今年或许是往年来最差的一年,也有可能是今后最好的一年了”,大环境差表示我们要付出更多的努力才能换到成果了,加油吧打工人!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="日常" scheme="https://zlinni.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>手撕万物Javascript篇</title>
    <link href="https://zlinni.github.io/posts/139818545f14/"/>
    <id>https://zlinni.github.io/posts/139818545f14/</id>
    <published>2022-04-15T06:27:16.000Z</published>
    <updated>2022-04-19T11:24:26.296Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>本篇关于尽可能手撕一切可以实现的代码，先从js开始下手</p></div><h1 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h1><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,timer</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> t = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> firstClick = !t;</span><br><span class="line">    <span class="keyword">if</span>(firstClick)&#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    t = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      t = <span class="literal">null</span>;</span><br><span class="line">    &#125;, timer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> begin = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cur = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span>(cur-begin&gt;=delay)&#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">      begin = cur;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">oldObj,newObj=&#123;&#125;</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> oldObj) &#123;</span><br><span class="line">    newObj[item] = oldObj[item];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><h2 id="api版本"><a href="#api版本" class="headerlink" title="api版本"></a>api版本</h2><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringfy(oldObj));</span><br></pre></td></tr></table></figure></p><p>缺陷：</p><ul><li>无法实现对函数，正则等特殊对象的克隆</li><li>会抛弃对象的constructor,所有的构造函数会指向Object</li><li>对象有循环引用会报错</li></ul><h2 id="1-0版本"><a href="#1-0版本" class="headerlink" title="1.0版本"></a>1.0版本</h2><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断是否是引用类型或者null 否则返回源对象进行浅拷贝</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>||obj===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是数组，初始化地址。</span></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        result = [];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归调用 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            result[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p><h2 id="2-0版本-解决循环引用"><a href="#2-0版本-解决循环引用" class="headerlink" title="2.0版本 解决循环引用"></a>2.0版本 解决循环引用</h2><p>循环引用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">b</span>:<span class="number">122</span>&#125;;</span><br><span class="line">a.target = a;</span><br><span class="line">deepClone(obj);<span class="comment">//报错: RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure><br>先方法判断复杂类型<br>然后用map存储对象 如果已经存在则直接返回<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> judObj = (<span class="function">(<span class="params">target</span>)=&gt;</span>(<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>||<span class="keyword">typeof</span> target === <span class="string">&#x27;function&#x27;</span>)&amp;&amp; target!==<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">const</span> deepClone2 = (<span class="function">(<span class="params">target,map=<span class="keyword">new</span> <span class="built_in">Map</span>()</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(map.get(target))<span class="keyword">return</span> target;</span><br><span class="line">  <span class="keyword">if</span>(judObj(target))&#123;</span><br><span class="line">    map.set(target,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Array</span>.isArray(target)?[]:&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> target)&#123;</span><br><span class="line">      <span class="keyword">if</span>(target.hasOwnProperty(key))&#123;</span><br><span class="line">        res[key] = deepClone2(target[key],map);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//测试数据</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">val</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a.target = a;</span><br><span class="line"><span class="keyword">let</span> newA = deepClone2(a);</span><br><span class="line"><span class="built_in">console</span>.log(newA)<span class="comment">//&#123; val: 2, target: &#123; val: 2, target: [Circular] &#125; &#125;</span></span><br></pre></td></tr></table></figure></p><p>but存在一个潜在的问题，就是map上的key和map构成了强引用关系，是很危险的。<br>科普强引用和弱引用的关系<br><div class="note primary flat"><p>被弱引用的对象在什么时候都可以被回收，但强引用的不行，上面的代码在程序结束之前都不会释放a的空间</p></div></p><p>所以需要用到weekMap构成弱引用，把Map改成weekMap即可</p><h2 id="拷贝特殊对象"><a href="#拷贝特殊对象" class="headerlink" title="拷贝特殊对象"></a>拷贝特殊对象</h2><p>特殊对象<br>可遍历的特殊对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;object Map&quot;</span>]</span><br><span class="line">[<span class="string">&quot;object Set&quot;</span>]</span><br><span class="line">[<span class="string">&quot;object Array&quot;</span>]</span><br><span class="line">[<span class="string">&quot;object Object&quot;</span>]</span><br><span class="line">[<span class="string">&quot;object Arguments&quot;</span>]</span><br></pre></td></tr></table></figure><br>不可遍历的特殊对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> boolTag = <span class="string">&#x27;[object Boolean]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">&#x27;[object Number]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">&#x27;[object String]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">&#x27;[object Date]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">&#x27;[object Error]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">&#x27;[object RegExp]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">&#x27;[object Function]&#x27;</span>;</span><br></pre></td></tr></table></figure><br>用最准确的那个方法判断<br>然后对于不能遍历的对象直接返回<br>对于能遍历的对象分类<br>如果是map的话 foreach 他的item和index赋值<br>如果是set foreach 他的item<br>其他的数组和对象 就直接用之前的方法遍历递归<br>注意要保留对象的原型<br>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> judObj = (<span class="function">(<span class="params">target</span>)=&gt;</span>(<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>||<span class="keyword">typeof</span> target === <span class="string">&#x27;function&#x27;</span>)&amp;&amp; target!==<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getObj = (<span class="function">(<span class="params">target</span>)=&gt;</span><span class="built_in">Object</span>.prototype.toString.call(target));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canTranverse = &#123;</span><br><span class="line">    <span class="string">&#x27;[object Map]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Set]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Array]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Object]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Arguments]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone3 = (<span class="function">(<span class="params">target,map=<span class="keyword">new</span> <span class="built_in">Map</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!judObj)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> type = getObj(target);</span><br><span class="line">    <span class="keyword">let</span> cloneTarget;</span><br><span class="line">    <span class="keyword">if</span>(!canTranverse[type])&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> ctor = target.prototype;</span><br><span class="line">        cloneTarget = <span class="keyword">new</span> ctor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(map.get(cloneTarget))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        map.set(cloneTarget,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(type === <span class="string">&#x27;[object Map]&#x27;</span>)&#123;</span><br><span class="line">        target.forEach(<span class="function">(<span class="params">item,index</span>) =&gt;</span> &#123;</span><br><span class="line">            cloneTarget.set(deepClone3(item),deepClone3(index));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">&#x27;[object Set]&#x27;</span>)&#123;</span><br><span class="line">        target.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">            cloneTarget.add(deepClone3(item));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">                cloneTarget[key] = deepClone3(target[key],map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="3-0-final"><a href="#3-0-final" class="headerlink" title="3.0 final"></a>3.0 final</h2><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getType = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isObject = <span class="function">(<span class="params">target</span>) =&gt;</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> target === <span class="string">&#x27;function&#x27;</span>) &amp;&amp; target !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canTraverse = &#123;</span><br><span class="line">  <span class="string">&#x27;[object Map]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;[object Set]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;[object Array]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;[object Object]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;[object Arguments]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> mapTag = <span class="string">&#x27;[object Map]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">&#x27;[object Set]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">&#x27;[object Boolean]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">&#x27;[object Number]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">&#x27;[object String]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">&#x27;[object Symbol]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">&#x27;[object Date]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">&#x27;[object Error]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">&#x27;[object RegExp]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">&#x27;[object Function]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleRegExp = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; source, flags &#125; = target;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> target.constructor(source, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleFunc = <span class="function">(<span class="params">func</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 箭头函数直接返回自身</span></span><br><span class="line">  <span class="keyword">if</span>(!func.prototype) <span class="keyword">return</span> func;</span><br><span class="line">  <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>;</span><br><span class="line">  <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span>;</span><br><span class="line">  <span class="keyword">const</span> funcString = func.toString();</span><br><span class="line">  <span class="comment">// 分别匹配 函数参数 和 函数体</span></span><br><span class="line">  <span class="keyword">const</span> param = paramReg.exec(funcString);</span><br><span class="line">  <span class="keyword">const</span> body = bodyReg.exec(funcString);</span><br><span class="line">  <span class="keyword">if</span>(!body) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (param) &#123;</span><br><span class="line">    <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(...paramArr, body[<span class="number">0</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(body[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleNotTraverse = <span class="function">(<span class="params">target, tag</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> Ctor = target.constructor;</span><br><span class="line">  <span class="keyword">switch</span>(tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> boolTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Boolean</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> numberTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Number</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> stringTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">String</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> symbolTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> errorTag: </span><br><span class="line">    <span class="keyword">case</span> dateTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">    <span class="keyword">case</span> regexpTag:</span><br><span class="line">      <span class="keyword">return</span> handleRegExp(target);</span><br><span class="line">    <span class="keyword">case</span> funcTag:</span><br><span class="line">      <span class="keyword">return</span> handleFunc(target);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!isObject(target)) </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  <span class="keyword">let</span> type = getType(target);</span><br><span class="line">  <span class="keyword">let</span> cloneTarget;</span><br><span class="line">  <span class="keyword">if</span>(!canTraverse[type]) &#123;</span><br><span class="line">    <span class="comment">// 处理不能遍历的对象</span></span><br><span class="line">    <span class="keyword">return</span> handleNotTraverse(target, type);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这波操作相当关键，可以保证对象的原型不丢失！</span></span><br><span class="line">    <span class="keyword">let</span> ctor = target.constructor;</span><br><span class="line">    cloneTarget = <span class="keyword">new</span> ctor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(map.get(target)) </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  map.set(target, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(type === mapTag) &#123;</span><br><span class="line">    <span class="comment">//处理Map</span></span><br><span class="line">    target.forEach(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.set(deepClone(key, map), deepClone(item, map));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(type === setTag) &#123;</span><br><span class="line">    <span class="comment">//处理Set</span></span><br><span class="line">    target.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.add(deepClone(item, map));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理数组和对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">        cloneTarget[prop] = deepClone(target[prop], map);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="实现发布订阅EventEmitter"><a href="#实现发布订阅EventEmitter" class="headerlink" title="实现发布订阅EventEmitter"></a>实现发布订阅EventEmitter</h1><p>订阅 取消 只能订阅一次 触发<br>代码如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.event = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">type,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.event)<span class="built_in">this</span>.event = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.event[type])&#123;</span><br><span class="line">      <span class="built_in">this</span>.event[type]=[callback]</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.event[type].push(callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">type,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.event)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">this</span>.event[type] = <span class="built_in">this</span>.event[type].find(<span class="function"><span class="params">item</span>=&gt;</span>item!==callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">once</span>(<span class="params">type,callback</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      callback();</span><br><span class="line">      <span class="built_in">this</span>.off(type,fn); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.on(type,fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">type,...args</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.event[type]&amp;&amp;<span class="built_in">this</span>.event[type].forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn.apply(<span class="built_in">this</span>,args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p>原理 找到实例对象的原型然后不断往上查找,如果和类实例的原型相同则为真,如果是null则为假<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myinstanceof</span>(<span class="params">example,classFunc</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(example);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(proto===<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span>(proto===classFunc.prototype)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      proto = <span class="built_in">Object</span>.getPrototypeOf(proto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><p>模拟new就要知道new操作符做了什么事情</p><ul><li>将对象的隐式原型指向构造函数的原型prototype</li><li>执行构造函数，使用call/apply改变this指向</li><li>返回值为object类型则作为new方法的返回值返回，否则返回上述全新对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mynew</span>(<span class="params">fn,...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">    <span class="keyword">let</span> res = fn.apply(instance,args);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span>?res:instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="call"><a href="#call" class="headerlink" title="call"></a>call</h1><p>call不传入参数则默认绑定的window<br>新建函数将函数设置当前this<br>然后删除该函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用法：f.call(obj,arg1)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">f.myCall(obj, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">//否则this指向window</span></span><br></pre></td></tr></table></figure></p><h1 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h1><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myapply = <span class="function"><span class="keyword">function</span>(<span class="params">context,args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">Symbol</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line">    context[key] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> res = context[key](...args);</span><br><span class="line">    <span class="keyword">delete</span> context[key];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否是new 是的话变成指向function 否则指向context</span></span><br><span class="line">        <span class="keyword">var</span> _this = <span class="built_in">this</span> <span class="keyword">instanceof</span> self ? <span class="built_in">this</span> : context;</span><br><span class="line">        <span class="comment">//改变f的原型链</span></span><br><span class="line">        F.prototype = self.prototype;</span><br><span class="line">        <span class="keyword">return</span> self.apply(_this, args.concat(...arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">proto</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    F.prototype = proto;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><h1 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a><code>Promise.resolve</code></h1><ol><li>值是promise对象则直接返回</li><li>返回一个new promise且如果他是then调用，则返回then方法</li><li>其他情况，返回成功状态的promise<br>code<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. promise return</span></span><br><span class="line"><span class="comment">// =&gt; new promise</span></span><br><span class="line"><span class="comment">// 2. param.then === &#x27;fun&#x27;</span></span><br><span class="line"><span class="comment">// =&gt; param.then(res,rej)</span></span><br><span class="line"><span class="comment">// 3. return resolve(param) </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve = (<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (param <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) <span class="keyword">return</span> param;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (param &amp;&amp; param.then &amp;&amp; <span class="keyword">typeof</span> param.then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> param.then(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> resolve(param)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h1 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a><code>Promise.reject</code></h1><p>reject传入的参数会作为一个reason原封不动的往下传<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a><code>Promise.prototype.finally</code></h1><p>不管状态如何都会执行并且往下传值.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve((cb()).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;,<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve((cb()).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a><code>Promise.all</code></h1><p>code如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.myall = <span class="function"><span class="keyword">function</span>(<span class="params">iterable</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">//传入的是可迭代对象</span></span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">//这里不一定是数组,不一定有length,所以要变量计算.</span></span><br><span class="line">      <span class="keyword">let</span> elementCount = <span class="number">0</span>; <span class="comment">//解决的promise数量</span></span><br><span class="line">      <span class="keyword">let</span> anErrorOccurred = <span class="literal">false</span>;<span class="comment">//判断是否错误</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> promise <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">            <span class="keyword">const</span> curIndex = index; <span class="comment">//封闭index的作用域</span></span><br><span class="line">            promise.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(anErrorOccurred)<span class="keyword">return</span>;</span><br><span class="line">                result[curIndex] = value;</span><br><span class="line">                elementCount++;</span><br><span class="line">                <span class="keyword">if</span>(elementCount === result.length)&#123;</span><br><span class="line">                    resolve(result)<span class="comment">//如果全部任务都成功,返回数组</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(anErrorOccurred)<span class="keyword">return</span>;</span><br><span class="line">                anErrorOccurred=<span class="literal">true</span>;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;)</span><br><span class="line">            index++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(index === <span class="number">0</span>)&#123;</span><br><span class="line">          resolve([]);<span class="comment">//长度是0 返回空数组</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(index);<span class="comment">//要在最后写result 因为index是在循环后才计算出来.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a><code>Promise.race</code></h1><p>race方法只要有一个率先改变了状态,后面就直接resolve<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.myrace = <span class="function"><span class="keyword">function</span> (<span class="params">iterable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> settlementOccurred = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> promise <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (settlementOccurred) <span class="keyword">return</span>;</span><br><span class="line">      settlementOccurred = <span class="literal">true</span>;</span><br><span class="line">      resolve(value);<span class="comment">//直接resolve</span></span><br><span class="line">    &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (settlementOccurred) <span class="keyword">return</span>;</span><br><span class="line">      settlementOccurred = <span class="literal">true</span>;</span><br><span class="line">      reject(err);<span class="comment">//直接reject</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a><code>Promise.allSettled</code></h1><p>执行完后不会失败,按顺序返回每个promise状态<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="built_in">Promise</span>.allSettled([resolved, rejected]);</span><br><span class="line">allSettledPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回结果：</span></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 2 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure></p><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.allSettled = <span class="function"><span class="keyword">function</span> (<span class="params">promiseArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!promiseArgs.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve([]);</span><br><span class="line">  <span class="comment">// 包装不是promise的项</span></span><br><span class="line">  <span class="keyword">const</span> promises = promiseArgs.map(<span class="function"><span class="params">p</span> =&gt;</span> p <span class="keyword">instanceof</span> <span class="built_in">Promise</span> ? p : <span class="built_in">Promise</span>.resolve(p));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> unSettledCount = promises.length;</span><br><span class="line">    promises.forEach(<span class="function">(<span class="params">p, index</span>) =&gt;</span> &#123;</span><br><span class="line">      p.then(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        res[index] = &#123;</span><br><span class="line">          <span class="attr">status</span>: <span class="string">&quot;resolve&quot;</span>,</span><br><span class="line">          reason</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        res[index] = &#123;</span><br><span class="line">          <span class="attr">status</span>: <span class="string">&quot;reject&quot;</span>,</span><br><span class="line">          reason</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        --unSettledCount;</span><br><span class="line">        <span class="keyword">if</span> (!unSettledCount) <span class="keyword">return</span> resolve(res);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Promise-retry超时请求"><a href="#Promise-retry超时请求" class="headerlink" title="Promise.retry超时请求"></a>Promise.retry超时请求</h1><p>简易版<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.retrySimple = <span class="function"><span class="keyword">function</span> (<span class="params">fn, maxRetry, timeout</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Expected a function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  maxRetry = maxRetry || <span class="number">3</span>;</span><br><span class="line">  timeout = timeout || <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> retryCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn().then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">      &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retryCount &gt;= maxRetry) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">setTimeout</span>(run,timeout);</span><br><span class="line">        retryCount++;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    run();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有缓存版<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整版 - 有缓存</span></span><br><span class="line"><span class="built_in">Promise</span>.retry = <span class="function"><span class="keyword">function</span> (<span class="params">fn, options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 参数检查</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Expected a function&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    options = options || &#123;&#125;;</span><br><span class="line">    <span class="comment">// 默认参数</span></span><br><span class="line">    options = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">        <span class="attr">maxRetry</span>: <span class="number">3</span>, <span class="comment">// 默认重试次数</span></span><br><span class="line">        <span class="attr">retryDelay</span>: <span class="number">1000</span>, <span class="comment">// 默认重试时间间隔</span></span><br><span class="line">        <span class="attr">cache</span>: <span class="literal">false</span>, <span class="comment">// 是否缓存结果</span></span><br><span class="line">        <span class="attr">cacheKey</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 缓存 key</span></span><br><span class="line">        <span class="attr">cacheExpire</span>: <span class="number">0</span>, <span class="comment">// 缓存过期时间，单位：毫秒</span></span><br><span class="line">        <span class="attr">cacheMax</span>: <span class="number">0</span> <span class="comment">// 缓存最大值，超过后清空缓存</span></span><br><span class="line">    &#125;, options);</span><br><span class="line">    <span class="keyword">let</span> retryCount = <span class="number">0</span>; <span class="comment">// 已重试次数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 内部函数，进行一次尝试</span></span><br><span class="line">        <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn().then(</span><br><span class="line">                <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 成功收到响应，如果需要缓存，则缓存结果，同时设置缓存过期时间</span></span><br><span class="line">                    <span class="keyword">if</span> (options.cache) &#123;</span><br><span class="line">                        <span class="built_in">localStorage</span>.setItem(options.cacheKey, <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">                            value,</span><br><span class="line">                            <span class="attr">expire</span>: <span class="built_in">Date</span>.now() + options.cacheExpire</span><br><span class="line">                        &#125;));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 封装的 promise 解决</span></span><br><span class="line">                    resolve(value);</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 超过了最大重试次数，拒绝</span></span><br><span class="line">                    <span class="keyword">if</span> (retryCount &gt;= options.maxRetry) &#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 没有超过重试次数，如果有缓存，则读取缓存</span></span><br><span class="line">                    <span class="keyword">if</span> (options.cache) &#123;</span><br><span class="line">                        <span class="keyword">const</span> cache = <span class="built_in">localStorage</span>.getItem(options.cacheKey);</span><br><span class="line">                        <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">                            <span class="keyword">const</span> cacheObj = <span class="built_in">JSON</span>.parse(cache);</span><br><span class="line">                            <span class="keyword">if</span> (cacheObj.expire &gt; <span class="built_in">Date</span>.now()) &#123;</span><br><span class="line">                                resolve(cacheObj.value);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 重试</span></span><br><span class="line">                    <span class="built_in">setTimeout</span>(run, options.retryDelay);</span><br><span class="line">                    retryCount++;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">        run();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="解析URL-Params对象"><a href="#解析URL-Params对象" class="headerlink" title="解析URL Params对象"></a>解析URL Params对象</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Vuejs灵魂之问</title>
    <link href="https://zlinni.github.io/posts/0941e8fc9dd3/"/>
    <id>https://zlinni.github.io/posts/0941e8fc9dd3/</id>
    <published>2022-04-14T03:04:12.000Z</published>
    <updated>2022-04-15T06:17:07.245Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>本文整理了高频vue面试考点，并将难度分为简单中等困难三个难度。</p></div><h1 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h1><h1 id="MVC和MVVM的区别"><a href="#MVC和MVVM的区别" class="headerlink" title="MVC和MVVM的区别"></a>MVC和MVVM的区别</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC的全称是 Model View Controller 是模型，视图，控制器的缩写，是一种软件设计规范。</p><ul><li>Model模型:是应用程序中用于处理程序数据逻辑的部分。通常模型对象负责从数据库里面存取数据</li><li>View视图:是应用程序中处理数据显示的部分。通常视图是依据模型数据渲染的。</li><li>Controller:是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414153548.png" alt=""></p><p>MVC的思想:一句话就是Controller负责将Model的数据取出来用View显示出来，换句话说就是在Controller里面把Model的值赋给View</p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM新增了VM类<br>ViewModel层:做了两件事情完成了双向绑定。</p><ol><li>将Model模型转化为了View视图。即将后端的数据转化为所看到的页面。使用的方式是数据绑定。</li><li>将View视图转化为了Model模型。即将页面转化为了后端的数据。使用的方式是DOM事件监听。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414154052.png" alt=""></p><p>MVVM和MVC最大的区别就是:他实现了View和Model的自动同步，也就是当Model的属性改变的时候，我们不需要手动去操作DOM元素，来改变View的显示，而是改变了属性之后View中的元素也会随之改变。</p><div class="note warning flat"><p>注意 Vue并没有完全遵循MVVM的思想，因为MVVM的思想是不允许Model和View直接通信 但是Vue提供了<code>$refs</code>这个属性让我们可以通信操作dom</p></div><h1 id="为什么data是一个函数"><a href="#为什么data是一个函数" class="headerlink" title="为什么data是一个函数"></a>为什么data是一个函数</h1><p>数据以函数返回值的形式定义，每复用一次组件就返回一份全新的data，类似给组件的实例创建一个私有的数据空间，这样实例之间互不影响。如果直接写成对象的形式，实例之间就共享了同一份data数据。</p><h1 id="Vue组件通讯有那些方式？"><a href="#Vue组件通讯有那些方式？" class="headerlink" title="Vue组件通讯有那些方式？"></a>Vue组件通讯有那些方式？</h1><ol><li>props和<code>$emit</code>父子间向子组件传递通过props，子向父传递通过emit触发事件。</li><li><code>$parent</code>,<code>$children</code>获取当前的父组件和子组件。</li><li>全局事件总线。</li><li>localStorage</li><li><code>$refs</code></li><li>Vuex</li></ol><h1 id="Vue的生命周期方法有那些？在那一步发送请求"><a href="#Vue的生命周期方法有那些？在那一步发送请求" class="headerlink" title="Vue的生命周期方法有那些？在那一步发送请求"></a>Vue的生命周期方法有那些？在那一步发送请求</h1><ul><li>beforeCreate 在实例初始化之前，数据观测data Observer和event/wacter事件配置之前被调用。在当前阶段data，methods，computed以及watch上的数据和方法都不能访问。</li><li>created 实例已经创建完成后被调用，在该阶段已经完了数据观测data observer，属性和方法的运算，watch/event的事件回调，这里没有<code>$el</code>，如果想要和DOM进行交互，指南通过<code>vm.$nextTick</code>来访问DOM</li><li>beforeMount 在挂载开始之前被调用，相关的render函数首次被调用。</li><li>mouted 在挂载完成后发生，在当前阶段，真实的DOM挂载完毕，数据完成双向绑定，可以访问到DOM节点。</li><li>beforeUpdate 数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。可以在这个钩子中进一步的更改状态，这不会触发附加的重渲染过程。</li><li>updated 发生在更新完成之后，当前阶段DOM已经完成更新，要注意的是避免在此阶段修改数据，因为可能会导致无限循环的更新，该钩子在服务器渲染期间不被调用。</li><li>beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在该阶段进行善后收尾工作，比如清除定时器。</li><li>destroyed Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑，所有的事件监听器都会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</li><li>activated keep-alive专属，组件被激活的时候调用。</li><li>deactivated keep-alive专属，组件被销毁的时候调用。</li></ul><div class="note primary flat"><p>异步请求在哪一步发起？</p></div><p>可以在created，beforeMount，mounted中进行，因为在这三个钩子中data已经创建，可以将服务器返回的数据进行赋值。</p><ul><li>对DOM有需求的话一般是放在mouted中，此时DOM已经加载完毕</li><li>对DOM没有需求可以放created，但是只是在created发出了请求，真正的数据还是在mouted阶段才获取。</li></ul><h1 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a>v-if和v-show的区别</h1><p>v-if是真正的条件渲染，在编译过程中会转化成三元表达式，条件不满足不渲染此节点。<br>v-show会被编译成指令，如果条件不满足对应的节点隐藏，相当于<code>display:none</code></p><p>使用场景<br>v-if适用于运行的时候很少改变条件，不需要频繁切换的场景。因为会很影响性能。<br>v-show适用于频繁切换的场景。</p><p>拓展<br><div class="note primary flat"><p><code>display:none</code>,<code>opacity:0</code>,<code>visibility:hidden</code>之间的区别？</p></div></p><p>三者都是隐藏。</p><ol><li>是否占据空间<br>关键在于display隐藏后不占据位置。visibility和opacity还是占据元素位置。</li><li>子元素是否继承。<br>display的父元素都不存在了，自然子元素不会被继承。<br>visibility会被子元素继承，可以使用visible来显示子元素<br>opacity会被子元素继承，但不可以设置1来重新显示子元素。</li><li>事件绑定<br>display的元素不存在了，自然无法使用他绑定的元素<br>visibility不会触发他上面绑定的事件<br>opacity会触发。</li><li>过度动画<br>想要使一个元素慢慢消失，只能用opacity。</li></ol><h1 id="说说Vue的内置指令。"><a href="#说说Vue的内置指令。" class="headerlink" title="说说Vue的内置指令。"></a>说说Vue的内置指令。</h1><p>v-once 定义它的元素只渲染一次包括它的所有子节点，首次渲染完之后将视为静态内容。<br>v-clock 该指令保存在元素上直到关联实例结束编译，解决初始化慢导致页面闪动的最佳实践。<br>v-bind 绑定属性，动态更改HTML元素上的属性可以简写成:<br>v-on 监听dom事件 可以简写成@<br>v-html 和<code>innerHTML</code>一样 注意防止xss攻击<br>v-text 更新元素的textContent<br>v-model 变为value和input的语法糖<br>v-if/v-else/v-else-if 配合template使用。<br>v-show 使用指令来实现隐藏和显示<br>v-for </p><ul><li>循环显示渲染列表</li><li>优先级比v-if高，最好不要一起使用—用computed</li><li>注意增加唯一的key—不要使用index作为key<br>v-pre 跳过这个元素以及它的子元素的编译，加快编译速度。</li></ul><h1 id="怎么理解Vue的单向数据流"><a href="#怎么理解Vue的单向数据流" class="headerlink" title="怎么理解Vue的单向数据流"></a>怎么理解Vue的单向数据流</h1><p>数据总是从父组件流到子组件，子组件理应没有权限修改父组件的数据，因为这样会导致数据流错乱。<br>当然如果需要修改父组件props穿过来的数据。最好定义一个data接收这个值再改变。</p><h1 id="computed和watch的区别和运用的场景"><a href="#computed和watch的区别和运用的场景" class="headerlink" title="computed和watch的区别和运用的场景"></a>computed和watch的区别和运用的场景</h1><p>computed和watch都是对属性的变化做出改变的一个函数了。区别在于computed是计算属性，更偏向于计算的结果这个状态，而watch是监视属性，可以看属性的old和new值，偏向于知道这个过程中发生了什么。<br>场景：<br>computed用在模板渲染比较多，某个值有依赖其他的响应式对象甚至是计算属性计算而来。<br>watch用在观测某个值的变化完成复杂的逻辑功能。</p><h1 id="v-if和v-for为什么不建议一起使用。"><a href="#v-if和v-for为什么不建议一起使用。" class="headerlink" title="v-if和v-for为什么不建议一起使用。"></a>v-if和v-for为什么不建议一起使用。</h1><p>首先是v-for的优先级高于v-if 会先解析v-for在去解析v-if 所以每次判断都会遍历整个渲染的数据再去找里面不需要的内容。改进的方法是使用computed 不用if。</p><h1 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h1><h1 id="Vue响应式数据的原理"><a href="#Vue响应式数据的原理" class="headerlink" title="Vue响应式数据的原理"></a>Vue响应式数据的原理</h1><p>整体思路是数据劫持+观测者模式</p><p>在对象内部使用<code>Object.defineProperty</code>将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应的属性的时候，每个属性都有自己的dep属性，存放她所依赖的watcher，当属性变化后会通知watcher派发更新。</p><p>手写</p><h1 id="Vue如何检测数组变化"><a href="#Vue如何检测数组变化" class="headerlink" title="Vue如何检测数组变化"></a>Vue如何检测数组变化</h1><p>数组考虑性能原因没有使用defineProperty对数组每一项进行拦截，而是选择对7种数组方法进行重写(push,shift,pop,splice,unshift,sort,reverse)</p><p>所以在vue种修改数组的索引和长度是无法检测到的。需要通过以上七种变异方法触发数组对应的watcher才能更新。</p><p>换言之，如果使用了其他方法操作vue中的数组，都是不安全的。</p><h1 id="vue3-0用过吗-了解多少"><a href="#vue3-0用过吗-了解多少" class="headerlink" title="vue3.0用过吗 了解多少"></a>vue3.0用过吗 了解多少</h1><ul><li>响应式原理的改变。使用了Proxy替代了<code>Object.defineProperty</code></li><li>使用了Composition API，组件的入口变成了setup</li><li>生命周期函数的变化 setup的集成。</li><li>性能上面的提升</li></ul><h1 id="Vue3和2的响应式原理区别"><a href="#Vue3和2的响应式原理区别" class="headerlink" title="Vue3和2的响应式原理区别"></a>Vue3和2的响应式原理区别</h1><p>我们知道vue2种的响应式不能很好的解决数组的问题，修改数组索引和长度无法检测，且对象删除和增加的操作也无法检测到。</p><p>vue3就利用了Proxy针对这几项进行了改变。可以直接监听对象和数组的变化。并且有多达13种拦截方法。</p><h1 id="Vue的父子组件生命周期钩子执行顺序"><a href="#Vue的父子组件生命周期钩子执行顺序" class="headerlink" title="Vue的父子组件生命周期钩子执行顺序"></a>Vue的父子组件生命周期钩子执行顺序</h1><ul><li><p>加载过程 很容易理解 因为父组件需要先有雏形才能放子组件，可以理解为进行到beforeMount才能放子组件<br>父beforeCreate<br>父created<br>父beforeMount<br>子beforeCreate<br>子created<br>子beforeMount<br>子mounted<br>父mounted<br>注意在这个过程中是子先mounted</p></li><li><p>子组件更新过程<br>父beforeUpdate<br>子beforeUpdate<br>子updated<br>父updated</p></li><li><p>父组件更新过程<br>父beforeUpdate<br>父updated</p></li><li><p>销毁过程<br>父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p></li></ul><h1 id="虚拟DOM是什么-有什么优缺点"><a href="#虚拟DOM是什么-有什么优缺点" class="headerlink" title="虚拟DOM是什么 有什么优缺点"></a>虚拟DOM是什么 有什么优缺点</h1><p>我们知道，在浏览器中一直操作真实DOM是很浪费性能的，这就是虚拟DOM产生的原因。vue2的virtual DOM本质就是用一个原生的js对象去描述一个DOM节点，是对真实DOM的一层抽象。</p><p>优点：</p><ul><li>保护性能下限，框架的虚拟DOM需要适配任何上层API可能的操作，他的一些DOM操作必须是能够有配合的，所以他的性能并不是最优的。但是比起我们粗暴的操作DOM性能要好很多。因此框架的虚拟DOM至少能够保证在你不需要性能优化的前提下依然还可以提供不错的性能。</li><li>无需手动操作DOM，我们不需要手动操作DOM，只需要写好viewmodel的逻辑，框架就会根据虚拟DOM和数据进行双向绑定，帮助我们更新视图提高我们的开发效率。</li><li>跨平台：虚拟dom本质上是js对象，而DOM和平台强相关，相比之下，虚拟dom可以更方便的进行跨平台操作，比如服务器渲染，weex开发等。</li></ul><p>缺点：</p><ul><li>刚刚也说了，虚拟DOM只能保证我们的性能下限，因此对于性能要求高的引用来说，虚拟DOM无法针对性的进行性能优化；</li><li>当首次渲染大量DOM的时候，由于多了一层虚拟DOM的计算，所以会比innerHTML插入慢。</li></ul><h1 id="v-model的原理"><a href="#v-model的原理" class="headerlink" title="v-model的原理"></a>v-model的原理</h1><p>v-model本质上只是一个语法糖，处理value和input</p><p>他在内部为不同的输入元素使用不同的property并抛出不同的事件。</p><ul><li>text和textarea元素使用value property和input事件</li><li>checkbox和radio使用checked property和change事件</li><li>select字段将value作为prop并将change作为事件。</li></ul><div class="note primary flat"><p>注意对于需要使用输入法的语言，你会发现v-model并不会在输入法组合文字的过程中得到更新。</p></div><p>在普通标签上<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;sth&quot;</span> /&gt;  <span class="comment">//这一行等于下一行</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;sth&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;sth = $event.target.value&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>在组件上<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;currency-input v-model=<span class="string">&quot;price&quot;</span>&gt;&lt;/currentcy-input&gt;</span><br><span class="line">&lt;!--上行代码是下行的语法糖</span><br><span class="line"> &lt;currency-input :value=<span class="string">&quot;price&quot;</span> @input=<span class="string">&quot;price = arguments[0]&quot;</span>&gt;&lt;/currency-input&gt;</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 子组件定义 --&gt;</span><br><span class="line">Vue.component(<span class="string">&#x27;currency-input&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;span&gt;</span></span><br><span class="line"><span class="string">   &lt;input</span></span><br><span class="line"><span class="string">    ref=&quot;input&quot;</span></span><br><span class="line"><span class="string">    :value=&quot;value&quot;</span></span><br><span class="line"><span class="string">    @input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span><br><span class="line"><span class="string">   &gt;</span></span><br><span class="line"><span class="string">  &lt;/span&gt;</span></span><br><span class="line"><span class="string"> `</span>,</span><br><span class="line"> <span class="attr">props</span>: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="v-for为什么要加key"><a href="#v-for为什么要加key" class="headerlink" title="v-for为什么要加key"></a>v-for为什么要加key</h1><p>如果不使用key，vue会使用一种最大限度减少动态元素并且尝试就地修改复用相同类型元素的算法。key是为Vue中的vnode的唯一标记，通过这个标记，我们的diff操作可以更准确，更迅速。</p><p>更准确：因为带key就不是就地复用了，在sameNode函数a的key和b的key对比中可以避免就地复用的情况。所以会更加准确。</p><p>更快速：利用key的唯一性生成map对象来获取对应节点，比遍历方法更快。</p><h1 id="vue事件绑定原理"><a href="#vue事件绑定原理" class="headerlink" title="vue事件绑定原理"></a>vue事件绑定原理</h1><p>原生事件绑定是通过<code>addEventListener</code>绑定给真实元素的，组件事件绑定是通过Vue自定义的$on来实现的。如果要在组件上使用原生事件，需要加<code>.native</code>修饰符，这样就相当于在父组件中把子组件当作普通的HTML标签，然后加上原生事件。</p><p><code>$on</code>,<code>$emit</code>是基于发布订阅模式的，维护一个事件中心，on的时候将事件按名称存在事件中心中，称之为订阅者，然后emit将对应的事件进行发布，去执行事件中心里对应的的监听器。</p><p>手写发布订阅</p><h1 id="vue-router路由钩子函数是什么-执行顺序是什么"><a href="#vue-router路由钩子函数是什么-执行顺序是什么" class="headerlink" title="vue-router路由钩子函数是什么 执行顺序是什么"></a>vue-router路由钩子函数是什么 执行顺序是什么</h1><p>钩子函数种类有全局守卫，路由守卫，组件守卫</p><p>全局守卫3个：<br>1.router.beforeEach 全局前置守卫<br>2.router.beforeResolve 全局解析守卫 在beforeRouteEnter调用后调用。<br>3.router.afterEach 全局后置钩子 进入路由后</p><p>路由独享守卫1个：<br>beforeEnter</p><p>组件守卫3个：<br>1.beforeRouteEnter 进入路由前 不能访问this<br>2.beforeRouteUpdate 路由复用同一个组件时<br>3.beforeRouteLeave 离开当前路由时。我们用它来禁止用户离开，比如还未保存草稿，或者在用户离开前，将setInterval销毁，防止离开之后，定时器还在调用。</p><p>完整的导航解析过程：</p><ol><li>导航被触发</li><li>在失活的组件里调用beforeRouteLeave守卫<br>3，调用全局的beforeEach守卫</li><li>在重用的组件里调用beforeRouteUpdate守卫<br>5，在路由配置里调用beforeEnter</li><li>解析异步路由组件</li><li>在被激活的组件里调用beforeRouteEnter</li><li>调用全局的beforeResolve守卫</li><li>导航被确认</li><li>调用全局的afterEach守卫</li><li>触发DOM更新</li><li>调用beforeRouteEnter守卫中传给next的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220415100347.png" alt=""></p><h1 id="vue-router-动态路由是什么？有什么问题"><a href="#vue-router-动态路由是什么？有什么问题" class="headerlink" title="vue-router 动态路由是什么？有什么问题"></a>vue-router 动态路由是什么？有什么问题</h1><p>我们经常需要把某种模式匹配到的路由全部映射到同个组件。例如我们有一个User组件，对于所有ID各不相同的用户，都需要用这个组件来渲染。那么我们可以在vue-router的路由路径中使用动态路由参数来达到这个效果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&#x27;user.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>:[</span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">&quot;/user/:id&quot;</span>,<span class="attr">component</span>:User&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><div class="note primary flat"><p>vue-router组件复用导致路由参数失效怎么办？</p></div><ol><li>通过watch监听路由参数再发请求。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">  <span class="string">&quot;$route&quot;</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.getData(<span class="built_in">this</span>.$route.params.xxx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>用key来防止复用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view :key=<span class="string">&quot;$router.fullPath&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Vuex的理解"><a href="#Vuex的理解" class="headerlink" title="Vuex的理解"></a>Vuex的理解</h1><p>vuex是专门为vue设计的全局状态管理工具，用于多个组件中数据共享。数据缓存等。但无法持久化，内部的核心原理是创造一个全局实例new vue<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220415101158.png" alt=""></p><p>主要包括以下几个模块：</p><ul><li>State 定义了应用状态的数据结构，可以在这里设置默认的初始状态</li><li>Getter 允许组件从Store中获取数据，mapGetters辅助函数仅仅是将store中的getter映射到局部计算属性</li><li>Mutation 是唯一更改store中状态的方法，且必须是同步函数</li><li>Action 用于提交mutation 而不是直接变更状态，可以包含任意异步操作。</li><li>Module 允许将单一的Store拆分为多个store且同时保存在单一的状态树中。</li></ul><h1 id="Vuex页面刷新数据丢失怎么解决"><a href="#Vuex页面刷新数据丢失怎么解决" class="headerlink" title="Vuex页面刷新数据丢失怎么解决"></a>Vuex页面刷新数据丢失怎么解决</h1><p>数据持久化使用本地存储或者第三方插件vuex-persist</p><h1 id="Vuex为什么要分模块而且加命名空间"><a href="#Vuex为什么要分模块而且加命名空间" class="headerlink" title="Vuex为什么要分模块而且加命名空间"></a>Vuex为什么要分模块而且加命名空间</h1><p>模块：由于使用单一的状态树，应用的所有状态会集中到一个比较大的对象。当应用变得复杂的时候，store对象就有可能变得相当臃肿。为了解决以上的问题，Vuex允许我们将store分割成模块module。每个模块拥有自己的state，mutation，action和getter</p><p>命名空间：默认情况下，模块内部的action，mutation，getter是注册在全局命名空间的—-这样能够使得多个模块能够对同一个mutation或者action做出相应。如果想要模块有更高的封装度和复用性，建议添加namespaced:true的方式使得他成为命名空间。当模块被注册的时候，他的所有getter，action以及mutation都会更具模块注册的路径调整名字。</p><h1 id="使用过Vue-SSR吗？说一说SSR"><a href="#使用过Vue-SSR吗？说一说SSR" class="headerlink" title="使用过Vue SSR吗？说一说SSR"></a>使用过Vue SSR吗？说一说SSR</h1><p>SSR也就是服务端渲染，也就是将vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。</p><p>优点：<br>SSR有更好的SEO，并且是因为按需分配，首屏的加载速度更快</p><p>缺点：<br>开发条件受到限制。服务端渲染只支持beforeCreate和created两个钩子。当我们需要一些外部拓展库的时候需要进行特殊处理，服务端渲染应用程序也需要处于nodejs的运行环境。</p><p>且服务端会有更大的负载需求。</p><h1 id="Vue使用了哪些设计者模式"><a href="#Vue使用了哪些设计者模式" class="headerlink" title="Vue使用了哪些设计者模式"></a>Vue使用了哪些设计者模式</h1><ol><li>工厂模式-传入参数即可创建实例。<br>虚拟dom根据参数的不同返回基础标签的vnode和组件vnode</li><li>单例模式-整个程序有且仅有一个实例<br>vue和vue-router的插件注册方法install判断如果系统存在实例就直接返回掉</li><li>发布-订阅模式（vue事件机制）<br>4，观察者模式-响应式数据原理</li><li>装饰模式-@装饰器用法</li><li>策略模式-策略模式指对象有某个行为，但在不同的场景下，该行为有不同的实现方案，比如选项的合并策略。</li></ol><h1 id="你做过哪些vue的性能优化"><a href="#你做过哪些vue的性能优化" class="headerlink" title="你做过哪些vue的性能优化"></a>你做过哪些vue的性能优化</h1><div class="note primary flat"><p>以下针对vue</p></div><ul><li>对象层级不要太深，否则性能就会差。</li><li>不需要响应式的数据不要放在data中，可以使用<code>Object.freeze</code>冻结数据</li><li>v-if和v-show区别使用</li><li>computed和watch区别使用场景。</li><li>v-for遍历必须加key key最好是id 且避免使用v-if</li><li>大数据列表和表格性能优化-虚拟列表/虚拟表格</li><li>防止内部泄漏，组件销毁后把全局变量和事件销毁。</li><li>图片懒加载</li><li>路由懒加载</li><li>第三方插件按需引入</li><li>适当采用keep-alive缓存组件</li><li>防抖节流避免反复请求</li><li>服务端渲染SSR or 预渲染</li></ul><h1 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h1><h1 id="Vue-mixin的使用场景和原理"><a href="#Vue-mixin的使用场景和原理" class="headerlink" title="Vue.mixin的使用场景和原理"></a>Vue.mixin的使用场景和原理</h1><p>在日常的开发中，我们经常会遇到在不同的组件中会需要用到一些相同或者类似的代码，这些代码的功能相对独立，可以通过vue的mixin抽离公共的业务逻辑，原理类似于原型链的继承，当组件初始化的时候会调用mergeOptions方法进行合并，采用策略模式针对不同的属性进行和并。当组件和混入对象拥有同名的选项的时候，这些选项将以恰当的方式“合并”</p><p>手撕mixin</p><h1 id="nextTick的使用场景和原理"><a href="#nextTick的使用场景和原理" class="headerlink" title="nextTick的使用场景和原理"></a>nextTick的使用场景和原理</h1><p>nextTick中的回调是在下次DOM循环更新结束之后执行的回调。在修改数据之后立刻使用这个方法，获取更新后的DOM。主要的思路是采用微任务优先的方式调用异步方法去执行nextTick包装的方法。</p><p>手撕nextTick</p><h1 id="keep-alive使用场景"><a href="#keep-alive使用场景" class="headerlink" title="keep-alive使用场景"></a>keep-alive使用场景</h1><p>keep-alive是vue内置的一个组件，可以实现组件缓存，当组件切换的时候不会对当前组件进行卸载。</p><ul><li>常用的两个属性include和exclude 允许组件有条件的进行缓存</li><li>生命周期两个 activated 和 deactivated。用来知道组件是否处于激活状态</li><li>keep-alive中话运用了LRU算法，选择最近最久未使用的组件进行淘汰</li></ul><p>手撕keep-alive</p><div class="note primary flat"><p>拓展 LRU算法是什么？</p></div><p>LRU 的核心思想是如果数据最近被访问过，那么将来被访问的几率也更高，所以我们将命中缓存的组件 key 重新插入到 this.keys 的尾部，这样一来，this.keys 中越往头部的数据即将来被访问几率越低，所以当缓存数量达到最大值时，我们就删除将来被访问几率最低的数据，即 this.keys 中第一个缓存的组件。</p><h1 id="Vue-set方法原理"><a href="#Vue-set方法原理" class="headerlink" title="Vue.set方法原理"></a>Vue.set方法原理</h1><p>了解了vue响应式原理的同学都知道在两种情况下修改数据vue是不会触发视图更新的。</p><p>1是给实例添加新的属性<br>2是直接更改数组的下标来修改数组的值</p><p>而set的原理就是我们给数组和对象本身都增加了<em>ob</em>属性，代表的是observer实例。当给对象新增不存在的属性，首先会把新的属性进行响应式的跟踪，然后触发对象ob的dep收集到的watcher去更新，当修改数组索引的时候我们调用数组本身的splice方法去更新数组。</p><p>手撕vueset</p><h1 id="Vue-extend原理"><a href="#Vue-extend原理" class="headerlink" title="Vue.extend原理"></a>Vue.extend原理</h1><p>他的原理是使用基础vue构造器，创建一个子类，参数是一个包含组件选项的对象。</p><p>其实就是一个子类构造器，是vue组件的核心api</p><p>实现的思路是使用原型继承的方法返回了vue的子类，并且利用mergeOption把传入组件的options和父类的options进行了合并</p><p>手撕vueextend</p><h1 id="写过自定义指令吗-原理是啥"><a href="#写过自定义指令吗-原理是啥" class="headerlink" title="写过自定义指令吗 原理是啥"></a>写过自定义指令吗 原理是啥</h1><p>指令本质上是装饰器，是vue对html元素的拓展，给html元素增加自定义功能。vue编译dom的时候，会找到指令对象，执行指令相关的方法。</p><p>自定义指令有五个生命周期，分别是bind，inserted，update，componentUpdated，unbind<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> bind 只调用一次，指令第一次绑定到元素的时候调用，在这里可以进行一次性的初始化设置。</span><br><span class="line"><span class="number">2.</span> inserted 被绑定的元素插入父节点的时候调用，只保证父节点存在，但不一定已被插入文档中</span><br><span class="line"><span class="number">3.</span> update 被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的更新。</span><br><span class="line"><span class="number">4.</span> componentUpdated 被绑定元素所在模板完成一次更新的时候调用。</span><br><span class="line"><span class="number">5.</span> unbind：只调用一次，指令与元素解绑的时候调用。</span><br></pre></td></tr></table></figure></p><p>原理</p><ol><li>在生成ast语法树时，遇到指令会给当前元素添加directives属性</li><li>通过genDirectives生成指令代码</li><li>在patch前将指令的钩子提取到cbs中，在patch过程中调用对应的钩子</li><li>当执行指令对应的钩子函数的时候，调用对应指令定义的方法。</li></ol><h1 id="Vue修饰符有哪些"><a href="#Vue修饰符有哪些" class="headerlink" title="Vue修饰符有哪些"></a>Vue修饰符有哪些</h1><p>事件修饰符<br>为了方便 下面的指令都省略.</p><ul><li>stop阻止事件继续传播</li><li>prevent 阻止标签默认行为</li><li>capture 使用事件捕获模式，即元素自身触发的事件先在此处理，然后交由内部元素进行处理</li><li>self 只当在<code>event.target</code>是当前元素的时候才触发处理函数</li><li>once 事件只会触发一次</li><li>passive 告诉浏览器不要阻止事件的默认行为。</li></ul><p>v-model修饰符</p><ul><li>lazy 通过这个修饰符，转变为在change事件再同步</li><li>number 自动将用户输入的值转换为数值类型</li><li>trim 自动过滤用户输入的首位空格</li></ul><p>键盘事件的修饰符</p><ul><li>enter</li><li>tab</li><li>delete（捕获删除 和 退格键）</li><li>esc</li><li>space</li><li>up down left right</li></ul><p>系统修饰符</p><ul><li>ctrl </li><li>alt</li><li>shift</li><li>meta</li></ul><p>鼠标按键修饰符</p><ul><li>left right middle</li></ul><h1 id="Vue模板编译原理"><a href="#Vue模板编译原理" class="headerlink" title="Vue模板编译原理"></a>Vue模板编译原理</h1><p>vue的编译过程就是将template转化为render函数的过程，分为以下几步：<br>第一步 模板字符串 转化为elements ASTs—解析器<br>第二步 对AST进行静态节点标记，主要用来做虚拟DOM的渲染优化—优化器<br>第三步 使用elements ASTs 生成render函数代码字符串—代码生成器</p><p>手撕模板编译</p><h1 id="生命周期钩子是如何实现的"><a href="#生命周期钩子是如何实现的" class="headerlink" title="生命周期钩子是如何实现的"></a>生命周期钩子是如何实现的</h1><p>vue生命周期钩子的核心是利用发布订阅模式先把用户传入的生命周期钩子订阅好，内部采用数组的方式存储，然后在创建组件实例的过程中会一次执行对应的钩子方法—发布</p><p>手撕生命周期钩子实现</p><h1 id="函数式组件使用场景和原理"><a href="#函数式组件使用场景和原理" class="headerlink" title="函数式组件使用场景和原理"></a>函数式组件使用场景和原理</h1><p>函数式组件与普通组件的区别</p><ol><li>函数式组件需要在声明组件的时候指定<code>functional:true</code></li><li>不需要实例化，所以没有this，他的this通过render函数的第二个参数context来代替</li><li>没有生命周期钩子函数，不能使用computed和watch</li><li>不能通过emit对外暴露事件，调用事件只能通过<code>context.listeners.click</code>的方式调用外部传入的事件.</li><li>因为函数式组件是没有实例化的，所以在外部通过ref去引用组件的时候，实际引用的是HTMLElement</li><li>函数式组件的props可以不用显示声明，所以在没有props里面声明的属性都会被隐式的解析为prop。</li></ol><p>优点</p><ol><li>由于函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件</li><li>函数式组件的结构比较简单，代码结构清晰</li></ol><p>使用场景：<br>一个简单的展示组件，作为容器组件的使用，比如router-view就是一个函数式组件</p><p>高阶组件—用于接收一个组件作为参数，返回一个被包装的组件</p><p>相关代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isTrue(Ctor.options.functional)) &#123;</span><br><span class="line">  <span class="comment">// 带有functional的属性的就是函数式组件</span></span><br><span class="line">  <span class="keyword">return</span> createFunctionalComponent(Ctor, propsData, data, context, children);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> listeners = data.on;</span><br><span class="line">data.on = data.nativeOn;</span><br><span class="line">installComponentHooks(data); <span class="comment">// 安装组件相关钩子 （函数式组件没有调用此方法，从而性能高于普通组件）</span></span><br></pre></td></tr></table></figure></p><h1 id="能说下vue-router中常用的路由模式实现原理吗"><a href="#能说下vue-router中常用的路由模式实现原理吗" class="headerlink" title="能说下vue-router中常用的路由模式实现原理吗"></a>能说下vue-router中常用的路由模式实现原理吗</h1><p>hash模式</p><ol><li>location.hash的值实际就是URL后面#的东西，他的特点在于hash虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，所以改变hash不会重新加载页面</li><li>可以为hash的改变添加监听事件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;hashchange&quot;</span>, funcRef, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>3.每改变一次hash都会在浏览器的访问历史中增加一个记录利用hash的以上特点，就可以实现前端路由更新视图但不请求页面的功能了。</li></ol><div class="note primary flat"><p>特点：兼容性好但是不美观</p></div><p>history模式<br>利用了HTML5 History Interface 中新增的pushState和replaceState方法</p><p>这两个方法应用于浏览器的历史记录站，在当前已有的back，forward，go的基础上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用它们修改的浏览器历史记录栈后，虽然当前的URL改变了，但是浏览器不会刷新页面，这就为单页应用前端路由更新视图但不重新请求页面提供了基础。<br><div class="note primary flat"><p>特点，虽然美观，但是刷新后出现404需要后端配置</p></div></p><h1 id="diff算法了解吗"><a href="#diff算法了解吗" class="headerlink" title="diff算法了解吗"></a>diff算法了解吗</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220415135701.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络不完全指南</title>
    <link href="https://zlinni.github.io/posts/62a0bd444c41/"/>
    <id>https://zlinni.github.io/posts/62a0bd444c41/</id>
    <published>2022-04-14T00:20:38.000Z</published>
    <updated>2022-04-14T13:54:38.176Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>本文通过OSI七层模型阐述前端常考的计网知识点</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414082617.png" alt=""></p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><div class="tip cogs"><p>参见HTTP灵魂之问</p></div><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><div class="note primary flat"><p>DNS的作用就是通过域名查询到IP</p></div><p>因为IP存在数字和英文的组合IPv6，很不利于人类记忆，所以出现了域名。你可以把域名看成某个IP的别名，DNS就是去查询这个别名真正的名称是什么</p><div class="note primary flat"><p>在TCP握手之前就已经进行了DNS查询，这个查询是操作系统自己完成的，当在浏览器中想访问<code>www.google.com</code>会进行以下操作。</p></div><ul><li>本地客户端向服务器发起请求查询 IP 地址</li><li>查看浏览器有没有该域名的 IP 缓存</li><li>查看操作系统有没有该域名的 IP 缓存</li><li>查看 Host 文件有没有该域名的解析配置</li><li>如果这时候还没得话，会通过直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器</li><li>然后去该服务器查询 google.com 这个二级域名</li><li>接下来查询 www.google.com 这个三级域名的地址</li><li>返回给 DNS 客户端并缓存起来</li></ul><div class="note primary flat"><p>以上介绍的是DNS迭代查询，还有一种是递归查询，区别是前者是由客户端去请求，后者是由系统配置的DNS去请求，得到结果之后将数据返回给客户端。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414083618.png" alt=""></p><h3 id="DNS解析优化"><a href="#DNS解析优化" class="headerlink" title="DNS解析优化"></a>DNS解析优化</h3><p>主要分为两个方案</p><ul><li>DNS预解析</li><li>减少DNS请求</li></ul><h3 id="DNS预解析"><a href="#DNS预解析" class="headerlink" title="DNS预解析"></a>DNS预解析</h3><div class="note primary flat"><p>DNS解析也需要时间的，可以通过预解析的方式来预先获取域名所对应的IP</p></div><p>link方式：手动解析<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//blog.poetries.top&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>meta方式：https自动解析<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;x-dns-prefetch-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;on&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>设置响应头：自动解析<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.set(<span class="string">&#x27;X-DNS-Prefetch-Control&#x27;</span>, <span class="string">&#x27;on&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h1 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h1><h2 id="URL的加密和解密"><a href="#URL的加密和解密" class="headerlink" title="URL的加密和解密"></a>URL的加密和解密</h2><h2 id="图片编码和解码"><a href="#图片编码和解码" class="headerlink" title="图片编码和解码"></a>图片编码和解码</h2><h1 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h1><h2 id="验证登陆"><a href="#验证登陆" class="headerlink" title="验证登陆"></a>验证登陆</h2><ul><li>cookie session</li><li>token </li><li>sso 单点登陆</li><li>OAuth第三方登陆</li></ul><h3 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie session"></a>cookie session</h3><p>登陆流程：首次登陆<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414092439.png" alt=""></p><ol><li>用户访问<code>a.com/pageA</code>并输入密码登陆</li><li>服务器验证密码无误后，会创建Session ID并将其保存起来</li><li>服务端响应这个请求，并通过Set-Cookie将Session ID写入Cookie中</li></ol><p>再次登陆：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414092643.png" alt=""></p><ol><li>用户访问<code>a.com/pageB</code>自动带上第一次登陆写入的Cookie</li><li>服务端对比Cookie中的SessionID和保存在服务端的SessionID是否一致</li><li>一致则成功</li></ol><h3 id="cookie-session存在的问题"><a href="#cookie-session存在的问题" class="headerlink" title="cookie session存在的问题"></a>cookie session存在的问题</h3><ul><li>服务器需要对接大量的客户端，导致服务器压力大。</li><li>如果服务器是一个集群，为了同步登陆态，就需要将SessionID同步到每一台机器上，无形中增加了服务器的维护成本。</li><li>由于SessionID存放在Cookie中所以无法避免CSRF攻击</li></ul><h3 id="token登陆"><a href="#token登陆" class="headerlink" title="token登陆"></a>token登陆</h3><p>为了解决cookie+session暴露出来的问题，我们可以使用token的登陆方式<br><div class="note primary flat"><p>token是服务端生成的一串字符串，以作为客户端请求的一个令牌。当第一次登陆完成后，服务器会生成一个token并返回给客户端，客户端后续访问只要带上这个token就可以完成身份验证。</p></div></p><h4 id="token机制实现流程"><a href="#token机制实现流程" class="headerlink" title="token机制实现流程"></a>token机制实现流程</h4><p>首次登陆：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414102745.png" alt=""></p><ol><li>用户输入账号密码，并点击登录。</li><li>服务器端验证账号密码无误，创建 Token。</li><li>服务器端将 Token 返回给客户端，由客户端自由保存。</li></ol><p>后续页面访问时：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414102830.png" alt=""></p><ol><li>用户访问 a.com/pageB 时，带上第一次登录时获取的 Token。</li><li>服务器端验证 Token ，有效则身份验证成功。</li></ol><h4 id="Token-机制的特点"><a href="#Token-机制的特点" class="headerlink" title="Token 机制的特点"></a>Token 机制的特点</h4><p>根据上面的案例，我们可以分析出Token的优缺点：</p><ul><li>服务器端不需要存放token，所以不会对服务器造成压力，即使服务器集群，也不需要增加维护成本。</li><li>Token可以存放在前端的任何地方，可以不用保存在Cookie中，提升了页面的安全性。</li><li>Token下发之后，只要在生效时间内，就一直有效，如果服务器想收回此token的权限，并不容易。</li></ul><h4 id="Token的生成方式"><a href="#Token的生成方式" class="headerlink" title="Token的生成方式"></a>Token的生成方式</h4><p>最常见的Token生成方式是使用JWT，他是一种简洁的，自包含的方法用于通信双方之间以JSON对象的形式安全的传递信息。</p><p>上文中我们说到，使用Token后，服务器端并不会存储Token，那怎么判断客户端的token是否合法有效？</p><p>答案其实就在Token字符串中，其实Token并不是一串杂乱无章的字符串，而是通过多种算法拼接组合而成的字符串。如下：</p><p>JWT算法主要分成了三个部分 </p><ul><li>header 头信息</li><li>payload 消息体</li><li>signature 签名</li></ul><p>header部分指定了JWT使用的签名算法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header = <span class="string">&#x27;&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;&#x27;</span>   <span class="comment">// `HS256` 表示使用了 HMAC-SHA256 来生成签名。</span></span><br></pre></td></tr></table></figure></p><p>payload部分指明了JWT的使用意图<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;&#123;&quot;loggedInAs&quot;:&quot;admin&quot;,&quot;iat&quot;:1422779638&#125;&#x27;</span>     <span class="comment">//iat 表示令牌生成的时间</span></span><br></pre></td></tr></table></figure></p><p>signature部分为JWT的签名 主要为了让JWT不能随意更改，签名的方法分为两个步骤</p><ol><li>输入base64url编码的header部分，base64url编码的payload部分，输出unsignedToken</li><li>输入服务器端私钥，unsignedToken,输出signature签名</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base64Header = encodeBase64(header)</span><br><span class="line"><span class="keyword">const</span> base64Payload = encodeBase64(payload)</span><br><span class="line"><span class="keyword">const</span> unsignedToken = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;服务器私钥&#x27;</span></span><br><span class="line"></span><br><span class="line">signature = HMAC(key, unsignedToken)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后Token计算如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base64Header = encodeBase64(header)</span><br><span class="line"><span class="keyword">const</span> base64Payload = encodeBase64(payload)</span><br><span class="line"><span class="keyword">const</span> base64Signature = encodeBase64(signature)</span><br><span class="line"></span><br><span class="line">token = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>.<span class="subst">$&#123;base64Signature&#125;</span>`</span></span><br></pre></td></tr></table></figure></p><p>服务器在判断token的时候<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [base64Header, base64Payload, base64Signature] = token.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> signature1 = decodeBase64(base64Signature)</span><br><span class="line"><span class="keyword">const</span> unsignedToken = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> signature2 = HMAC(<span class="string">&#x27;服务器私钥&#x27;</span>, unsignedToken)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(signature1 === signature2) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;签名验证成功，token 没有被篡改&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> payload =  decodeBase64(base64Payload)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Date</span>() - payload.iat &lt; <span class="string">&#x27;token 有效期&#x27;</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;token 有效&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有了 Token 之后，登录方式已经变得非常高效，接下来我们介绍另外两种登录方式。</p><h3 id="SSO单点登陆"><a href="#SSO单点登陆" class="headerlink" title="SSO单点登陆"></a>SSO单点登陆</h3><div class="note primary flat"><p>单点登陆指的是在公司内部搭建一个公共的认证中心，公司下的所有产品的登陆都可以在认证中心中完成，一个产品在认证中心登陆后，再去访问另外一个产品，可以不用再次登陆，即可获取登陆状态。</p></div><h4 id="SSO机制实现流程"><a href="#SSO机制实现流程" class="headerlink" title="SSO机制实现流程"></a>SSO机制实现流程</h4><p>用户首次访问需要在认证中心登陆</p><h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h2><p><a href="https://juejin.cn/post/6844904046436843527">https://juejin.cn/post/6844904046436843527</a></p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h2><div class="note primary flat"><p>它们是传输层中的两个协议：<br>UDP是面向无连接的，不需要在正是传递数据之前连接起双方，具有不可靠性；不保证有序且不丢失的将数据传递到对端，并且没有任何控制流量的算法。优点是：相比TCP更轻更高效。<br>TCP建立连接和断开连接都需要握手，并且在数据传输的过程中，通过算法来保证数据的可靠性</p></div><h3 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h3><p>UDP：</p><ul><li>直播</li><li>游戏</li></ul><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><div class="note primary flat"><p>建立连接前，客户端和服务端需要通过握手来确认对方</p></div><ul><li>客户端发送SYN同步序列编号请求，进入SYN_SEND状态，等待确认</li><li>服务端接收并确认SYN包之后发送SYN+ACK包，进入SYN_RECV状态</li><li>客户端接收SYN+ACK包之后，发送ACK包，双方进入ESTABLISHED状态</li></ul><h4 id="为什么采用三次握手？"><a href="#为什么采用三次握手？" class="headerlink" title="为什么采用三次握手？"></a>为什么采用三次握手？</h4><p>举例：已失效的连接请求报文段</p><ul><li>如果客户端发送请求报文但由于网络问题导致报文失效，服务端接收到请求后就会发送确认报文表示同意连接。此时如果是两次握手，那么此时服务端已经建立了新的连接，但由于这个请求是失效的，客户端并没有建立连接，服务端就会浪费很多资源。如果是三次握手，那么此时服务端收不到确认连接的信息，就知道客户端没有建立连接。这就是三次握手的作用。<div class="note primary flat"><p>TCP有六种标识SYN建立连接，ACK确认，PSH传送，FIN结束，RST重置，URG紧急</p></div></li></ul><h4 id="三次握手过程中可以携带数据吗？"><a href="#三次握手过程中可以携带数据吗？" class="headerlink" title="三次握手过程中可以携带数据吗？"></a>三次握手过程中可以携带数据吗？</h4><ul><li>第一次第二次握手不能携带数据，因为第一次握手和第二次握手服务端还没有建立连接，此时发送数据会让服务器受到攻击。</li><li>第三次握手服务器已经处于ESTABLISHED状态，对于客户端来说已经建立了连接，并且也知道服务器的接收发送能力是正常的了，所以能携带数据。</li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><div class="note primary flat"><p>为了确保数据能完成传输</p></div><ul><li>客户端—FIN—&gt;服务端，FIN——WAIT</li><li>服务端—ACK—&gt;客户端，CLOSE——WAIT</li><li>服务端—ACK，FIN—&gt;客户端，LAST——ACK</li><li>客户端—ACK—&gt;服务端，CLOSED</li></ul><h4 id="为什么连接的时候是三次握手，关闭的时候是四次挥手？"><a href="#为什么连接的时候是三次握手，关闭的时候是四次挥手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候是四次挥手？"></a>为什么连接的时候是三次握手，关闭的时候是四次挥手？</h4><ul><li>服务端接收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。</li><li>但是在关闭连接的时候，当服务端收到FIN报文的时候 ，很可能并不会立刻关闭连接，所以只能先回复一个ACK报文，告诉客户端，你发的FIN报文收到了，只有等服务器所有的报文发送完了才能发送FIN报文，因此不能一起发送，故需要四次挥手。 </li></ul><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="计算机网络" scheme="https://zlinni.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP灵魂之问</title>
    <link href="https://zlinni.github.io/posts/18a3127ce1f3/"/>
    <id>https://zlinni.github.io/posts/18a3127ce1f3/</id>
    <published>2022-04-10T01:42:40.000Z</published>
    <updated>2022-04-18T01:57:07.108Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>记录HTTP前端常考考点，关联计算机网络。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414082510.png" alt=""></p><h1 id="1-0-1-x-2-0"><a href="#1-0-1-x-2-0" class="headerlink" title="1.0 1.x 2.0"></a>1.0 1.x 2.0</h1><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h2><p>任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。</p><p>除了GET命令，还引入了POST命令和HEAD命令。</p><p>http请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p><p>只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。</p><p>不支持断点续传，也就是说，每次都会传送全部的页面和数据。</p><p>通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）</p><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h2><p>http1.1是目前最为主流的http协议版本，从1999年发布至今，仍是主流的http协议版本。</p><p>引入了持久连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 keep-alive 来设置</p><p>引入了管道机制（ pipelining），即在同一个TCP连接里，客户端可以同时发送多个 请求，进一步改进了HTTP协议的效率。</p><p>HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。</p><p>支持断点续传，通过使用请求头中的 Range 来实现。</p><p>使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</p><p>新增方法：PUT、 PATCH、 OPTIONS、 DELETE。</p><h2 id="http1-x版本问题"><a href="#http1-x版本问题" class="headerlink" title="http1.x版本问题"></a>http1.x版本问题</h2><p>在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。</p><p>HTTP/1.1 版本默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞。</p><p>http/1.x 版本支持Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。</p><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><p>二进制分帧 这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”：头信息帧和数据帧。</p><p>头部压缩 HTTP 1.1版本会出现 User-Agent、Cookie、Accept、Server、Range 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 HPACK 算法进行压缩。</p><p>多路复用 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。</p><p>服务器推送 允许服务器未经请求，主动向客户端发送资源，即服务器推送。</p><p>请求优先级 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</p><h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>在HTTP1.1之前的时代，请求体一般有响应的压缩编码过程，通过Content-Encoding头部字段来指定，但你有没有想过头部字段本身的压缩呢？当请求字段非常复杂的时候，尤其对于GET请求，请求报文几乎全是请求头，这个时候还是存在非常大的优化空间的。HTTP2针对头部字段采用了压缩算法HPACK对请求头进行压缩。</p><p>HPACK算法是专门为HTTP2.0设计的，它的主要亮点有两个：</p><ul><li>首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的过程中对于之前出现过的值，只需要把索引传给对方即可，对方拿到索引表查即可。这种传索引的方式，可以让请求头的字段得到极大程度的精简和复用。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413183603.png" alt=""></li></ul><p>HTTP2当中废除了起始行的概念，将起始行中的请求方法，URI，状态码转换成了头字段，不过这些字段都有个：前缀，用来和其他请求区分开来。</p><ul><li>其次是对于整数和字符串进行哈夫曼编码，哈夫曼编码的原理是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的索引序列，可以达到非常高的压缩效率。</li></ul><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。</p><h4 id="HTTP队头阻塞"><a href="#HTTP队头阻塞" class="headerlink" title="HTTP队头阻塞"></a>HTTP队头阻塞</h4><p>我们之前讨论了HTTP队头阻塞的问题，其根本原因在于HTTP基于请求响应模型，在同一个TCP长连接中，前面的请求没有得到响应，后面的请求就会被阻塞。</p><p>后面我们又讨论到并发连接和域名分片的方式解决队头阻塞的问题，但实际上治标不治本，因为只是单纯的增加了TCP连接，分摊风险而已。而且这么做也有弊端，多条TCP连接会竞争有限的带宽，让真正优先级高的请求不能优先处理。</p><p>而HTTP2便从HTTP协议本身解决了这个问题。注意，这里并不是TCP阻塞，而是HTTP队头阻塞，两者并不是一回事。TCP的队头阻塞是在数据包层面，单位是数据包，前一个报文没有收到便不会将后面的报文上传给HTTP，而HTTP的队头阻塞是在HTTP请求响应的层面，前一个请求没有处理完，后一个请求就会被阻塞住。两者所在的层次不一样。</p><h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p>首先HTTP2认为明文传输对机器而言太麻烦了，不方便计算机的解析，因为对于文本而言会有多义性的字符，比如回车换行到底是内容还是分隔符，在内部需要用到状态机去识别，效率比较低。于是HTTP2干脆把报文全部换成二进制，全部传输01串，方便机器解析。</p><p>原来Headers+Body的报文格式如今被拆分成一个个二进制的帧，用Headers帧存放头部字段，用Data帧存放请求体数据。分帧之后，服务器看到的不再是一个个完整的HTTP请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了HTTP队头阻塞问题。</p><p>通信双方都可以给对方发送二进制帧，这种二进制的双向传输的序列，也叫做流Stream。HTTP2用流来在一个TCP连接上来进行多个数据帧的通信，这就是多路复用的概念。</p><p>可能你会有一个疑问，既然是乱序收发，那么如何来处理这些乱序的数据帧呢？</p><p>首先要声明的是，所谓的乱序指的是不同ID的Stream是乱序的，但同一个Stream ID的数据帧一定是按顺序传输的。二进制到达后对方会将Stream ID相同的二进制帧组装成完整的请求报文和响应报文。当然，在二进制帧中还有一些其他字段，实现了优先级和流量控制。下一节再介绍。</p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>另外值得一说的是HTTP2的服务器推送Server Push。在HTTP2中，服务器已经不再是被动的接收请求，响应请求，他也能新建Stream来给客户端发送信息，当TCP连接建立之后，比如浏览器请求一个HTML文件，服务器就可以在返回HTML的基础上，将HTML中引用到的一些其他资源文件一起返回给客户端，减少客户端等待。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当然，HTTP/2 新增那么多的特性，是不是 HTTP 的语法要重新学呢？不需要，HTTP/2 完全兼容之前 HTTP 的语法和语义，如请求头、URI、状态码、头部字段都没有改变，完全不用担心。同时，在安全方面，HTTP 也支持 TLS，并且现在主流的浏览器都公开只支持加密的 HTTP/2, 因此你现在能看到的 HTTP/2 也基本上都是跑在 TLS 上面的了。最后放一张分层图给大家参考:<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413190733.png" alt=""></p><h3 id="HTTP2缺点"><a href="#HTTP2缺点" class="headerlink" title="HTTP2缺点"></a>HTTP2缺点</h3><ul><li>TCP 以及 TCP+TLS建立连接的延时,HTTP/2使用TCP协议来传输的，而如果使用HTTPS的话，还需要使用TLS协议进行安全传输，而使用TLS也需要一个握手过程,在传输数据之前，导致我们需要花掉 3～4 个 RTT。</li><li>TCP的队头阻塞并没有彻底解决。在HTTP/2中，多个请求是跑在一个TCP管道中的。但当HTTP/2出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该TCP连接中的所有请求。</li></ul><h3 id="HTTP-2-中的二进制帧是如何设计的？"><a href="#HTTP-2-中的二进制帧是如何设计的？" class="headerlink" title="HTTP/2 中的二进制帧是如何设计的？"></a>HTTP/2 中的二进制帧是如何设计的？</h3><p>帧结构<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413190800.png" alt=""><br>每个帧分为帧头和帧体。先是三个字节的帧长度，这个长度表示是帧体的长度。</p><p>然后是帧类型，分为数据帧和控制帧。数据帧用来存放HTTP报文，控制帧用来管理流的传输。</p><p>接下来的一个字节是帧标志，里面一共有8个标志位，常用的有END_HEADERS表示头数据结束，END_STREAM表示单方向数据发送结束。</p><p>后四个字节是Stream ID，也就是流标识符，有了他就能从乱序的二进制帧中选出ID相同的帧，按顺序组装成请求响应报文。</p><h3 id="流的状态变化"><a href="#流的状态变化" class="headerlink" title="流的状态变化"></a>流的状态变化</h3><p>从前面可以知道，在HTTP2中，所谓的流，其实就是二进制的双向传输的序列，那么在HTTP2请求和响应的过程中，流的状态是如何改变的呢？</p><p>HTTP2其实也是借鉴了TCP状态变化的思想，根据帧的标志位来实现具体的状态改变，这里我们以一个普通的请求响应过程为例子来说明。</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413214916.png" alt=""></p><p>最开始两者都是空闲状态，当客户端发送Header帧后，开始分配Stream ID，此时客户端的流打开，服务端接收之后服务端的流也打开，两端的流打开后，就可以互相传递数据帧和控制帧了。</p><p>当客户端要关闭的时候，向服务端发送END_STREAM帧，进入半关闭状态，这个时候客户端只能接收数据，而不能发送数据。</p><p>服务端接收到这个END_STREAM帧之后，也进入半关闭状态，不过此时服务端只能发送不能接收。随后服务端也向客户端发送END_STREAM帧，表示数据发送完毕，双方进入关闭状态。</p><p>如果下次要开启新的流，流ID需要自增，直到上限为止，到达上限之后开一个新的TCP连接重头开始计数。由于流ID字段字节长度为4个子节，最高位又被保留，因此范围是0~2的31次方，大约21亿个。</p><h3 id="流的特性"><a href="#流的特性" class="headerlink" title="流的特性"></a>流的特性</h3><p>刚刚讲到了流的状态变化的过程，这里顺便来总结一下流传输的特性。</p><ul><li>并发性。一个HTTP2连接上可以同时发送多个帧，这一点和HTTP1不一样。这是实现多路复用的基础。</li><li>自增性。流ID是不可重用的，而会按顺序递增，达到上限后新开TCP连接从头开始。</li><li>双向性。客户端和服务端都可以创建流，互不干扰，双方都可以作为发送方和接收方。</li><li>可设置优先级。可以设置数据帧的优先级，让服务器优先处理重要资源，优化用户体验。</li></ul><h2 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h2><div class="note primary flat"><p>Google 在推SPDY的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 UDP 协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。主要特性如下：</p></div><ul><li>实现了类似TCP的流量控制、传输可靠性的功能。虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性</li><li>实现了快速握手功能。由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据。</li><li>集成了TLS加密功能。目前QUIC使用的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。</li><li>多路复用，彻底解决TCP中队头阻塞的问题。</li></ul><h1 id="http报文的组成部分"><a href="#http报文的组成部分" class="headerlink" title="http报文的组成部分"></a>http报文的组成部分</h1><p>请求报文</p><ul><li>请求行(http方法+页面地址+http协议+版本)</li><li>请求头(key+value值)</li><li>空行(服务端通过空行来判断下一部分不再是请求头，而当作请求体来解析)</li><li>请求体(数据部分)<br>响应报文</li><li>状态行+响应头+空行+响应体</li></ul><h2 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h2><p>对于请求报文来说 起始行类似下面这样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /home HTTP/<span class="number">1.1</span></span><br></pre></td></tr></table></figure><br>也就是方法加路径加版本<br>对于响应报文来说，起始行类似于下面这样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br></pre></td></tr></table></figure><br>响应报文的起始行也叫状态行 由http版本 状态码和原因三部分组成<br>值得注意的是 在起始行中，每两个部分之间用空格隔开，最后一个部分后面应该接个换行，严格遵循<code>ABNF</code>语法规范</p><h2 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h2><p>展示一下请求头和响应头在报文中的位置：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220411184426.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220411184443.png" alt=""><br><div class="note primary flat"><p>不管是请求头还是响应头，其中的字段是相当多的，而且牵扯到http非常多的特性，这里就不一一列举的，重点看看这些头部字段的格式：</p></div></p><ul><li>字段名不区分大小写</li><li>字段名不允许出现空格</li><li>字段名后面必须紧跟着<code>:</code></li></ul><h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><div class="note primary flat"><p>用来区分头部和实体</p></div><p>问：如果在头部的中间故意加一个空行会怎么样？<br>后面的全部被当成实体。</p><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><p>具体的数据，也就是body部分，请求报文对应请求体，响应报文对应响应体</p><h1 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h1><p><code>http/1.1</code>规定了以下方法</p><ul><li>GET: 通常用来获取资源</li><li>HEAD: 获取资源的元信息</li><li>POST: 提交数据，即上传数据</li><li>PUT: 修改数据</li><li>DELETE: 删除资源(几乎用不到)</li><li>CONNECT: 建立连接隧道，用于代理服务器</li><li>OPTIONS: 列出可对资源实行的请求方法，用来跨域请求</li><li>TRACE: 追踪请求-响应的传输路径</li></ul><h2 id="GET-POST-区别"><a href="#GET-POST-区别" class="headerlink" title="GET/POST 区别"></a>GET/POST 区别</h2><div class="note primary flat"><p>首先从直观上是语义的区别，而后又有些具体的差异：</p></div><ul><li>从缓存的角度，GET请求会被浏览器主动缓存下来，留下历史记录，而POST默认不会</li><li>从编码的角度，GET请求只能进行url编码，只能接收ASCII符，而POST没有限制。</li><li>从参数的角度，GET一般在URL，因此不安全，POST放在请求体中，更适合传输敏感信息。</li><li>从幂等性的角度，GET是幂等的，而POST不是。（幂等表示执行同样的操作，结果也是相同的）</li><li>从TCP的角度，GET请求会一次性把请求报文发出去，而POST会分为两个TCP数据包，首先发送header部分，如果服务器响应100，然后发body部分。（火狐除外，它的浏览器只发送一个TCP包）</li></ul><h1 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h1><div class="note primary flat"><p>URI, 全称为(Uniform Resource Identifier), 也就是统一资源标识符，它的作用很简单，就是区分互联网上不同的资源。</p></div><p>但是，她并不是我们常说的网址，网址指的是URL，实际上URI包含了URN和URI两个部分，由于URL过于普及，就默认将URI视为URL了。</p><h2 id="URI的结构"><a href="#URI的结构" class="headerlink" title="URI的结构"></a>URI的结构</h2><p>如下：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220411221333.png" alt=""></p><ul><li><code>scheme</code>表示协议名，比如http、https、file等，特点是后面都要跟<code>://</code></li><li><code>user:passwd@</code> 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。</li><li><code>host:port</code>表示主机名和端口。</li><li><code>path</code>表示请求路径，标记资源所在位置。</li><li><code>query</code>表示查询参数，为<code>key=val</code>这种形式，多个键值对之间用&amp;隔开。</li><li><code>fragment</code>表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置。</li></ul><p>eg<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//www.baidu.com/s?wd=HTTP&amp;rsv_spt=1</span></span><br></pre></td></tr></table></figure><br>这个 URI 中，<code>https</code>即<code>scheme</code>部分，<code>www.baidu.com</code>为<code>host:port</code>部分（注意，<code>http</code> 和 <code>https</code> 的默认端口分别为80、443），<code>/s</code>为path部分，而<code>wd=HTTP&amp;rsv_spt=1</code>就是<code>query</code>部分。</p><h2 id="URI编码"><a href="#URI编码" class="headerlink" title="URI编码"></a>URI编码</h2><p>URI 只能使用ASCII, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。<br>因此，URI 引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个<code>%</code>。<br>如，空格被转义成了<code>%20</code>，三元被转义成了<code>%E4%B8%89%E5%85%83</code>。</p><h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><div class="note primary flat"><p>RFC规定HTTP的状态码为三位数，被分为五类：</p></div><ul><li>1xx：表示目前是协议处理的中间状态，还需要后续操作。</li><li>2xx：表示成功状态。</li><li>3xx：重定向状态，资源位置发生变动，需要重新请求。</li><li>4xx：请求报文有误</li><li>5xx：服务器端发生错误。<br>接下来就一一分析状态码：</li></ul><h2 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h2><p>101 Switching Protocols 在http升级为websocket的时候，如果服务器同意变更，就会发送状态码101</p><h2 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h2><p>200 OK 是见的最多的成功状态码，通常在响应体中放有数据。<br>204 No Content 含义与200相同，但响应头后没有body数据。<br>206 Partial Content顾名思义，表示部分内容，他的使用场景是为HTTP分块下载和断点续传，</p><h2 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h2><p>301 Moved Permanently永久重定向，对应302 Found 即临时重定向<br><div class="note primary flat"><p>比如你的网站升级到httos了，以前的站点不用了，应当返回301，这时候浏览器默认做缓存优化，在第二次访问的时候自动访问重定向的地址。<br>而如果只是暂时不用，那么直接返回302即可，和301不同的是，浏览器不会做缓存优化</p></div><br>304 Not Modified 当协商缓存命中时会返回这个状态码</p><h2 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h2><p>400 Bad Request 开发者看到经常一头雾水，只是笼统的提示了一下错误，并不知道哪里出错了。<br>403 Forbidden 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止，信息敏感…<br>404 Not Found 资源未找到，表示服务器上面没有这个资源。<br>405 Method Not Allow 该请求方法服务器不允许<br>406 Not Acceptable 资源无法满足客户端条件。<br>408 Request Timeout 服务器等待太久<br>409 Conflict 多个请求发生了冲突<br>413 Request Entity Too Large: 请求体的数据过大。<br>414 Request-URI Too Long: 请求行里的 URI 太大。<br>429 Too Many Request: 客户端发送的请求过多。<br>431 Request Header Fields Too Large请求头的字段内容太大。</p><h2 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h2><p>500 Internal Server Error: 仅仅告诉你服务器出错了，出了啥错咱也不知道。<br>501 Not Implemented: 表示客户端请求的功能还不支持。<br>502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。<br>503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><div class="note primary flat"><p>HTTP的特点概括如下：</p></div><ul><li>灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</li><li>可靠传输。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。</li><li>请求-应答。也就是一发一收、有来有回， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。</li><li>无状态。这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。</li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><h2 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h2><p>对需要长连接的场景来说，需要保存大量的上下文信息，以免传输大量的重复信息，这时候无状态就是缺点<br>但对于一些应用仅仅只需要获取一些数据来说，不需要保存上下文信息，无状态反而减小了网络开销</p><h2 id="明文传输"><a href="#明文传输" class="headerlink" title="明文传输"></a>明文传输</h2><p>即协议里面的报文不使用二进制数据，而是使用明文<br>对于调试来说是一种便利，但是同时也把HTTP报文信息传输给了外界，给攻击者提供了便利。WIFI陷阱就是利用HTTP明文传输的特点，诱导你连上热点，然后疯狂抓取你的流量，从而拿到你的敏感信息。</p><h2 id="队头阻塞问题"><a href="#队头阻塞问题" class="headerlink" title="队头阻塞问题"></a>队头阻塞问题</h2><p>当http开启长连接的时候，共用一个TCP连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其他的请求只能处于阻塞状态，也就是著名的队头阻塞问题，下面会有一小节讨论他。</p><h1 id="Accept系列字段"><a href="#Accept系列字段" class="headerlink" title="Accept系列字段"></a>Accept系列字段</h1><div class="note primary flat"><p>对于Accept系列字段分为四个部分，数据格式，压缩方式，支持语言和字符集</p></div><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><div class="note primary flat"><p>HTTP支持非常多的数据格式，那么这么多格式的数据一下子到客户端，客户端怎么知道他的格式呢？</p></div><p>介绍一个标准：MIME(Multipurpose Internet Mail Extensions, 多用途互联网邮件扩展)<br>他首用在电子邮件系统中，让邮件可以发送任意类型的数据，这对于HTTP来说也是通用的。<br>因此 HTTP从MIME type取了一部分来标记报文的body数据类型，这些类型体现在<code>Content-type</code>这个字段，当然这是针对于发送端而言的。接收端想要接收指定类型的数据，也可以用<code>Accept</code>字段<br>具体而言，这两个字段的取值可以分为下面几类:</p><ul><li>text： text/html, text/plain, text/css 等</li><li>image: image/gif, image/jpeg, image/png 等</li><li>audio/video: audio/mpeg, video/mp4 等</li><li>application: application/json, application/javascript, application/pdf, application/octet-stream</li></ul><h2 id="压缩方式"><a href="#压缩方式" class="headerlink" title="压缩方式"></a>压缩方式</h2><p>当然这些数据都是会进行压缩的，采用什么压缩方式在于发送方的<code>Content-Encoding</code>字段上，同样的，接收什么样的压缩方式体现在接收方的<code>Accept-Encoding</code>上，取值如下：</p><ul><li>gzip 当今最流行的压缩格式</li><li>deflate 另外一种著名的压缩格式</li><li>br 一种专门为HTTP发明的压缩算法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line">Content-Encoding: gzip</span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line">Accept-Encoding: gzip</span><br></pre></td></tr></table></figure><h2 id="支持语言"><a href="#支持语言" class="headerlink" title="支持语言"></a>支持语言</h2><p>对于发送方而言，还有一个<code>Content-Language</code>字段，在需要实现国际化的方案当中，可以用来指定支持的语言，在接受方对应的字段为<code>Accept-Language</code>。如:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line">Content-Language: zh-CN, zh, en</span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line">Accept-Language: zh-CN, zh, en</span><br></pre></td></tr></table></figure></p><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>最后是一个比较特殊的字段, 在接收端对应为<code>Accept-Charset</code>，指定可以接受的字符集，而在发送端并没有对应的<code>Content-Charset</code>, 而是直接放在了<code>Content-Type</code>中，以<code>charset</code>属性指定。如:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line">Accept-Charset: charset=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure></p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220412104403.png" alt=""></p><h1 id="对于定长和不定长的数据，HTTP-是怎么传输的？"><a href="#对于定长和不定长的数据，HTTP-是怎么传输的？" class="headerlink" title="对于定长和不定长的数据，HTTP 是怎么传输的？"></a>对于定长和不定长的数据，HTTP 是怎么传输的？</h1><h2 id="定长包体"><a href="#定长包体" class="headerlink" title="定长包体"></a>定长包体</h2><p>对于定长包体而言，发送端在传输的时候一般会带上 <code>Content-Length</code>, 来指明包体的长度。</p><p>我们用一个nodejs服务器来模拟一下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(req.url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    res.setHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>);</span><br><span class="line">    res.setHeader(<span class="string">&#x27;Content-Length&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">    res.write(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8081</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功启动&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>启动后访问: localhost:8081。</p><p>浏览器中显示如下:<br>//helloworld<br>这是长度正确的情况，那不正确的情况是如何处理的呢？</p><p>我们试着把这个长度设置的小一些:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&#x27;Content-Length&#x27;</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure><br>重启服务，再次访问，现在浏览器中内容如下:<br>//hellowor<br>那后面的ld哪里去了呢？实际上在 http 的响应体中直接被截去了。</p><p>然后我们试着将这个长度设置得大一些:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&#x27;Content-Length&#x27;</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure><br>直接无法显示了。可以看到<code>Content-Length</code>对于 http 传输过程起到了十分关键的作用，如果设置不当可以直接导致传输失败。</p><h2 id="不定长包体"><a href="#不定长包体" class="headerlink" title="不定长包体"></a>不定长包体</h2><div class="note primary flat"><p>上述是针对于定长包体，那么对于不定长包体而言是如何传输的呢？</p></div><p>这里就必须介绍另外一个 http 头部字段了:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><br>表示分块传输数据，设置这个字段后会自动产生两个效果:</p><ol><li><code>Content-Length</code> 字段会被忽略</li><li>基于长连接持续推送动态内容<br>我们依然以一个实际的例子来模拟分块传输，nodejs 程序如下:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(req.url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    res.setHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf8&#x27;</span>);</span><br><span class="line">    res.setHeader(<span class="string">&#x27;Content-Length&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">    res.setHeader(<span class="string">&#x27;Transfer-Encoding&#x27;</span>, <span class="string">&#x27;chunked&#x27;</span>);</span><br><span class="line">    res.write(<span class="string">&quot;&lt;p&gt;来啦&lt;/p&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      res.write(<span class="string">&quot;第一次传输&lt;br/&gt;&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      res.write(<span class="string">&quot;第二次传输&quot;</span>);</span><br><span class="line">      res.end()</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8009</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功启动&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220412110217.png" alt=""><br>用 telnet 抓到的响应如下:<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220412110235.png" alt=""><br>注意，Connection: keep-alive及之前的为响应行和响应头，后面的内容为响应体，这两部分用换行符隔开。</li></ol><p>响应体的结构比较有意思，如下所示:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chunk长度(<span class="number">16</span>进制的数)</span><br><span class="line">第一个chunk的内容</span><br><span class="line">chunk长度(<span class="number">16</span>进制的数)</span><br><span class="line">第二个chunk的内容</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><br>最后是留有有一个空行的，这一点请大家注意。</p><p>以上便是 http 对于定长数据和不定长数据的传输方式。</p><h1 id="HTTP-如何处理大文件的传输？"><a href="#HTTP-如何处理大文件的传输？" class="headerlink" title="HTTP 如何处理大文件的传输？"></a>HTTP 如何处理大文件的传输？</h1><div class="note primary flat"><p>对于几百 M 甚至上 G 的大文件来说，如果要一口气全部传输过来显然是不现实的，会有大量的等待时间，严重影响用户体验。因此，HTTP 针对这一场景，采取了范围请求的解决方案，允许客户端仅仅请求一个资源的一部分。</p></div><h2 id="如何支持"><a href="#如何支持" class="headerlink" title="如何支持"></a>如何支持</h2><div class="note primary flat"><p>当然，前提是服务器要支持范围请求，要支持这个功能，就必须加上这样一个响应头:</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: none</span><br></pre></td></tr></table></figure><h2 id="Range-字段拆解"><a href="#Range-字段拆解" class="headerlink" title="Range 字段拆解"></a>Range 字段拆解</h2><div class="note primary flat"><p>而对于客户端而言，它需要指定请求哪一部分，通过<code>Range</code>这个请求头字段确定，格式为<code>bytes=x-y</code>。接下来就来讨论一下这个 Range 的书写格式:</p></div><ul><li>0-499表示从开始到第 499 个字节。</li><li>500- 表示从第 500 字节到文件终点。</li><li>-100表示文件的最后100个字节。<br>服务器收到请求之后，首先验证范围是否合法，如果越界了那么返回416错误码，否则读取相应片段，返回206状态码。<br>同时，服务器需要添加<code>Content-Range</code>字段，这个字段的格式根据请求头中Range字段的不同而有所差异。<br>具体来说，请求单段数据和请求多段数据，响应头是不一样的。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单段数据</span></span><br><span class="line"><span class="attr">Range</span>: bytes=<span class="number">0</span>-<span class="number">9</span></span><br><span class="line"><span class="comment">// 多段数据</span></span><br><span class="line"><span class="attr">Range</span>: bytes=<span class="number">0</span>-<span class="number">9</span>, <span class="number">30</span>-<span class="number">39</span></span><br></pre></td></tr></table></figure>接下来我们就分别来讨论着两种情况。</li></ul><h2 id="单段数据"><a href="#单段数据" class="headerlink" title="单段数据"></a>单段数据</h2><p>对于单段数据的请求，返回的响应如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">206</span> Partial Content</span><br><span class="line">Content-Length: <span class="number">10</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Range: bytes <span class="number">0</span>-<span class="number">9</span>/<span class="number">100</span></span><br><span class="line"></span><br><span class="line">i am xxxxx</span><br></pre></td></tr></table></figure><br>值得注意的是<code>Content-Range</code>字段，0-9表示请求的返回，100表示资源的总大小，很好理解。</p><h2 id="多段数据"><a href="#多段数据" class="headerlink" title="多段数据"></a>多段数据</h2><p>接下来我们看看多段请求的情况。得到的响应会是下面这个形式:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">206</span> Partial Content</span><br><span class="line">Content-Type: multipart/byteranges; boundary=<span class="number">00000010101</span></span><br><span class="line">Content-Length: <span class="number">189</span></span><br><span class="line"><span class="attr">Connection</span>: keep-alive</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--<span class="number">00000010101</span></span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes <span class="number">0</span>-<span class="number">9</span>/<span class="number">96</span></span><br><span class="line"></span><br><span class="line">i am xxxxx</span><br><span class="line">--<span class="number">00000010101</span></span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes <span class="number">20</span>-<span class="number">29</span>/<span class="number">96</span></span><br><span class="line"></span><br><span class="line">eex jspy e</span><br><span class="line">--<span class="number">00000010101</span>--</span><br></pre></td></tr></table></figure><br>这个时候出现了一个非常关键的字段<code>Content-Type: multipart/byteranges;boundary=00000010101</code>，它代表了信息量是这样的:</p><ul><li>请求一定是多段数据请求</li><li>响应体中的分隔符是 00000010101<br>因此，在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上<code>--</code>表示结束。</li></ul><p>以上就是 http 针对大文件传输所采用的手段。</p><h1 id="HTTP-中如何处理表单数据的提交？"><a href="#HTTP-中如何处理表单数据的提交？" class="headerlink" title="HTTP 中如何处理表单数据的提交？"></a>HTTP 中如何处理表单数据的提交？</h1><p>在 http 中，有两种主要的表单提交的方式，体现在两种不同的<code>Content-Type</code>取值:</p><ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data<br>由于表单提交一般是POST请求，很少考虑GET，因此这里我们将默认提交的数据放在请求体中。</li></ul><h2 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a><code>application/x-www-form-urlencoded</code></h2><p>特点:</p><ul><li>数据会被编码为&amp;分割的键值对</li><li>字符以URL形式编码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换过程: &#123;a: 1, b: 2&#125; -&gt; a=1&amp;b=2 -&gt; 如下(最终形式)</span></span><br><span class="line"><span class="string">&quot;a%3D1%26b%3D2&quot;</span></span><br></pre></td></tr></table></figure><h2 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a><code>multipart/form-data</code></h2><ul><li>请求头中的<code>Content-Type</code>字段会包含<code>boundary</code>，且<code>boundary</code>的值有浏览器默认指定。例: <code>Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe</code>。<br>8 数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如<code>Content-Type</code>，在最后的分隔符会加上<code>--</code>表示结束。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data;name=<span class="string">&quot;data1&quot;</span>;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">data1</span><br><span class="line">----WebkitFormBoundaryRRJKeWfHPGrS4LKe</span><br><span class="line">Content-Disposition: form-data;name=<span class="string">&quot;data2&quot;</span>;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">data2</span><br><span class="line">----WebkitFormBoundaryRRJKeWfHPGrS4LKe--</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><div class="note primary flat"><p>值得一提的是，multipart/form-data 格式最大的特点在于:每一个表单元素都是独立的资源表述。另外，你可能在写业务的过程中，并没有注意到其中还有boundary的存在，如果你打开抓包工具，确实可以看到不同的表单元素被拆分开了，之所以在平时感觉不到，是以为浏览器和 HTTP 给你封装了这一系列操作。<br>而且，在实际的场景中，对于图片等文件的上传，基本采用<code>multipart/form-data</code>而不用<code>application/x-www-form-urlencoded</code>，因为没有必要做 <code>URL</code> 编码，带来巨大耗时的同时也占用了更多的空间。</p></div><h1 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h1><p>什么是队头阻塞？<br>HTTP的传输是请求应答模式的，即报文必须一发一收，但值得注意的是里面的任务被放到一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理，这就是队头阻塞问题。</p><h2 id="并发连接"><a href="#并发连接" class="headerlink" title="并发连接"></a>并发连接</h2><p>对于同一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个任务阻塞了其他所有任务。在RFC2616规定过客户端最多并发两个连接，不过事实现在的浏览器标准中，上限要高很多，比如Chrome是6个<br>但其实，即使提高了并发连接，还是不能满足人们对性能的要求。</p><h2 id="域名分片"><a href="#域名分片" class="headerlink" title="域名分片"></a>域名分片</h2><p>一个域名不是可以并发六个长连接吗？那就多分几个域名<br>比如content1.sanyuan.com 、content2.sanyuan.com。<br>这样一个<code>sanyuan.com</code>域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>简介<br>我们知道HTTP是无状态的协议，每次HTTP请求都是独立，无关的，默认不需要保留任何信息，但有时候要保存一些状态。所以就诞生了Cookie<br>本质是浏览器里存储的一个很小的文本文件，内部以键值对的方式来存储。想同一个域名发送请求，都会携带相同的Cookie，服务器拿到Cookie进行解析，便能拿到客户端的状态，而服务端就可以通过响应头中的<code>Set-Cookie</code>字段来给客户端写入Cookie。<br>eg<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求头</span></span><br><span class="line"><span class="attr">Cookie</span>: a=xxx;b=xxx</span><br><span class="line"><span class="comment">// 响应头</span></span><br><span class="line"><span class="built_in">Set</span>-Cookie: a=xxx</span><br><span class="line">set-Cookie: b=xxx</span><br></pre></td></tr></table></figure></p><h2 id="Cookie属性"><a href="#Cookie属性" class="headerlink" title="Cookie属性"></a>Cookie属性</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>设置有效期用以下两个属性</p><ul><li>Expires过期时间</li><li>Max-Age用的是一段时间间隔，单位是s，从浏览器收到报文开始计算。<br>若Cookie过期，则Cookie会被删除并不会发送给服务端。</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>两个属性</p><ul><li>Domain域名</li><li>Path路径<br>在发送请求之前，发现域名和路径两者不匹配，则不会带上Cookie。值得注意的是，对于路径来说，<code>/</code>表示域名下的任意路径都允许使用Cookie</li></ul><h3 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h3><p>如果带上Secure。说明只能通过HTTPS传输Cookie<br>如果带上HttpOnly，说明只能通过HTTP协议传输，不能通过JS访问，这也是预防XSS攻击的重要手段。<br>对应的，对于CSRF攻击的预防，也有SameSite属性。<br>三个值 <code>Strict</code>,<code>Lax</code>,<code>None</code></p><ul><li>在strict模式下，浏览器完全禁止第三方请求携带Cookie，比如请求<code>aaa.com</code>的网站只能在<code>aaa.com</code>的域名当中请求才能携带Cookie，在其他网站请求都不行。</li><li>在lax模式下，就宽松一点，但是只能在GET方法提交表单或者a标签发送get请求的情况下可以携带Cookie，其他情况都不能。</li><li>在None，也就是默认模式下，请求会自动携带上Cookie</li></ul><h2 id="Cookie的缺点"><a href="#Cookie的缺点" class="headerlink" title="Cookie的缺点"></a>Cookie的缺点</h2><ol><li>容量缺陷 4kb</li><li>性能缺陷，cookie紧跟域名，不管域名下面某个地址需不需要这个cookie，都会携带上完整的cookie，这样随着请求的增多，会造成巨大的性能浪费，但是可以通过domain和path来指定作用域解决。</li><li>安全缺陷，cookie是以纯文本的形式存储在浏览器中的，很容易被用户非法获取，然后进行一系列的篡改，在cookie有效期内发给服务器，这是很危险的。另外，在httponly为false的情况下，cookie信息能直接通过js脚本获取。</li></ol><h1 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h1><p>我们知道在HTTP是基于请求响应模型的协议，一般由客户端请求，服务器来进行响应。<br>当然也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应。而对于源服务器，表现为客户端发起请求，具有双重身份，那代理服务器是用来做什么的呢？</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>负载均衡。客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP都是多少，客户端是不知道的。因此这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各个源服务器的负载尽量平均。当然这样的算法有很多，包括随机算法，轮询，一致性，hash，LRU等等，不过这些算法并不是重点。</li><li>保障安全。利用心跳机制监控后台的服务器，一旦发现故障就将其踢出集群。并且对于上下行的数据进行过滤，对非法IP限流，这些都是代理服务器的工作。</li><li>缓存代理。将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里，下一节详细拆解。</li></ol><h2 id="相关头部字段"><a href="#相关头部字段" class="headerlink" title="相关头部字段"></a>相关头部字段</h2><h3 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h3><p>代理服务器需要表明自己的身份，在HTTP传输中留下自己的痕迹，怎么办？<br>通过Via字段来记录，举个例子，现在中间有两台代理服务器，在客户端发送请求后会经历这样一个过程：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 -&gt; 代理<span class="number">1</span> -&gt; 代理<span class="number">2</span> -&gt; 源服务器</span><br></pre></td></tr></table></figure><br>在源服务器收到请求之后，会在请求头拿到这个字段<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Via: proxy_server1, proxy_server2</span><br></pre></td></tr></table></figure><br>可以看到Via的代理顺序即为在HTTP传输中报文传达的顺序。</p><h3 id="X-Forwarded-For"><a href="#X-Forwarded-For" class="headerlink" title="X-Forwarded-For"></a>X-Forwarded-For</h3><p>字面意思就是为谁转发，它记录的是请求方的IP地址，注意和Via区分开，它记录的是请求方的。</p><h3 id="X-Real-IP"><a href="#X-Real-IP" class="headerlink" title="X-Real-IP"></a>X-Real-IP</h3><p>是一种获取用户真实IP的字段，不管中间经过多少代理，这个字段始终记录最初客户端的IP。<br>相应的，还有<code>X-Forwarded-Host</code>和<code>X-Forwarded-Proto</code>，分别记录着客户端的域名和协议名</p><h3 id="X-Forwarded-For产生的问题"><a href="#X-Forwarded-For产生的问题" class="headerlink" title="X-Forwarded-For产生的问题"></a>X-Forwarded-For产生的问题</h3><p>这个字段记录的是请求方的IP，所以说每次经过代理它都会发生改变。<br>所以产生了一下两个问题</p><ol><li>意味着代理必须解析HTTP请求头，然后修改，比直接转发数据性能下降。</li><li>在HTTPS通信加密的过程中，原始报文是不允许被修改的。<br>由此产生了代理协议，一般使用明文版本，只需要在HTTP请求行上加上这样格式的文本即可。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口</span></span><br><span class="line">PROXY TCP4 <span class="number">0.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.2</span> <span class="number">1111</span> <span class="number">2222</span></span><br><span class="line">GET / HTTP/<span class="number">1.1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>就可以解决<code>X-Forwarded-For</code>带来的问题了。</li></ol><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><div class="note primary flat"><p>浏览器缓存分为强缓存和协商缓存，当客户端请求某个资源的时候，获取缓存的流程如下：</p></div><ul><li>先根据这个资源的一些<code>http header</code>判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发送请求到服务器。</li><li>当强缓存没有命中的时候，客户端会发送请求到服务器，服务器通过一些<code>request header</code>验证这个资源是否命中协商缓存，称为<code>http</code>再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源。</li><li>强缓存和协商缓存的共同之处在于，如果命中缓存，服务器都不会返回资源；区别是，强缓存不会发送请求到服务器，协商缓存会。</li><li>当协商缓存也没有命中的时候，服务器将资源发送到客户端。</li><li>当<code>ctrl+f5</code>强制刷新网页的时候，直接从服务器加载，则跳过强缓存和协商缓存。</li><li>当F5刷新网页的时候，跳过强缓存，但是会检查协商缓存。</li></ul><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><div class="note primary flat"><p>强缓存的两种方式如下：</p></div><ul><li><code>Expires</code>(该字段是http1.0时的规范，值为一个绝对是件绝对时间的GMT格式的时间字符串，代表缓存资源的过期时间)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, <span class="number">22</span> Oct <span class="number">2018</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure><ul><li><code>Cache-Control:max-age</code>该字段是http1.1的规范，强缓存利用其<code>max-age</code>值来判断缓存资源的最大声明周期，它的值单位为秒。</li><li><code>private</code>：客户端可以缓存</li><li><code>public</code>：客户端和代理服务器都可以缓存</li><li><code>max-age=t</code>：缓存内容将在t秒后失效</li><li><code>no-cache</code>：需要使用协商缓存来验证缓存数据</li><li><code>no-store</code>：所有内容都不会缓存<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-control: max-age=<span class="number">30</span></span><br></pre></td></tr></table></figure></li></ul><div class="note warning flat"><p>强缓存表示在缓存存在的期间不需要请求，会返回状态码200<br><code>Expires</code>受限于本地时间，如果修改了本地时间，可能导致缓存失效。<br><code>Cache-Control:max-age</code>优先级高于<code>Expires</code></p></div><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><div class="note primary flat"><p>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回304<br>协商缓存也有两种方式：<code>Last-Modified</code>,<code>If-Modified-Since</code></p></div><ul><li><code>Last-Modified</code>值为资源最后更新时间。</li><li><code>If-Modified-Since</code>会将<code>Last-Modified</code>的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就把新的资源发送过来，否则命中协商缓存。<div class="note warning flat"><p>但是如果在本地打开缓存文件，就会造成<code>Last-Modified</code>被修改，所以http1.1出现了<code>ETag</code>和<code>If-None-Match</code></p></div></li><li><code>ETag</code>类似于文件指纹，表示资源的唯一性。</li><li><code>If-None-Match</code>会将当前的<code>Etag</code>发送给服务器，询问服务器该资源的<code>Etag</code>是否有变动，如果有变动则发送新的资源回来，如果没有修改则命中协商缓存。且注意<code>Etag</code>的优先级大于<code>Last-Modified</code></li></ul><h2 id="选择合适的缓存策略"><a href="#选择合适的缓存策略" class="headerlink" title="选择合适的缓存策略"></a>选择合适的缓存策略</h2><div class="note primary flat"><p>对于大部分场景可以使用强缓存配合协商缓存解决问题。但在一些特殊的情况下选择特殊的缓存策略更为重要。</p></div><ul><li>对于某些不需要缓存的资源，可以使用<code>Cache-control:no-store</code>表示该资源不需要缓存。</li><li>对于频繁变动的资源，可以使用<code>Cache-Control:no-cache</code>配合<code>Etag</code>使用，表示该资源已被缓存，但是每次都会发送请求询问该资源是否更新。</li><li>对于代码文件来说，通常使用<code>Cache-Control:max-age=31536000</code>并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会下载新的文件。</li></ul><h2 id="缓存新鲜度"><a href="#缓存新鲜度" class="headerlink" title="缓存新鲜度"></a>缓存新鲜度</h2><div class="note primary flat"><p>缓存新鲜度 = <code>max-age || (expires - date)</code></p></div><ul><li>date表示创建报文的时间，可以理解为服务器返回新资源的时间。</li><li>过期时间-创建时间就能计算缓存时间。默认转为秒</li></ul><h2 id="启发式缓存"><a href="#启发式缓存" class="headerlink" title="启发式缓存"></a>启发式缓存</h2><p>我们上述已经知道强缓存的新鲜度公式了，那么如果此时没有<code>max-age</code>,<code>expires</code>这两个关键字的时候，新鲜度怎么计算呢？<br>此时没有了强缓存的必要字段，但服务器还是会走强缓存<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date: Thu, 02 Sep 2021 13:28:56 GMT</span><br><span class="line">age: 10467792</span><br><span class="line">cache-control: public</span><br><span class="line">last-modified: Mon, 26 Apr 2021 09:56:06 GMT</span><br></pre></td></tr></table></figure><br>浏览器会触发启发式缓存，公式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缓存新鲜度 = max(<span class="number">0</span>,（date - last-modified)) * <span class="number">10</span>%</span><br></pre></td></tr></table></figure><br>根据响应报头中 date 与 last-modified 值之差与 0 取最大值后取其值的百分之十作为缓存时间。</p><h2 id="Last-Modified弊端"><a href="#Last-Modified弊端" class="headerlink" title="Last-Modified弊端"></a><code>Last-Modified</code>弊端</h2><div class="note primary flat"><p>它是一个时间，最小单位是秒，但如果资源修改得非常快，快到毫秒级别，那么服务器就无法识别，导致浏览器资源没有即使更新。<br>二 当服务器资源被修改了 但实质上的东西并没有改变 此时也会发送最新的<code>Last-Modified</code>，但我们不希望它这样做。<br>于是就产生了<code>Etag</code></p></div><h1 id="HTTP-缓存及缓存代理？"><a href="#HTTP-缓存及缓存代理？" class="headerlink" title="HTTP 缓存及缓存代理？"></a>HTTP 缓存及缓存代理？</h1><p>强缓存和协商缓存<br>首先通过 <code>Cache-Control</code> 验证强缓存是否可用<br>如果强缓存可用，直接使用<br>否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的<code>If-Modified-Since</code>或者<code>If-None-Matc</code>h这些条件请求字段检查资源是否更新<br>若资源更新，返回资源和200状态码<br>否则，返回304，告诉浏览器直接从缓存获取资源<br>这一节我们主要来说说另外一种缓存方式: 代理缓存。</p><h2 id="为什么产生代理缓存"><a href="#为什么产生代理缓存" class="headerlink" title="为什么产生代理缓存"></a>为什么产生代理缓存</h2><p>对于源服务器来说，他也是有缓存的，比如Redis，Memcache，但对于HTTP缓存来说，如果每次客户端缓存失效都要到源服务器获取，那么源服务器的压力是非常大的。<br>由此引入了缓存代理机制，让代理服务器承担一部分HTTP缓存，客户端缓存过期之后就到就近的代理服务器上面获取，代理缓存过期了才请求源服务器，这样流量巨大的时候才能明显降低源服务器的压力。<br>那缓存代理是如何做到的呢？<br>总的来说，代理缓存分为两个部分，一部分是源服务器端的控制，一部分是客户端的控制。</p><h2 id="源服务器的缓存控制"><a href="#源服务器的缓存控制" class="headerlink" title="源服务器的缓存控制"></a>源服务器的缓存控制</h2><h3 id="private和public"><a href="#private和public" class="headerlink" title="private和public"></a>private和public</h3><p>在源服务器的响应头中，在<code>Cache-Control</code>这个字段中可以加入private或者public是否允许代理服务器进行缓存，前者禁止，后者允许。<br>比如一些比较敏感的数据，就不要缓存到代理服务器了，这样别人访问代理服务器就能获取了，这部分就private设置。</p><h3 id="proxy-revalidate"><a href="#proxy-revalidate" class="headerlink" title="proxy-revalidate"></a>proxy-revalidate</h3><p><code>must-revalidate</code>的意思是客户端缓存过期就直接到源服务器获取，<code>proxy-revalidate</code>表示客户端缓存过期到代理服务器获取。</p><h3 id="s-maxage"><a href="#s-maxage" class="headerlink" title="s-maxage"></a>s-maxage</h3><p>s是share的意思，限制了缓存在代理服务器中可以存放多久，和限制客户端缓存时间的max-age并不冲突<br>eg<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public, max-age=<span class="number">1000</span>, s-maxage=<span class="number">2000</span></span><br></pre></td></tr></table></figure><br>这个响应是允许代理服务器缓存的，在本地缓存的时间是1000s，在代理服务器的缓存时间是2000s</p><h2 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h2><h3 id="max-stale和min-fresh"><a href="#max-stale和min-fresh" class="headerlink" title="max-stale和min-fresh"></a>max-stale和min-fresh</h3><p>在客户端的请求头中，可以加入这两个字段，来对代理服务器上的缓存进行宽容和限制操作。<br>比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max-stale = <span class="number">5</span></span><br></pre></td></tr></table></figure><br>表示客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也没关系，只要在过期的五秒内还是可以从代理缓存中获取的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min-fresh = <span class="number">5</span></span><br></pre></td></tr></table></figure><br>表示代理缓存需要一定的新鲜度，不要等缓存刚好过期才去拿，一定要在到期的前5s内拿，否则拿不到。</p><h3 id="only-if-cached"><a href="#only-if-cached" class="headerlink" title="only-if-cached"></a>only-if-cached</h3><p>这个字段加上后表示客户端只会接收代理缓存，而不会接收源服务器的缓存。如果代理缓存无效直接返回504（Gateway Timeout）</p><h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>回顾一下url的组成<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220412195102.png" alt=""><br>违背同源策略（协议scheme，主机host，端口port三者一致）即为跨域<br>非同源有以下限制：</p><ul><li>不能读取和修改对方的DOM</li><li>不能访问对方的Cookie，indexDB和LocalStorage</li><li>限制XMLHttpRequest请求。<br>当浏览器向目标URI发送AJAX请求的时候，如果当前URL和目标URL不同源，则产生跨域，这就是跨域请求。</li></ul><p>跨域请求的响应一般会被浏览器拦截，注意：是被浏览器拦截，响应其实是已经发送到客户端了，那么这个拦截是如何发生的呢？</p><p>首先要知道浏览器是多进程的，以Chrome为例子，进程组成如下：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220412195516.png" alt=""><br>以下内容是CV<br>WebKit 渲染引擎和V8 引擎都在渲染进程当中。<br>当<code>xhr.send</code>被调用，即<code>Ajax</code>请求准备发送的时候，其实还只是在渲染进程的处理。为了防止黑客通过脚本触碰到系统资源，浏览器将每一个渲染进程装进了沙箱，并且为了防止 CPU 芯片一直存在的Spectre 和 Meltdown漏洞，采取了站点隔离的手段，给每一个不同的站点(一级域名不同)分配了沙箱，互不干扰。具体见YouTube上Chromium安全团队的演讲视频。<br>在沙箱当中的渲染进程是没有办法发送网络请求的，那怎么办？只能通过网络进程来发送。那这样就涉及到进程间通信(IPC，Inter Process Communication)了。接下来我们看看 chromium 当中进程间通信是如何完成的，在 chromium 源码中调用顺序如下:<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220412195744.png" alt=""><br>可能看了你会比较懵，如果想深入了解可以去看看 <code>chromiu</code> 最新的源代码，<code>IPC</code>源码地址及<code>Chromium IPC</code>源码解析文章。<br>总的来说就是利用<code>Unix Domain Socket</code>套接字，配合事件驱动的高性能网络并发库<code>libevent</code>完成进程的 IPC 过程。<br>好，现在数据传递给了浏览器主进程，主进程接收到后，才真正地发出相应的网络请求。<br>在服务端处理完数据后，将响应返回，主进程检查到跨域，且没有cors(后面会详细说)响应头，将响应体全部丢掉，并不会发送给渲染进程。这就达到了拦截数据的目的。<br>接下来我们来说一说解决跨域问题的几种方案。</p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS是W3C规定的一个标准，全称是跨域资源共享，他需要浏览器和服务器的共同支持，具体来说，非 IE 和 IE10 以上支持CORS，服务器需要附加特定的响应头，后面具体拆解。不过在弄清楚 CORS 的原理之前，我们需要清楚两个概念: 简单请求和非简单请求。</p><p>浏览器根据请求方法和请求头的特定字段，将请求做了个分类，具体来说规则是这样的，凡是满足以下条件的为简单请求：</p><ul><li>请求方法为GET POST 或者HEAD</li><li>请求头的取值范围为：Accept，Accept-Language，Content-Language，Content-Type（仅限三个值：<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>）<br>除此之外的就是非简单请求.<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><div class="note primary flat"><p>请求发出去之前，浏览器在做什么？</p></div>他会自动在请求头中，添加一个Origin字段，用来说明请求来自哪个源。服务器拿到请求之后，在回应时对应的添加<code>Access-Control-Allow-Origin</code>字段，如果Origin不在这个字段的范围内，浏览器就会将响应拦截。<br>因此<code>Access-Control-Allow-Origin</code>字段是服务器用来决定浏览器是否拦截这个响应，这是必须的字段。与此同时，其他一些可选的功能性字段，用来描述如果不会被拦截，这些字段将发挥各自的作用。</li></ul><p><code>Access-Control-Allow-Credentials</code>这个字段是一个布尔值，表示是否允许发送Cookie，对于跨域请求，浏览器对这个字段的默认值设为false，而如果需要拿到浏览器的Cookie，需要添加这个响应头并且设置为true，并且前端也需要设置<code>withCredentials</code>属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><br><code>Access-Control-Expose-Headers</code>这个字段是给XMLHttpRequest对象赋能，让它不仅能拿到基本的六个响应头字段，包括<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>和<code>Pragma</code>）, 还能拿到这个字段声明的响应头字段。比如这样设置:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Expose-Headers: aaa</span><br></pre></td></tr></table></figure><br>那么前端就能通过<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest.getResponseHeader(<span class="string">&#x27;aaa&#x27;</span>) </span><br></pre></td></tr></table></figure><br>拿到该字段的值。</p><h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>非简单请求相对而言会有些不同，体现在两个方面，预检请求和响应字段。<br>以PUT方法为例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://xxx.com&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;PUT&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;X-Custom-Header&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><br>当这段代码执行的时候会发送预检请求，这个预检请求的请求行和请求体如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS / HTTP/<span class="number">1.1</span></span><br><span class="line"><span class="attr">Origin</span>: 当前地址</span><br><span class="line"><span class="attr">Host</span>: xxx.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br></pre></td></tr></table></figure><br>预检请求的方法是OPTIONS，同时会加上Origin源地址和Host目标地址，这很简单。同时也会加上两个关键的字段:</p><ul><li>Access-Control-Request-Method, 列出 CORS 请求用到哪个HTTP方法</li><li><p>Access-Control-Request-Headers，指定 CORS 请求将要加上什么请求头<br>这是预检请求。接下来是响应字段，响应字段也分为两部分，一部分是对于预检请求的响应，一部分是对于 CORS 请求的响应。<br>预检请求的响应。如下面的格式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Max-Age: <span class="number">1728000</span></span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>其中有这样几个关键的响应头字段:</p></li><li><p>Access-Control-Allow-Origin: 表示可以允许请求的源，可以填具体的源名，也可以填*表示允许任意源请求。</p></li><li>Access-Control-Allow-Methods: 表示允许的请求方法列表。</li><li>Access-Control-Allow-Credentials: 简单请求中已经介绍。</li><li>Access-Control-Allow-Headers: 表示允许发送的请求头字段</li><li>Access-Control-Max-Age: 预检请求的有效期，在此期间，不用发出另外一条预检请求。</li></ul><p>在预检请求的响应返回后，如果请求不满足响应头的条件，则触发XMLHttpRequest的onerror方法，当然后面真正的CORS请求也不会发出去了。<br>CORS 请求的响应。绕了这么一大转，到了真正的 CORS 请求就容易多了，现在它和简单请求的情况是一样的。浏览器自动加上Origin字段，服务端响应头返回Access-Control-Allow-Origin。可以参考以上简单请求部分的内容。</p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>虽然XMLHttpRequest对象遵循同源政策，但是script标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。这也就是 JSONP 的原理，接下来我们就来封装一个 JSONP:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsonp = <span class="function">(<span class="params">&#123; url, params, callbackName &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> generateURL = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dataStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      dataStr += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>&amp;`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dataStr += <span class="string">`callback=<span class="subst">$&#123;callbackName&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;dataStr&#125;</span>`</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化回调函数名称</span></span><br><span class="line">    callbackName = callbackName || <span class="built_in">Math</span>.random().toString.replace(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;&#x27;</span>); </span><br><span class="line">    <span class="comment">// 创建 script 元素并加入到当前文档中</span></span><br><span class="line">    <span class="keyword">let</span> scriptEle = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    scriptEle.src = generateURL();</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(scriptEle);</span><br><span class="line">    <span class="comment">// 绑定到 window 上，为了后面调用</span></span><br><span class="line">    <span class="built_in">window</span>[callbackName] = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(data);</span><br><span class="line">      <span class="comment">// script 执行完了，成为无用元素，需要清除</span></span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(scriptEle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当然在服务端也会有响应的操作, 以 express 为例:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; a, b, callback &#125; = req.query</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line">  <span class="comment">// 注意哦，返回给script标签，浏览器直接把这部分字符串执行</span></span><br><span class="line">  res.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;数据包&#x27;)`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><br>前端这样简单地调用一下就好了:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jsonp(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123; </span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 拿到数据进行处理</span></span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// 数据包</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>和CORS相比，JSONP 最大的优势在于兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。</p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx是一种高效的反向代理服务器，可以用来轻松解决跨域问题。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220412223038.png" alt=""><br>下面关于正向代理和反向代理的区别<br>正向代理：帮助客户端访问自己访问不到的服务器，然后将结果返回给客户端。<br>反向代理：拿到客户端的请求，将请求转发给其他服务器，主要的场景是维持服务器集群的负载均衡，换句话说，反向代理帮其他服务器拿到请求，然后选择一个合适的服务器转发给他。<br>因此两者的区别就很明显了，正向代理是帮客户端做事情，反向代理是帮其他服务器做事情。<br>那么Nginx是如何解决跨域的呢？<br>比如说现在客户端的域名为<code>client.com</code>，服务器的域名为<code>server.com</code>，客户端向服务器发送 Ajax 请求，当然会跨域了，那这个时候让 Nginx 登场了，通过下面这个配置:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen  <span class="number">80</span>;</span><br><span class="line">  server_name  client.com;</span><br><span class="line">  location /api &#123;</span><br><span class="line">    proxy_pass server.com;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Nginx 相当于起了一个跳板机，这个跳板机的域名也是<code>client.com</code>，让客户端首先访问 <code>client.com/api</code>，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给<code>server.com</code>，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。<br>其实还有一些不太常用的方式，大家了解即可，比如<code>postMessage</code>，当然<code>WebSocket</code>也是一种方式，但是已经不属于 HTTP 的范畴，另外一些奇技淫巧就不建议大家去死记硬背了，一方面从来不用，名字都难得记住，另一方面临时背下来，面试官也不会对你印象加分，因为看得出来是背的。当然没有背并不代表减分，把跨域原理和前面三种主要的跨域方式理解清楚，经得起更深一步的推敲，反而会让别人觉得你是一个靠谱的人。</p><h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><h2 id="和http的区别："><a href="#和http的区别：" class="headerlink" title="和http的区别："></a>和http的区别：</h2><div class="note primary flat"><ol><li>https协议需要ca证书 费用比较高</li><li>http的信息是明文传输，https是经过ssl协议加密传输的</li><li>端口不同 一般来讲http是80端口 https是443端口</li></ol></div><h2 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h2><div class="note primary flat"><p>通信不容易收到拦截，ssl是tls的前身，现在绝大部分的浏览器不支持ssl而是支持tls，但是ssl的名气很大，所以人们经常会说ssl。</p></div><p>SSL安全套接层(Secure Socket Layer),在OSI七层模型中处于会话层(第五层)。之前SSL出过三个大版本，当他发展到第三个大版本的时候才被标准化，成为TLS(传输层安全，Transport Layer Security)并被当作TLS1.0版本，准确的说TLS1.0 = SSL3.1</p><p>现在的主流版本是TLS/1.2,之前的TLS1.0，1.1都被认为是不安全的，在不久的将来会被完全淘汰，因此我们下面要讨论的是TLS/1.2</p><h3 id="传统RSA握手"><a href="#传统RSA握手" class="headerlink" title="传统RSA握手"></a>传统RSA握手</h3><h3 id="TLS1-2握手"><a href="#TLS1-2握手" class="headerlink" title="TLS1.2握手"></a>TLS1.2握手</h3><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413091420.png" alt=""></p><h4 id="step1：Client-Hello"><a href="#step1：Client-Hello" class="headerlink" title="step1：Client Hello"></a>step1：Client Hello</h4><p>首先浏览器发送client_random,TLS版本，加密套件列表。</p><p>client_random是什么？用来形成最终secret的一个参数</p><p>加密套件列表是什么？eg<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TLS_ECDHE_WITH_AES_128_GCM_SHA256</span><br></pre></td></tr></table></figure></p><p>意思是在TLS握手的过程中，使用ECDHE算法pre_random,128位的AES算法进行对称加密，在对称加密的过程中使用主流的GCM分组模式，因为对称加密中很重要的一个问题就是如何分组，最后一个是采用哈希摘要算法，采用SHA256算法。</p><p>其中值得解释的是这个哈希摘要算法，试想一下这个场景，服务端现在给客户端发信息来了，而客户端不知道此时的消息是服务端的还是中间人的，现在引入这个哈希摘要算法，将服务端的证书信息通过这个算法生成一个摘要，用来标识这个服务器的身份，然后用CA私钥加密后把加密后的标识和CA公钥发给客户端。客户端拿到这个CA公钥来解密，生成另外一份摘要。两个摘要进行对比，如果相同则能确认服务器的身份。这也就是所谓数字签名的原理。其中除了哈希摘要算法，最重要的是私钥加密，公钥解密。</p><h4 id="step2-Server-Hello"><a href="#step2-Server-Hello" class="headerlink" title="step2 Server Hello"></a>step2 Server Hello</h4><p>server_random发送这个随机数，确认TLS版本，需要使用的加密套件和自己的证书，那么这个server_params是做什么的呢？</p><h4 id="step3-Client验证证书，生成secret"><a href="#step3-Client验证证书，生成secret" class="headerlink" title="step3 Client验证证书，生成secret"></a>step3 Client验证证书，生成secret</h4><p>客户端验证服务器传过来的证书和签名是否通过，如果验证通过，则将client_params传递给服务器。</p><p>接着客户端通过ECDHE算法计算出了pre_random,其中传入两个参数：server_params和client_params。现在你应该清楚这两个参数的作用了吧，由于ECDHE算法是基于椭圆曲线离散对数，这两个参数也称作椭圆曲线的公钥。</p><p>客户端现在拥有了client_random,server_random和pre_random,接下来这三个数通过一个伪随机数函数计算出最终的secret</p><h4 id="step4-Server生成secret"><a href="#step4-Server生成secret" class="headerlink" title="step4 Server生成secret"></a>step4 Server生成secret</h4><p>客户端传了client_params过来了，服务端开始用ECDHE算法生成pre_random,接着用和客户端同样的伪随机函数生成最后的secret</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><div class="note primary flat"><p>TLS握手实际上是一个双向认证的过程，从step1可以看出客户端有能力验证服务器的身份（数字签名），那么服务器能不能验证客户端的身份呢？</p></div><p>当然是可以的。具体来说，在step3中，客户端发送client_params,实际上是给服务器一个验证消息，让服务器走相同的流程（哈希摘要，私钥加密，公钥解密），确认客户端的身份</p><div class="note primary flat"><p>在客户端生成secret后，会给服务器发送一个收尾的信息，告诉服务器之后都要用对称加密，对称加密的算法就是用第一次约定的，服务器生成完secret后也会向客户端发送一个收尾信息，告诉客户端以后用对称加密来通信。</p></div><p>这个收尾信息包括两个部分，一部分是<code>Change Cipher Spec</code>,意味着后面加密传输了，另外一个是Finished消息，这个消息是对之前发送的所有数据做的摘要，对摘要进行加密，让对方验证一下。</p><p>当双方都验证通过之后，握手才正式结束，后面的HTTP正式开始传输加密报文。</p><h4 id="RSA和ECDHE有什么区别？"><a href="#RSA和ECDHE有什么区别？" class="headerlink" title="RSA和ECDHE有什么区别？"></a>RSA和ECDHE有什么区别？</h4><ol><li>ECDHE握手，也就是主流的TLS1.2握手，使用ECHDE算法实现pre_random的加密解密，没有用到RSA</li><li>使用ECDHE还有一个特点，就是客户端发送完收尾信息后可以提前抢跑，直接发送HTTP报文，节省一个RTT，不必等到收尾信息到到服务器，然后等服务器返回收尾信息告诉自己，直接开始发送请求，这也叫TLS False Start<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3>数字签名是公钥加一些个人信息用哈希算法生成摘要之后，再用私钥加密生成的东西。<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3>数字证书应用了数字签名的技术，将个人信息和公钥用哈希算法生成摘要之后，再用CA的私钥加密，这整个就是数字证书。<h3 id="TLS1-3做了什么改进？"><a href="#TLS1-3做了什么改进？" class="headerlink" title="TLS1.3做了什么改进？"></a>TLS1.3做了什么改进？</h3>TLS 1.2 虽然存在了 10 多年，经历了无数的考验，但历史的车轮总是不断向前的，为了获得更强的安全、更优秀的性能，在2018年就推出了 TLS1.3，对于TLS1.2做了一系列的改进，主要分为这几个部分:强化安全、提高性能。</li></ol><h4 id="强化安全"><a href="#强化安全" class="headerlink" title="强化安全"></a>强化安全</h4><p>TLS1.3废除了很多加密算法，最后只保留了五个加密套件。</p><ul><li>TLS_AES_128_GCM_SHA256</li><li>TLS_AES_256_GCM_SHA384</li><li>TLS_CHACHA20_POLY1305_SHA256</li><li>TLS_AES_128_GCM_SHA256</li><li>TLS_AES_128_GCM_8_SHA256</li></ul><p>可以看到，最后剩下的对称加密算法是AES和CHACHA20，之前主流的也会这两种。分组模式也只剩GCM和POLY1305，哈希摘要算法只剩下SHA256和SHA384了</p><p>那你可能会问了，之前RSA这么重要的非对称加密算法怎么不在了？</p><p>两方面原因：</p><ol><li>2015年发现了FREAK攻击，就是说有人发现了RSA漏洞，能够进行破解了。</li><li>一旦私钥泄漏，那么中间人可以通过私钥计算出之前所有的报文secret，破解之前所有的密文。</li></ol><p>为什么？回到RSA握手的过程中，客户端拿到服务器的证书后，提取出服务器的公钥，然后生成pre_random并用公钥加密传送给服务器，服务器通过私钥解密，从而拿到真实的pre_random。当中间人拿到了服务器的私钥，并且截获之前的所有报文的时候， 那么就能拿到pre_random,server_random和client_random并根据对应的随机数函数生成secret，也就是拿到了TLS的最终会话密钥，每一个历史报文都能通过这样的方式破解。</p><p>但ECDHE在每次握手的时候都生成临时性的密钥对，即使私钥被破解，之前的历史信息也不会收到影响。这种一次性破解并不影响历史信息的性质也叫前向安全性</p><p>RSA算法不具备前向安全性，所以被ECDHE取代了。</p><h4 id="提升性能"><a href="#提升性能" class="headerlink" title="提升性能"></a>提升性能</h4><h5 id="握手改进"><a href="#握手改进" class="headerlink" title="握手改进"></a>握手改进</h5><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413095834.png" alt=""><br>大体上看和TLS1.2差不多，不过和TLS1.2相比少了一个RTT，服务器不需要在等待对方证书验证完毕之后再拿到client_params,而是直接在第一次握手的时候就能拿到，拿到之后立刻计算出secret，节省了之前不必要的等待时间。同时也意味着第一次握手的时候客户端需要传送更多的消息，一口气传完。</p><p>这种TLS1.3的握手方式也被称为1-RTT握手，但其实这种握手方式还是有一定的优化空间的，接下里介绍这种优化方式。</p><h5 id="会话复用"><a href="#会话复用" class="headerlink" title="会话复用"></a>会话复用</h5><div class="note primary flat"><p>会话复用有两种方式：Session ID和Session Ticket</p></div><p>先说说最早出现的Session ID，具体做法是客户端和服务端连接的时候会保存各自的会话ID，并存储会话密钥，当再次连接的时候，客户端发送ID过来，服务器查找这个ID是否存在，如果找到了就直接复用之前的会话状态，会话密钥就不用重新生成，直接用原来的那个部分。</p><p>但这个方式也存在一定的弊端，就是当客户端数量庞大的时候，对服务端的存储压力非常大。</p><p>因此出现了第二种方式—Session Ticket，服务端压力大那就给客户端保存呗。具体来说，双方连接成功后，服务器加密会话信息，用Session Ticket消息发送给客户端，让客户端保存下来。下次重连的时候，就把这个ticket进行解密，验证它有没有过期，如果没过期就恢复之前的会话状态。</p><p>这种方式虽然减小了服务器的压力，但是带来了安全问题，即每次用一个固定的密钥来解密ticket数据，一旦黑客拿到这个密钥，之前所有的历史记录也会被破解了。因此为了避免这样的问题，密钥需要定期更换。</p><p>总的来说，这些会话复用的技术在保证1-RTT的时候，也节省了生成会话密钥这些算法所消耗的时间，是一笔客观的性能提升。</p><h5 id="PSK"><a href="#PSK" class="headerlink" title="PSK"></a>PSK</h5><p>刚刚说的是1-RTT的情况，能不能优化到0-RTT呢？</p><p>答案是可以的，方法也很简单，在发送Session Ticket的同时带上数据，不用等服务器确认，这种方式被称为<code>Pre-Shared Key</code>即PSK。</p><p>这种方法虽然方便，但是也带来了安全问题，中间人截获PSK数据，不断向服务器重复发，类似于TCP第一次握手携带数据，增加了服务器被攻击的风险。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>TLS1.3在1.2的基础上废除了大量的算法，提升了安全性，同时利用会话复用节省了重新生成密钥的时间，利用PSK做到了0-RTT连接。</p><h2 id="客户端是如何对比数字签名？"><a href="#客户端是如何对比数字签名？" class="headerlink" title="客户端是如何对比数字签名？"></a>客户端是如何对比数字签名？</h2><ul><li>浏览器会安装一些比较权威的第三方认证机构的公钥，比如VeriSign、Symantec以及GlobalSign等等</li><li>验证数字签名的时候，直接从本地拿到第三方公钥，对私钥加密后的数字签名进行解密得到真正的签名。</li><li>然后客户端利用签名生成规则进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。</li></ul><h2 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h2><div class="note primary flat"><p>https就是利用上面的对称加密和非对称加密进行一个混合加密。兼顾了对称加密传输快和非对称消耗资源大的问题。</p></div><h2 id="如何把http请求换成https"><a href="#如何把http请求换成https" class="headerlink" title="如何把http请求换成https"></a>如何把http请求换成https</h2><div class="note primary flat"><p>用axios进行封装的时候域名最好也定义一个baseURL 方便在后面将它改为https的的请求<br>or<br>使用meta标签 </p></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span> =<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;upgrade-insecure-requests&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="为什么说HTTPS比HTTP安全呢"><a href="#为什么说HTTPS比HTTP安全呢" class="headerlink" title="为什么说HTTPS比HTTP安全呢"></a>为什么说HTTPS比HTTP安全呢</h2><ul><li>通过混合加密保证传输的数据不被窃听</li><li>通过数字签名的方式保证数据不会被篡改</li><li>通过数字证书保证服务器身份的真实性</li></ul><h2 id="什么是中间人攻击？"><a href="#什么是中间人攻击？" class="headerlink" title="什么是中间人攻击？"></a>什么是中间人攻击？</h2><p>中间人攻击(Man-in-the-MiddleAttack，简称“MITM攻击”)是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方 直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻 击中，攻击者可以拦截通讯双方的通话并插入新的内容。中间人攻击是一个(缺乏)相互认证的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，SSL协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信 任的数字证书认证机构颁发，并且能执行双向身份认证。<br>中间人攻击过程 1客户端发送请求到服务端，请求被中间人截获。<br>2)服务器向客户端发送公钥。<br>3)中间人截获公钥，保留在自己手上。然后自己生成一个【伪 造的】公钥，发给客户端。<br>4)客户端收到伪造的公钥后，生成加密hash值发给服务器。<br>5)中间人获得加密hash值，用自己的私钥解密获得真秘钥。同时生成假的加密hash值，发给服务器。<br>6 ) 服务器用私钥解密获得假密钥。然后加密数据传输给客户端。</p><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="计算机网络" scheme="https://zlinni.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP" scheme="https://zlinni.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>FooTok项目杂谈</title>
    <link href="https://zlinni.github.io/posts/92dd6276498c/"/>
    <id>https://zlinni.github.io/posts/92dd6276498c/</id>
    <published>2022-03-24T14:33:23.000Z</published>
    <updated>2022-03-28T11:40:07.365Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>老项目新谈，用vue3重构ing</p></div><h1 id="主题演示"><a href="#主题演示" class="headerlink" title="主题演示"></a>主题演示</h1><p>待填充…</p><h1 id="构建工具-技术栈"><a href="#构建工具-技术栈" class="headerlink" title="构建工具+技术栈"></a>构建工具+技术栈</h1><p>编译软件：vscode<br>开发框架: vue3<br>打包工具：vite<br>UI：element-plus<br>icon：阿里巴巴<br>其他：pinia， vue-router，git<br>插件：pubsub，nanoid，less-loader<br>后端： nodejs，mysql</p><h1 id="part0-路由-amp-pinia"><a href="#part0-路由-amp-pinia" class="headerlink" title="part0 路由&amp;pinia"></a>part0 路由&amp;pinia</h1><p>定义路由，以及重定向。<br>当时在router里面把路径写错了导致页面跳转问题出现。！！！<br>vue3的路由写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    createRouter,</span><br><span class="line">    createWebHashHistory</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"><span class="keyword">const</span> routes = [&#123;</span><br><span class="line">xxxx</span><br><span class="line">&#125;]</span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">    <span class="attr">history</span>: createWebHashHistory(),</span><br><span class="line">    routes,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><br>pinia写法</p><h1 id="part1-mainFrame"><a href="#part1-mainFrame" class="headerlink" title="part1 mainFrame"></a>part1 mainFrame</h1><div class="tip "><p>这个部分是关于整个页面框架的</p></div><h2 id="element-plus"><a href="#element-plus" class="headerlink" title="element-plus"></a>element-plus</h2><p>全局引入和按需引入，没什么好说的。注意的是官网的例子部分是ts，不太友好。</p><h2 id="农历的类"><a href="#农历的类" class="headerlink" title="农历的类"></a>农历的类</h2><p>使用到了一个可以返回农历值的方法，将他封装了起来，放进了plugins。最后暴露方法出来。</p><h2 id="css变量"><a href="#css变量" class="headerlink" title="css变量"></a>css变量</h2><p>这次使用了css变量来定义全部的颜色变量，方便后期修改<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220324225112.png" alt=""><br>注意使用css变量的框架不要设置<code>style:scoped</code>否则后面的读不出来数据。</p><h1 id="part2-login"><a href="#part2-login" class="headerlink" title="part2 login"></a>part2 login</h1><div class="tip "><p>这个部分是关于login页面的</p></div><p>还待解决的问题：分辨率不同footok的标题向下位置不同<br>注意router的引入<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRoute, useRouter &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br></pre></td></tr></table></figure></p><h2 id="注册的判断"><a href="#注册的判断" class="headerlink" title="注册的判断"></a>注册的判断</h2><p>关于id的正则表达式：<code>/^[a-zA-Z0-9_-]&#123;4,16&#125;$/</code>（只支持字母，数字，下划线，减号）<br>关于密码的正则：<code>/^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z]).*$/</code>（最少六位加大小写），并且注意不能空密码空账号<br>注意watch方法中，reactive的变量检测使用<code>()=&gt;obj.xxx</code><br>例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">watch(</span><br><span class="line">  <span class="function">() =&gt;</span> userData.password,</span><br><span class="line">  <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> patt = <span class="regexp">/^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z]).*$/</span>;</span><br><span class="line">    <span class="keyword">if</span> (!patt.test(newValue)) &#123;</span><br><span class="line">      passwordTips.value = <span class="string">&quot;您的密码强度不够&quot;</span>;</span><br><span class="line">      isSuccess.passWordSuccess = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      passwordTips.value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      isSuccess.passWordSuccess = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h2 id="登陆和注册以及axios"><a href="#登陆和注册以及axios" class="headerlink" title="登陆和注册以及axios"></a>登陆和注册以及axios</h2><p>发送：注意发送的时候不要发响应式的对象，因为后端不需要你的响应式对象，它需要一个普通对象，所以可以使用toRaw将你的数据变成普通对象之后发送。<br>接收：axios的问题是要知道code和数据来自哪里。这里发现后端发来的数据中，code来自data</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">  .post(<span class="string">&quot;http://localhost:3000/api/register&quot;</span>, rawData)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.data.code === <span class="number">200</span>) &#123;</span><br><span class="line">      sessionStorage.setItem(<span class="string">&quot;sid&quot;</span>, res.data.data.user.id);</span><br><span class="line">      router.push(&#123; <span class="attr">name</span>: <span class="string">&quot;index&quot;</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    userNameTips.value = <span class="string">&quot;用户名已存在&quot;</span>;</span><br><span class="line">    isSuccess.userNameSuccess = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>注册逻辑：200则注册成功，在session里面放sid，这样router里面就能放行，并且跳转。如果异常则是用户名已存在。（网络异常的判断？）<br>登陆逻辑：200登陆成功，否则用户名存在。<br>（登陆的优化？安全？token？jwt？）</p><h1 id="part3-indexAside"><a href="#part3-indexAside" class="headerlink" title="part3 indexAside"></a>part3 indexAside</h1><div class="tip "><p>这个部分是关于两侧aside页面的</p></div><p>用到了视口单位进行了响应式。</p><h1 id="part4-foodSwiper"><a href="#part4-foodSwiper" class="headerlink" title="part4 foodSwiper"></a>part4 foodSwiper</h1><div class="tip "><p>这个部分是关于轮播图页面的</p></div><p>三个需求</p><ol><li>展示轮播图片 五个一循环 点击换一些 再切换五个<br>目前还没解决的问题是 根据用户请求 </li><li>点赞功能</li><li>收藏功能</li></ol><h2 id="轮播图片"><a href="#轮播图片" class="headerlink" title="轮播图片"></a>轮播图片</h2><p>采用的element的走马灯并进行了魔改。具体魔改的是下方的指示灯<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220325200931.png" alt=""><br>遇到的问题：</p><ol><li>axios请求图片之后需要滑动走马灯才显示的问题<br>原因：没有设置渲染条件，走马灯没读到数据。<br>解决方法：<code>v-if</code>数据的长度，有数据就显示</li><li>点击换一些过一会屏幕空白<br>原因：没有初始化数据数组长度<br>解决方法：先初始化再赋值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getfood = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  foodMsgObj.foodMsg = [];</span><br><span class="line">  axiosFoodMsg()</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      foodMsgObj.foodMsg = res;</span><br><span class="line">    &#125;) <span class="comment">//初始化走马灯文字</span></span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;el-carousel__button&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; btn.length; i++) &#123;</span><br><span class="line">        btn[i].innerText = wordObj[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>魔改的指示灯不显示<br>原因：赋值完dom还没有渲染完，所以魔改的灯没有值。<br>解决方法：如上，使用异步。</li><li>魔改的指示灯背景色 这个是css问题 已经解决。<br>亮点：封装了axios方法到hook，方便后面请求使用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">let</span> idObj =&#123;</span><br><span class="line">        <span class="attr">id</span>:<span class="built_in">parseInt</span>(sessionStorage.getItem(<span class="string">&#x27;sid&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> axios.post(<span class="string">&quot;/api/swiper&quot;</span>,idObj).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// if(res.status ===200)&#123;</span></span><br><span class="line">        <span class="comment">//     arr = res.data;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (res.data.code === <span class="number">200</span>) &#123;</span><br><span class="line">            arr = res.data.data.records;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(arr);</span><br><span class="line">    &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>axios注意事项：</p></div></li><li>注意res的data和data里面的data问题。</li><li>注意return，它返回的是一个<code>promise</code>对象，解析<code>promise</code>对象需要使用then方法<h2 id="点赞功能"><a href="#点赞功能" class="headerlink" title="点赞功能"></a>点赞功能</h2><div class="note primary flat"><p>性能优化：防抖后确认和第一次的状态不一致才发送请求改变状态</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> updateLikeTime = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> likeInit;</span><br><span class="line"><span class="keyword">var</span> zan = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = foodMsgObj.foodMsg.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.id === id;</span><br><span class="line">  &#125;)[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">//如果是第一次 那么记录初始点赞状态</span></span><br><span class="line">  <span class="keyword">if</span> (!arr.zanfirstClick) &#123;</span><br><span class="line">    likeInit = arr.islike;</span><br><span class="line">    arr.zanfirstClick = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//点赞和取消点赞</span></span><br><span class="line">  <span class="keyword">if</span> (!arr.islike) &#123;</span><br><span class="line">    arr.likenum++;</span><br><span class="line">    arr.islike = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(updateLikeTime);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    arr.likenum--;</span><br><span class="line">    arr.islike = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(updateLikeTime);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果最后一次操作和初始状态不一样 才设置定时器发送请求</span></span><br><span class="line">  <span class="keyword">if</span> (likeInit !== arr.islike) &#123;</span><br><span class="line">    updateLikeTime = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> updateData = &#123;</span><br><span class="line">        <span class="attr">userid</span>: sessionStorage.getItem(<span class="string">&quot;sid&quot;</span>),</span><br><span class="line">        <span class="attr">id</span>: id,</span><br><span class="line">        <span class="attr">islike</span>: arr.islike,</span><br><span class="line">      &#125;;</span><br><span class="line">      axios.post(<span class="string">&quot;/api/updatelike&quot;</span>, updateData).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">        <span class="keyword">if</span> (res.status === <span class="number">200</span>) &#123;</span><br><span class="line">          arr.zanfirstClick = <span class="literal">false</span>;</span><br><span class="line">          <span class="built_in">console</span>.log(id,<span class="string">&quot;点赞转换成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="收藏功能"><a href="#收藏功能" class="headerlink" title="收藏功能"></a>收藏功能</h2>同上 逻辑类似不赘述<h1 id="part5-foodMap"><a href="#part5-foodMap" class="headerlink" title="part5 foodMap"></a>part5 foodMap</h1><div class="tip "><p>这个部分是关于美食地图的</p></div>需求如下：</li><li>热点地图 点击切换区域</li><li>axios请求后显示相应的收录数，收录排行前二的数据</li><li>点击数据 跳转对应的详情页（产生通用接口传id查sql跳转）</li><li>查看所有直接跳转美食目录<h2 id="热点地图"><a href="#热点地图" class="headerlink" title="热点地图"></a>热点地图</h2>这个玩意当时纠结了很久，怎么点击一个地图的热点区域并高亮该区域<br>目前知道的方法就是map标签，里面添加area标签以及poly属性处理多边形。前提还要和图片进行一个绑定。原理是通过点击热点区域动态改变图片src<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//代码太长删掉了一部分 值得一提的是usemap和map中的id绑定，但此时只有写name即可视为绑定。</span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;mainMap&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">usemap</span>=<span class="string">&quot;#map&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mainmap&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">area</span></span></span><br><span class="line"><span class="tag">          <span class="attr">shape</span>=<span class="string">&quot;poly&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:coords</span>=<span class="string">&quot;huanan1&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;huanan&quot;</span></span></span><br><span class="line"><span class="tag">          @<span class="attr">click.native</span>=<span class="string">&quot;changeMap&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">area</span></span></span><br><span class="line"><span class="tag">          <span class="attr">shape</span>=<span class="string">&quot;poly&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:coords</span>=<span class="string">&quot;huanan2&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;huanan&quot;</span></span></span><br><span class="line"><span class="tag">          @<span class="attr">click.native</span>=<span class="string">&quot;changeMap&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure>写到这你以为很简单？看到上面的coords属性了吗，这个是坐标的区域，也就意味着每个多边形的坐标都需要知道，以至于…<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220326144056.png" alt=""><br>这只是一部分，后面的坐标还有很多。是通过ps的方式找坐标的，也就意味着要一个一个点打…</li></ol><h2 id="交互部分"><a href="#交互部分" class="headerlink" title="交互部分"></a>交互部分</h2><p>剩下的功能倒不是很难实现，也没什么值得一提的地方，除了后端这个数据<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220326144306.png" alt=""><br>前端就只能慢慢的解构赋值了</p><h2 id="热点地图自适应（已解决）"><a href="#热点地图自适应（已解决）" class="headerlink" title="热点地图自适应（已解决）"></a>热点地图自适应（已解决）</h2><p>原先问题：没有办法解决当缩放的时候，失去热点区域的问题，因为图片被缩放了，但是热点区域没有发生改变，原来的坐标还是在屏幕对应的位置 所以会出错。<br>解决方法：先记录图片初始化的大小，x坐标乘现在宽/初始宽的比例，y坐标乘现在高/初始高的比例，得到缩放后的比例。<br>过程中遇到的问题和注意事项：</p><ol><li>坐标是字符串 转数组才能操作 操作完要转回字符串。</li><li>需要暴露两个obj 一个是初始坐标obj，另外一个暴露的obj会变成响应式后面使用。如果只暴露一个，那么响应式的就算暂存了地址中的数据也会发生变化。</li><li>替换坐标的时候，不能采用<code>obj = function返回的obj</code>这样的形式，会丢失响应式。建议直接<code>obj.xx = xxfunction(xx)...</code>这样的形式保证不会出错。</li><li>缩放设置定时器避免重复计算。<br>上代码<br>hook里面的<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> coordsObj = &#123;</span><br><span class="line">    <span class="attr">huanan1</span>: huanan1,</span><br><span class="line">    <span class="attr">huanan2</span>: huanan2,</span><br><span class="line">    <span class="attr">huanan3</span>: huanan3,</span><br><span class="line">    <span class="attr">huabei</span>: huabei,</span><br><span class="line">    <span class="attr">huazhong</span>: huazhong,</span><br><span class="line">    <span class="attr">huadong</span>: huadong,</span><br><span class="line">    <span class="attr">xibu</span>: xibu</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> initCoords = &#123;</span><br><span class="line">    <span class="attr">huanan1</span>: huanan1,</span><br><span class="line">    <span class="attr">huanan2</span>: huanan2,</span><br><span class="line">    <span class="attr">huanan3</span>: huanan3,</span><br><span class="line">    <span class="attr">huabei</span>: huabei,</span><br><span class="line">    <span class="attr">huazhong</span>: huazhong,</span><br><span class="line">    <span class="attr">huadong</span>: huadong,</span><br><span class="line">    <span class="attr">xibu</span>: xibu</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCoords</span>(<span class="params">arr, w, h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> img = <span class="built_in">document</span>.getElementById(<span class="string">&quot;mainmap&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> newWidth = img.width;</span><br><span class="line">    <span class="keyword">let</span> newHeight = img.height;</span><br><span class="line">    <span class="keyword">let</span> widthpercent = newWidth / w;</span><br><span class="line">    <span class="keyword">let</span> heightpercent = newHeight / h;</span><br><span class="line">    arr = arr.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// x坐标</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">            arr[i] = <span class="built_in">Math</span>.round(<span class="built_in">parseInt</span>(arr[i]) * widthpercent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//y</span></span><br><span class="line">            arr[i] = <span class="built_in">Math</span>.round(<span class="built_in">parseInt</span>(arr[i]) * heightpercent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> newPosition = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        newPosition += arr[j];</span><br><span class="line">        <span class="keyword">if</span> (j &lt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">            newPosition += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newPosition;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    coordsObj,</span><br><span class="line">    initCoords,</span><br><span class="line">    setCoords,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>vue里面的<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mycoordsObj = reactive(coordsObj);</span><br><span class="line"><span class="comment">//热点区域自适应</span></span><br><span class="line"><span class="comment">//初始化热点</span></span><br><span class="line"><span class="keyword">let</span> time = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initCoord</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">clearTimeout</span>(time);</span><br><span class="line">  time = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    mycoordsObj.huanan1 = setCoords(initCoords.huanan1, <span class="number">767</span>, <span class="number">586</span>);</span><br><span class="line">    mycoordsObj.huanan2 = setCoords(initCoords.huanan2, <span class="number">767</span>, <span class="number">586</span>);</span><br><span class="line">    mycoordsObj.huanan3 = setCoords(initCoords.huanan3, <span class="number">767</span>, <span class="number">586</span>);</span><br><span class="line">    mycoordsObj.huabei = setCoords(initCoords.huabei, <span class="number">767</span>, <span class="number">586</span>);</span><br><span class="line">    mycoordsObj.huazhong = setCoords(initCoords.huazhong, <span class="number">767</span>, <span class="number">586</span>);</span><br><span class="line">    mycoordsObj.huadong = setCoords(initCoords.huadong, <span class="number">767</span>, <span class="number">586</span>);</span><br><span class="line">    mycoordsObj.xibu = setCoords(initCoords.xibu, <span class="number">767</span>, <span class="number">586</span>);</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;</span><br><span class="line">initCoord(<span class="number">200</span>);</span><br><span class="line"><span class="comment">//当缩放的时候 自适应 且设置定时器避免多次计算</span></span><br><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  initCoord(<span class="number">1500</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2></li><li>png转webp，从400k变100k直升四倍，注意格式工厂的webp转换底色会变绿</li><li>依旧是定时器，避免重复计算。</li></ol><h1 id="part6-foodCatalog"><a href="#part6-foodCatalog" class="headerlink" title="part6 foodCatalog"></a>part6 foodCatalog</h1><div class="tip "><p>这个部分是关于美食目录的</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220328194001.png" alt=""><br>需求如下：</p><ol><li>分页显示图片，内容，点击图片跳转详情页</li><li>根据不同标签显示不同种类图片<h2 id="骨架屏的使用"><a href="#骨架屏的使用" class="headerlink" title="骨架屏的使用"></a>骨架屏的使用</h2>第一次使用element的骨架屏，用法也比较简单，需要在<code>el-skeleton</code>标签内放两个template，一个用于骨架显示，一个用于实际显示。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-skeleton</span> <span class="attr">:loading</span>=<span class="string">&quot;loading&quot;</span> <span class="attr">animated</span> <span class="attr">:throttle</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 骨架显示 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-skeleton-item</span></span></span><br><span class="line"><span class="tag">      <span class="attr">variant</span>=<span class="string">&quot;image&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        width: 24%;</span></span></span><br><span class="line"><span class="string"><span class="tag">        height: 32%;</span></span></span><br><span class="line"><span class="string"><span class="tag">        margin-bottom: 5px;</span></span></span><br><span class="line"><span class="string"><span class="tag">        margin-right: 5px;</span></span></span><br><span class="line"><span class="string"><span class="tag">      &quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">&quot;item in 12&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 实际图片显示 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;foodBox&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-card</span> <span class="attr">:body-style</span>=<span class="string">&quot;&#123; padding: &#x27;0px&#x27; &#125;&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;item in foodData&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span></span></span><br><span class="line"><span class="tag">        &gt;</span><span class="tag">&lt;<span class="name">el-image</span> <span class="attr">:src</span>=<span class="string">&quot;item.foodbigimg&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; item.foodname &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-card</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-skeleton</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-pagination</span></span></span><br><span class="line"><span class="tag">  <span class="attr">background</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;pagin&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">layout</span>=<span class="string">&quot;prev, pager, next&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">current-change</span>=<span class="string">&quot;handleCurrentChange&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:currentPage</span>=<span class="string">&quot;currentPage&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:total</span>=<span class="string">&quot;pageSize&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>遇到的问题：<br>项目中一页显示12个，骨架屏里面也有十二个内容，想着切换的条件应该是图片loading完毕就显示。所以给<code>el-image</code>的load事件绑定了loading，但是实际上并没有用。猜想可能是图片不是同时渲染，所以给出的boolean值也随时间变化，不是固定值，所以骨架屏整个的切换无法进行。<br>解决方法：<br>不等图片渲染完再取消了，直接收到请求之后取消。<h2 id="分页器"><a href="#分页器" class="headerlink" title="分页器"></a>分页器</h2>element的分页器也是第一次使用，当时遇到的问题就是不知道怎么响应当前页数，就是点到第几页显示对应的数字。后面从文档中了解到使用<code>@current-change=&quot;handleCurrentChange&quot;</code>绑定当前页，默认传入的是当前页的值val 这样就可以传参到后端了。</li></ol><h2 id="性能优化-1"><a href="#性能优化-1" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li>骨架屏：请求回来之前使用骨架屏，响应之后渲染图片，增加用户体验</li><li>css的loading，这个和骨架屏的原理其实差不多，选了骨架屏</li><li>依旧是png转webp，可以到达更小的size其实，只需要缩略图</li></ol><h1 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h1><h2 id="链接hash问题"><a href="#链接hash问题" class="headerlink" title="链接hash问题"></a>链接hash问题</h2><p>vite会自动把链接变成哈希值，所以是不能直接引入某某链接的，需要使用一个方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getAssetsImages.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">fileName,imgName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> URL(<span class="string">`/src/assets/img/<span class="subst">$&#123;fileName&#125;</span>/<span class="subst">$&#123;imgName&#125;</span>`</span>,</span><br><span class="line">        <span class="keyword">import</span>.meta.url).href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个js由于使用的场景太多 直接封装之后放入了hook使用。后面考虑全局使用。</p><h2 id="vite配置项的问题"><a href="#vite配置项的问题" class="headerlink" title="vite配置项的问题"></a>vite配置项的问题</h2><p>vite的配置项和之前vuecli不太一样，而且确保能完全使用它的功能，还需要将vite的版本升到最新。所以当时配置的时候删库重新init了vite项目，这个问题需要非常注意。<br>检验的方法是：init之后康康有没有<code>vite.config.js</code></p><h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><p>代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    defineConfig</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">    <span class="attr">plugins</span>: [vue()],</span><br><span class="line">    <span class="attr">base</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">    <span class="attr">build</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;modules&#x27;</span>,</span><br><span class="line">        <span class="attr">outDir</span>: <span class="string">&#x27;dist&#x27;</span>, <span class="comment">//指定输出路径</span></span><br><span class="line">        <span class="attr">assetsDir</span>: <span class="string">&#x27;assets&#x27;</span>, <span class="comment">// 指定生成静态资源的存放路径</span></span><br><span class="line">        <span class="attr">minify</span>: <span class="string">&#x27;terser&#x27;</span> <span class="comment">// 混淆器，terser构建后文件体积更小</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">server</span>: &#123;</span><br><span class="line">        <span class="attr">cors</span>: <span class="literal">true</span>, <span class="comment">// 默认启用并允许任何源</span></span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">// 在服务器启动时自动在浏览器中打开应用程序</span></span><br><span class="line">        <span class="comment">//反向代理配置，注意rewrite写法，开始没看文档在这里踩了坑</span></span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="comment">//     &#x27;/api&#x27;: &#123;</span></span><br><span class="line">            <span class="comment">//         target:&#x27;http://isinpc.natappfree.cc&#x27;,</span></span><br><span class="line">            <span class="comment">//         changeOrigin: true,</span></span><br><span class="line">            <span class="comment">//         rewrite: (path) =&gt; path.replace(/^\/api/, &#x27;&#x27;)</span></span><br><span class="line">            <span class="comment">//   &#125;</span></span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&#x27;http://localhost:8081&#x27;</span>,</span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">rewrite</span>: <span class="function">(<span class="params">path</span>) =&gt;</span> path.replace(<span class="regexp">/^\/api/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>这里的proxy是配置转发，前端使用ajax或者axios的时候，就会将<code>localhost:3000</code>自动转换成对应的值。这里方便合作还使用到了内网穿透的api，来换切换使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Webpack5实战指南</title>
    <link href="https://zlinni.github.io/posts/7fc1593f40ed/"/>
    <id>https://zlinni.github.io/posts/7fc1593f40ed/</id>
    <published>2022-03-22T03:02:28.000Z</published>
    <updated>2022-04-02T11:12:31.165Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>咱们常见的打包工具比如vite，vuecli底层都是通过webpack实现的，下面就来对webpack进行一个学习并且实战运用</p></div><h1 id="为什么需要webpack"><a href="#为什么需要webpack" class="headerlink" title="为什么需要webpack"></a>为什么需要webpack</h1><p>这就要回顾一下没出现打包工具之前的弊端了。在以前，我们的js都是引入之后写在页面上的，有很多第三方的js比如jquery，lodash等，以及自己编写的js，此时需要注意引入的顺序，否则就会报错。可能会想到将它们合并到一个文件里面就不会报错，但是这样一来冗长的代码导致可读性差，可维护性弱的问题。此外还有作用域和文件太大的问题。</p><h2 id="作用域问题"><a href="#作用域问题" class="headerlink" title="作用域问题"></a>作用域问题</h2><p>我们知道，像jq这种库，全局声明是<code>$</code>符号，这个符号是绑定在window对象上面的，而lodash是绑定的下划线，我们自己的业务文件可能也绑定了类似于user这样的变量到window上面。这样一来我们的window对象就会被污染了，使得它变得非常臃肿。这就是作用域问题。</p><h2 id="文件太大"><a href="#文件太大" class="headerlink" title="文件太大"></a>文件太大</h2><p>如果不合并，那么有多少个js，就加载多少个js，页面可能就会出现一边加载一边渲染的问题。<br>如果将文件合并，这个巨大的js就会带来网络瓶颈，比如首页白屏问题</p><h1 id="before-webpack"><a href="#before-webpack" class="headerlink" title="before webpack"></a>before webpack</h1><p>在webpack之前，我们使用的是grunt和gulp这两款工具来管理我们的项目资源，我们称之为任务执行器。它是通过IIFE来解决作用域问题。在IIFE中，文件可以安全拼接而不用担心作用域问题<br>IIFE包裹的东西是不能在外部访问的，所以它不会污染作用域。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> jojo =<span class="string">&#x27;jojojo&#x27;</span>;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">console</span>.log(jojo);<span class="comment">//不行</span></span><br></pre></td></tr></table></figure><br>但如果我们想要暴露出一些内容应该怎么做呢？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;ajsjdajsd&#x27;</span>;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><br>我们的grunt和gulp就是采用这种方式进行管理的，但是由此就引申出了一个问题，如果我们的代码有1w行，我们修改了其中的一行，里面的内容就会重新编译，造成了不需要的性能浪费。<br>解决的办法是实现方法的懒加载或者把文件拆分成一个一个方法的模块</p><h1 id="代码拆分"><a href="#代码拆分" class="headerlink" title="代码拆分"></a>代码拆分</h1><p>nodejs的commonjs提供了导入导出的功能，使得js代码可以模块化了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//math.js</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x,y</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> minus = <span class="function">(<span class="params">x,y</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">add,</span><br><span class="line">minus</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//server.js</span></span><br><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./math.js&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(math.add(<span class="number">4</span>,<span class="number">5</span>))<span class="comment">//9</span></span><br></pre></td></tr></table></figure><br>虽然在node上面支持模块化，但是我们的浏览器是不支持这样使用的，也就是只能在node环境下面才能用commonjs。</p><h1 id="让浏览器支持模块化"><a href="#让浏览器支持模块化" class="headerlink" title="让浏览器支持模块化"></a>让浏览器支持模块化</h1><p>我们为了能让浏览器支持模块化，使用的是browserify,requirejs这样的打包工具。下面使用requirejs来演示<br>新建requirejs文件夹 放入<code>add.js</code>,<code>minus.js</code>,<code>main.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addjs</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">define([], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//minusjs</span></span><br><span class="line"><span class="keyword">const</span> minus = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line">define([], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> minus;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//mainjs</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;./requirejs/add.js&#x27;</span>,<span class="string">&#x27;./requirejs/minus.js&#x27;</span>],<span class="function"><span class="keyword">function</span>(<span class="params">add,minus</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(add(<span class="number">4</span>,<span class="number">5</span>)) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>注意mainjs的引入路径是根据<code>index.html</code>来判断的。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/require.js/2.3.6/require.js&quot;</span> <span class="attr">data-main</span>=<span class="string">&quot;./requirejs/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><br>引入requirejs从bootcdn，然后使用<code>data-main</code>定义文件入口。<br>除了requirejs，ecma其实也给我们提供了模块化的方法，比如以前学过的<code>import</code>和<code>export</code><br>注意需要<code>live server</code>插件来保证同源<br>回顾一下<code>export</code>三种方式 </p><ol><li>分别暴露 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> aa=<span class="string">&#x27;xczxc&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">xxxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m1 <span class="keyword">from</span> <span class="string">&#x27;xxxx&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li>统一暴露<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jojo = <span class="string">&#x27;jostar&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sad</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">xxxx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;jojo,sad&#125;;</span><br></pre></td></tr></table></figure></li><li>默认暴露<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="keyword">let</span> jojo =<span class="string">&#x27;jostar&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> jojoprocess = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">xxxx</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="webpack的竞品"><a href="#webpack的竞品" class="headerlink" title="webpack的竞品"></a>webpack的竞品</h1><ol><li>parcel<br>0配置 用户无需做其他操作，开箱即用。<br>如果你想构建一个简单的应用并且让他快速的构建起来，可以使用parcel</li><li><code>rollup.js</code><br>用标准化的格式来编写代码，减少无用的代码来缩小包的体积<br>如果你想构建一个类库，并且只用导入很少的第三方库，可以使用rollup</li><li>vite</li></ol><h1 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h1><h2 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h2><div class="note info simple"><p>确保有node环境</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli --global</span><br></pre></td></tr></table></figure><p>一定要加global 否则失效<br>查看版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack -v</span><br></pre></td></tr></table></figure><br><div class="note warning flat"><p>全局安装的方式并不推荐，因为它会锁定你的webpack版本，导致后面不能使用别的版本的webpack。另外没有写入依赖，合作的时候就无法通过npmi来安装。</p></div></p><h2 id="局部安装"><a href="#局部安装" class="headerlink" title="局部安装"></a>局部安装</h2><div class="note warning flat"><p>注意项目的名字不能有中文</p></div><p>首先创建packgejson<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><br>然后安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli --save-dev</span><br></pre></td></tr></table></figure></p><h2 id="运行webpack"><a href="#运行webpack" class="headerlink" title="运行webpack"></a>运行webpack</h2><p>新建文件夹src 新建helloworldjs并暴露helloworld方法,新建indexjs导入方法并使用.<br>然后把全局的webpack卸载<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall webpack webpack-cli --global</span><br></pre></td></tr></table></figure><br>之后使用webpack命令查看webpack还是否存在,发现已经不能使用.<br>接着使用命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><br>发现会产生一个dist文件,里面有打包的mainjs(注意此时会报一个mode的warning 但是并无大碍)<br>为什么webpack命令又可以运行了呢?因为npx会查找当前目录是否存在该命令,如果没有就去上一层找,而我们在最外层定义局部安装了webpack 所以可以使用.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">()=&gt;</span>&#123;<span class="string">&quot;use strict&quot;</span>;<span class="built_in">console</span>.log(<span class="string">&quot;helloworld&quot;</span>)&#125;)();</span><br></pre></td></tr></table></figure></p><h2 id="自定义文件配置"><a href="#自定义文件配置" class="headerlink" title="自定义文件配置"></a>自定义文件配置</h2><p>上面提到打包后创建了mainjs,那么我们如何修改这个入口文件的路径和文件名呢?<br>先使用命令创建mainjs<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack --entry ./src/index.js --mode production</span><br></pre></td></tr></table></figure><br>这样就解决了mode问题.<br>但我们发现这样的方式并不方便直观,所以webpack提供了一个新的方式.在<code>webpack.config.js</code>里面去配置参数即可.<br>这个文件是建立在当前目录下面的请注意<br>注意:这个文件是在nodejs里面运行的,因此我们去定义模块的时候,得使用nodejs的<code>commandjs</code>模块<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>:<span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>:&#123;</span><br><span class="line">        <span class="attr">filename</span>:<span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>:path.resolve(__dirname,<span class="string">&#x27;./dist&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们引入路径的时候不能直接写相对路径.webpack要求一个绝对路径,所以说要使用到node模块中的path引入绝对路径.<br>再执行<code>npx webpack</code>发现main变成了bundlejs,而且它们两个完全不一样<br>那么现在打包完了 如何在浏览器上面运行代码?<br>引入bundlejs即可.(手动引入)</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="自动引入资源"><a href="#自动引入资源" class="headerlink" title="自动引入资源"></a>自动引入资源</h2><div class="note primary flat"><p>上面讲到了要引入打包后的bundlejs只能手动引入,那么有什么办法可以自动引入呢?<br>这就使用到了webpack的插件.</p></div><ol><li>安装插件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure></li><li>在<code>webpack.config.js</code>中引入<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>:<span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>:&#123;</span><br><span class="line">        <span class="attr">filename</span>:<span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>:path.resolve(__dirname,<span class="string">&#x27;./dist&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mode</span>:<span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">    <span class="attr">plugins</span>:[</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>执行<code>npx webpack</code>即可看见dist目录下面打包的html了</li></ol><h2 id="插件配置项"><a href="#插件配置项" class="headerlink" title="插件配置项"></a>插件配置项</h2><div class="note primary flat"><p>通过插件配置项可以改变输出的名字和插入的js位置，但需要模板</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        <span class="attr">template</span>:<span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">        <span class="attr">filename</span>:<span class="string">&#x27;jojo.html&#x27;</span>,</span><br><span class="line">        <span class="attr">inject</span>:<span class="string">&#x27;body&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>注意上面的模板路径要正确。</p><h2 id="清除上次dist"><a href="#清除上次dist" class="headerlink" title="清除上次dist"></a>清除上次dist</h2><p>在output里面配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">    <span class="attr">filename</span>:<span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>:path.resolve(__dirname,<span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">    <span class="attr">clean</span>:<span class="literal">true</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1 id="source-map调试"><a href="#source-map调试" class="headerlink" title="source-map调试"></a>source-map调试</h1><div class="note primary flat"><p>如果代码出错，我们打包后的html在浏览器中显示错误的位置并不是源文件中的位置，而是打包后的某个错误文件的位置，要想知道源文件错误的位置在哪里，需要配置devtool,而且必须放在plugins前面</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool:<span class="string">&#x27;inline-source-map&#x27;</span>,</span><br></pre></td></tr></table></figure><h1 id="自动编译"><a href="#自动编译" class="headerlink" title="自动编译"></a>自动编译</h1><div class="note primary flat"><p>每次都要<code>npx webpack</code>很麻烦 直接使用<code>npx webpack --watch</code>指令即可</p></div><h1 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h1><div class="note primary flat"><p>每次都要刷新很麻烦</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure><p>配置文件中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">    <span class="attr">static</span>:path.resolve(__dirname,<span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>webpack-dev-server</code>没有输出任何的物理文件，他把输出的打包以后的bundle文件放到了内存里，就算把dist文件删掉也没有关系 类似于vue-cli</p><h1 id="资源模块"><a href="#资源模块" class="headerlink" title="资源模块"></a>资源模块</h1><div class="note primary flat"><p>webpack可以使用内置的资源模块来引入任何的其他类型资源，资源模块我们叫做<code>asset module</code>，是一种模块类型，允许我们用webpack来打包其他的资源文件，比如像字体文件，图标文件等等。资源模块类型称作为<code>asset module type</code>会通过四种新的类型模块来替换所有的loader</p></div><ol><li><code>asset/resourse</code>会发送一个单独的文件并导出URL</li><li><code>asset/inline</code>会导出一个资源的Data URL</li><li><code>asset/source</code>会导出资源的源代码</li><li><code>asset</code>他会在导出一个Data URL和发送一个单独的文件之间进行选择。</li></ol><h2 id="asset-resource导出单独的文件"><a href="#asset-resource导出单独的文件" class="headerlink" title="asset/resource导出单独的文件"></a><code>asset/resource</code>导出单独的文件</h2><p>导出到指定的文件夹<br>方式1：全局<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220401212439.png" alt=""><br>方式2：局部<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220401212548.png" alt=""><br>适合处理大图片</p><h2 id="asset-inline"><a href="#asset-inline" class="headerlink" title="asset/inline"></a><code>asset/inline</code></h2><p>不会生成资源，适用于svg，会转换成base64链接</p><h2 id="asset-source"><a href="#asset-source" class="headerlink" title="asset/source"></a><code>asset/source</code></h2><p>导出源代码 适合于渲染文本内容。</p><h2 id="asset"><a href="#asset" class="headerlink" title="asset"></a><code>asset</code></h2><p>自动选择url或者文件，依据是文件的大小,默认情况是8k以下base64 以上生成对应的文件。可以自定义<br>自定义方法如下：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220401212935.png" alt=""></p><h1 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h1><div class="note primary flat"><p>webpack只能解析js和json，loader提供了解析其他资源的可能，并且将这些文件转换为有效的模块</p></div><p>打包流程图：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220401213137.png" alt=""></p><div class="note primary flat"><p>那么loader怎么定义呢？</p></div><p>例子：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220401213256.png" alt=""></p><h2 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h2><p>安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-loader -D</span><br></pre></td></tr></table></figure></p><p>使用<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220401213459.png" alt=""></p><div class="note warning flat"><p>但是我们在控制台中发现他并没有生成link来连接css，也没有对应的style放置css，所以一个cssloader是不够的</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220401213717.png" alt=""></p><h2 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h2><p>安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install style-loader -D</span><br></pre></td></tr></table></figure></p><div class="note primary flat"><p>我们需要使用这个styleloader来帮助我们加载css样式，但是我们发现在use里面使用一个字符串就不合适了。此时改为数组的形式。且数组是有顺序的，我们应该先写styleloader 再写cssloader。原因是我们需要先用cssloader来帮助我们识别webpack文件，在通过styleloader加载我们的css</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220401214206.png" alt=""></p><div class="note primary flat"><p>由此还得说明webpack支持链式调用，他的执行顺序是从后往前，第一个cssloader会讲结果或者是转后的源，传递给下一个loader，最后webpack希望styleloader会返回一个js，就实现了效果。</p></div><h2 id="less-loader"><a href="#less-loader" class="headerlink" title="less-loader"></a>less-loader</h2><p>执行方法<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220401214523.png" alt=""></p><h2 id="抽离和压缩css"><a href="#抽离和压缩css" class="headerlink" title="抽离和压缩css"></a>抽离和压缩css</h2><div class="note primary flat"><p>上述讲述的loader会把他放在style里面，而我们更期望能够将他转换为一个单独的文件，用link进行一个加载，所以要如何操作？</p></div><ul><li>安装插件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure><ul><li><p>取名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402182142.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402182004.png" alt=""><br>这样加载出来的就会多个link标签</p></li><li><p>但是我们会发现 这样的css并没有压缩，所以我们需要一个插件帮助我们压缩css</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-minimizer-webpack-plugin -D</span><br></pre></td></tr></table></figure><ul><li>定义变量<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402182549.png" alt=""></li><li>需要将mode改为<code>production</code></li><li>配置项<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402182646.png" alt=""></li></ul><h2 id="加载图像"><a href="#加载图像" class="headerlink" title="加载图像"></a>加载图像</h2><ul><li>需要将mode改为development</li><li>使用<code>assetModuleFilename</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402183022.png" alt=""></li></ul><h2 id="fonts字体"><a href="#fonts字体" class="headerlink" title="fonts字体"></a>fonts字体</h2><ul><li>加载格式<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402183102.png" alt=""></li></ul><h2 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h2><ul><li>安装</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D babel-loader @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure><ul><li><code>babel-loader</code>:解析es6</li><li><code>@babel-core</code>：核心模块</li><li><code>@babel/preset-env</code>:babel预设一组babel的插件集合 </li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402183615.png" alt=""></p><h2 id="regeneratorRuntime插件"><a href="#regeneratorRuntime插件" class="headerlink" title="regeneratorRuntime插件"></a>regeneratorRuntime插件</h2><div class="note primary flat"><p>上述步骤执行指令会浏览器报错 缺少该插件。</p></div><ul><li>安装</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save @babel/runtime</span><br><span class="line">npm install --save-dev @babel/plugin-transform-runtime</span><br></pre></td></tr></table></figure><ul><li>使用<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402183848.png" alt=""></li></ul><h1 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h1><div class="note primary flat"><p>常见的代码分离方式如下：</p></div><ol><li>入口起点：使用entry配置手动分离代码</li><li>防止重复：使用<code>Entry dependencies</code>或者<code>SplitChunksPlugin</code>去重和分离代码</li><li>动态导入：通过模块的内联函数调用来分离代码</li></ol><h2 id="入口起点"><a href="#入口起点" class="headerlink" title="入口起点"></a>入口起点</h2><div class="note primary flat"><p>这个方法需要配置入口文件，如下</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402190445.png" alt=""></p><div class="note warning flat"><p>但如果我们引入了相同的js库，他会分别打包到对应的入口，即会重复</p></div><h2 id="防止重复"><a href="#防止重复" class="headerlink" title="防止重复"></a>防止重复</h2><div class="note primary flat"><p>使用下面的配置方法抽离公共的库,这里抽离的是lodash，最后会变成一个单独的js文件</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402190708.png" alt=""></p><p>方法2：使用webpack内置的插件<code>split-chunks-Plugin</code></p><ul><li>入口文件格式改回来<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402191138.png" alt=""></li><li>配置<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402191156.png" alt=""></li></ul><h2 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a>动态导入</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Webpack" scheme="https://zlinni.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的JavaScript①</title>
    <link href="https://zlinni.github.io/posts/fee85c52fd07/"/>
    <id>https://zlinni.github.io/posts/fee85c52fd07/</id>
    <published>2022-03-17T00:46:42.000Z</published>
    <updated>2022-04-19T10:50:57.451Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>首先js的类型有基本数据类型和引用类型<br>前者有七种 后者是一种<br>根据以前的USONB理论 大致是<br><code>Undefined</code>,<code>String</code>,<code>Symbol</code>,<code>Object</code>,<code>Null</code>,<code>Number</code>,<code>BigInt</code>,<code>Boolean</code></p><h2 id="基本数据类型的作用？"><a href="#基本数据类型的作用？" class="headerlink" title="基本数据类型的作用？"></a>基本数据类型的作用？</h2><p>基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p><h2 id="object为什么是引用类型？"><a href="#object为什么是引用类型？" class="headerlink" title="object为什么是引用类型？"></a><code>object</code>为什么是引用类型？</h2><p>而引用类型 在创建对象的时候会在堆内存中开辟一个空间 用来存放对象的属性 在为对象添加属性的时候，是将属性放在堆内存中开辟的空间里。<br>在栈内存中保存显示 对象名+一个地址 类似于指针 执行堆内存中对象开辟的空间<br>引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念；占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。<br>引申出栈和堆的概念！</p><h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a><code>BigInt</code></h2><div class="note primary flat"><p>js的精度只有2的53次方，所以当数据大于这个数的时候会出现解析不准确(最后一位被四舍五入)，这个时候就需要这个库来帮忙解决。</p></div><ul><li>业务场景</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = axios.create(&#123;</span><br><span class="line">  <span class="attr">transformResponse</span>:[</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JSONbigint.parse(data);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//注意这里的jsonbigint是引入bigint所随意取的一个名称，一般在请求之前将数据使用这个库帮助js进行解析，这里是挂载axios进行预处理。</span></span><br></pre></td></tr></table></figure><ul><li>创建bigint，只需要在数字结尾加个n即可。或者使用<code>BigInt()</code>构造函数，但此时要传入字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">99151651515165151n</span>)<span class="comment">//99151651515165151n</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">99151651515165151</span>)<span class="comment">//99151651515165150 会四舍五入最后一位，解析不准确</span></span><br><span class="line"><span class="built_in">BigInt</span>(<span class="string">&quot;99151651515165151&quot;</span>)<span class="comment">//99151651515165151n 注意要传入字符串！！</span></span><br></pre></td></tr></table></figure><ul><li>注意控制台中输出bigint的数据 是绿色的。</li><li>不能用三个等于判断<code>BigInt</code>和常规数字 因为它们的类型不同</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">10n</span>===<span class="number">10</span>)<span class="comment">//false;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">10n</span>)<span class="comment">//BigInt</span></span><br></pre></td></tr></table></figure><ul><li>不支持一元加号(+)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10n</span> + <span class="number">20n</span>;    <span class="comment">// → 30n</span></span><br><span class="line"><span class="number">10n</span> - <span class="number">20n</span>;    <span class="comment">// → -10n</span></span><br><span class="line">+<span class="number">10n</span>;         <span class="comment">// → TypeError: Cannot convert a BigInt value to a number</span></span><br><span class="line">-<span class="number">10n</span>;         <span class="comment">// → -10n</span></span><br><span class="line"><span class="number">10n</span> * <span class="number">20n</span>;    <span class="comment">// → 200n</span></span><br><span class="line"><span class="number">20n</span> / <span class="number">10n</span>;    <span class="comment">// → 2n</span></span><br><span class="line"><span class="number">23n</span> % <span class="number">10n</span>;    <span class="comment">// → 3n</span></span><br><span class="line"><span class="number">10n</span> ** <span class="number">3n</span>;    <span class="comment">// → 1000n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">10n</span>;</span><br><span class="line">++x;          <span class="comment">// → 11n</span></span><br><span class="line">--x;          <span class="comment">// → 9n</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h1><p>在js的执行过程中，主要有三种类型的内存空间，一是代码空间，二是栈空间，三是堆空间。代码空间顾名思义就是存储代码用的，栈空间是用来保存变量和变量值的，堆空间是保存地址的。<br>对于栈空间来说，原始类型存储的是变量的值，而引用类型存储的是在堆空间中的地址，所以当js需要访问数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手程序</p><h2 id="闭包是怎么存储"><a href="#闭包是怎么存储" class="headerlink" title="闭包是怎么存储"></a>闭包是怎么存储</h2><p>js引擎对于闭包的处理，是当遇到一个闭包的时候，在堆空间中创建一个<code>closure(fn)</code>对象，用来保存闭包中的变量，所以闭包中的变量是存储在堆空间中的。这就是为什么闭包可以常驻在内存的原因。</p><h2 id="js为什么需要栈和堆"><a href="#js为什么需要栈和堆" class="headerlink" title="js为什么需要栈和堆"></a>js为什么需要栈和堆</h2><p>首先知道栈是让变量循环利用，通常也是设置一些小数据来放入栈中，而我们知道引用类型数据obj一般占用的空间都比较大。所以js引擎需要栈和堆来维持内存的平衡。 </p><ul><li>题目1<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lee&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(a.name);  <span class="comment">//第一个console</span></span><br><span class="line">b.name = <span class="string">&#x27;son&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.name);  <span class="comment">//第二个console</span></span><br><span class="line"><span class="built_in">console</span>.log(b.name);  <span class="comment">//第三个console</span></span><br></pre></td></tr></table></figure>第一个是lee显而易见，第二个console是son 第三个也是。这是因为a是对象 是引用类型 在赋值给b的时候 实际上是给了a在堆中的地址 所以b访问的是堆空间中a的变量 那么修改了b 自然a也会发生变动，这里就引出了堆空间共享的概念</li><li>题目2<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Julia&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o.age = <span class="number">24</span>;</span><br><span class="line">  o = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Kath&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = change(a);     <span class="comment">// 注意这里没有new，后面new相关会有专门文章讲解</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age);    <span class="comment">// 第一个console</span></span><br><span class="line"><span class="built_in">console</span>.log(a.age);    <span class="comment">// 第二个console</span></span><br></pre></td></tr></table></figure>第一个输出30 第二个输出24<br>原因是function里面传入的是a在堆中的地址，那么自然a的age就会变成24 但是到了return这一步 它会把传入的内存地址修改 导致o变成另外一个内存地址 将o的数据存放在该内存中， 所以b就是kath和30</li></ul><h1 id="检测方式"><a href="#检测方式" class="headerlink" title="检测方式"></a>检测方式</h1><div class="note primary flat"><p>数据类型检测有很多种，常用的是<code>typeof instanceof constructor Object.prototype.toString.call([])</code></p></div><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a><code>typeof</code></h2><div class="note primary flat"><p>该方法是基于计算机底层的数据类型的二进制进行判断。 用于判断除了<code>array null</code>之外的类型,即可以判断除了<code>null</code>之外的基础数据类型和除了<code>array</code>之外的应用数据类型<br>下面看一下它对于所有类型的处理 注意它可以处理function</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object     []数组的数据类型在 typeof 中被解释为 object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object     null 的数据类型被 typeof 解释为 object</span></span><br></pre></td></tr></table></figure><ul><li>为什么null会被<code>typeof</code>识别成<code>object</code>？<br>这个是一个历史遗留问题 js底层是二进制存储的 前三位代表的是数据的存储类型 对于object来说则是000 而刚好null也是全0 正好代表object类型的数据格式 所以null才会输出object</li></ul><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h2><p>由于上面的方法不能精确判断数组和null的原因 所以产生了新的方法<code>instanceof</code><br>康康它对于所有类型的处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false  </span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true    </span></span><br><span class="line"><span class="comment">// console.log(undefined instanceof Undefined);</span></span><br><span class="line"><span class="comment">// console.log(null instanceof Null);</span></span><br></pre></td></tr></table></figure><p>和由此可见 <code>instanceof</code>方法能准确的判断引用数据类型 但是不能判断基础数据类型<br>因为它的原理是和原型链相关的 ,相当于判断是不是这个类的实例，所以对于<code>undefined和null</code>来说，这两者是没有原型的 所以无法判断。<br>引申一下 <code>null</code>是所有原型的终点 <code>undefined</code>是表示没有这个值 缺少这个值 </p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><code>constructor</code></h2><p>构造器判断方法 注意带括号 否则会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">2</span>).constructor === <span class="built_in">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).constructor === <span class="built_in">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="string">&#x27;str&#x27;</span>).constructor === <span class="built_in">String</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(([]).constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).constructor === <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;).constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>弊端是 如果改变了对象原型，该方法会失效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">Fn.prototype=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> f=<span class="keyword">new</span> Fn();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===Fn);    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===<span class="built_in">Array</span>); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a><code>Object.prototype.toString.call()</code></h2><p>使用<code>Object</code>上面的<code>toString</code>方法 会返回一个格式为<code>[object Xxx]</code>的字符串，通过call重新调用就可以精确判断对象类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString(&#123;&#125;)       <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;)  <span class="comment">// 同上结果，加上call也ok</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>)    <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;1&#x27;</span>)  <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>)  <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)  <span class="comment">// &quot;[object Function]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)   <span class="comment">//&quot;[object Null]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">//&quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/123/g</span>)    <span class="comment">//&quot;[object RegExp]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">//&quot;[object Date]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([])       <span class="comment">//&quot;[object Array]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>)  <span class="comment">//&quot;[object HTMLDocument]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>)   <span class="comment">//&quot;[object Window]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面这段代码可以看出，Object.prototype.toString.call() 可以很好地判断引用类型，甚至可以把 document 和 window 都区分开来。</span></span><br></pre></td></tr></table></figure><p>由于代码过长 推荐封装一下<code>Object.prototype.toString</code><br>实现一个全局通用的判断方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> type = <span class="keyword">typeof</span> obj;</span><br><span class="line"><span class="comment">//如果是基本类型 直接返回</span></span><br><span class="line"><span class="keyword">if</span>(type!==<span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toStirng.call(obj).replace(<span class="regexp">/^\[object (\S+)\]$/</span>, <span class="string">&#x27;$1&#x27;</span>);  <span class="comment">// 注意正则中间有个空格</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 代码验证，需要注意大小写，哪些是typeof判断，哪些是toString判断？思考下 */</span></span><br><span class="line">getType([])     <span class="comment">// &quot;Array&quot; typeof []是object，因此toString返回</span></span><br><span class="line">getType(<span class="string">&#x27;123&#x27;</span>)  <span class="comment">// &quot;string&quot; typeof 直接返回</span></span><br><span class="line">getType(<span class="built_in">window</span>) <span class="comment">// &quot;Window&quot; toString返回</span></span><br><span class="line">getType(<span class="literal">null</span>)   <span class="comment">// &quot;Null&quot;首字母大写，typeof null是object，需toString来判断</span></span><br><span class="line">getType(<span class="literal">undefined</span>)   <span class="comment">// &quot;undefined&quot; typeof 直接返回</span></span><br><span class="line">getType()            <span class="comment">// &quot;undefined&quot; typeof 直接返回</span></span><br><span class="line">getType(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// &quot;function&quot; typeof能判断，因此首字母小写</span></span><br><span class="line">getType(<span class="regexp">/123/g</span>)      <span class="comment">//&quot;RegExp&quot; toString返回</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220316104931.png" alt=""></p><h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><div class="note primary flat"><p>在js中 类型转换有三种情况 分别是</p></div><ul><li>转换为布尔值</li><li>转换为数字</li><li>转化为字符串</li></ul><p>一图流：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220330090846.png" alt=""></p><h2 id="转Boolean"><a href="#转Boolean" class="headerlink" title="转Boolean"></a>转<code>Boolean</code></h2><div class="note primary flat"><p>在条件判断的时候，除了<code>undefined</code>,<code>null</code>,<code>false</code>,<code>NaN</code>,<code>`,0,</code>-0`，其他值都会转成true 包括对象</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>)          <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>)       <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>)  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>)        <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">1</span>)          <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">13</span>)         <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27;12&#x27;</span>)       <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="对象转原始类型"><a href="#对象转原始类型" class="headerlink" title="对象转原始类型"></a>对象转原始类型</h2><div class="note primary flat"><p>对象转原始类型的时候，会调用内置的<code>[[ToPrimitive]]</code>函数，对于该函数来说，算法逻辑一般如下</p></div><ul><li>如果已经是原始类型了，那么就不需要转换了</li><li>调用<code>x.valueOf()</code>如果转换为基础类型，那么就返回转换的值。</li><li>调用<code>toString()</code>如果转换为基础类型，就返还转换的值。</li><li>如果都没有返回原始类型，就会报错。</li></ul><div class="note primary flat"><p>当然你也可以重写<code>Symbol.toPrimitive</code>该方法在转原始类型的时候调用优先级最高</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">toStirng</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>+a <span class="comment">//3</span></span><br></pre></td></tr></table></figure><h2 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a>四则运算符</h2><div class="note primary flat"><p>他有以下几个特点：</p></div><ul><li>运算中如果其中一方为字符串，就会把另外一方也转换成字符串。</li><li>如果其中一方不是字符串或者数字，那么会将他转换成数字或者字符串。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>+<span class="string">&#x27;1&#x27;</span> <span class="comment">//11</span></span><br><span class="line"><span class="literal">true</span>+<span class="literal">true</span> <span class="comment">//2</span></span><br><span class="line"><span class="number">4</span>+[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">//41,2,3</span></span><br></pre></td></tr></table></figure><ul><li>第一行 特点一</li><li>第二行 特点二</li><li>第三行 特点二</li></ul><div class="note primary flat"><p>另外对于加法还需要注意表达式<code>a ++ b</code></p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> + + <span class="string">&#x27;b&#x27;</span> <span class="comment">// &quot;aNaN&quot;</span></span><br></pre></td></tr></table></figure><ul><li>因为<code>+ &#39;b&#39;</code>的结果是<code>NaN</code> 所以…且在部分代码中有尝试使用+某个值的形式来快速获取number类型</li><li>那么对于除了加法的运算符来说，只要其中一方是数字，那么另外一方就会被转为数字。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>*<span class="string">&#x27;3&#x27;</span><span class="comment">//12</span></span><br><span class="line"><span class="number">4</span>*[] <span class="comment">//0</span></span><br><span class="line"><span class="number">4</span>*[<span class="number">1</span>,<span class="number">2</span>] <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><ul><li>如果是对象，就通过<code>toPrimitive</code>转换对象。</li><li>如果是字符串，就通过<code>unicode</code>字符索引来比较。 </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a&gt;-<span class="number">1</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p>在以上代码中，a是对象，所以通过<code>valueOf</code>转化为原始类型再比较</p></div><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><div class="note primary flat"><p>强制类型转换的方式包括<code>Number()</code>,<code>parseInt()</code>,<code>parseFloat()</code>,<code>toString()</code>,<code>String()</code>,<code>Boolean()</code>这几种方法都比较类似。</p></div><ul><li><code>Number</code>的强制转换规则</li><li>如果是布尔值 <code>true</code>是1 <code>false</code>是0</li><li>如果是数字，返回自身</li><li>如果是<code>null</code> 返回 0</li><li>如果是<code>undefined</code> 返回<code>NaN</code></li><li>如果是字符串 遵循以下规则：如果字符串中只包含数字 或者是<code>0x</code>开头的十六进制数字字符串，允许包含正负号。则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为0；如果不是以上格式的字符串，均返回<code>NaN</code></li><li>如果是<code>Symbol</code> 抛出错误</li><li>如果是对象，并且部署了<code>[Symbol.toPrimitive]</code>，那么调用此方法，否则调用<code>valueOf</code>方法，然后根据前面的规则返回转换的值。如果转换的结果是<code>NaN</code>，那么调用对象的<code>toString()</code>方法，再次按照前面的规则返回对应的值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>);        <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>);       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;0111&#x27;</span>);      <span class="comment">//111</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>);        <span class="comment">//0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;&#x27;</span>);          <span class="comment">//0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;1a&#x27;</span>);        <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">Number</span>(-<span class="number">0X11</span>);       <span class="comment">//-17</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;0X11&#x27;</span>)       <span class="comment">//17</span></span><br></pre></td></tr></table></figure><h2 id="Object的转换规则"><a href="#Object的转换规则" class="headerlink" title="Object的转换规则"></a>Object的转换规则</h2><div class="note primary flat"><p>对象转换的规则，会先调用内置的<code>[Symbol.ToPrimitive]</code>函数，其规则逻辑如下：</p></div><ul><li>如果部署了该方法，优先调用再返回。</li><li>调用<code>valueOf</code>如果转换为基础类型 则返回</li><li>调用<code>toStirng</code>如果转换为基础类型 则返回</li><li>如果都没有 则报错</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="number">1</span>); <span class="comment">// 输出5</span></span><br><span class="line"><span class="comment">// 因为有[Symbol.toPrimitive]所以输出的是5</span></span><br><span class="line"><span class="comment">// 如果没有则使用valueOf 输出3</span></span><br><span class="line"><span class="comment">// 如果删掉valueOf 则返回31 字符串拼接</span></span><br><span class="line"><span class="comment">// 再看两个特殊的case：</span></span><br><span class="line"><span class="number">10</span> + &#123;&#125;</span><br><span class="line"><span class="comment">// &quot;10[object Object]&quot;</span></span><br><span class="line"><span class="comment">// 没有primitive 则先调用valueOf 发现返回的值是&#123;&#125; 不是基础类型 所以调用toString 返回[object Object]再拼接</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="literal">undefined</span>,<span class="number">4</span>,<span class="number">5</span>] + <span class="number">10</span></span><br><span class="line"><span class="comment">// &quot;1,2,,4,510&quot;，</span></span><br><span class="line"><span class="comment">// 没有primitive 则先调用valueOf 发现返回的是数组 不是基础类型 继续调用toString 返回1,2,,4,5 字符串拼接 最后结果是1,2,,4,510</span></span><br></pre></td></tr></table></figure><h2 id="的隐式转换规则"><a href="#的隐式转换规则" class="headerlink" title="==的隐式转换规则"></a><code>==</code>的隐式转换规则</h2><ul><li>如果类型相同，无需进行类型转换。</li><li>如果其中一个是<code>null</code>或者<code>undefined</code> 那么另外一个操作符必须是<code>null</code>或者<code>undefined</code>才会返true 否则都是false</li><li>如果其中一个是<code>Symbol</code>类型 那么返回true</li><li>两个操作值如果是<code>string</code>和<code>number</code>类型，则转字符串为<code>number</code></li><li>如果一个是<code>boolean</code>则转<code>number</code></li><li>如果一个操作值为<code>object</code>且另一方为<code>number string or Symbol</code>就会把<code>object</code>转化为原始类型再进行判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>       <span class="comment">// true  规则2</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span>               <span class="comment">// false 规则2</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="literal">null</span>              <span class="comment">// false 规则2</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span>                 <span class="comment">// true  规则4 字符串转隐式转换成Number之后再对比</span></span><br><span class="line"><span class="string">&#x27;123&#x27;</span> == <span class="number">123</span>            <span class="comment">// true  规则4 字符串转隐式转换成Number之后再对比</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>              <span class="comment">// true  e规则 布尔型隐式转换成Number之后再对比</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span>               <span class="comment">// true  e规则 布尔型隐式转换成Number之后再对比</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意这里a又可以等于1、2、3</span></span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a ==<span class="number">3</span>);  <span class="comment">//true f规则 Object隐式转换</span></span><br><span class="line"><span class="comment">// 注：但是执行过3遍之后，再重新执行a==3或之前的数字就是false，因为value已经加上去了，这里需要注意一下</span></span><br></pre></td></tr></table></figure><h2 id="的隐式转换规则-1"><a href="#的隐式转换规则-1" class="headerlink" title="+的隐式转换规则"></a><code>+</code>的隐式转换规则</h2><div class="note primary flat"><p>加号操作符，，不仅可以用作数字相加，还可以用作字符串拼接，仅当加号两边都是数字的到时候，进行的是加法运算，如果两边都是字符串，直接拼接，无需进行隐式转换。</p></div><ul><li>如果其中有一个是字符串，另外一个是<code>undefined</code>,<code>null</code>或者布尔型，则调用<code>toStirng</code>方法进行字符串拼接；如果是纯对象，数组，正则等。则默认调用对象的转换方法会存在优先级，然后再进行拼接。</li><li>如果其中有一个是数字，另外一个是<code>undefined</code>,<code>null</code>或者布尔型，则会将其转换成数字进行加法运算，对象同上一条规则。</li><li>如果其中一个是字符串，另一个是数字，则拼接。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span>        <span class="comment">// 3  常规情况</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="string">&#x27;2&#x27;</span>    <span class="comment">// &#x27;12&#x27; 常规情况</span></span><br><span class="line"><span class="comment">// 下面看一下特殊情况</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="literal">undefined</span>   <span class="comment">// &quot;1undefined&quot; 规则1，undefined转换字符串</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="literal">null</span>        <span class="comment">// &quot;1null&quot; 规则1，null转换字符串</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="literal">true</span>        <span class="comment">// &quot;1true&quot; 规则1，true转换字符串</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="number">1n</span>          <span class="comment">// &#x27;11&#x27; 比较特殊字符串和BigInt相加，BigInt转换为字符串</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">undefined</span>     <span class="comment">// NaN  规则2，undefined转换数字相加NaN</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">null</span>          <span class="comment">// 1    规则2，null转换为0</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">true</span>          <span class="comment">// 2    规则2，true转换为1，二者相加为2</span></span><br><span class="line"><span class="number">1</span> + <span class="number">1n</span>            <span class="comment">// 错误  不能把BigInt和Number类型直接混合相加</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="number">3</span>           <span class="comment">// &#x27;13&#x27; 规则3，字符串拼接</span></span><br></pre></td></tr></table></figure><h2 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a><code>null</code>和<code>undefined</code>的区别</h2><ul><li>首先<code>undefined</code>和<code>null</code>都是基本数据类型，这两个基本数据类型分别都只有一个值。就是<code>undefined</code>和<code>null</code></li><li><code>undefined</code>代表的含义是未定义，<code>null</code>代表的含义是空对象，其实不是真的对象。一般变量声明了还没有定义的时候是<code>undefined</code>，<code>null</code>主要用于赋值给一些可能返回对象的变量，作为初始化。</li></ul><div class="note primary flat"><p>其实null不是对象，虽然<code>typeof null</code>会输出<code>object</code>，但是这个只是js的历史遗留问题，000开头的是对象，null也是正好全0 所以判了是object 但实际不是</p></div><ul><li><code>undefined</code>在js中不是一个保留字，这意味着我们可以用<code>undefined</code>来作为一个变量名，but这样的做法非常的危险，他会影响我们对<code>undefined</code>值的判断。但我们可以通过一些方法获取安全的<code>undefined</code>值，比如说<code>void 0</code></li></ul><h1 id="This"><a href="#This" class="headerlink" title="This"></a><code>This</code></h1><div class="note primary flat"><p>this指向调用其的对象。顺带一提，es6中的箭头函数没有<code>this</code>,<code>argument</code>,<code>super</code>等。这些只依赖包含箭头函数最接近的函数。</p></div><div class="note primary flat"><p>先来看适用场景</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">foo()<span class="comment">//指向window window没有a 输出undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo() <span class="comment">//指向obj 输出2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> foo() <span class="comment">//指向c new绑定了c c没有a 输出undefined</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p>箭头函数中的this</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a()()())</span><br><span class="line"><span class="comment">//箭头函数的this指向第一个包含他的普通函数的this这里是window</span></span><br></pre></td></tr></table></figure><ul><li>另外对箭头函数使用bind这类函数是没有用的</li><li>那么说到bind 有没有考虑过一个函数多次bind的结果是什么？</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>) &#125;</span><br><span class="line">fn.bind().bind(a)() <span class="comment">// =&gt; window</span></span><br><span class="line"><span class="comment">//可以发现给函数bind几次 fn中的this永远由第一次bind决定</span></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="comment">// fn.bind().bind(a) 等于</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply()</span><br><span class="line">  &#125;.apply(a)</span><br><span class="line">&#125;</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>this的绑定优先级如下：<br><code>new</code>最高，然后是<code>bind</code>，之后是<code>obj.foo()</code> 最后是<code>foo()</code> 同时<code>this</code>一旦被绑定，就不会被任何方式改变。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220331091103.png" alt=""></p><p>因为满足不了业务需求 所以产生了三种方式让我们手动改变this的指向<code>call apply bind</code></p><h1 id="apply-call-bind-原理"><a href="#apply-call-bind-原理" class="headerlink" title="apply/call/bind 原理"></a>apply/call/bind 原理</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220331091536.png" alt=""></p><div class="note primary flat"><p>这三个方法都是挂载在Function对象上的三个方法，调用这三个方法的必须是一个函数。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func.call(thisArg, param1, param2, ...)</span><br><span class="line">func.apply(thisArg, [param1,param2,...])</span><br><span class="line">func.bind(thisArg, param1, param2, ...)</span><br></pre></td></tr></table></figure><ul><li>在浏览器中，全局范围内的this指向window对象</li><li>在函数中，this永远指向最后调用它的那个对象</li><li>构造函数中，this指向被new出来的新对象</li><li><code>call apply bind</code>中的this被强绑定在指定的那个对象上</li><li>箭头函数中的this比较特殊。箭头函数this作为父作用域的this，不是调用时的this，要知道前四种方式都是调用时确定，也就是动态的，然而箭头函数的this是静态的，声明的时候就确定了下来。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220331092027.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value)</span><br><span class="line">&#125;</span><br><span class="line">getValue.call(a, <span class="string">&#x27;poe&#x27;</span>, <span class="string">&#x27;24&#x27;</span>)</span><br><span class="line">getValue.apply(a, [<span class="string">&#x27;poe&#x27;</span>, <span class="string">&#x27;24&#x27;</span>])</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化</p></div><h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><div class="note primary flat"><p>用<code>Object.prototype.toStirng</code>来判断类型是最合适的，借用它我们几乎可以判断所有类型的数据。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="keyword">typeof</span> obj;</span><br><span class="line">  <span class="keyword">if</span>(type!==<span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).replace(<span class="regexp">/^$/</span>,<span class="string">&#x27;$1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类数组借用方法"><a href="#类数组借用方法" class="headerlink" title="类数组借用方法"></a>类数组借用方法</h2><div class="note primary flat"><p>var arrayLike = {<br>  0: ‘java’,<br>  1: ‘script’,<br>  length: 2<br>}<br>Array.prototype.push.call(arrayLike, ‘jack’, ‘lily’);<br>console.log(typeof arrayLike); // ‘object’<br>console.log(arrayLike);<br>// {0: “java”, 1: “script”, 2: “jack”, 3: “lily”, length: 4}</p></div><div class="note primary flat"><p>用call方法来借用Array原型链上面的push方法 实现一个类数组的push方法，给arrayLike添加元素</p></div><h2 id="获取数组最大值-最小值"><a href="#获取数组最大值-最小值" class="headerlink" title="获取数组最大值/最小值"></a>获取数组最大值/最小值</h2><div class="note primary flat"><p>我们可以用apply来实现数组中判断最大最小值，apply直接传递数组作为调用方法的参数。也可以减少一步展开数组，直接使用Math的方法来获取最大最小。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">13</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>];</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, arr); </span><br><span class="line"><span class="keyword">const</span> min = <span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, arr);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(max);  <span class="comment">// 16</span></span><br><span class="line"><span class="built_in">console</span>.log(min);  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h2 id="实现一个bind函数"><a href="#实现一个bind函数" class="headerlink" title="实现一个bind函数"></a>实现一个bind函数</h2><p>对于实现以下几个函数，可以从几个方面思考。</p><ul><li>不传入第一个参数，那么默认为window</li><li>改变了this指向，让新的对象可以执行该函数，那么思路是否可以变成给新的对象添加一个函数 最后执行完再删除。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否是new 是的话变成指向function 否则指向context</span></span><br><span class="line">        <span class="keyword">var</span> _this = <span class="built_in">this</span> <span class="keyword">instanceof</span> self ? <span class="built_in">this</span> : context;</span><br><span class="line">        <span class="comment">//改变f的原型链</span></span><br><span class="line">        F.prototype = self.prototype;</span><br><span class="line">        <span class="keyword">return</span> self.apply(_this, args.concat(...arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个call函数"><a href="#实现一个call函数" class="headerlink" title="实现一个call函数"></a>实现一个call函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(args)</span><br><span class="line">  <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个apply函数"><a href="#实现一个apply函数" class="headerlink" title="实现一个apply函数"></a>实现一个apply函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myapply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">Symbol</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line">    context[key] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> result = context[key](...args);</span><br><span class="line">    <span class="keyword">delete</span> context[key];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h1><div class="note primary flat"><p>当执行js代码的时候，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数的代码会产生函数执行环境，只此两种执行环境。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b() <span class="comment">// call b</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;Hello world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;call b&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>上面的输出是因为变量提升。通常的解释是声明的代码移动到顶部。但更准确的解释是，在生成执行环境时，会有两个阶段，一个是创建阶段:js解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为undefined，所以在第二个阶段，也就是代码执行阶段，我们可以提前使用。</p></div><ul><li>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b() <span class="comment">// call b second</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;call b fist&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;call b second&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;Hello world&#x27;</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p><code>var</code>会产生很多错误，所以在es6中引入了<code>let</code>，它不能在声明前使用，但并不是说它没有提升，他有提升，且也在声明的时候开辟了内存，但因为它的这个特性导致它不能在声明前使用。</p></div><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><div class="note primary flat"><p>当执行js代码的时候，会产生三种执行上下文</p></div><ul><li>全局执行上下文</li><li>函数执行上下文</li><li><code>eval</code>执行上下文</li></ul><div class="note primary flat"><p>每个执行上下文都有三种重要属性</p></div><ul><li>变量对象（VO),包含变量，函数声明和函数的形参，该属性只能在全局上下文中访问。</li><li>作用域链，js采用词法作用域链，也就是说变量的作用域是在定义的时候决定了。</li><li><code>this</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>对于上述代码代码中，执行栈中有两个上下文：全局上下文和函数foo上下文</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack = [</span><br><span class="line">    globalContext,</span><br><span class="line">    fooContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>对于全局上下文来说，VO大概是这样的</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">globalContext.VO === globe</span><br><span class="line">globalContext.VO = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="literal">undefined</span>,</span><br><span class="line"><span class="attr">foo</span>: &lt;<span class="built_in">Function</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>对于函数foo来说，VO不能访问，只能访问到活动对象AO</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fooContext.VO === foo.AO</span><br><span class="line">fooContext.AO &#123;</span><br><span class="line">    <span class="attr">i</span>: <span class="literal">undefined</span>,</span><br><span class="line"><span class="attr">b</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">arguments</span>: <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// arguments 是函数独有的对象(箭头函数没有)</span></span><br><span class="line"><span class="xml">// 该对象是一个伪数组，有 `length` 属性且可以通过下标访问元素</span></span><br><span class="line"><span class="xml">// 该对象中的 `callee` 属性代表函数本身</span></span><br><span class="line"><span class="xml">// `caller` 属性代表函数的调用者</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p>IIFE注意事项</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo = <span class="number">10</span></span><br><span class="line">    <span class="built_in">console</span>.log(foo)</span><br><span class="line">&#125;()) <span class="comment">// -&gt; ƒ foo() &#123; foo = 10 ; console.log(foo) &#125;</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p>js解释器在遇到IIFE的时候，会创建一个辅助的特定对象，然后将函数的名称（这里是foo）作为这个特定对象的属性。因此函数内部才可以访问到foo，但这个值是只读的，所以我们并不能修改 也不能像这样对他赋值改变，所以最后打印的还是这个函数，并且外部的值也没有改变</p></div><p>总结<br><div class="note primary flat"><p>执行上下文可以简单理解为一个对象</p></div></p><p>它包含三个部分</p><ul><li>变量对象VO</li><li>作用域链 词法作用域</li><li>this指向</li></ul><p>它的类型</p><ul><li>全局执行上下文</li><li>函数执行上下文</li><li><code>eval</code>执行上下文</li></ul><p>代码执行的过程</p><ul><li>创建全局执行上下文 （global EC）</li><li>全局执行上下文(caller)逐行 自上而下执行。遇到函数的时候，函数执行上下文(callee)被push到执行栈顶层</li><li>函数执行上下文被激活后，成为<code>active EC</code> 开始执行函数中的代码，<code>caller</code>被挂起</li><li>函数执行完后，<code>callee</code>被pop出执行栈，控制权还给全局上下文(caller)继续执行</li></ul><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><ul><li>作用域：作用域就是定义变量的区域，他有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找</li><li>作用域链：作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数</li></ul><div class="note primary flat"><p>作用域链本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象</p></div><ul><li>当我们查找一个变量的时候，如果在当前执行环境中没有找到，我们可以沿着作用域链向后查找</li><li>作用域链的创建过程和执行上下文的建立有关。</li></ul><div class="note primary flat"><p>作用域可以理解为变量的可访问性 总共分为三种类型 分别为：</p></div><ul><li>全局作用域</li><li>函数作用域</li><li>块级作用域</li></ul><h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><div class="note primary flat"><p>全局变量是挂载在window对象下的变量，所以在网页中的任何位置都可以使用并且访问到这个全局变量。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalName = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(globalName) <span class="comment">// global</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;inner&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(name) <span class="comment">// inner</span></span><br><span class="line">&#125; </span><br><span class="line">getName();</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// </span></span><br><span class="line"><span class="built_in">console</span>.log(globalName); <span class="comment">//global</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  vName = <span class="string">&#x27;setName&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">setName();</span><br><span class="line"><span class="built_in">console</span>.log(vName); <span class="comment">// setName</span></span><br></pre></td></tr></table></figure><ul><li>全局变量在什么地方可以被访问到</li><li>但是可能会引起命名冲突的问题，所以定义变量的时候注意作用域</li></ul><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><div class="note primary flat"><p>函数中定义的变量叫做函数变量，这个时候只有在函数内部才能访问到它，所以它的作用域也就是函数的内部称为函数作用域</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;inner&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">//inner</span></span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>除了这个函数内部，其他地方都是不能访问到它的，同时当这个函数被执行完之后，这个局部变量也会相应被销毁，所以外面访问不到这个局部变量</p></div><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><div class="note primary flat"><p>es6新增了块级作用域，直接的表现就是let关键字。使用它定义的变量只能在块级作用域中被访问。有暂时性死区的特点。也就是说这个变量在定义之前是不能被使用的。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//a is not defined</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&#x27;123&#x27;</span>；</span><br><span class="line">  <span class="built_in">console</span>.log(a)； <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//a is not defined</span></span><br><span class="line"><span class="comment">//如果这里是var 那么结果就是三个123</span></span><br></pre></td></tr></table></figure><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><div class="note primary flat"><p>闭包其实就是一个可以访问其他函数内部变量的函数。创建闭包的常见方式是在一个函数内创建另外一个函数，创建的函数可以访问到当前函数的局部变量。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br><span class="line"><span class="keyword">var</span> result = fun1();</span><br><span class="line">result();  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合闭包的概念，我们把这段代码放到控制台执行一下，就可以发现最后输出的结果是 1（即 a 变量的值）。那么可以很清楚地发现，a 变量作为一个 fun1 函数的内部变量，正常情况下作为函数内的局部变量，是无法被外部访问到的。但是通过闭包，我们最后还是可以拿到 a 变量的值</span></span><br></pre></td></tr></table></figure><h2 id="闭包的两个常用的用途"><a href="#闭包的两个常用的用途" class="headerlink" title="闭包的两个常用的用途"></a>闭包的两个常用的用途</h2><ul><li>闭包的第一个用途是使我们在函数外部能够访问到内部的变量。</li><li>另外一个用途是使得已经允许结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象 的引用，所以这个变量对象不会被回收。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// fn 是闭包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="comment">// 这里也是闭包</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn2 = fn1()</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure><h2 id="闭包产生的原因"><a href="#闭包产生的原因" class="headerlink" title="闭包产生的原因"></a>闭包产生的原因</h2><div class="note primary flat"><p>闭包产生的本质是：当前环境中存在指向父级作用域的引用。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">//2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fun2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = fun1();</span><br><span class="line">result();</span><br></pre></td></tr></table></figure><ul><li>在上面这段代码中，我们知道，result会拿到父级作用域的变量输出2。因为在当前的环境中，含有对fun2函数的引用，而fun2中又引用了window和fun1，fun2，那么此时fun2可以访问到fun1中的2 那么就输出2</li><li>那是不是只有返回函数才算是产生了闭包？其实不是，回到闭包的本质。我们只需要让父级作用域的引用存在即可。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun3;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  fun3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br><span class="line">fun3();</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>可以看出其中输出的结果还是2 因为在给fun3赋值的时候，fun3就可以访问到window fun1和本身的作用域，然后由下往上查找 找到了fun1中的2 输出2</p></div><p>结论：<br>不能通过最后有没有返回函数来判断闭包。</p><h2 id="闭包的表现形式"><a href="#闭包的表现形式" class="headerlink" title="闭包的表现形式"></a>闭包的表现形式</h2><ol><li>返回一个函数</li><li>在定时器，事件监听，ajax请求，webworkers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时器</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;，<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">$(<span class="string">&#x27;#app&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Event Listener&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>作为函数参数传递的形式<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(baz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 这就是闭包</span></span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 输出2，而不是1</span></span><br></pre></td></tr></table></figure></li><li>IIFE创建了闭包 保存了全局作用域window和当前函数的作用域。因此可以输出全局作用域的变量。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">// 输出2</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IIFE 这个函数会稍微有些特殊，算是一种自执行匿名函数，这个匿名函数拥有独立的作用域。这不仅可以避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域，我们经常能在高级的 JavaScript 编程中看见此类函数。</span><br></pre></td></tr></table></figure><h2 id="如何解决循环输出问题？"><a href="#如何解决循环输出问题？" class="headerlink" title="如何解决循环输出问题？"></a>如何解决循环输出问题？</h2><div class="note primary flat"><p>code如下</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现 最后的结果是五个6 那么为什么是五个6？如何实现输出12345？</p><ul><li>首先是事件循环机制 同步任务执行完之后再去执行任务栈中的宏任务微任务，settimeout是宏任务，因此循环结束后它的回调才依次执行。</li><li>因为settimeout是一种闭包，往上查找它的父级作用域是window，而变量i是var声明，是window对象上面的全局变量，所以开始执行settimeout的时候i已经是6了 所以最后连续输出的都是6</li></ul><div class="note primary flat"><p>那么如何依次输出12345呢？</p></div><ol><li>利用IIFE <div class="note primary flat"><p>可以利用IIFE 每次for循环的时候把此时的变量传递到定时器里面，然后执行。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>利用es6的let<div class="note primary flat"><p>let有块级作用域，代码以块级执行 相当于任务每次都是等待块级执行完再执行下一个块级</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>利用定时器传入第三个参数<div class="note primary flat"><p>定时器的第三个参数是传入的值，可以是一个function</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j)</span><br><span class="line">  &#125;, <span class="number">0</span>,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="New的原理"><a href="#New的原理" class="headerlink" title="New的原理"></a>New的原理</h1><h2 id="常见考点"><a href="#常见考点" class="headerlink" title="常见考点"></a>常见考点</h2><ul><li>new做了什么事情？</li><li>new返回不同的类型时有声明表现？</li><li>手写new的实现过程<div class="note primary flat"><p>new关键字的主要作用就是执行一个构造函数，返回一个实例对象，在new的过程中，根据构造函数的情况，来确定是否可以接收参数的传递。下面见例子。</p></div></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.log(p.name)  <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure><p>p是通过person这个构造函数生成的一个实例对象。</p><div class="note primary flat"><p>new可以帮助我们构建出一个实例，并且绑定上this，执行的步骤为以下：</p></div><ol><li>创建一个新的对象</li><li>将对象连接到构造函数原型上，并绑定this this指向新对象</li><li>执行构造函数的代码（为这个新对象添加属性）</li><li>返回新对象</li></ol><p>在第四步返回新对象的时候会有一个情况例外：<br><div class="note primary flat"><p>如果不用new关键字会怎么样？</p></div></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = Person();</span><br><span class="line"><span class="built_in">console</span>.log(p) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// &#x27;name&#x27; of undefined</span></span><br></pre></td></tr></table></figure><ul><li>从上面的代码可以看出，不用new 结果是undefined。因为默认情况下this指向window 所以name是Jack </li><li>那么如果构造函数中return一个对象，结果会是怎么样呢？</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&#x27;Jack&#x27;</span>; </span><br><span class="line">   <span class="keyword">return</span> &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.log(p)  <span class="comment">// &#123;age: 18&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p.age) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p>通过这段代码可以看出，当构造函数最后return出来的是一个和this无关的对象的时候，new会直接返回这个对象，而不是通过new执行步骤生成的this对象</p></div><p>但如果这里构造函数返回的不是一个对象 还是会按照new的原则返回新生成的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&#x27;Jack&#x27;</span>; </span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;tom&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.log(p)  <span class="comment">// &#123;name: &#x27;Jack&#x27;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p>总结：new关键字执行之后返回一个对象，要么是实例对象，要不是return语句指定的对象</p></div><h2 id="手写new的实现过程"><a href="#手写new的实现过程" class="headerlink" title="手写new的实现过程"></a>手写new的实现过程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">fn,...args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> fn != <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//我们知道obj.__proto__ = fn.prototype的</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">  <span class="keyword">var</span> res = fn.apply(obj,args);</span><br><span class="line">  <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用<code>Object.create</code>创建一个空对象并将obj的proto指定为构造函数原型</li><li>使用apply方法 将构造函数内的this指向为obj</li><li>在create返回的时候使用三目运算符决定返回结果</li></ol><h1 id="原型、原型链"><a href="#原型、原型链" class="headerlink" title="原型、原型链"></a>原型、原型链</h1><p><code>__proto__</code>和prototype的关系：<code>__proto__</code>和<code>constructor</code>是对象独有的，<code>prototype</code>是函数独有的。</p><div class="note primary flat"><p>在js中我们使用构造函数来新建一个对象，每一个构造函数的内部都有一个prototype属性，这个属性是一个对象，这个对象包含了可以由该构造函数的所有实例共享的方法和属性。当我们使用构造函数新建一个对象之后，在这个对象的内部将包含一个指针，这个指针指向构造函数的prototype属性对应的值，在es5中这个指针被称为对象的原型。一般来说不能获取到这个值，但是浏览器下载都实现了<code>proto</code>属性让我们来访问，但是最好是不要使用这个属性，因为他不是规范的，最好使用<code>Object.getPrototypeOf()</code>来获取对象的原型</p></div><p>当我们访问一个对象的属性的时候，如果这个对象内部不存在这个属性，那么他就会去他的原型对象里面找这个属性，这个原型对象又会有自己的原型，于是就一直找下去，也就是原型链的概念。原型链的尽头一般来说是<code>Object.prototype</code>所以这就是我们新建的对象为什么能够使用<code>toString</code>等方法的原因</p><div class="note primary flat"><p>特点：js的对象都是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型的时候，与之相关的对象也会继承这一改变。</p></div><ul><li>原型，一个简单的对象，用于实现对象的属性继承。</li><li>构造函数 可以通过new来创建对象的一个函数</li><li>实例 通过构造函数和new创建出来的对象。通过<code>__proto__</code>指向原型，通过<code>constructor</code>指向构造函数。</li></ul><div class="note primary flat"><p>以<code>Object</code>为例，他是一个构造函数，因此可以用它创建实例</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>则此时， 实例为instance, 构造函数为Object，我们知道，构造函数拥有一个prototype的属性指向原型，因此原型为:</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型</span></span><br><span class="line"><span class="keyword">const</span> prototype = <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure><p>三者关系：</p><ul><li><code>实例.__proto__ === 原型</code></li><li><code>原型.constructor === 构造函数</code></li><li><code>构造函数.prototype = 原型</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402093146.png" alt=""></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><div class="note primary flat"><p>原型链是由原型对象组成，每个对象都有<code>__proto__</code>属性，指向了创建该对象的构造函数的原型。<code>__proto__</code>将对象连接起来组成了原型链，是一个用来实现继承和共享属性的有限的对象链。</p></div><ul><li>属性查找机制：当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象<code>Object.prototype</code>，如还是没找到，则输出<code>undefined</code>；</li><li>属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: <code>b.prototype.x = 2</code>；但是这样会造成所有继承于该对象的实例的属性发生改变。</li></ul><h2 id="js获取原型的方法"><a href="#js获取原型的方法" class="headerlink" title="js获取原型的方法"></a>js获取原型的方法</h2><ul><li><code>p.__proto__</code></li><li><code>p.constructor.prototype</code></li><li><code>Object.getPrototypeOf(p)</code></li></ul><p>另外：</p><ul><li>每个函数都有<code>prototype</code>属性，除了<code>Function.prototype.bind()</code> 该属性指向原型。</li><li>每个对象都有<code>__proto__</code>属性，指向了创建该对象的构造函数的原型</li><li>对象可以通过<code>__proto__</code>来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了原型链。</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402094159.png" alt=""><br><div class="note primary flat"><p>涉及面试题：原型如何实现继承？class如何实现继承？class本质</p></div><br>首先讲一下class，其实在js中不存在类，class只是语法糖，本质还是函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line">Person <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><div class="note primary flat"><p>组合继承是最常用的继承方式</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = value;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//通过call的方式来继承父类的属性(调用构造x1)</span></span><br><span class="line">    Parent.call(<span class="built_in">this</span>,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过改变子类的原型来继承父类的函数（x2 此时继承了构造函数，多了不必要的属性）</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> children = <span class="keyword">new</span> Child(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">children.getValue()</span><br><span class="line"><span class="built_in">console</span>.log(children <span class="keyword">instanceof</span> Parent)<span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>通过call来继承父类的属性，然后改变子类的原型来继承父类的函数。</li><li>优点：构造函数可以传参，不会和父类引用属性共享，可以复用父类的函数。</li><li>缺点：继承父类的时候调用了两次父类的构造函数，把父类不必要的属性也给继承了。内存上面浪费</li></ul><h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><div class="note primary flat"><p>这种方法对组合继承进行了优化，组合继承的缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点即可。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.val = value</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>,value);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype,&#123;</span><br><span class="line">  <span class="attr">constructor</span>:&#123;</span><br><span class="line">    <span class="attr">value</span>:Child,</span><br><span class="line">    <span class="attr">enumerable</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line">child.getValue();</span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Parent)</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>以上继承将父类的原型赋值给了子类，并且将构造函数设置成了子类，这样解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p></div><h2 id="Class继承"><a href="#Class继承" class="headerlink" title="Class继承"></a>Class继承</h2><div class="note primary flat"><p>以上两种方式都是通过原型去解决的，在es6中我们可以通过class去实现继承，并且实现起来很简单</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(value)</span><br><span class="line">    <span class="built_in">this</span>.val = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line">child.getValue();</span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Parent)</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>class实现继承的核心在于使用extends表明继承自哪个父类，并且在子类构造函数中必须调用super<br>super可以看作<code>Parent.call(this,value)</code></p></div><div class="note warning flat"><p>其实这样做还是有缺陷的，比如父类的静态方法还是不能继承。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寄生组合继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = value</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.val)</span><br><span class="line">&#125;</span><br><span class="line">Parent.staticMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是静态&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, value);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: Child,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line">child.getValue();</span><br><span class="line"><span class="comment">//Child.staticMethod()//报错</span></span><br><span class="line">Parent.staticMethod()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而class继承则可以<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">caseA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我是静态&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(value)</span><br><span class="line">    <span class="built_in">this</span>.val = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line">child.getValue();</span><br><span class="line">Child.caseA()</span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Parent)</span><br></pre></td></tr></table></figure></p><h2 id="其他继承"><a href="#其他继承" class="headerlink" title="其他继承"></a>其他继承</h2><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="对象遍历"><a href="#对象遍历" class="headerlink" title="对象遍历"></a>对象遍历</h2><ol><li><code>for in</code></li><li><code>Object.keys(xxx)</code>把key取出来作为一个数组。</li><li><code>Object.values(xxx)</code>遍历对象的值作为一个数组<h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2></li></ol><ul><li>基本思想是使用对象，类，继承，封装等基本概念来进行程序设计</li><li>优点：<ul><li>易维护：采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，维护也只是在局部模块，所以维护起来非常方便，成本较低</li><li>易拓展</li><li>开发工作的重用性，继承性高，降低重复工作量</li><li>缩短了开发周期<div class="note primary flat"><p>一般面向对象包括：继承，封装，多态，抽象</p></div></li></ul></li></ul><h2 id="对象形式的继承"><a href="#对象形式的继承" class="headerlink" title="对象形式的继承"></a>对象形式的继承</h2><div class="note primary flat"><p>讲深浅拷贝之前，我们需要知道，基本数据类型在栈里面，被复制了就算修改也不会改变原来的的值，引用数据类型在堆里面，因为共享内存所以复制后被修改会改变源对象的值，至此引申出深浅拷贝。</p></div><ul><li>浅拷贝<div class="note primary flat"><p>基本的浅拷贝就是对象的赋值，但我们需要注意，实际上我们的需求是复制源对象上面的属性，那么单纯的赋值，会把新对象的值给覆盖掉。参见下面</p></div></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;allin&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">home</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">        <span class="attr">office</span>: <span class="string">&#x27;office&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">sclools</span>: [<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;z&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> programer = &#123;</span><br><span class="line">    <span class="attr">language</span>: <span class="string">&#x27;js&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果不使用该方法 programmer里面的language会被覆盖掉</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">p, c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = c || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> prop <span class="keyword">in</span> p)&#123;</span><br><span class="line">        c[prop] = p[prop];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">extend(Person, programer);</span><br><span class="line"><span class="comment">//or </span></span><br><span class="line"><span class="comment">// programer = Object.assign(programer,Person);</span></span><br><span class="line">programer.name;  <span class="comment">// allin</span></span><br><span class="line">programer.address.home;  <span class="comment">// home</span></span><br><span class="line">programer.address.home = <span class="string">&#x27;house&#x27;</span>;  <span class="comment">//house</span></span><br><span class="line">Person.address.home;  <span class="comment">// house</span></span><br><span class="line"><span class="comment">//programmer依旧保留自己的language</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>注意 浅拷贝不是新对象的地址指向整个旧对象的地址，而是拷贝旧对象的属性的地址。即自己原先的内容不变，拷贝的过程中如果key重复覆盖，否则保留。<br>思路是遍历对象 赋值。</p></div><p>深拷贝<br><div class="note primary flat"><p>深拷贝是开辟一个新的内存地址，将源对象的各个属性复制进去<br>注意的点：对象原型上面的属性不应该去拷贝，使用到<code>Object.hasOwnProperty(key)</code></p></div></p><ol><li>通过<code>JSON.parse(JSON.stringfy())</code>进行深拷贝</li></ol><ul><li>是序列化和反序列化的过程，序列化是存储地址的一个映射，所以反序列化之后，修改并不会影响原先的地址。就可以达成深拷贝。</li><li>缺点：不能拷贝<code>undefined function 正则 Error对象</code></li></ul><ol><li>递归</li></ol><ul><li>通过判断引用类型数据进行初始化之后赋值的操作指向新的地址。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断是否是引用类型或者null 否则返回源对象进行浅拷贝</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>||obj===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是数组，初始化地址。</span></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        result = [];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归调用 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            result[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li>缺点：栈会溢出。</li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul><li>命名空间<ul><li>js是没有命名空间的，因此可以用对象来模拟</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = &#123;&#125;<span class="comment">//命名空间app</span></span><br><span class="line"><span class="comment">//模块1</span></span><br><span class="line">app.module1 = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;allin&#x27;</span>,</span><br><span class="line">  <span class="attr">f</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">app.module1.name;</span><br><span class="line">app.module1.f();</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>对象的属性外界是可读可写的，那么如何达到封装的目的？通过闭包和局部变量</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Girl</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//通过方法访问变量</span></span><br><span class="line">  <span class="keyword">var</span> love = <span class="string">&#x27;jojo&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.name =name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> love;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.movelove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    love = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Girl(<span class="string">&#x27;bb&#x27;</span>,<span class="number">19</span>);</span><br><span class="line">g.say();</span><br><span class="line">g.movelove();</span><br><span class="line">g.say();</span><br></pre></td></tr></table></figure><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><div class="note primary flat"><p>就是在函数外面定义静态方法，静态方法只有该类能够使用。</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员</span></span><br><span class="line">Person.walk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;static&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Person.walk();  <span class="comment">// static</span></span><br></pre></td></tr></table></figure><h2 id="私有与公有"><a href="#私有与公有" class="headerlink" title="私有与公有"></a>私有与公有</h2><div class="note primary flat"><p>对象的方法和属性分为私有和公有，公有的属性需要在实例化的时候传入对应的值去调用，私有的属性和方法只能通过公有的方法暴露出去。注意私有的方法如果返回的是公有的属性，还需要使用call改变this指向</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 私有属性与方法</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;allin&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//公有属性与方法</span></span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;say hello&#x27;</span>);</span><br><span class="line">        work.call(<span class="built_in">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="number">123</span>);</span><br><span class="line">p1.name; <span class="comment">// undefined</span></span><br><span class="line">p1.id;  <span class="comment">// 123</span></span><br><span class="line">p1.say();  <span class="comment">// say hello 123</span></span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><div class="note primary flat"><p>同一个父类继承出来的子类有各自的形态,写的时候注意<code>子类,prototype = new 父类()</code></p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.eat = <span class="string">&#x27;肉&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tiger</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.color = <span class="string">&#x27;黑黄相间&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cheetah</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.color = <span class="string">&#x27;报文&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Lion</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.color = <span class="string">&#x27;土黄色&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tiger.prototype =  Cheetah.prototype = Lion.prototype = <span class="keyword">new</span> Cat();<span class="comment">//共享一个祖先 Cat</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> T = <span class="keyword">new</span> Tiger();</span><br><span class="line"><span class="keyword">var</span> C = <span class="keyword">new</span> Cheetah();</span><br><span class="line"><span class="keyword">var</span> L = <span class="keyword">new</span> Lion();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(T.color);</span><br><span class="line"><span class="built_in">console</span>.log(C.color);</span><br><span class="line"><span class="built_in">console</span>.log(L.color);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(T.eat);</span><br><span class="line"><span class="built_in">console</span>.log(C.eat);</span><br><span class="line"><span class="built_in">console</span>.log(L.eat);</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><div class="note primary flat"><p>虚函数是类成员中的概念，是只做了一个声明而未实现的方法，具有虚函数的类称之为抽象类。抽象类不能被实例化因为其中的虚函数并不是一个完整的函数，不能被调用。<br>在js中实现抽象类就是在父类中调用一个未定义的方法，但这个方法在子类中必须被实现。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AbstractClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象类不能直接被调用&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">AbstractClass.prototype.detect = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">AbstractClass.prototype.stop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;stop&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">AbstractClass.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NormalClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  NormalClass.prototype = <span class="built_in">Object</span>.create(AbstractClass.prototype);</span><br><span class="line">  NormalClass.prototype.constructor = NormalClass;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> NormalClass();</span><br><span class="line"><span class="built_in">console</span>.log(n)</span><br><span class="line">n.detect();</span><br><span class="line">n.init();</span><br></pre></td></tr></table></figure><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><ol><li>面向对象的三个基本特征</li><li>手写一下函数的公有和私有方法以及调用的形式<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;jojo&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">    sayName.call(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><div class="note primary flat"><p>事件的触发过程？事件代理？</p></div><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><div class="note primary flat"><p>事件流是一个事件沿着特定数据结构传播的过程。冒泡和捕获是事件流在DOM中的两种不同的传播方式。</p></div><h2 id="事件流的三个阶段"><a href="#事件流的三个阶段" class="headerlink" title="事件流的三个阶段"></a>事件流的三个阶段</h2><ul><li>事件捕获阶段</li><li>目标阶段</li><li>事件冒泡阶段</li></ul><h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><div class="note primary flat"><p>事件捕获通俗的理解就是鼠标点击或者触发dom事件的时候，浏览器从根节点开始由外到内的进行事件传播，即点击了子元素。如果父元素通过捕获方式注册了对应的事件的话，会先触发父元素绑定的事件</p></div><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><div class="note primary flat"><p>事件冒泡和事件捕获相反，顺序是由内到外直到根节点</p></div><p>无论是事件捕获还是冒泡，都有一个共同的特征就是事件传播<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220404101558.png" alt=""></p><h2 id="事件流阻止"><a href="#事件流阻止" class="headerlink" title="事件流阻止"></a>事件流阻止</h2><div class="note primary flat"><p>在一些情况下要阻止事件流的传播，阻止默认动作的发生</p></div><ul><li><code>event.preventDefault()</code>取消事件对象的默认动作以及继续传播</li><li><code>event.stopPropagation()/event.cancelBubble = true</code>阻止事件冒泡<h3 id="在不同浏览器的处理"><a href="#在不同浏览器的处理" class="headerlink" title="在不同浏览器的处理"></a>在不同浏览器的处理</h3></li><li>在IE下使用 <code>event.returnValue= false</code>，</li><li>在非IE下则使用 <code>event.preventDefault()</code>进行阻止<h3 id="preventDefault与stopPropagation的区别"><a href="#preventDefault与stopPropagation的区别" class="headerlink" title="preventDefault与stopPropagation的区别"></a><code>preventDefault</code>与<code>stopPropagation</code>的区别</h3></li><li><code>preventDefault</code>告诉浏览器不用执行与事件相关联的默认动作（如表单提交）</li><li><code>stopPropagation</code>是停止事件继续冒泡，但是对IE9以下的浏览器无效<h2 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h2></li><li>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 <code>false</code>。useCapture 决定了注册的事件是捕获事件还是冒泡事件</li><li>一般来说，我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件<div class="note warning flat"><p>注意<code>addEventListener</code>需要销毁，<code>onClick</code>则不需要因为每次都替换</p></div><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2></li><li>优化性能，当子节点过多的时候给父元素绑定事件通过冒泡只执行一次事件节省内存并且不需要给子节点注销事件。<h2 id="事件的兼容写法"><a href="#事件的兼容写法" class="headerlink" title="事件的兼容写法"></a>事件的兼容写法</h2><div class="note primary flat"><p>ie的event和非ie的event不太一样，也不能一起用</p></div></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gete</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//兼容ie的事件</span></span><br><span class="line">  e = e || <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="comment">//兼容ie的target</span></span><br><span class="line">  <span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><div class="note primary flat"><p>四种方案：commonjs，AMD，CMD，ES6</p></div><ul><li><p>CommonJS，node的，通过require来引入模块，通过<code>module.exports</code>定义输出接口。是以同步的方式引入模块的。</p></li><li><p>AMD是采用异步的方式加载模块，模块的加载不影响后面语句的执行 所有依赖这个模块的语句都定义在一个回调函数里面，等加载完再执行回调函数。requirejs实现了AMD规范</p></li><li>CMD方案，也是解决异步加载的委托。代表有seajs。和requirejs的区别在于模块定义的时候堆依赖的处理不同和对依赖模块的执行时机处理不同。</li><li>最后是es6的，通过import和export进行导入导出。默认暴露统一暴露分别暴露。<ul><li>默认暴露：<code>export default</code></li><li>分别暴露：<code>export xxx1;exportxxx2</code>，引入<code>import &#123;xxx1,xxx2&#125; from &#39;xxx&#39;</code></li><li>统一暴露：<code>export &#123;aa1,aa1&#125;</code>，引入<code>import &#123;aa1,aa2&#125; from &#39;xxx&#39;</code></li></ul></li></ul><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><ul><li>写法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.a;<span class="comment">//1</span></span><br></pre></td></tr></table></figure></li><li>注意浏览器中使用的话用<code>browserify</code><div class="note primary flat"><p>和es6的区别如下：</p></div></li><li>前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案,前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。</li><li>而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li><li>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。</li><li>但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li><li>后者会编译成 require/exports 来执行的</li></ul><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><div class="note primary flat"><p>和CMD的区别：</p></div><ul><li>对依赖的处理不一样。AMD是依赖前置。定义模块的时候就要声明依赖的模块，CMD就近依赖，用到哪个才去require</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>); <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐</span></span><br><span class="line">define([<span class="string">&quot;./a&quot;</span>, <span class="string">&quot;./b&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>对于依赖模块的执行实际处理不同。AMD和CMD异步加载，但是AMD在模块加载完就立刻执行依赖模块，依赖模块的执行顺序和我们写的顺序不一定一致。而CMD在依赖模块加载完成后并不执行，只是下载。等全部的依赖模块都加载好后，再去执行，和我们的书写顺序一致。</li></ul><h1 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h1><div class="note primary flat"><p>Iterator是一种接口，也可以说是一种规范，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。即依次处理该数据结构的所有成员</p></div><p>语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note primary flat"><p><code>[Symbol.iterator]</code>属性名是固定的写法，只要拥有了该属性的对象，就能用迭代器的方式进行遍历。</p></div></p><ul><li>迭代器的遍历方法是首先获得一个迭代器的指针。初始时该指针指向第一条数据之前，接着通过调用next方法，改变指针的指向，让他调用下一条数据。</li><li>每次的next都会返回一个对象 有两个属性<ul><li>value： 表示你想获取的数据</li><li>done：布尔值 代表遍历是否结束 true则结束<h2 id="iterator的作用"><a href="#iterator的作用" class="headerlink" title="iterator的作用"></a>iterator的作用</h2>三个作用</li></ul></li><li>创建一个指针对象指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的next方法 指针指向第二个成元</li><li>不断调用next 直到结束位置(假如有三个数据 需要next四次 最后一次的结果是<code>&#123; value: undefined, done: true &#125;</code>)<br>案例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123;<span class="attr">nums</span>:<span class="number">1</span>&#125;,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="built_in">Symbol</span>.iterator]();<span class="comment">//获取数组的迭代器</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: Object &#123; num: 1 &#125;, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h2 id="具有iterator接口的数据结构"><a href="#具有iterator接口的数据结构" class="headerlink" title="具有iterator接口的数据结构"></a>具有iterator接口的数据结构</h2><div class="note primary flat"><p>一个数据结构只要有iterator接口就能被认为是可以遍历的。可以用forof。</p></div>具有iterator接口的数据结构的有四种：</li></ul><ol><li>数组</li><li>类数组</li><li>Set</li><li>Map<h2 id="为什么对象没有iterator接口"><a href="#为什么对象没有iterator接口" class="headerlink" title="为什么对象没有iterator接口"></a>为什么对象没有iterator接口</h2></li></ol><ul><li>对象只能用forin和<code>Object.keys、values</code>遍历</li><li>因为一个对象的哪个属性先遍历和后便利是不确定的，需要开发者手动指定。</li><li>对对象部署iterator接口没有必要 因为map弥补了他的缺陷而且map有iterator接口<br>对对象部署iterator<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    <span class="attr">hobbie</span>: <span class="string">&#x27;睡觉&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keyArr = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> index&lt;keyArr.length?&#123;</span><br><span class="line">        <span class="attr">value</span>:&#123;</span><br><span class="line">          <span class="attr">key</span>:keyArr[index],</span><br><span class="line">          <span class="attr">val</span>:obj[keyArr[index++]]</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;:&#123;</span><br><span class="line">        <span class="attr">done</span>:<span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><div class="note primary flat"><p>谈到promise的时候，除了将他解决的痛点以及常用的api之外，最好进行拓展吧eventloop带进来好好讲一下。微任务，任务的指向顺序，如果看过promise源码，最好可以谈一谈原生promise是如何实现的，还有就是promise的链式调用</p></div><ul><li>promise是es6新增的语法，解决了回调地狱的问题</li><li>promise可以被看成是一个状态机，初始是<code>pending</code>可以通过函数<code>resolve</code>和<code>reject</code>将状态转变为<code>resolved</code>or<code>rejected</code>状态。状态一旦发生改变就不能再次变化。</li><li>then函数会返回一个promise实例，并且该返回值是一个新的实例而不是之前的实例。因为promise规范规定除了pending状态，其他状态是不能改变的。如果返回的是一个相同实例的话，多个then调用就失去了意义。对于then来说，本质上可以看成是flatMap</li></ul><h2 id="promise的基本情况"><a href="#promise的基本情况" class="headerlink" title="promise的基本情况"></a>promise的基本情况</h2><div class="note primary flat"><p>简单来说他是一个容器，里面保存着某个未来才会结束的事件，通常是异步操作的结果。从语法上面来说，promise是一个对象，从他可以获取异步操作的消息。</p></div><p>一般 Promise 在执行过程中，必然会处于以下几种状态之一。</p><ul><li>待定（pending）：初始状态，既没有被完成，也没有被拒绝。</li><li>已完成（fulfilled）：操作成功完成。</li><li>已拒绝（rejected）：操作失败。<div class="note primary flat"><p>待定状态的promise对象指向的话，最后要么会通过一个值完成，要么会通过一个原因被拒绝。当其中一种情况发生的时候，我们用promise的then方法排列起来的相关处理程序就会被调用。因为最后<code>Promise.prototype.then</code> 和 <code>Promise.prototype.catch</code>方法返回的是一个<code>Promise</code>所以它们可以继续被链式调用。</p></div>关于 Promise 的状态流转情况，有一点值得注意的是，内部状态改变之后不可逆，你需要在编程过程中加以注意。文字描述比较晦涩，我们直接通过一张图就能很清晰地看出 Promise 内部状态流转的情况<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220405105526.png" alt=""><h2 id="then-catch"><a href="#then-catch" class="headerlink" title="then catch"></a>then catch</h2></li><li>thencatch都会返回一个新的promise</li><li>catch不管放在哪里都能捕获上层未捕获的错误</li><li>不写默认返回<code>return Promise.resolve(undefined)</code>也是成功回调</li><li>直接return 一个error对象不会抛出错误 所以不会被catch捕获</li><li>返回的值不能是promise本身 否则死循环</li><li>then可以接收两个参数的，在某些时候你可以认为catch是then第二个参数的简便写法。<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2></li><li>不管最后的状态如何都会执行</li><li>不接受任何参数 所以在finally中是没办法知道最终的状态的</li><li>默认返回上一次的promise对象值，如果抛出的是一个异常则返回异常的promise对象</li></ul><h2 id="new-Promise（大坑）"><a href="#new-Promise（大坑）" class="headerlink" title="new Promise（大坑）"></a><code>new Promise</code>（大坑）</h2><p>先看一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    reject()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;失败的状态&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><br>正确答案是1243<br>这是为什么呢？因为我们会忽略一个问题，就是在<code>new Promise</code>的时候，构造器的方法就已经开始执行了，虽然我们一般提倡用函数封装之后<code>return</code>出去这个promise对象。所以就是先执行<code>new Promise</code>里面的代码 输出12然后状态到<code>resolved</code>然后执行同步的4 最后因为成功的回调到3</p><h2 id="promise的静态方法"><a href="#promise的静态方法" class="headerlink" title="promise的静态方法"></a>promise的静态方法</h2><h3 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h3><ul><li>语法:<code>Promise.all(iterable)</code></li><li>参数：一个可迭代对象，例如Array（括号里面放数组）</li><li>描述：此方法对于汇总多个promise的结果很有用，在es6中可以将多个<code>Promise.all</code>异步请求并发操作，返回的结果一般有下面两种情况。<ol><li>当所有结果成功返回按照请求顺序返回成功结果</li><li>当其中一个方法失败就进入失败方法。</li></ol></li><li>业务场景 </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个页面中需要加载获取轮播列表、获取店铺列表、获取分类列表这三个操作，页面需要同时发出请求进行页面渲染，这样用 `Promise.all` 来实现，看起来更清晰、一目了然。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获取轮播数据列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBannerList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;轮播数据&#x27;</span>)</span><br><span class="line">      &#125;,<span class="number">300</span>) </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.获取店铺列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStoreList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">&#x27;店铺数据&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">500</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.获取分类列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCategoryList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">&#x27;分类数据&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">700</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initLoad</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">Promise</span>.all([getBannerList(),getStoreList(),getCategoryList()])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) </span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; </span><br><span class="line">initLoad()</span><br></pre></td></tr></table></figure><h4 id="all如果有一个抛出了异常会如何处理。"><a href="#all如果有一个抛出了异常会如何处理。" class="headerlink" title="all如果有一个抛出了异常会如何处理。"></a>all如果有一个抛出了异常会如何处理。</h4><div class="note primary flat"><p>all和race传入的数组中如果会有抛出异常的异步任务，那么只有最先抛出的错误会被捕获。并且是被then的第二个参数或者后面的catch捕获，但并不影响数组中其他的异步任务的执行。</p></div><h4 id="all是并发的还是串行的"><a href="#all是并发的还是串行的" class="headerlink" title="all是并发的还是串行的"></a>all是并发的还是串行的</h4><div class="note primary flat"><p>并发的。不过<code>promise.all().then()</code>结果中数组的顺序和<code>Promise.all()</code>接收到的数组顺序一致</p></div><h4 id="all的并发限制"><a href="#all的并发限制" class="headerlink" title="all的并发限制"></a>all的并发限制</h4><div class="note primary flat"><p>Promise.all可以保证，promises数组中所有promise对象都达到resolve状态，才执行then回调。</p><p>这时候考虑一个场景：如果你的promises数组中每个对象都是http请求，或者说每个对象包含了复杂的调用处理。而这样的对象有几十万个。</p><p>那么会出现的情况是，你在瞬间发出几十万http请求（tcp连接数不足可能造成等待），或者堆积了无数调用栈导致内存溢出。</p><p>这时候，我们就需要考虑对Promise.all做并发限制。</p><p>Promise.all并发限制指的是，每个时刻并发执行的promise数量是固定的，最终的执行结果还是保持与原来的Promise.all一致。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncPool</span>(<span class="params">poolLimit, array, iteratorFn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line">    <span class="keyword">const</span> executing = [];</span><br><span class="line">    <span class="keyword">const</span> enqueue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 边界处理，array为空数组</span></span><br><span class="line">        <span class="keyword">if</span> (i === array.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每调一次enqueue，初始化一个promise</span></span><br><span class="line">        <span class="keyword">const</span> item = array[i++];</span><br><span class="line">        <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> iteratorFn(item, array));</span><br><span class="line">        <span class="comment">// 放入promises数组</span></span><br><span class="line">        ret.push(p);</span><br><span class="line">        <span class="comment">// promise执行完毕，从executing数组中删除</span></span><br><span class="line">        <span class="keyword">const</span> e = p.then(<span class="function">() =&gt;</span> executing.splice(executing.indexOf(e), <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 插入executing数字，表示正在执行的promise</span></span><br><span class="line">        executing.push(e);</span><br><span class="line">        <span class="comment">// 使用Promise.rece，每当executing数组中promise数量低于poolLimit，就实例化新的promise并执行</span></span><br><span class="line">        <span class="keyword">let</span> r = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">        <span class="keyword">if</span> (executing.length &gt;= poolLimit) &#123;</span><br><span class="line">            r = <span class="built_in">Promise</span>.race(executing);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归，直到遍历完array</span></span><br><span class="line">        <span class="keyword">return</span> r.then(<span class="function">() =&gt;</span> enqueue());</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> enqueue().then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.all(ret));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allSettled方法"><a href="#allSettled方法" class="headerlink" title="allSettled方法"></a><code>allSettled</code>方法</h3><ul><li><code>Promise.allSettled</code>的语法及参数跟<code>Promise.all</code>类似.不同在于它执行完之后不会失败，会按顺序返回每个promise的状态</li><li>案例</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="built_in">Promise</span>.allSettled([resolved, rejected]);</span><br><span class="line">allSettledPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回结果：</span></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 2 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><h3 id="any方法-还在草案不能使用"><a href="#any方法-还在草案不能使用" class="headerlink" title="any方法(还在草案不能使用)"></a>any方法(还在草案不能使用)</h3><ul><li>语法：<code>Promise.any（iterable）</code></li><li>参数： iterable 可迭代的对象，例如 Array。</li><li>描述：any返回一个promise 只要参数promise实例中有一个变成fulfilled状态，最后any返回的实例就返回fulfilled状态，如果全部都是rejected，就返回rejected状态<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> anyPromise = <span class="built_in">Promise</span>.any([resolved, rejected]);</span><br><span class="line">anyPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回结果：</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="race方法"><a href="#race方法" class="headerlink" title="race方法"></a>race方法</h3><ul><li>语法：<code>Promise.race（iterable）</code></li><li>参数： iterable 可迭代的对象，例如 Array。</li><li>描述： race方法返回一个promise，只要参数的promise之中有一个实例率先改变状态，那么race方法的返回状态就跟着改变。那个率先改变的promise实例的返回值就传递给race方法的回调函数。</li><li>业务场景：图片加载 超时判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求某个图片资源</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestImg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; resolve(img); &#125;</span><br><span class="line">    img.src = <span class="string">&#x27;http://www.baidu.com/img/flexible/logo/pc/result.png&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//延时函数，用于给请求计时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; reject(<span class="string">&#x27;图片请求超时&#x27;</span>); &#125;, <span class="number">5000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([requestImg(), timeout()])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面的代码中可以看出，采用 Promise 的方式来判断图片是否加载成功，也是针对 Promise.race 方法的一个比较好的业务场</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220405111554.png" alt=""></p><h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><div class="note primary flat"><p>generator是es6新增的语法，和promise一样可以用来异步编程，最大的特点是它可以利用yield和next分段执行。</p></div><ul><li><code>function *foo(x)</code>使用<em>号来声明该函数是一个生成器函数，`</em>`的位置比较随意。</li><li><code>yield</code>关键字用来实现分段执行，它的意思是产出，当生成器函数遇到yield的时候会暂停并把他后面的表达式抛出去。（注意yield可以不写在生成器中）</li><li><code>next</code>表示将代码的控制权还给生成器函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = foo(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(it.next())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>过程：</p><ul><li>首先执行第一个next的时候传参会被忽略 因为赋值的时候已经传了参 所以参数就是5 且到第一个yield停止。返回后面的结果 就是6 此时x为5</li><li>来到第二个next 传入的参数覆盖上一次yield的结果 所以此时y为<code>12*2=24</code> 那么返回的结果就是8</li><li>第三个next 传入的参数覆盖上一次yield的结果 所以此时z为13 那么总体就是<code>5+24+13=42</code></li></ul><h2 id="简单实现generator"><a href="#简单实现generator" class="headerlink" title="简单实现generator"></a>简单实现generator</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cb 也就是编译过的 test 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generator</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> object = &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">stop</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = cb(object);</span><br><span class="line">        <span class="keyword">if</span> (ret === <span class="literal">undefined</span>) <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: ret,</span><br><span class="line">          <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果你使用 babel 编译后可以发现 test 函数变成了这样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="keyword">return</span> generator(<span class="function"><span class="keyword">function</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> ((_context.prev = _context.next)) &#123;</span><br><span class="line">        <span class="comment">// 可以发现通过 yield 将代码分割成几块</span></span><br><span class="line">        <span class="comment">// 每次执行 next 函数就执行一块代码</span></span><br><span class="line">        <span class="comment">// 并且表明下次需要执行哪块代码</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">          _context.next = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">          _context.next = <span class="number">6</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 执行完毕</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">          <span class="keyword">return</span> _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a><code>async/await</code></h1><div class="note primary flat"><p>Generator的语法糖，有更好的语义性和适用性，返回的是promise</p></div><ul><li>await和promise一样更多是笔试题</li><li>await相比直接使用promise来说 优势在于处理then的调用链，能够更清晰的写出代码。缺点在于await可能导致性能问题。因为await会阻塞代码。也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性，此时更应该使用<code>Promise.all</code></li><li>一个函数如果加上了async 那么就会返回一个promise<div class="note primary flat"><p><code>async =&gt; *</code> <code>await =&gt; yield</code></p></div>案例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + <span class="keyword">await</span> <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>, a) <span class="comment">// -&gt; &#x27;2&#x27; 10</span></span><br><span class="line">  a = (<span class="keyword">await</span> <span class="number">10</span>) + a</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>, a) <span class="comment">// -&gt; &#x27;3&#x27; 20</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>, a) <span class="comment">// -&gt; &#x27;1&#x27; 1</span></span><br></pre></td></tr></table></figure></li><li>首先函数b执行 但是遇到了<code>await</code>暂时返还了代码的控制权，所以到外面去执行了a++并输出a为1。</li><li>又因为await内部实现了generators，且它会保留堆栈中的东西，所以在返还之前的a=0被保留了下来。输出10 然后是20</li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><div class="note primary flat"><p>async/await的优势在于处理 then 的调用链，能够更清晰准确的写出代码，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。</p></div><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><div class="note primary flat"><p>首先js的任务分为同步任务和异步任务，异步中又分为宏任务和微任务，我们常见的settimeout，setinterval系列就是宏任务，promise，muationobserver系列就是微任务，微任务插队宏任务。</p></div><ul><li>默认代码从上到下执行，执行环境通过<code>script</code>来执行</li><li>代码执行过程中，先执行同步任务，再执行异步任务。</li><li>给异步任务划分队列，分别存在微任务（立即存放）和宏任务（时间到了或者事情发生了在存放）到队列中</li><li>script执行后清空所有微任务。</li><li>微任务执行完毕后渲染页面（不是每次都调用—）</li><li>再去宏任务队列中看看也没有到达时间的，拿出来其中一个执行。</li><li>执行完毕后按上述的步骤不停循环。<br>例子(UI渲染是宏任务)<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406095138.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406095150.png" alt=""><div class="note primary flat"><p>自动执行的情况 会输出 listener1 listener2 task1 task2</p></div><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406095222.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406100602.png" alt=""><div class="note primary flat"><p>如果手动点击click 会一个宏任务取出来一个个执行，先执行click的宏任务，取出微任务去执行。会输出 listener1 task1 listener2 task2</p></div></li></ul><p>案例1<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="comment">// await xx ==&gt; promise.resolve(()=&gt;&#123;console.log(3)&#125;).then()</span></span><br><span class="line">  <span class="comment">// console.log(3) 放到promise.resolve或立即执行</span></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="number">3</span>) </span><br><span class="line">  <span class="comment">// 相当于把console.log(4)放到了then promise.resolve(()=&gt;&#123;console.log(3)&#125;).then(()=&gt;&#123;</span></span><br><span class="line">  <span class="comment">//   console.log(4)</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line">  <span class="comment">// 微任务谁先注册谁先执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">  resolve(<span class="number">7</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">d</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(d)&#125;)</span><br><span class="line"></span><br><span class="line">asyncFunc()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 1 6 2 3 8 7 4 5</span></span><br></pre></td></tr></table></figure><br>案例2<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406101017.png" alt=""></p><h2 id="JS为什么是单线程？"><a href="#JS为什么是单线程？" class="headerlink" title="JS为什么是单线程？"></a>JS为什么是单线程？</h2><div class="note primary flat"><p>js的单线程和它的用途有关，作为浏览器脚本语言，JavaScript主要用途是与用户互动以及操作DOM。这决定了他只能是单线程，否则会带来很复杂的同步问题。比如假定js同时有两个线程，一个线程在某dom节点上添加内容，另外一个线程删除了节点。这个时候浏览器应该以哪个线程为准？所以为了避免复杂性，从一诞生，js就是单线程，这已经成为了这门语言的核心特征以后也不会改变。</p></div><h2 id="浏览器事件循环"><a href="#浏览器事件循环" class="headerlink" title="浏览器事件循环"></a>浏览器事件循环</h2><div class="note primary flat"><p>涉及面试题：异步代码的执行顺序？解释一下什么是Event Loop</p></div><ul><li>首先js是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来确保代码的有序进行。</li><li>在执行同步代码的时候，如果遇到了异步事件，js引擎并不会一致等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。</li><li>当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行</li><li>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行</li><li>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。<h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a><code>process.nextTick</code></h2><div class="note primary flat"><p><code>process.nextTick</code>指定的异步任务总是发生于所有异步任务之前。</p></div></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;);</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 2 5 4 3 1</span></span><br></pre></td></tr></table></figure><h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><ul><li><code>process.nextTick</code></li><li><code>promise</code></li><li><code>Object.observe</code></li><li><code>MutationObserver</code><h2 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h2></li><li><code>script</code></li><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code></li><li><code>I/O</code> 网络请求完成、文件读写完成事件</li><li><code>UI rendering</code></li><li>用户交互事件（比如鼠标点击、滚动页面、放大缩小等）</li></ul><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><ul><li>对于在js中的字符串，对象，数组是没有固定大小的，只有当对它们进行动态分配存储的时候，解释器才会分配内存来处理这些数据。当js的解释器消耗完系统中所有可用的内存的时候，就会造成系统崩溃。</li><li>内存泄漏，在某些情况下，不再使用到的变量所占用内存没有及时释放，导致程序运行中，内存占用越来越大，极端情况导致系统崩溃，服务器宕机。</li><li>js有自己的一套辣鸡回收机制，js 的解释器可以检测到什么时候程序不再使用这个对象（数据），就会把它所占用的内存释放掉。</li><li>针对js的来及回收机制有下面两种方法（常用）：标记清除，引用计数。</li><li>标记清除。<div class="note primary flat"><p>v8的辣鸡回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另外一个是不死的对象会活得更久。基于这个假说，v8引擎将内存分为了新生代和老生代。</p></div></li><li>新创建的对象或者只经过一次的辣鸡回收的对象被称为新生代，经历过多次垃圾回收的对象被称为老生代。</li><li>新生代被分为from和to两个空间，to一般是闲置的。当from空间满了之后会执行Scavenge算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后继续执行。</li></ul><h2 id="Scavenge"><a href="#Scavenge" class="headerlink" title="Scavenge"></a>Scavenge</h2><div class="note primary flat"><p>这个算法分三步：</p></div><ul><li>首先检查from空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代，如果不满足条件则移动to空间。</li><li>如果对象不存活，则释放对象的空间。</li><li>最后将From空间和to空间进行角色交换</li></ul><h2 id="新生代-gt-老生代"><a href="#新生代-gt-老生代" class="headerlink" title="新生代=&gt;老生代"></a>新生代=&gt;老生代</h2><div class="note primary flat"><p>条件有两个：</p></div><ul><li>第一个是判断对象是否经过一次Scavenge回收，如果经过则将对象从From空间复制到老生代中。若没有经历，则复制到to空间。</li><li>第二个是to空间的内存使用占比是否超过限制。当对象从from空间复制到to空间的时候，若to空间的使用超过25%，则将对象直接晋升到老生代。设置25%的原因是因为算法结束之后，两个空间结束后会交换位置，如果to空间的内存太小，会影响后续的内存分配。<div class="note primary flat"><p>老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉没有标记的对象，由于标记清除后会造成很多内存碎片，不便于后面的内存分配，所以了解内存碎片的问题引入了标记压缩法。</p></div>由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。为了解决这个问题v8引入了增量标记法，将一次停顿进行的过程分为多部，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</li></ul><h2 id="什么时候回收？"><a href="#什么时候回收？" class="headerlink" title="什么时候回收？"></a>什么时候回收？</h2><div class="note primary flat"><p>v8引擎帮我们实现了自动的垃圾回收管理。利用浏览器的渲染的空闲时间进行垃圾回收</p></div><h2 id="具体的回收机制？"><a href="#具体的回收机制？" class="headerlink" title="具体的回收机制？"></a>具体的回收机制？</h2><div class="note primary flat"><p>栈内存的回收：栈内存调用栈上下文切换后就被回收，比较简单。<br>堆内存的回收：v8的堆内存分为新生代内存和老生代内存，新生代内存是临时分配的内存，存在时间短，老生代存在时间长。<br>新生代的回收机制：新生代内存容量小，64位系统下只有32m。新生代内存分为from和to两个部分。在进行扫描的时候，先扫描from，将非存活对象回收，将存活对象顺序复制到to中，之后调换fromto进行下一次回收<br>老生代的回收机制：</p><ul><li>晋升：如果新生代的变量经过多次回收依然存在，那么就会被放入老内存中。</li><li>标记清除：老生代内存会先遍历所有对象并打上标记，然后对正在使用或被强引用的对象取消标记，回收标记的对象。</li><li>整理内存碎片：把对象挪到内存的一端。</li></ul></div><h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><ul><li>意外的全局变量：无法被回收</li><li>定时器：未被正确关闭，导致所引用的外部变量无法被释放。</li><li>事件监听：没有正确销毁（低版本浏览器可能出现）</li><li>闭包<ul><li>第一种情况是我们使用未声明的变量，而意外的创建了一个全局变量，而使得这个变量一直留在内存中无法被回收</li><li>第二种情况是我们设置了setInterval定时器，而忘记取消他，如果循环函数对外部变量有引用的话，那么这个变量会被一直留在内存中，无法被回收。</li><li>第三种情况是我们获取一个DOM元素的引用。而后面的元素被删除。由于我们一直保留了对这个元素的引用，所以他也无法被回收。</li><li>第四种情况是不合理的使用闭包，从而导致某些变量一直被流在内存当中。</li></ul></li><li>dom引用：dom元素被删除时，内存中的引用未被正确清空。</li><li>控制台<code>console.log</code>打印的东西</li></ul><div class="note primary flat"><p>可以用chrome中的timeline进行内存标记，可视化查看内存的变化情况，找出异常点。</p></div><h1 id="区别篇"><a href="#区别篇" class="headerlink" title="区别篇"></a>区别篇</h1><h2 id="python和js的区别"><a href="#python和js的区别" class="headerlink" title="python和js的区别"></a>python和js的区别</h2><ul><li>python web后端，js前后端</li><li>语法差异</li><li>数值类型有<code>int float complex</code> js有<code>Number BigInt</code></li></ul><p>题外 回调地狱？ flatMap？ set和map手写 ？ 串行？</p><h1 id="let-const-var"><a href="#let-const-var" class="headerlink" title="let const var"></a>let const var</h1><p>tob toc ？<br>柯里化<br>前端埋点<br>词法作用域<br>console dir<br>v8辣鸡回收</p><p>vue：</p><ul><li>vue2生命周期</li><li>ajax放created 和 mouted区别</li><li>放created的流程是怎么样的<br>同步执行完created mouted 请求才接收</li><li>了解过fetch吗？fetch存在的问题？</li><li>vuex的几个模块，actions可以放异步吗<br>vue3：</li><li>vue3性能比vue2好的原因<br>vue3的diff使用了静态标记，生成虚拟dom树的时候只对比这些内容<br>对于不参与更新的元素使用了静态提升，只会创建一次，在渲染的时候重新复用。<br>事件监听器缓存：不需要每次都追踪函数的变化，直接缓存函数起来复用。</li><li>vue3watch的缺陷</li></ul><p>css：</p><ul><li>使用过css变量吗？和less，sass变量有什么区别？<br>兼容性，less和sass转普通的css<br>less，sass可以插入字符串 css不行<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@direction:</span> left;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"><span class="selector-tag">padding-</span><span class="variable">@&#123;left&#125;</span>: <span class="selector-tag">5xpx</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如何实现一个自适应正方形 讲一下思路<br><a href="https://blog.csdn.net/ztj771299799/article/details/79806769">https://blog.csdn.net/ztj771299799/article/details/79806769</a></li></ul><p>浏览器：</p><ul><li>window.resize的触发间隔是多少？<br>操作系统</li><li>进程和线程<br>进程是</li><li>并行和并发</li></ul><p>js：</p><ul><li>前端埋点有了解吗？优缺点</li><li>为什么使用gif进行请求?有什么好处？<br>gif防止跨域，防止页面的阻塞，占用空间小</li><li>对闭包就是返回一个函数这句话你是怎么看的？</li><li>闭包是怎么放在内存中的</li><li>有使用过Symbol和BigInt吗</li><li>浅拷贝和赋值的区别。</li></ul><p>场景：<br>假设现在有一个按钮，要避免多次请求你会怎么做？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端算法日记</title>
    <link href="https://zlinni.github.io/posts/fa1981f36489/"/>
    <id>https://zlinni.github.io/posts/fa1981f36489/</id>
    <published>2022-03-09T03:01:33.000Z</published>
    <updated>2022-04-19T14:20:33.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>前端也是要刷算法的呀= =<br>选自leetcode hot 100 和 剑指offer</p></div><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">实战</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>给定一个整数数组<code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 和为目标值 <code>target</code>  的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。<br>示例 1：<br>输入：<code>nums = [2,7,11,15], target = 9</code><br>输出：<code>[0,1]</code><br>解释：因为 <code>nums[0] + nums[1] == 9</code> ，返回 <code>[0, 1]</code> 。<br>示例 2：<br>输入：<code>nums = [3,2,4], target = 6</code><br>输出：<code>[1,2]</code><br>示例 3：<br>输入：<code>nums = [3,3], target = 6</code><br>输出：<code>[0,1]</code><br>提示：<br><code>2 &lt;= nums.length &lt;= 104</code><br><code>-109 &lt;= nums[i] &lt;= 109</code><br><code>-109 &lt;= target &lt;= 109</code><br>只会存在一个有效答案<br>进阶：你可以想出一个时间复杂度小于<code>O(n2)</code> 的算法吗？</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>这道题对前端来说考察的应该是用map方法来操作数据的问题。<br>回顾一下map的三个方法<br><code>map.get(key)</code>用于返回key对应的value值<br><code>map.set(key,value)</code>设置key和value值<br><code>map.has(key)</code>返回key是否存在<br>那么这道题的思路就是 先遍历数组 判断target和数字的差值是否在map里面，如果是则返回key和当前i，否则存入map<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i===<span class="number">0</span>)&#123;map.set(nums[i],i)&#125;</span><br><span class="line">        <span class="keyword">let</span> less = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span>(map.has(less))&#123;</span><br><span class="line">            <span class="keyword">return</span> [map.get(less),i];</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>其实不用到map这个api也是可以做的，并且用时还快一点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums,target</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line"><span class="keyword">let</span> less = target - nums[i];</span><br><span class="line"><span class="keyword">if</span>(map[less]!==<span class="literal">undefined</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> [map[less],i];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">map[nums[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">实战</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220309190959.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>这个就很类似于链表的合并，但是这个相较于合并特殊的一点在于它不能设置val为0 而是要设置next为一个新的节点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">    <span class="keyword">let</span> cur = dummy;</span><br><span class="line">    <span class="keyword">let</span> newAdd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//对l1 l2的加法逻辑单独放一块 避免有一方提前结束</span></span><br><span class="line">        <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">            count += l1.val;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">            count += l2.val;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        count += newAdd;</span><br><span class="line">        <span class="comment">//这里下个节点要用listnode新建，不能直接赋当前的val为count%10</span></span><br><span class="line">        cur.next = <span class="keyword">new</span> ListNode(count % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//向下取整进位数</span></span><br><span class="line">        newAdd = <span class="built_in">Math</span>.floor(count / <span class="number">10</span>);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//如果已经结束了且最后的进位还大于0 那么要再新建一个节点放这个数</span></span><br><span class="line">    <span class="keyword">if</span> (newAdd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cur.next = <span class="keyword">new</span> ListNode(newAdd)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3.无重复字符的最长字串"></a>3.无重复字符的最长字串</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">实战</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220309192827.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路就是用include方法循环判断是否存在这个字符 如果存在就删去，如果不存在就push<br>然后判断maxlength<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> str <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr.includes(str)) &#123;</span><br><span class="line">            arr.shift();</span><br><span class="line">        &#125;</span><br><span class="line">        arr.push(str);</span><br><span class="line">        <span class="keyword">if</span>(arr.length&gt;max)&#123;</span><br><span class="line">            max =arr.length</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">实战</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220309193413.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路就是合并数组 然后sort排序，然后判断奇偶来写。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMedianSortedArrays = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [...nums1,...nums2];</span><br><span class="line">    arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> len = arr.length</span><br><span class="line">    <span class="keyword">if</span>(len%<span class="number">2</span>!==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parseFloat</span>(arr[(len-<span class="number">1</span>)/<span class="number">2</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">parseFloat</span>((arr[len/<span class="number">2</span>]+arr[len/<span class="number">2</span>-<span class="number">1</span>])/<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19.删除链表的倒数第 N 个结点"></a>19.删除链表的倒数第 N 个结点</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">实战</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220309194806.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路就是快慢指针，快指针先走n步，然后快慢一起遍历就能找到要删除节点的前驱节点和后继节点。<br>注意细节问题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">let</span> fast = dummy;</span><br><span class="line">    <span class="keyword">let</span> slow = dummy;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//  这里判断不能写fast 要写fast.next 如果写了前者，那么到最后一个节点他还会前进</span></span><br><span class="line">    <span class="keyword">while</span>(fast.next)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意这里不能直接写fast 如果只存在一个节点那么快慢指针同步 最后还是会返回fast节点的值</span></span><br><span class="line">   <span class="comment">//  slow.next = fast;</span></span><br><span class="line">   slow.next = slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">实战</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220309195925.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路 利用栈 先定义括号的数据结构，然后进站的是右括号 如果和出栈的对应 那么最后栈空<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> leftToRight = &#123;</span><br><span class="line">        <span class="string">&#x27;(&#x27;</span>:<span class="string">&#x27;)&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;[&#x27;</span>:<span class="string">&#x27;]&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#123;&#x27;</span>:<span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> ch = s[i];</span><br><span class="line">        <span class="keyword">if</span>(ch===<span class="string">&#x27;&#123;&#x27;</span>||ch===<span class="string">&#x27;[&#x27;</span>||ch===<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            stack.push(leftToRight[ch]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.pop()!==ch)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stack.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">实战</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220309200133.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路 对链表进行穿针 最后多余出来的部分直接合并<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">list1, list2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> head = <span class="keyword">new</span> ListNode();</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">while</span>(list1&amp;&amp;list2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1.val&lt;=list2.val)&#123;</span><br><span class="line">            cur.next = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur.next = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意这里是cur.next 因为是合并剩下的部分 而不是取代当前</span></span><br><span class="line">    cur.next = list1!==<span class="literal">null</span>?list1:list2;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">实战</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220310085330.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>看到涉及前后的问题 使用双指针 指向头尾</p><ol><li>高度是相对小的指针的值 宽度是下标的差值 </li><li>指针移动的条件是相对小的那边移动<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> right = height.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right!==left)&#123;</span><br><span class="line"><span class="keyword">let</span> square = <span class="built_in">Math</span>.min(height[left],height[right])*(right-left);</span><br><span class="line"><span class="keyword">if</span>(square&gt;max)&#123;</span><br><span class="line">max=square;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(height[left]&lt;height[right])&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">实战</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220313193323.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路就是双指针 头指针和尾指针</p><ol><li>先对数组进行排序</li><li>遍历数组，还有个next指针 为<code>i+1</code></li><li>头指针 next指针 尾指针 用<code>while</code>来判断，终止条件是next等于尾指针</li></ol><ul><li>若它们代表的元素相加若等于0，将三个指针代表的元素入数组，并将next指针指向下一位，如果下一位和上一位的数字相同则跳过 next继续指向下一位</li><li>如果小于0 next指针++</li><li>如果大于0 尾指针—<br>特别注意 如果前一项等于后一项 那么直接跳过当前项<br>代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">let</span> next = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> last = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (next &lt; last) &#123;</span><br><span class="line">            <span class="keyword">const</span> sum = nums[i] + nums[next] + nums[last];</span><br><span class="line">            <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">                res.push([nums[i], nums[next], nums[last]]);</span><br><span class="line">                next++;</span><br><span class="line">                <span class="keyword">while</span> (nums[next] === nums[next - <span class="number">1</span>]) &#123;</span><br><span class="line">                    next++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                next++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16.最接近的三数之和"></a>16.最接近的三数之和</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">实战</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220313194812.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路 和三数之和类似 多了个比较 最接近其实就是绝对值最小<br>代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSumClosest = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="literal">Infinity</span>;</span><br><span class="line">    <span class="keyword">let</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> next = i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> last = len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(next&lt;last)&#123;</span><br><span class="line">            <span class="keyword">const</span> sum = nums[i]+nums[next]+nums[last];</span><br><span class="line">            <span class="keyword">const</span> diff = <span class="built_in">Math</span>.abs(sum-target);</span><br><span class="line">            <span class="keyword">if</span>(diff&lt;min)&#123;</span><br><span class="line">                min = diff;</span><br><span class="line">                res = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">                next++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                last--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li><li class="tab"><button type="button" data-href="#test-3">经典案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">实战</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220313205436.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路 和三数差不多 但是多了层循环<br>代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fourSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>] &amp;&amp; i &lt; len) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">let</span> first = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (first &lt; len - <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first &gt; i + <span class="number">1</span> &amp;&amp; nums[first] === nums[first - <span class="number">1</span>] &amp;&amp; first &lt; len - <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">let</span> next = first + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> last = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (next &lt; last) &#123;</span><br><span class="line">                <span class="keyword">let</span> sum = nums[i] + nums[first] + nums[next] + nums[last];</span><br><span class="line">                <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">                    res.push([nums[i], nums[first], nums[next], nums[last]]);</span><br><span class="line">                    next++;</span><br><span class="line">                    <span class="keyword">while</span> (nums[next] === nums[next - <span class="number">1</span>]) &#123;</span><br><span class="line">                        next++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    next++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    last--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            first++;</span><br><span class="line">            <span class="keyword">while</span> (nums[first] === nums[first - <span class="number">1</span>]) &#123;</span><br><span class="line">                first++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53.最大子数组和"></a>53.最大子数组和</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220317204004.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>动态规划 但是是从前往后<br>正负收益 如果是相减是负收益 那么不要这个 取当前项<br>优化：不使用dp数组来维护这些变量 直接用一个sum变量来代替<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line"><span class="comment">//初始化maxSum</span></span><br><span class="line"><span class="keyword">let</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//初始化sum</span></span><br><span class="line"><span class="keyword">let</span> sum = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line"><span class="comment">//比较收益 两者差值和当前值谁更大 取更大的</span></span><br><span class="line">sum = <span class="built_in">Math</span>.max(sum-nums[i],nums[i]);</span><br><span class="line"><span class="comment">//比较最大收益 取最大收益</span></span><br><span class="line">maxSum = <span class="built_in">Math</span>.max(sum,maxSum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220317205059.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>动态规划 状态方程是<code>f[n]= f[n-1]+f[n-2]</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> f = [];</span><br><span class="line">f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">f[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span> ;i&lt;=n;i++)&#123;</span><br><span class="line">f[i] = f[i-<span class="number">1</span>]+f[i-<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220317210015.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>注意在函数里面递归你的二叉树<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="keyword">const</span> res = <span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!n)<span class="keyword">return</span>;</span><br><span class="line">res(root.left);</span><br><span class="line">arr.push(root.val);</span><br><span class="line">res(root.right);</span><br><span class="line">&#125;</span><br><span class="line">res(root);</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220317210209.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>左右节点都存在<br>左右节点相等<br>左节点的左等于右节点的右<br>左节点的右等于右键点的左<br>即为镜像<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jud = <span class="function">(<span class="params">l,r</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="comment">//已经是叶子节点了 返回真</span></span><br><span class="line"><span class="keyword">if</span>(!l&amp;&amp;!r)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(l&amp;&amp;r&amp;&amp;l.val===r.val&amp;&amp;jud(l.left,r.right)&amp;&amp;jud(l.right,r.left))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> jud(root.left,root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220318155736.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>最大深度用深度优先遍历<br>然后注意判断的时机<br>代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> dfs = <span class="function">(<span class="params">n,l</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!n)<span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//只在叶子节点的时候开始判断</span></span><br><span class="line"><span class="keyword">if</span>(!n.left&amp;&amp;!n.right)&#123;</span><br><span class="line">max = <span class="built_in">Math</span>.max(max,l);</span><br><span class="line">&#125;</span><br><span class="line">dfs(n.left,l+<span class="number">1</span>);</span><br><span class="line">dfs(n.right,l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">dfs(root,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220318155828.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>先提出一个概念 收益 这里的话是前后元素的差值<br>这里涉及到一个问题 其实有时候不需要知道买进卖出的价格 我们只需要知道在这个过程中，收益的幅度，也就是收益为负的时候，刷新这个收益为0，收益为正的时候，和最大收益比较并考虑是否刷新最大收益。<br>代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span> (<span class="params">prices</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> last = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;prices.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">last = <span class="built_in">Math</span>.max(<span class="number">0</span>,last+prices[i+<span class="number">1</span>]-prices[i]);</span><br><span class="line">max = <span class="built_in">Math</span>.max(max,last);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a>136. 只出现一次的数字</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220318161857.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>利用异或的性质</p><ol><li>0异或任何数都返回那个数字</li><li>两个数字异或 相同0 不同1<br>代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    nums.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        res = res^item;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220320140032.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left = invertTree(root.left);</span><br><span class="line">    <span class="keyword">let</span> right = invertTree(root.right);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220320141647.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>快慢指针 如果是环形 快指针走两步 慢指针走一步 最后肯定会相遇<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> slow = head;</span><br><span class="line">    <span class="keyword">let</span> fast = head;</span><br><span class="line">    <span class="keyword">while</span> (slow&amp;&amp;fast&amp;&amp;fast.next) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        <span class="keyword">if</span>(slow===fast)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a>155. 最小栈</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220320143256.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>两个栈 一个用于存放最小的数据集合 一个用于普通存放<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MinStack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stack1 = [];</span><br><span class="line">    <span class="built_in">this</span>.stack2 = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">val</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stack1.push(val);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.stack2)&#123;</span><br><span class="line">        <span class="built_in">this</span>.stack2.push(val);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val&lt;=<span class="built_in">this</span>.stack2[<span class="built_in">this</span>.stack2.length-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="built_in">this</span>.stack2.push(val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.stack2.unshift(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.stack1.pop()===<span class="built_in">this</span>.stack2[<span class="built_in">this</span>.stack2.length-<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="built_in">this</span>.stack2.pop();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.top = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack1[<span class="built_in">this</span>.stack1.length-<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.getMin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack2[<span class="built_in">this</span>.stack2.length-<span class="number">1</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MinStack()</span></span><br><span class="line"><span class="comment"> * obj.push(val)</span></span><br><span class="line"><span class="comment"> * obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.getMin()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220320145134.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>连接headA和headB 使得它们总路程相同<br>那么可以看 此时总路程相同 速度相同 如果有相交的点 那么最后肯定会到达该点<br>假设公共路径是c 第一条公共路径之前是a 第二条是b<br>那么第一条路径就是a+c+b+c<br>第二条就是b+c+a+c<br>当第一条走过 a+c+b的时候 第二条也走过了b+c+a 此时下一步的c就是交点或者终点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> p1 = headA;</span><br><span class="line"><span class="keyword">let</span> p2 = headB;</span><br><span class="line"><span class="keyword">while</span>(p1!===p2)&#123;</span><br><span class="line">p1 = p1 ? p1.next : headB;</span><br><span class="line">p2 = p2 ? p2.next : headA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a>448. 找到所有数组中消失的数字</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220320152709.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路 set去重之后找到利用set的has特性 如果不存在该数字就把数组原地的<code>nums[count]</code>修改为i ，最后分割数组即可。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findDisappearedNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(nums);</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">1</span>;i&lt;=nums.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!set.has(i))&#123;</span><br><span class="line">nums[count] = i;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums.splice(<span class="number">0</span>,count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220320153743.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="built_in">parseInt</span>(nums.length/<span class="number">2</span>)]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220320162258.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = nums.length</span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            nums[k++] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; n)&#123;</span><br><span class="line">        nums[k++] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a>617. 合并二叉树</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220321141252.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTrees = <span class="function"><span class="keyword">function</span> (<span class="params">root1, root2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root1 &amp;&amp; !root2) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> jud = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!n1)<span class="keyword">return</span> n2;</span><br><span class="line">        <span class="keyword">if</span>(!n2)<span class="keyword">return</span> n1;</span><br><span class="line">        n1.val += n2.val;</span><br><span class="line">        n1.left = jud(n1.left, n2.left);</span><br><span class="line">        n1.right = jud(n1.right, n2.right);</span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jud(root1, root2)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a>543. 二叉树的直径</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220321143350.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> diameterOfBinaryTree = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> deep = (<span class="function">(<span class="params">n1</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!n1) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> left = deep(n1.left);</span><br><span class="line">        <span class="keyword">let</span> right = deep(n1.right);</span><br><span class="line">        max = <span class="built_in">Math</span>.max(left+right,max);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    deep(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a>461. 汉明距离</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220321144547.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingDistance = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x^y).toString(<span class="number">2</span>).split(<span class="string">&#x27;&#x27;</span>).filter(<span class="function"><span class="params">s</span>=&gt;</span>s===<span class="string">&#x27;1&#x27;</span>).length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a>338. 比特位计数</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220321145257.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        arr.push((i).toString(<span class="number">2</span>).replace(<span class="regexp">/0/g</span>,<span class="string">&#x27;&#x27;</span>).length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a>剑指 Offer 10- I. 斐波那契数列</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220321150914.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>经典动态规划 注意栈溢出。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> f = [];</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        f[i] = (f[i-<span class="number">1</span>]+f[i-<span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a>剑指 Offer 10- II. 青蛙跳台阶问题</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220321160431.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numWays = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> f = [];</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i] = (f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>])%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a>剑指 Offer 11. 旋转数组的最小数字</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220322144752.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minArray = <span class="function"><span class="keyword">function</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min(...numbers)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a>剑指 Offer 15. 二进制中1的个数</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220322145049.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n.toString(<span class="number">2</span>).split(<span class="string">&#x27;&#x27;</span>).filter(<span class="function"><span class="params">s</span>=&gt;</span>s===<span class="string">&#x27;1&#x27;</span>).length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数"></a>剑指 Offer 17. 打印从1到最大的n位数</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220322150012.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> printNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// n = Math.pow(10,n);</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        count*=<span class="number">10</span>;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">1</span>;i&lt;count;i++)&#123;</span><br><span class="line">        arr.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220322151039.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>双指针 左指针维护奇数数组 右指针维护偶数数组<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exchange = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> right = nums.length;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[left]%<span class="number">2</span>===<span class="number">1</span>)&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">[nums[left],nums[right]] = [nums[right],nums[left]];</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a>剑指 Offer 27. 二叉树的镜像</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220322151651.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>反转二叉树<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mirrorTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">let</span> left = mirrorTree(root.left);</span><br><span class="line">    <span class="keyword">let</span> right = mirrorTree(root.right);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a>剑指 Offer 28. 对称的二叉树</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220322152626.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>对称二叉树<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> jud = <span class="function">(<span class="params">l,r</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l&amp;&amp;!r)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&amp;&amp;r&amp;&amp;l.val===r.val&amp;&amp;jud(l.left,r.right)&amp;&amp;jud(l.right,r.left))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jud(root.left,root.right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a>剑指 Offer 40. 最小的k个数</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220328163042.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getLeastNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">arr, k</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> arr.sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a - b).slice(<span class="number">0</span>, k)</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a>剑指 Offer 42. 连续子数组的最大和</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220328164733.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>收益和当前值比较 取最大 得到新收益<br>新收益和总收益比较 刷新总收益<br>注意初始化的时候总收益和收益都是第一个元素 避免只有一个元素的时候<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> bonus = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> max = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">bonus = <span class="built_in">Math</span>.max(bonus+nums[i],nums[i]);</span><br><span class="line">max = <span class="built_in">Math</span>.max(bonus,max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a>剑指 Offer 50. 第一个只出现一次的字符</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220328170035.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>巧用indexOf 的第二个属性<br>从xx位置开始查找<br>所以如果查了第一次 发现第一次后面还有该数就说明重复<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line"><span class="keyword">let</span> a = s.indexOf(s[i]);</span><br><span class="line"><span class="keyword">let</span> b = s.indexOf(s[i],a+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(b===-<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> s[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot; &quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a>剑指 Offer 39. 数组中出现次数超过一半的数字</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220329142638.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>中位数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b).splice(nums.length / <span class="number">2</span>, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a>剑指 Offer 53 - I. 在排序数组中查找数字 I</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220329144820.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums.filter(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item === target</span><br><span class="line">    &#125;).length</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a>剑指 Offer 53 - II. 0～n-1中缺失的数字</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220329150951.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> missingNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    <span class="keyword">let</span> vsum = (<span class="number">0</span>+len)*(len+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> rsum = nums.reduce(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cur+=pre;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> vsum-rsum</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a>剑指 Offer 57. 和为s的两个数字</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220329153258.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code 双指针<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> len = nums.length;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> j = len-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line"><span class="keyword">let</span> sum = nums[i]+nums[j];</span><br><span class="line"><span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> [nums[i],nums[j]]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a>剑指 Offer 58 - I. 翻转单词顺序</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220329154224.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>注意条件<br>code<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.trim(<span class="string">&quot;&quot;</span>).split(<span class="string">&quot; &quot;</span>).filter(<span class="function"><span class="params">item</span>=&gt;</span>&#123;<span class="keyword">return</span> item!==<span class="string">&quot;&quot;</span>&#125;).reverse().join(<span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a>剑指 Offer 57 - II. 和为s的连续正数序列</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220329160716.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>双指针 滑动窗口<br>初始化左右指针数值为1，和为0<br>循环条件 左指针小于目标值一半(比如说目标值15 一半就是7.5 左最大只能到7)<br>当和小于目标值的时候 需要扩大右边界 此时和<code>+=</code>右指针 右指针++<br>当和大于目标值 需要扩大左边界 此时和<code>-=</code>左指针 左指针++<br>当和等于目标值 循环嵌入值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findContinuousSequence = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> list = [];</span><br><span class="line"><span class="keyword">let</span> left = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> right = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(left&lt;target/<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">sum+=right;</span><br><span class="line">right++;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">sum-=left;</span><br><span class="line">left++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="comment">//此时的right已经进位</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = left;i&lt;right;i++)&#123;</span><br><span class="line">arr.push(i)</span><br><span class="line">&#125;</span><br><span class="line">list.push(arr);</span><br><span class="line">sum-=left;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a>剑指 Offer 58 - II. 左旋转字符串</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220329162543.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseLeftWords = <span class="function"><span class="keyword">function</span>(<span class="params">s, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.substring(n).concat(s.substring(<span class="number">0</span>,n))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a>剑指 Offer 61. 扑克牌中的顺子</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220329165542.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220329165640.png" alt=""><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isStraight = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nozero = nums.filter(<span class="function">(<span class="params">item</span>)=&gt;</span>item!==<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(nozero);</span><br><span class="line">    <span class="keyword">if</span>(set.size !== nozero.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Math</span>.max(...nozero)-<span class="built_in">Math</span>.min(...nozero)&lt;<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a>剑指 Offer 62. 圆圈中最后剩下的数字</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220330144003.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>约瑟夫环<br>code</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lastRemaining = <span class="function"><span class="keyword">function</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> curIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ler i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        curIndex = (curIndex+m)%i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curIndex</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a>剑指 Offer 65. 不用加减乘除做加法</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220330145426.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>先异或计算进位，再位与进位<br>推导过程eg <code>0001+0011=0100</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0001</span>^<span class="number">0011</span> = <span class="number">0010</span> <span class="comment">//2</span></span><br><span class="line"><span class="number">0001</span>&amp;<span class="number">0011</span> = <span class="number">0001</span> </span><br><span class="line"><span class="number">0001</span>&lt;&lt;<span class="number">1</span> = <span class="number">0010</span> <span class="comment">//2</span></span><br><span class="line"><span class="comment">//2+2=4</span></span><br><span class="line"><span class="number">0010</span>^<span class="number">0010</span> = <span class="number">0000</span> <span class="comment">//0</span></span><br><span class="line"><span class="number">0010</span>&amp;<span class="number">0010</span> = <span class="number">0010</span> </span><br><span class="line"><span class="number">0010</span>&lt;&lt;<span class="number">1</span> = <span class="number">0100</span> <span class="comment">//4</span></span><br><span class="line"><span class="comment">//0+4=4 条件是b==0截至</span></span><br></pre></td></tr></table></figure><p>所以代码是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b!==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> c = (a^b);</span><br><span class="line">        b = ((a&amp;b)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        a = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a>剑指 Offer 29. 顺时针打印矩阵</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220330151905.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>定义一个数组res为空<br>四个方向，一次循环 右下左上<br>第一步 右 res直接concat目标数组shift的内容<br>第二步 下 循环遍历目标数组 删除目标数组中每一个数组的最后一位并加入res<br>注意此时要判断数组是否还存在。<br>第三步 左 取出目标数组最后一行 pop后反转加入res 此时res需要concat<br>注意此时要判断数组是否还存在。<br>第四步 上 剩余的最后一层到第一层<br>注意此时要判断数组是否还存在。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spiralOrder = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">while</span>(matrix.length)&#123;</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        res.concat(matrix.shift());</span><br><span class="line">        <span class="comment">//下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            matrix[i].length&amp;&amp;res.push(matrix[i].pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        matrix.length &amp;&amp; (res = res.concat(matrix.pop().reverse()));</span><br><span class="line">        <span class="comment">//上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=matrix.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            matrix[i].length&amp;&amp;res.push(matrix[i].shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a>剑指 Offer 32 - II. 从上到下打印二叉树 II</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220331131917.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>bfs + map记录<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> jud = <span class="function">(<span class="params">n,count</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(!map[count])&#123;</span><br><span class="line">            map[count] = [n.val];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map[count].push(n.val);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        jud(n.left,count);</span><br><span class="line">        jud(n.right,count);</span><br><span class="line">    &#125;</span><br><span class="line">    jud(root,count);</span><br><span class="line">    <span class="keyword">return</span> [...Object.values(map)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a>剑指 Offer 55 - I. 二叉树的深度</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220331133906.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code bfs<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> max =<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">const</span> deep = <span class="function">(<span class="params">n,l</span>)=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!n)<span class="keyword">return</span>;</span><br><span class="line">       max = <span class="built_in">Math</span>.max(l,max);</span><br><span class="line">       deep(n.left,l+<span class="number">1</span>);</span><br><span class="line">       deep(n.right,l+<span class="number">1</span>);</span><br><span class="line">   &#125; </span><br><span class="line">   deep(root,<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a>剑指 Offer 54. 二叉搜索树的第k大节点</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220331140105.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>中序遍历的结果是升序数组 反过来就是降序 找k个就行<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kthLargest = <span class="function"><span class="keyword">function</span> (<span class="params">root, k</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> res;</span><br><span class="line">   <span class="keyword">const</span> midOrder = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">       midOrder(root.right);</span><br><span class="line">       k--;</span><br><span class="line">       <span class="keyword">if</span>(!k)<span class="keyword">return</span> res = root.val;</span><br><span class="line">       midOrder(root.left);</span><br><span class="line">   &#125; </span><br><span class="line">   midOrder(root);</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a>剑指 Offer 55 - II. 平衡二叉树</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220331191109.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>后序遍历，自下而上，如果遇到了不符合的情况直接剪枝返回-1<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isBalanced = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> post = <span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> left = post(n.left);</span><br><span class="line">        <span class="keyword">let</span> right = post(n.right);</span><br><span class="line">        <span class="keyword">if</span>(right&lt;<span class="number">0</span>||left&lt;<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.abs(left-right)&lt;=<span class="number">1</span>?<span class="built_in">Math</span>.max(left,right)+<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> post(root)!=-<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220331194409.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>二叉搜索树的概念：<br>左子树的值恒小于根节点的值<br>右子树的值恒大于根节点的值<br>因此对于二叉搜索树的最近公共祖先有三种情况</p><ol><li>如果左小于根 右大于根 则返回根节点</li><li>如果左右小于根 那么第一个符合值相等条件的就是公共祖先</li><li>如果左右大于根 那么第一个符合值相等条件的就是公共祖先<br>注意 传入的是节点 不是节点值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span>(<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.val&lt;root.val&amp;&amp;q.val&lt;root.val)&#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.val&gt;root.val&amp;&amp;q.val&gt;root.val)&#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a>剑指 Offer 68 - II. 二叉树的最近公共祖先</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220331200046.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>isLeft代表左树中有q或p isRight代表右树中有q或p<br>isNode表示此节点为q或p<br>当左中右其中两个为真 那么此节点就是公共祖先<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span>(<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = root;</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">let</span> isLeft = dfs(n.left);</span><br><span class="line">        <span class="keyword">let</span> isRight = dfs(n.right);</span><br><span class="line">        <span class="keyword">let</span> isNode = n===p || n===q;</span><br><span class="line">        <span class="keyword">if</span>((isLeft&amp;&amp;isRight)||(isLeft&amp;&amp;isNode)||(isRight&amp;&amp;isNode))res = n;</span><br><span class="line">        <span class="keyword">return</span> isLeft || isRight || isNode;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="中等题"><a href="#中等题" class="headerlink" title="中等题"></a>中等题</h1><h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220405170718.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>遍历空出最后两个位置<br>前后一对，定义a为nums[i]<br>如果靠后a的那个数字小于a<br>那么查看此时靠后a的数字是否是最后一个 如果是 直接交换它和a<br>如果不是 则定义k等于i+1 找到比a大的第一个数字 因为后面的数字都是降序排列 所以用一个while就能搞定 <code>(while(a&lt;nums[k+1]){k++})</code><br>然后交换k和a<br>再将a后面的数字做升序排列</p><p>如果i已经是0了<br>那么nums反转<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nextPermutation = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">let</span> a = nums[i];</span><br><span class="line">        <span class="keyword">if</span> (a &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> === len)&#123;</span><br><span class="line">                [nums[i],nums[i+<span class="number">1</span>]] = [nums[i+<span class="number">1</span>],nums[i]];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> k = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (a &lt; nums[k+<span class="number">1</span>]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] = nums[k];</span><br><span class="line">            nums[k] = a;</span><br><span class="line">            <span class="keyword">let</span> left = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> right = len;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                [nums[left], nums[right]] = [nums[right], nums[left]];</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">            nums.reverse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a>153. 寻找旋转排序数组中的最小值</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406141715.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>注意mid可以写成<code>left+((right-left)&gt;&gt;1)</code><br>如果left值等于right值 说明升序 直接返回nums0<br>乱序的情况下：<br>如果mid大于left，right就来到左边界<br>如果mid小于left，left就来到右边界<br>如果mid》mid+1 说明mid+1是最小值<br>如果mid《mid-1 说明mid是最小值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMin = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums.length)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums.length===<span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> left =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right= nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//升序</span></span><br><span class="line">    <span class="keyword">if</span>(nums[left]&lt;nums[right])&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + ((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;nums[left])&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[mid+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;nums[mid-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[mid];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406143911.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>边界条件是mid===target<br>如果left《=mid<br>且target》left小于mid 说明在左侧 right=mid-1 否则在右侧 left=mid+1<br>如果left》mid<br>且target》mid小于right 说明在右侧left =mid+1 否则在左侧 right=mid-1<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums.length)<span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]===target)<span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;=nums[left])&#123;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;=nums[left]&amp;&amp;target&lt;nums[mid])&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;nums[mid]&amp;&amp;target&lt;=nums[right])&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a>81. 搜索旋转排序数组 II</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406144216.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>去重思路<br>如果numsleft===numsmid则<code>++left continue</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums.length)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid =left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]===target)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]===nums[left])&#123;</span><br><span class="line">            ++left;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;nums[left])&#123;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;=nums[left]&amp;&amp;target&lt;nums[mid])&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;nums[mid]&amp;&amp;target&lt;=nums[right])&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406150117.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>找到之后判断前面和后面的数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchRange = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums.length)<span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        mid = left + ((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]===target)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i=mid,j=mid;</span><br><span class="line">    <span class="keyword">while</span>(nums[i]===nums[i-<span class="number">1</span>])i--;</span><br><span class="line">    <span class="keyword">while</span>(nums[j]===nums[j+<span class="number">1</span>])j++;</span><br><span class="line">    <span class="keyword">return</span> [i,j]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406153544.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>回溯<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> combinationSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">idx,path,t</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t===<span class="number">0</span>)&#123;</span><br><span class="line">                res.push([...path]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=idx;i&lt;nums.length;i++)&#123;</span><br><span class="line">            path.push(nums[i]);</span><br><span class="line">            dfs(i,path,t-nums[i]);</span><br><span class="line">            path.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>,[],target);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406155001.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>回溯 带used 注意使用方法是<code>new Array(nums.length).fill(false)</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> used = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length).fill(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">path</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.length === nums.length)&#123;</span><br><span class="line">            res.push([...path]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i])<span class="keyword">continue</span>;</span><br><span class="line">            path.push(nums[i]);</span><br><span class="line">            used[i]=<span class="literal">true</span>;</span><br><span class="line">            dfs(path);</span><br><span class="line">            path.pop();</span><br><span class="line">            used[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs([])</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406161008.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>先对角线交换然后反转。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = matrix.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&lt;len;j++)&#123;</span><br><span class="line">            [matrix[i][j],matrix[j][i]] = </span><br><span class="line">            [matrix[j][i],matrix[i][j]]  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix.map(<span class="function"><span class="params">item</span>=&gt;</span>item.reverse());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220407155829.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>截取反转再补上注意环<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseBetween = <span class="function"><span class="keyword">function</span>(<span class="params">head, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> reverse = <span class="function">(<span class="params">head</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> cur =head;</span><br><span class="line">        <span class="keyword">let</span> pre =<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            [cur.next,pre,cur] = [pre,cur,cur.next]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">let</span> pre = dummy;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;left-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//12345</span></span><br><span class="line">    <span class="keyword">let</span> rightNode = pre;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;right-left+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        rightNode = rightNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//45</span></span><br><span class="line">    <span class="keyword">let</span> leftNode = pre.next <span class="comment">//2345</span></span><br><span class="line">    <span class="keyword">let</span> curr = rightNode.next <span class="comment">//5</span></span><br><span class="line">    pre.next = <span class="literal">null</span>; <span class="comment">//1 234 </span></span><br><span class="line">    rightNode.next = <span class="literal">null</span> <span class="comment">//4 5</span></span><br><span class="line">    reverse(leftNode)<span class="comment">//432</span></span><br><span class="line">    pre.next = rightNode;</span><br><span class="line">    leftNode.next = curr;</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a>165. 比较版本号</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220407180832.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compareVersion = <span class="function"><span class="keyword">function</span>(<span class="params">version1, version2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr1 = version1.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> arr2 = version2.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="built_in">Math</span>.max(arr1.length,arr2.length);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!arr2[i])arr2[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!arr1[i])arr1[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Number</span>(arr1[i])===<span class="built_in">Number</span>(arr2[i]))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">Number</span>(arr1[i])&lt;<span class="built_in">Number</span>(arr2[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">Number</span>(arr1[i])&gt;<span class="built_in">Number</span>(arr2[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a>647. 回文子串</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220408161534.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>我们要知道一个串是否是回文子串<br>从i开头j结尾开始<br>此时charAt的i和j相等 就得判断i+1和j-1是否是相等<br>或者说 当j-i小于等于2的时候 这个时候足够小 就可以认为它是回文子串。<br>所以得出dp的条件是<code>dp[i][j] = (j-i&lt;=2)||dp[i+1][j-1]</code><br>但是我们要计算<code>dp[i+1][j-1]</code>直接从上到下是不行的，必须i从下到上，因此代码为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countSubstrings = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = s.length;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        dp[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> count =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&lt;len;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)!==s.charAt(j))<span class="keyword">continue</span>;</span><br><span class="line">            dp[i][j] = (j-i&lt;=<span class="number">2</span>) || dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j])count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220408165206.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>回文子串的做法加判断<br>res初始化为s0<br>如果dp为真且<code>j-i+1&gt;res.length</code>的情况下<br>返回<code>res = s.slice(i,j+1)</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = s.length;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        dp[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = s[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&lt;len;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)!==s.charAt(j))<span class="keyword">continue</span>;</span><br><span class="line">            dp[i][j] = ((j-i)&lt;=<span class="number">2</span>) || dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]&amp;&amp;j-i+<span class="number">1</span>&gt;res.length)&#123;</span><br><span class="line">                res = s.slice(i,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220410145007.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>dfs传入l，r和str 初始的时候l和r都是n str是空串<br>前两者用于判断左右括号是否害存在<br>如果左大于0 l-1 空串加入左括号<br>如果左小于右 那么右括号才能进组 r-1 加入右括号<br>结束的条件是当空串的长度为2n的时候<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];<span class="comment">//空数组放结果</span></span><br><span class="line">    <span class="keyword">let</span> len = n*<span class="number">2</span>;<span class="comment">//最大长度</span></span><br><span class="line">    <span class="keyword">const</span> dfs = (<span class="function">(<span class="params">l,r,str</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length===len)&#123;</span><br><span class="line">            res.push(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            dfs(l-<span class="number">1</span>,r,str+<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">            dfs(l,r-<span class="number">1</span>,str+<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    dfs(n,n,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220410145538.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>动态规划，定义max为第一个值 遍历数组 如果i《max的时候（此时还没有到最后）<br>max和<code>nums[i]+i</code>比较大小 之后比较跳跃完的节点 <code>max&gt;=nums.length-1</code><br>是的话就可以跳到<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canJump = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length===<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=max)&#123;</span><br><span class="line">            max = <span class="built_in">Math</span>.max(nums[i]+i,max);</span><br><span class="line">            <span class="keyword">if</span>(max&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220410150120.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>如果中序遍历的长度不存在或者中序遍历的过程没有值直接返回null<br>从前序遍历找到根节点（第一个或者shift）<br>此时在中序中找到这个节点，然后新建树<br>根据中序遍历分类出左子树和右子树<br>之后左子树加入这个节点之前，右子树在该节点之后<br>注意新建节点：<code>new TreeNode(xxx)</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = (<span class="function">(<span class="params">inorder</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inorder||!inorder.length)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> top = preorder.shift();</span><br><span class="line">        <span class="keyword">let</span> p = inorder.indexOf(top);</span><br><span class="line">        <span class="keyword">let</span> tree = <span class="keyword">new</span> TreeNode(top);</span><br><span class="line">        tree.left = res(inorder.slice(<span class="number">0</span>,p));</span><br><span class="line">        tree.right = res(inorder.slice(p+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res(inorder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220410151231.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>如果中序遍历的时候左子树值小于根节点右子树值大于根节点即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValidBST = <span class="function"><span class="keyword">function</span>(<span class="params">root,min=-<span class="literal">Infinity</span>,max=<span class="literal">Infinity</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.val&lt;=min||root.val&gt;=max)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left,min,root.val)&amp;&amp;isValidBST(root.right,root.val,max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220411141253.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>哈希表<br>如何判断<code>abc</code>和<code>bca</code>相等关键在于<code>&quot;bca&quot;.split(&quot;&quot;).sort().toString() //a,b,c</code><br>用map维护key为上述字符串，value为结果数组的结果集<br>最后返回<code>[...map.values()]</code>即可<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> groupAnagrams = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> str)&#123;</span><br><span class="line">        <span class="keyword">let</span> s1 = item.split(<span class="string">&quot;&quot;</span>).sort().toString();</span><br><span class="line">        <span class="keyword">let</span> res = map.get(s1) || [];</span><br><span class="line">        res.push(item);</span><br><span class="line">        map.set(s1,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [...map.values()]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220411150138.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>先对数组进行排序 注意这里是sort每个数组的第一位 避免出现<code>[1,4],[0,4]</code>这样的比较 正确应该是比较<code>[0,4],[1,4]</code><br>然后取数组的第一个作为基准temp 之后遍历数组 如果temp[1]比数组当前项item的[0]要大则有交集，<br>再取两者的右边界最大值为temp[1]<br>如果没有交集 则temp入res temp和item交换<br>最后一个也要入res<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    intervals = intervals.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> temp = intervals[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> item = intervals[i];</span><br><span class="line">        <span class="keyword">if</span>(temp[<span class="number">1</span>]&gt;=item[<span class="number">0</span>])&#123;</span><br><span class="line">            temp[<span class="number">1</span>] = <span class="built_in">Math</span>.max(temp[<span class="number">1</span>],item[<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.push(temp);</span><br><span class="line">            temp = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(temp);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220411153939.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>用一维数组维护数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">6</span> <span class="comment">//6是最后答案 那么6是怎么计算出来的呢？</span></span><br></pre></td></tr></table></figure><br>如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="comment">//step2 </span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span>+<span class="number">1</span>=<span class="number">2</span> <span class="number">2</span>+<span class="number">1</span>=<span class="number">3</span></span><br><span class="line"><span class="comment">//step3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span>+<span class="number">1</span>=<span class="number">3</span> <span class="number">3</span>+<span class="number">3</span>=<span class="number">6</span></span><br><span class="line"><span class="comment">//6</span></span><br></pre></td></tr></table></figure><br>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m)</span><br><span class="line">dp.fill(<span class="number">1</span>) <span class="comment">// 直接从1开始</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>;j &lt; m; j++) &#123;</span><br><span class="line">        dp[j] += dp[j-<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220411160412.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>回溯<br>传递空数组path，长度l，开始位置start。<br>遍历数组传递 初始长度是i，开始位置是0 注意i要小于等于原数组长度（比如说123 才能取到123否则只有12 1这种情况）<br>当数组长度等于长度的时候push到res数组里面然后返回（截至条件）<br>从start开始遍历数组 传递concat当前numi项，长度，和i+1作为下次的条件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> backtrack = (<span class="function">(<span class="params">path,l,start</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.length === l)&#123;</span><br><span class="line">            res.push(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            backtrack(path.concat(nums[i]),l,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=nums.length;i++)&#123;</span><br><span class="line">        backtrack([],i,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ol><li>单词搜索<div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220411170212.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><ol><li>定二维数组 used初始化false</li><li>双重循环dfs</li><li>dfs第一步判断越界情况</li><li>第二步标记存在或者不等于该单词 false</li><li>定义res 传入dfs四个方向</li><li>成功回调 改变used状态<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exist = <span class="function"><span class="keyword">function</span> (<span class="params">board, word</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> r = board.length;</span><br><span class="line">    <span class="keyword">let</span> c = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">const</span> used = <span class="keyword">new</span> <span class="built_in">Array</span>(r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">        used[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(c).fill(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> dfs = (<span class="function">(<span class="params">row, col, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === word.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || col &lt; <span class="number">0</span> || row === r || col === c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (used[row][col] || board[row][col] !== word[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        used[row][col] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">const</span> res = dfs(row + <span class="number">1</span>, col, i + <span class="number">1</span>) || dfs(row - <span class="number">1</span>, col, i + <span class="number">1</span>) || dfs(row, col + <span class="number">1</span>, i + <span class="number">1</span>) || dfs(row, col - <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (res) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        used[row][col] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ol><h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220412160515.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>左右指针<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortColors = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> cur=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> swap = (<span class="function">(<span class="params">i,j</span>)=&gt;</span>&#123;</span><br><span class="line">        [nums[i],nums[j]]=</span><br><span class="line">        [nums[j],nums[i]]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">while</span>(cur&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur&gt;=left&amp;&amp;cur&lt;=right&amp;&amp;nums[cur]!==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[cur]===<span class="number">0</span>)swap(cur,left++);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[cur]===<span class="number">2</span>)swap(cur,right--);</span><br><span class="line">        &#125;</span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. 最小路径和</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220412162918.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>一维数组维护<br>例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line">那么路径表则是</span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">6</span></span><br><span class="line"><span class="number">6</span> <span class="number">8</span> <span class="number">7</span><span class="comment">//-&gt;7</span></span><br></pre></td></tr></table></figure><br>其实是一个一维数组的作用 <code>upset = [0]</code><br>状态方程是：<code>Math.min(left,top)+grid[i][j]</code><br>注意边界问题<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minPathSum = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> upset = [<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;grid[i].length;j++)&#123;</span><br><span class="line">            <span class="keyword">let</span> top = <span class="built_in">isNaN</span>(upset[j])?<span class="literal">Infinity</span>:upset[j];</span><br><span class="line">            <span class="keyword">let</span> left = <span class="built_in">isNaN</span>(upset[j-<span class="number">1</span>])?top:upset[j-<span class="number">1</span>];</span><br><span class="line">            ret = <span class="built_in">Math</span>.min(top,left)+grid[i][j];</span><br><span class="line">            upset[j] = ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a>96. 不同的二叉搜索树</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413141814.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numTrees = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//初始化dp数组，dp[0]也就是一边没有节点（拎起的是第一个或最后一个节点），没有节点的组合应该只有一种</span></span><br><span class="line">    <span class="keyword">let</span> dp = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)<span class="keyword">return</span> dp[n];</span><br><span class="line">    <span class="comment">//从3个节点开始遍历到n个节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算出中间节点</span></span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(i/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//j表示拎起第j个节点</span></span><br><span class="line">            <span class="comment">// 总共i个节点</span></span><br><span class="line">            <span class="comment">// i - j 表示拎起的节点的右边节点的数量</span></span><br><span class="line">            <span class="comment">//  左边节点数量为 i - 1 - (i - j) = j - 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=mid;j++)&#123;</span><br><span class="line">            dp[i] += <span class="number">2</span>*dp[i-j]*dp[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点数为奇数时要对中间节点特殊处理</span></span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>!==<span class="number">0</span>)&#123;</span><br><span class="line">            dp[i]+= dp[i-(mid+<span class="number">1</span>)]*dp[i-(mid+<span class="number">1</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a>114. 二叉树展开为链表</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413143531.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flatten = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 拍平左右子树为链表</span></span><br><span class="line">    flatten(root.left);    </span><br><span class="line">    flatten(root.right);    </span><br><span class="line">    <span class="comment">// 保存左右子树</span></span><br><span class="line">    <span class="keyword">let</span> left = root.left;</span><br><span class="line">    <span class="keyword">let</span> right = root.right;</span><br><span class="line">    <span class="comment">// 去掉左子树 将右子树变成左子树</span></span><br><span class="line">    root.left = <span class="literal">null</span>;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="comment">// 拿到现在的树 将右子树插入</span></span><br><span class="line">    <span class="keyword">let</span> p = root;</span><br><span class="line">    <span class="keyword">while</span>(p.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">    p.right = right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a>128. 最长连续序列</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413145212.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>哈希表 建立set 遇到有value1-1就跳过 否则就while判断是否有value+1 有就删除避免重复<br>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestConsecutive = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">    nums = <span class="keyword">new</span> <span class="built_in">Set</span>(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.has(item-<span class="number">1</span>))<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">1</span>;<span class="comment">//本身也算</span></span><br><span class="line">        <span class="keyword">while</span>(nums.has(item+<span class="number">1</span>))&#123;</span><br><span class="line">            nums.delete(item+<span class="number">1</span>);</span><br><span class="line">            item++;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        max = <span class="built_in">Math</span>.max(max,count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413150812.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>先找到slow和fast交点 然后pre开始出发 和slow香蕉则是起点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> detectCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head||!head.next)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> slow = head;</span><br><span class="line">    <span class="keyword">let</span> fast = head;</span><br><span class="line">    <span class="keyword">let</span> pre = head;</span><br><span class="line">    <span class="keyword">while</span>(slow&amp;&amp;fast&amp;&amp;fast.next)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span>(slow === fast)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pre!==slow)&#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a>148. 排序链表</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413152816.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="keyword">new</span> ListNode().next;</span><br><span class="line">    <span class="keyword">const</span> res = [head.val];</span><br><span class="line">    <span class="keyword">let</span> node = head.next;</span><br><span class="line">    <span class="keyword">let</span> node2 = head;</span><br><span class="line">    <span class="keyword">let</span> node3 = node2;</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        res.push(node.val)</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    res.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;res.length;j++)&#123;</span><br><span class="line">        node2.val = res[j];</span><br><span class="line">        node2 = node2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413155543.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>定义max，curMax和curMin初始化为nums0<br>从1开始遍历，curmax，curmin都乘上numsi<br>比较curmax，curmin，numsi三者最大值和最小值分别赋给curmax，curmin<br>如果max小于curmax 交换<br>返回max<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProduct = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums.length)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> [max,curMax,curMin] = [nums[<span class="number">0</span>],nums[<span class="number">0</span>],nums[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        [curMax,curMin] = [curMax*nums[i],curMin*nums[i]];</span><br><span class="line">        [curMax,curMin] = [<span class="built_in">Math</span>.max(curMax,curMin,nums[i]),<span class="built_in">Math</span>.min(curMax,curMin,nums[i])]</span><br><span class="line">        <span class="keyword">if</span>(max&lt;curMax)max =curMax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a>287. 寻找重复数</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413162155.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>哈希表<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findDuplicate = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.has(item))<span class="keyword">return</span> item;</span><br><span class="line">        set.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a>剑指 Offer 07. 重建二叉树</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414140411.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>根节点是前序的第一个为top<br>在中序中indexof该节点p<br>新建树tree 根是top<br>用dfs不断将节点插入treeleft和right 方法是slice<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span> (<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dfs = (<span class="function">(<span class="params">inorder</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!inorder || !inorder.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> top = preorder.shift();</span><br><span class="line">        <span class="keyword">let</span> tree = <span class="keyword">new</span> TreeNode(top);</span><br><span class="line">        <span class="keyword">let</span> p = inorder.indexOf(top);</span><br><span class="line">        tree.left = dfs(inorder.slice(<span class="number">0</span>, p));</span><br><span class="line">        tree.right = dfs(inorder.slice(p + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> dfs(inorder);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a>剑指 Offer 04. 二维数组中的查找</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414142224.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>方法1 拍平然后include<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findNumberIn2DArray = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> matrix.flat(<span class="number">2</span>).includes(target)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>方法2 对每项进行二分<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findNumberIn2DArray = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> matrix)&#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>, right = item.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">const</span> mid = left + ((right-left)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span>(item[mid] === target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a>剑指 Offer 13. 机器人的运动范围</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414152401.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>初始化二维数组，未遍历的为0<br>设置dfs 传入ij，判断越界，已经遍历则直接return<br>否则打上标记 判断分割的数之和是否小于等于k<br>如果是则count++，往下和往右dfs<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> movingCount = <span class="function"><span class="keyword">function</span> (<span class="params">m, n, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(m).fill().map(<span class="function"><span class="params">_</span>=&gt;</span><span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> run = (<span class="function">(<span class="params">i,j</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=m||j&gt;=n)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[i][j])<span class="keyword">return</span>;</span><br><span class="line">        arr[i][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(bitCount(i)+bitCount(j)&lt;=k)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            run(i+<span class="number">1</span>,j);</span><br><span class="line">            run(i,j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> bitCount = (<span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            res += n%<span class="number">10</span>;</span><br><span class="line">            n = <span class="built_in">Math</span>.floor(n/<span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;)</span><br><span class="line">    run(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a>208. 实现 Trie (前缀树)</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220415160850.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Trie = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.trie = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">word</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Trie.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.trie.add(word);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">word</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Trie.prototype.search = <span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.trie.has(word))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">prefix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Trie.prototype.startsWith = <span class="function"><span class="keyword">function</span>(<span class="params">prefix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> <span class="built_in">this</span>.trie)&#123;</span><br><span class="line">        <span class="keyword">if</span>(item.startsWith(prefix))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new Trie()</span></span><br><span class="line"><span class="comment"> * obj.insert(word)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.search(word)</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.startsWith(prefix)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a>406. 根据身高重建队列</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220415162855.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>先用sort 排序第一个数字从大到小，如果相同比较第二个数字按小到大<br>eg<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">7</span>,<span class="number">0</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">2</span>]]</span><br><span class="line">=&gt;</span><br><span class="line">[ [ <span class="number">7</span>, <span class="number">0</span> ], [ <span class="number">7</span>, <span class="number">1</span> ], [ <span class="number">6</span>, <span class="number">1</span> ], [ <span class="number">5</span>, <span class="number">0</span> ], [ <span class="number">5</span>, <span class="number">2</span> ], [ <span class="number">4</span>, <span class="number">4</span> ] ]</span><br></pre></td></tr></table></figure><br>然后用splice在item1前面添加item进行排序<br>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reconstructQueue = <span class="function"><span class="keyword">function</span>(<span class="params">people</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    people.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a[<span class="number">0</span>]===b[<span class="number">0</span>]?a[<span class="number">1</span>]-b[<span class="number">1</span>]:b[<span class="number">0</span>]-a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(people)</span><br><span class="line">    people.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        res.splice(item[<span class="number">1</span>],<span class="number">0</span>,item);</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(reconstructQueue([[<span class="number">7</span>,<span class="number">0</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">2</span>]]))</span><br><span class="line">[ [ <span class="number">7</span>, <span class="number">0</span> ], [ <span class="number">7</span>, <span class="number">1</span> ], [ <span class="number">6</span>, <span class="number">1</span> ], [ <span class="number">5</span>, <span class="number">0</span> ], [ <span class="number">5</span>, <span class="number">2</span> ], [ <span class="number">4</span>, <span class="number">4</span> ] ]</span><br><span class="line">[ [ <span class="number">7</span>, <span class="number">0</span> ] ]</span><br><span class="line">[ [ <span class="number">7</span>, <span class="number">0</span> ], [ <span class="number">7</span>, <span class="number">1</span> ] ]</span><br><span class="line">[ [ <span class="number">7</span>, <span class="number">0</span> ], [ <span class="number">6</span>, <span class="number">1</span> ], [ <span class="number">7</span>, <span class="number">1</span> ] ]</span><br><span class="line">[ [ <span class="number">5</span>, <span class="number">0</span> ], [ <span class="number">7</span>, <span class="number">0</span> ], [ <span class="number">6</span>, <span class="number">1</span> ], [ <span class="number">7</span>, <span class="number">1</span> ] ]</span><br><span class="line">[ [ <span class="number">5</span>, <span class="number">0</span> ], [ <span class="number">7</span>, <span class="number">0</span> ], [ <span class="number">5</span>, <span class="number">2</span> ], [ <span class="number">6</span>, <span class="number">1</span> ], [ <span class="number">7</span>, <span class="number">1</span> ] ]</span><br><span class="line">[ [ <span class="number">5</span>, <span class="number">0</span> ], [ <span class="number">7</span>, <span class="number">0</span> ], [ <span class="number">5</span>, <span class="number">2</span> ], [ <span class="number">6</span>, <span class="number">1</span> ], [ <span class="number">4</span>, <span class="number">4</span> ], [ <span class="number">7</span>, <span class="number">1</span> ] ]</span><br><span class="line">[ [ <span class="number">5</span>, <span class="number">0</span> ], [ <span class="number">7</span>, <span class="number">0</span> ], [ <span class="number">5</span>, <span class="number">2</span> ], [ <span class="number">6</span>, <span class="number">1</span> ], [ <span class="number">4</span>, <span class="number">4</span> ], [ <span class="number">7</span>, <span class="number">1</span> ] ]</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a>238. 除自身以外数组的乘积</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220416141723.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>eg<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pre  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line">res  <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">6</span></span><br><span class="line">prod <span class="number">1</span> <span class="number">2</span> <span class="number">6</span> <span class="number">24</span></span><br><span class="line">=&gt;</span><br><span class="line">res  <span class="number">24</span> <span class="number">12</span> <span class="number">8</span> <span class="number">6</span> </span><br><span class="line">prod <span class="number">24</span> <span class="number">24</span> <span class="number">12</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><br>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> productExceptSelf = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> prod =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        res[i] = prod;</span><br><span class="line">        prod *= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    prod =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        res*=prod;</span><br><span class="line">        prod *= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a>538. 把二叉搜索树转换为累加树</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220416142809.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>BST中序遍历为升序列，逆向中序遍历为降序列。<br>使用一个sum变量记录累加和，从大到小（树从右到左）遍历一遍，每次加上结点本身的值即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> convertBST = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> inOrderR = (<span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n)<span class="keyword">return</span>;</span><br><span class="line">        inOrderR(n.right);</span><br><span class="line">        sum+=n.val;</span><br><span class="line">        n.val = sum;</span><br><span class="line">        inOrderR(n.left);</span><br><span class="line">    &#125;)</span><br><span class="line">    inOrderR(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220416145609.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>新建根broot dfs初始化count<br>count增加的条件是当当前值等于p或q的时候<br>如果broot还不存在<br>如果此时左子树还有 递归左子树找相同 count+=dfs左<br>如果broot还不在 就是说左边没有或者只有一个 那么count+=dfs右<br>如果broot还不在且count找到两个节点 那么回源root就是他的公共祖先<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span> (<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> broot = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> dfs = (<span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n.val === p.val || n.val === q.val)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!broot)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n.left)&#123;</span><br><span class="line">                count+=dfs(n.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!broot&amp;&amp;n.right)&#123;</span><br><span class="line">                count+=dfs(n.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!broot&amp;&amp;count === <span class="number">2</span>)&#123;</span><br><span class="line">                broot = n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> broot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220416153654.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>单调栈<br>先看看一个单调栈的做法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调递增栈的实现</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> res = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (res.length &amp;&amp; res[res.length - <span class="number">1</span>] &lt; arr[i]) &#123;</span><br><span class="line">        res.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(arr[i])</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6 5 3</span></span><br></pre></td></tr></table></figure><br>过程是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">3</span> ]</span><br><span class="line">[ <span class="number">4</span> ]</span><br><span class="line">[ <span class="number">4</span>, <span class="number">2</span> ]</span><br><span class="line">[ <span class="number">6</span> ]</span><br><span class="line">[ <span class="number">6</span>, <span class="number">4</span> ]</span><br><span class="line">[ <span class="number">6</span>, <span class="number">5</span> ]</span><br><span class="line">[ <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span> ]</span><br><span class="line">[ <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span> ]</span><br></pre></td></tr></table></figure><br>所以本题 弹出的时候取到index 然后<code>res[index] = i-index</code><br>注意栈放的是下标<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dailyTemperatures = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(stack.length&amp;&amp;nums[i]&gt;nums[stack[stack.length-<span class="number">1</span>]])&#123;</span><br><span class="line">            <span class="keyword">let</span> index = stack.pop();</span><br><span class="line">            res[index] = i - index;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220417140715.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>bfs<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220417140747.png" alt=""><br>注意bfs的技巧是 第一次for因为后续要带入新的length，所以不能写<code>i&lt;xxx.length</code>而是要写<code>len=xxx.length;i&lt;len</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> numSquares = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> queue = [n];</span><br><span class="line">    <span class="keyword">let</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> visitMap = &#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        level++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,len=queue.length;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> cur = queue.shift();</span><br><span class="line">            <span class="keyword">let</span> maxNum = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.sqrt(cur));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=maxNum;j++)&#123;</span><br><span class="line">                <span class="keyword">let</span> res = cur - j*j;</span><br><span class="line">                <span class="keyword">if</span>(res === <span class="number">0</span>) <span class="keyword">return</span> level;</span><br><span class="line">                <span class="keyword">if</span>(!visitMap[res])&#123;</span><br><span class="line">                    visitMap[res]=<span class="literal">true</span>;</span><br><span class="line">                    queue.push(res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a>347. 前 K 个高频元素</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220417143843.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>设置map对每个元素出现的次数进行维护<br>然后使用解构和sort分类出最大次数的<br>最后利用slice+map返回前k高频<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> topKFrequent = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    nums.forEach(<span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">        map.set(n,map.has(n)?map.get(n)+<span class="number">1</span>:<span class="number">1</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> resArr = [...map].sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>b[<span class="number">1</span>]-a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> resArr.slice(<span class="number">0</span>,k).map(<span class="function"><span class="params">n</span>=&gt;</span>n[<span class="number">0</span>])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出vue.js</title>
    <link href="https://zlinni.github.io/posts/885b6d5d3821/"/>
    <id>https://zlinni.github.io/posts/885b6d5d3821/</id>
    <published>2022-03-06T13:45:45.000Z</published>
    <updated>2022-03-18T11:44:22.842Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tip cogs"><p>记录《深入浅出Vue.js》这本书中的内容，以笔记的形式了解vue之中涉及的部分原理</p></div><h1 id="Object变化侦测"><a href="#Object变化侦测" class="headerlink" title="Object变化侦测"></a>Object变化侦测</h1><div class="tip "><p>vue的特性之一就是响应式系统，我们在学习的过程中知道它是通过侦测数据的变化进行视图的更新，而具体到其中的原理是什么呢？</p></div><h2 id="推和拉"><a href="#推和拉" class="headerlink" title="推和拉"></a>推和拉</h2><p>变化侦测分为两种类型 一种是推一种是拉。<br>在Angular和React里面，变化侦测的内容属于”拉“，意思是当状态发生变化的时候，它不知道哪个状态改变了。只知道状态有可能变了。然后发送一个信号告诉框架。<br>而在Vue当中，变化侦测属于”推”。当状态发送改变的时候，vue立刻就知道了，然后在一定程度上知道哪些状态变了。意味着vue能进行颗粒度更细的更新。</p><h2 id="颗粒度"><a href="#颗粒度" class="headerlink" title="颗粒度"></a>颗粒度</h2><p>所谓颗粒度呢，就是指某一个状态在发生更新的时候，会影响到多少节点。举个例子来说，假如一个状态绑定着很多个依赖，此时每个依赖表示一个具体的DOM节点，当这个状态改变的时候，会向所有依赖发出通知，进行更新操作。<br>因此颗粒度越细，开销也就越大，所以vue将粒度调为中等，同时将依赖绑定的DOM节点换为了组件。</p><h2 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h2><p>vue中，先前的版本里，es6对浏览器的支持并不理想，所以采取了<code>defineProperty</code>的方法而非<code>Proxy</code>，通过前者的方法可以很容易的侦测对象的变化，并用getter/setter来对对象进行响应式的处理。</p><h2 id="如何收集依赖"><a href="#如何收集依赖" class="headerlink" title="如何收集依赖"></a>如何收集依赖</h2><p>在本节中，依赖的收集其实是使用到了getter，触发依赖使用到了setter。</p><h2 id="依赖收集在哪里？"><a href="#依赖收集在哪里？" class="headerlink" title="依赖收集在哪里？"></a>依赖收集在哪里？</h2><p>很清晰的理解，知道要收集依赖，那么势必有保存依赖的地方，而这个地方最好是唯一的，全局性的，因为我们做出的改变需要通知到这个依赖，然后让这样依赖去反馈或者处理我们需要的数据等。<br>代码的编写方面 在get中push数据到window的全局变量中，然后在set中循环触发依赖。<br>但是这样编写代码还是有点耦合，于是把收集依赖处理依赖的代码封装成一个Dep类，这个类中有增删改查的方法，还要向依赖发送通知的方法。这样只需要在变化侦测的代码中实例化这个Dep类就可以使用以上方法。</p><h2 id="依赖是谁？"><a href="#依赖是谁？" class="headerlink" title="依赖是谁？"></a>依赖是谁？</h2><p>在上一小节中，知道依赖最好是存放到一个全局变量中访问和获取，并且在我们调用get的时候负责管理依赖的类会执行修改 set的时候会新增，但我们收集完这些依赖，实际上是要去告诉其他地方或者其他用到依赖的地方，去通知他们要修改，而对于这个起到通知作用的类，我们称之为Watcher。<br>(在下面会了解到依赖其实就是watcher实例)</p><h2 id="Watcher是谁？"><a href="#Watcher是谁？" class="headerlink" title="Watcher是谁？"></a>Watcher是谁？</h2><p>在vue的watch方法中，可以知道参数变化之后触发函数的功能。而这个Watcher类也是需要做到这样的事情。在代码中可以看见，作者通过将Watcher类的this赋值给全局变量，然后再读取值触发getter方法，将watcher实例传输到Dep类中，这样Dep就会获取到该实例并且进行增删改查。在增删改查的部分，还会用到watcher的update方法，这就是代码的神奇之处。<br>写到这里可能有点一头雾水，实际上依赖就是这个watcher实例，这个类就是负责通知Dep是否进行增删改查的。</p><h2 id="递归侦测所有key"><a href="#递归侦测所有key" class="headerlink" title="递归侦测所有key"></a>递归侦测所有key</h2><p>其实写到这里 已经满足了变化侦测的基本需求了。但是如果我们想检测到数据中所有的属性，光是上面还不够，需要封装一个Observer类。这个类将数据内的全部属性，包括子属性，都转化成getter、setter的形式，然后去追踪它们的变化。</p><h2 id="Observer的缺点"><a href="#Observer的缺点" class="headerlink" title="Observer的缺点"></a>Observer的缺点</h2><p>上面实现了传入一个obj变成响应式obj的Observer类。但其实它也存在缺点，比如我们要使用点运算符新增一个数据或者delete方法删除一个数据的时候，vue并不能检测到，这是因为getter/setter方法本身只支持数据的修改，不能检测到数据的增加和删除。但是vue提供了两个api来帮助解决这个问题。一个是<code>vm.$set</code>，另外一个是<code>vm.$delete</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>变化侦测就是侦测数据的变化，当数据发生变化的时候，能侦测到并发出通知。<br>Object通过defineProperty的方法来将属性转化为响应式来追踪数据的变化。我们需要在getter中收集依赖，当setter被触发的时候通知getter中收集的依赖数据发生变化。<br>收集依赖需要为依赖找到一个存储依赖的地方，为此创建了Dep用于收集依赖，删除依赖和向依赖发送信息。<br>所谓的依赖，其实就是Watcher。只有Watcher触发的getter才会收集依赖，哪个watcher触发了getter，就把哪个watcher收集到Dep。当数据发生变化的时候，会循环依赖列表，把所有的watcher都通知一遍。</p><h1 id="Array变化侦测"><a href="#Array变化侦测" class="headerlink" title="Array变化侦测"></a>Array变化侦测</h1><div class="tip "><p>上文介绍了Object的变化侦测 但是getter和setter方法并不会触发数组的方法，比如push，pull等等，下面讲解vue是如何操作使得数组的操作能够被检测</p></div><h2 id="如何追踪变化-1"><a href="#如何追踪变化-1" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h2><p>我们知道Object的变化是靠setter来追踪的，一旦数据发送了变化 就触发setter。<br>那么我们只要操作数组的时候，通知到一个容器让他存储这种变化即可。<br>可惜的是在es6之前没有提供元编程的能力，也没有提供拦截原型方法的能力，但是程序员可以自己创建一个方法，取拦截<code>Array.prototype</code>之后我们想使用Array上面的方法去操作数组的时候，使用的都是拦截器上面的方法，然后在拦截器中使用原生Array原型上面的方法去操作数组。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220317212521.png" alt=""></p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>拦截器其实是一个和<code>Array.prototype</code>一样的<code>Object</code> 里面包含的属性一模一样，只不过这个<code>object</code>中某些可以改变数组和自身内容的方法是处理过的。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220317213444.png" alt=""><br>代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto);</span><br><span class="line">[<span class="string">&#x27;push&#x27;</span>,<span class="string">&#x27;pop&#x27;</span>,<span class="string">&#x27;shift&#x27;</span>,<span class="string">&#x27;unshift&#x27;</span>,<span class="string">&#x27;splice&#x27;</span>,<span class="string">&#x27;sort&#x27;</span>,<span class="string">&#x27;reverse&#x27;</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>))</span>&#123;</span><br><span class="line"><span class="comment">//缓存原始方法</span></span><br><span class="line"><span class="keyword">const</span> original = arrayProto[method];</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(arrayMethods,methods,&#123;</span><br><span class="line"><span class="attr">value</span>:<span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> original.apply(<span class="built_in">this</span>,args);<span class="comment">//触发Array上面的方法</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">enumerable</span>:<span class="literal">false</span>,</span><br><span class="line"><span class="attr">writable</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">configurable</span>:<span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在上面的代码中 创建了变量<code>arrayMethods</code>，继承自<code>Array.prototype</code>，所以有它的全部功能。然后用<code>arrayMethods</code>去覆盖数组原型。<br>接着封装数组的方法在<code>Object.defineProperty</code>中<br>假如使用的是push，那么实际上调用的是<code>arrayMethods.push</code>然后<code>arrayMethods.push</code>是函数<code>mutator</code>所以实际执行的是<code>mutator</code>函数<br>最后在<code>mutator</code>中执行<code>original</code>（它是原生数组原型上面的方法 比如push）来做它应该做的事情。<br>因此我们就可以在<code>mutator</code>中做一些其他的事情 比如发送变化通知。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>CDN内容分发网络</title>
    <link href="https://zlinni.github.io/posts/5e2ce1604d71/"/>
    <id>https://zlinni.github.io/posts/5e2ce1604d71/</id>
    <published>2022-02-25T10:59:07.000Z</published>
    <updated>2022-02-27T02:49:12.953Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>大家可能都有过这样的经历，把博客建立在类似github上面的外网上，然后国内正常的访问方式访问博客，静态资源的加载速度都非常的慢，解决这个问题的方法就是使用CDN，依赖市场上的CDN，可以实现博客的加速访问，接下来就来详细讲述CDN（内容分发网络）的原理。</p></div><h1 id="Content-Delivery-Network"><a href="#Content-Delivery-Network" class="headerlink" title="Content Delivery Network"></a>Content Delivery Network</h1><p>CDN全称是Content Delivery Network，俗称内容分发网络，它是集中在世界各地的边缘服务器的集合。当你的服务器需要给来自世界各地的用户响应内容的时候，由于距离原因难免会有很大的网络延迟，所以就有人专门在世界各地设置了能帮你转发内容的服务器，并且有专门的人员进行维护。这些服务器叫做边缘服务器，意思就是接近用户的服务器，它们构建起来就是内容分发网络体系。CDN的这些服务器就是近距离给用户发送网页内容的。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220227095858.png" alt=""></p><h1 id="分发内容"><a href="#分发内容" class="headerlink" title="分发内容"></a>分发内容</h1><p>CDN服务器分发的内容分为两个部分，一个是静态内容，一个是动态内容。<br>简单的理解可以是长期不需要改变的内容为静态内容，经常需要改变的内容为动态内容，就好比网页中的标题，导航栏等，就是一开始设计好之后就基本不会更改的。而类似于echarts图表这种，可能会随某些操作进行变化的称之为动态内容。<br>像博客这种大部分都是静态内容的就很适合使用CDN，接下来通过分发流程讲解原因。</p><h1 id="分发流程"><a href="#分发流程" class="headerlink" title="分发流程"></a>分发流程</h1><p>CDN肯定一开始是不知道源服务器给了什么内容的，就需要主服务器将静态内容提前push到CDN服务器上面，当世界各地的用户需要访问网站的时候，就近的CDN就把内容响应到客户端，这也就是说如果你的静态博客像hexo这样的，在本地发布好才上传的博客，就可以先将静态的内容通过主服务器缓存到CDN服务器上面，这样客户端访问就可以飞快的运行。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220227100752.png" alt=""><br>如果是动态内容，由于主服务器没办法预测用户会产生怎么样的动态数据，所以也就没办法提前缓存到CDN服务器上面，这样的话CDN的作用就不是很大了，虽然也有CDN能够提高动态的服务，比方说时间。时间是一直变动的，如果一直让主服务器提供时间的动态内容，万一主服务器产生了网络的波动，时间就没办法同步。这时候就可以采用CDN上面的接口。有些CDN会提供类似的时间接口，让主服务器用CDN上面的接口，这样用户就可以直接在CDN上面获取时间，而不是通过主服务器了<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220227102557.png" alt=""><br>CDN的设置无形中给主服务器设置了一道墙，因为访问主服务器的内容就得先访问CDN服务器，这样就能减少或者避免DDOS攻击，但是这样一来就会攻击CDN服务器了。这样的话CDN服务器接受的了吗？</p><h1 id="安全性和可靠性"><a href="#安全性和可靠性" class="headerlink" title="安全性和可靠性"></a>安全性和可靠性</h1><p>CDN的老板们肯定考虑过这个问题，他们将检测多台服务器的负载情况，如果说某台服务器超载了，那么就把用户的请求移动到没有超载的CDN服务器上面，这种情况也称之为负载均衡。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220227102959.png" alt=""><br>但是CDN是怎么将这些流量转移到别的服务器的呢？这里值得一提的是这个名为任播的技术，利用它的通信方式，服务器对外都拥有同样的ip地址<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220227103208.png" alt=""><br>如果这个ip地址收到用户的请求之后，请求就会由距离最近的CDN服务器响应，同样的道理，只要使用这个技术，不管你的攻击有多猛烈，都可以将流量转移到没有超载的服务器上面<br>不仅如此，CDN还会帮你把文件进行最小化或者压缩文档，就和webpack打包之后生成的js/css代码类似，省略掉不必要的字符后都是一行的。<br>最后正式因为CDN更加接近用户提供服务，大大减小了CDN到源服务器之间的带宽的占用和使用</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>大部分的镜像源和网站都会使用CDN，比如npm的unpkg，hexo使用的jsdelivr，这些免费的东西最后可能还是会避免不了被禁用的命运。比如后者在国内的驾驶照就被吊销了，只能使用所谓的“附近”节点，导致hexo有段时间直接GG，好在现在笔者所处的位置访问还算ok，可能以后会考虑部署到自己的服务器上面并购置CDN包吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="网络" scheme="https://zlinni.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Vue打包优化+可视化js体积</title>
    <link href="https://zlinni.github.io/posts/105e254930e2/"/>
    <id>https://zlinni.github.io/posts/105e254930e2/</id>
    <published>2022-02-25T04:21:03.000Z</published>
    <updated>2022-02-25T06:39:00.813Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>最近在了解性能优化的时候发现了vue的打包优化，其原理就是通过cdn的方式引入插件从而减小打包后的js和css体积。还有一个则是一款插件，可以让vue打包后以网页的形式显示js和css体积，更加直观。</p></div><h1 id="webpack-bundle-analyzer"><a href="#webpack-bundle-analyzer" class="headerlink" title="webpack-bundle-analyzer"></a>webpack-bundle-analyzer</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">效果预览</button></li><li class="tab"><button type="button" data-href="#test-2">安装方式</button></li><li class="tab"><button type="button" data-href="#test-3">使用教程</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>鼠标移动到上面会显示相关的js大小<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220225123114.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>项目地址：<a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">传送门</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NPM</span></span><br><span class="line">npm install --save-dev webpack-bundle-analyzer</span><br><span class="line"><span class="comment"># Yarn</span></span><br><span class="line">yarn add -D webpack-bundle-analyzer</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><ol><li>安装</li><li>打开<code>package.json</code>，修改<code>script</code>下面的<code>build</code><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;vue-cli-service serve&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;vue-cli-service build --report&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;vue-cli-service lint&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li>新建<code>vue.config.js</code>写入以下内容<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>).BundleAnalyzerPlugin;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">        <span class="attr">plugins</span>: [</span><br><span class="line">            <span class="keyword">new</span> BundleAnalyzerPlugin()</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>npm run build</code>打包项目，会在dist下面生成一个<code>report.html</code>，右键运行</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="vue打包优化-cdn"><a href="#vue打包优化-cdn" class="headerlink" title="vue打包优化+cdn"></a>vue打包优化+cdn</h1><p>原理：通过cdn的方式引入插件从而减小打包后的js和css体积<br>这里要用到<code>configureWebpack</code>里面的<code>externals</code>配置项，简单说一下该配置项:就是不通过npm下载的类库，在html文件中以script引入，然后在页面中使用import导入的这种方式<br>写法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>).BundleAnalyzerPlugin;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">    <span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">        <span class="attr">externals</span>:&#123;</span><br><span class="line">            <span class="string">&#x27;vue&#x27;</span>:<span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;vue-router&#x27;</span>:<span class="string">&#x27;VueRouter&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;vuex&#x27;</span>:<span class="string">&#x27;Vuex&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;vuetify&#x27;</span>:<span class="string">&#x27;Vuetify&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">plugins</span>: [</span><br><span class="line">            <span class="keyword">new</span> BundleAnalyzerPlugin()</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中 配置项里面的键指的是<code>package.json</code>中依赖的名字，后面跟的是对应的cdn里面的全局变量，一般来说只要上述三个加ui（如果你的ui按需引入则不用添加上去）达到减小打包体积。<br>注意:</p><ol><li>你的页面有多少个全局插件，就引入多少个对应的值<br>然后在<code>public</code>下面的<code>index.html</code>中配置插件的地址，可以用免费的cdn引入，推荐bootcdn<a href="https://www.bootcdn.cn/">传送门</a>。<br>接着看你自己依赖中写的对应的版本，这里我的依赖放出来演示一下<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;core-js&quot;</span>: <span class="string">&quot;^3.6.5&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;echarts&quot;</span>: <span class="string">&quot;^5.3.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;less-loader&quot;</span>: <span class="string">&quot;^6.2.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;nanoid&quot;</span>: <span class="string">&quot;^3.2.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;pubsub-js&quot;</span>: <span class="string">&quot;^1.9.4&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;vue&quot;</span>: <span class="string">&quot;^2.6.11&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;vue-clock-lonlyape&quot;</span>: <span class="string">&quot;^1.2.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;vue-router&quot;</span>: <span class="string">&quot;^3.5.3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;vuetify&quot;</span>: <span class="string">&quot;^2.6.2&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;vuex&quot;</span>: <span class="string">&quot;^3.6.2&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;vuex-persist&quot;</span>: <span class="string">&quot;^3.1.3&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">        externals:&#123;</span><br><span class="line">          &#x27;vue&#x27;:&#x27;Vue&#x27;,</span><br><span class="line">          &#x27;vue-router&#x27;:&#x27;VueRouter&#x27;,</span><br><span class="line">          &#x27;vuex&#x27;:&#x27;Vuex&#x27;,</span><br><span class="line">          &#x27;vuetify&#x27;:&#x27;Vuetify&#x27;,</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>举例这个vue是<code>2.6.11</code>版本的，就打开bootcdn搜索vue，找到该版本并复制<code>min.js</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220225142247.png" alt=""><br>从官网上拷贝到相应的cdn地址之后引入：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220225124252.png" alt=""><br>之后重新打包即可看到体积比之前减小了很多。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>牛客网刷题record</title>
    <link href="https://zlinni.github.io/posts/2d20c31c4911/"/>
    <id>https://zlinni.github.io/posts/2d20c31c4911/</id>
    <published>2022-02-22T10:49:45.000Z</published>
    <updated>2022-03-01T10:53:46.506Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>记录一下牛客网的错题记录以及知识点，用于查漏补缺</p></div><h1 id="基础不牢，地动山摇Day1"><a href="#基础不牢，地动山摇Day1" class="headerlink" title="基础不牢，地动山摇Day1"></a>基础不牢，地动山摇Day1</h1><details class="folding-tag" blue><summary> 行内元素 </summary>              <div class='content'>              <p>行内元素典型代表 span  ,a,  ,strong , em,  del,  ins<br>特点：</p><ol><li>在一行上显示</li><li>不能直接设置宽高</li><li>元素的宽和高就是内容撑开的宽高。</li></ol><p>行内块元素（内联元素）典型代表  input  img<br>特点：</p><ol><li>在一行上显示</li><li>可以设置宽高</li></ol><p>块元素典型代表,div,h1-h6,p,ul,li<br>特点: </p><ol><li>独占一行</li><li>可以设置宽高</li><li>嵌套（包含）下，子块元素宽度（没有定义情况下）和父块元素宽度默认一致。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220222191634.png" alt=""><br>行内元素不可以设置宽高，但是可以设置   左右padding、左右margin</li></ol>              </div>            </details><details class="folding-tag" blue><summary> `link`和`import` </summary>              <div class='content'>              <p>link除了引用样式文件，还可以引用图片等资源文件，而import只引用样式文件<br>link属于html范畴 import属于css范畴<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;any&quot;</span> <span class="attr">mask</span> <span class="attr">href</span>=<span class="string">&quot;//www.baidu.com/img/baidu.svg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>兼容性不同，link不存在兼容性的问题，import在IE5以上支持，是css2.1新增的<br>在样式表文件可以使用import导入其它的样式表文件，而link不可以<br>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。<br>link支持使用Javascript控制DOM去改变样式；而@import不支持。<br>原文链接：<a href="https://blog.csdn.net/lxcao/article/details/52639442">https://blog.csdn.net/lxcao/article/details/52639442</a></p>              </div>            </details><details class="folding-tag" blue><summary> DOM事件 </summary>              <div class='content'>              <p>onchange()  事件会在域的内容改变时发生<br>比如：<code>&lt;input type=&quot;text&quot;&gt;, &lt;select&gt;, &lt;textarea&gt;</code></p><p>onblur()  会在对象失去焦点时发生</p>              </div>            </details><details class="folding-tag" blue><summary> css选择器 </summary>              <div class='content'>              <p>这次主要错在了相邻兄弟选择器<br>eg<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span> + <span class="selector-class">.b</span>&#123;xxx&#125;</span><br></pre></td></tr></table></figure><br>这样的是选择兄弟中第一个叫b的人，而不是所有兄弟b</p>              </div>            </details><details class="folding-tag" blue><summary> input的元素 </summary>              <div class='content'>              <p>text password radio checkbox submit reset file image search button<br>email url number range color<br>关于时间 (date, month, week, time, datetime, datetime-local)</p>              </div>            </details><details class="folding-tag" blue><summary> 获取用户位置H5 </summary>              <div class='content'>              <p><code>getCurrentPosition()</code></p>              </div>            </details><details class="folding-tag" blue><summary> fieldset </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220222191949.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> audio和video </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220222192302.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220222192326.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220224164217.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> DHTML </summary>              <div class='content'>              <p>DHTML 将 HTML、JavaScript、DOM 以及 CSS 组合在一起，用于创造动态性更强的网页。<br>通过 JavaScript 和 HTML DOM，能够动态地改变 HTML 元素的样式。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220223205919.png" alt=""><br>DHTML具有三个主要优点：动态样式、动态内容、动态定位</p>              </div>            </details><details class="folding-tag" blue><summary> H5中可以省略结束标记的标签 </summary>              <div class='content'>              <p>选C，html5中可以省略结束标记的元素有<br>1、dd<br>2、dt<br>3、li<br>4、p<br>5、optgroup<br>6、option<br>7、rt<br>8、rp<br>9、thread<br>10、tfoot<br>11、tr<br>12、td<br>13、th </p>              </div>            </details><details class="folding-tag" blue><summary> 锚伪类 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220222192700.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> nthchild的n从0开始 </summary>              <div class='content'>              <p>xx</p>              </div>            </details><details class="folding-tag" blue><summary> BFC </summary>              <div class='content'>              <p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与,<br>哪些情况会产生BFC:<br>根元素<br>float属性不为none<br>position为absolute或fixed<br>display为inline-block, table-cell, table-caption, flex, inline-flex<br>overflow不为visible<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220223195229.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220223195252.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> H5新增的标签 </summary>              <div class='content'>              <p>新增header，footer，nav，article，section，aside，datalist，audio，video，embed，input属性<br>没有head！！！</p>              </div>            </details><details class="folding-tag" blue><summary> ul和ol </summary>              <div class='content'>              <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;blockquote&gt; 标签定义块引用。 &lt;h1&gt; - &lt;h6&gt; 标签可定义标题。 &lt;strong&gt; 标签和 &lt;em&gt; 标签一样，用于强调文本，但不加粗，是斜体。它强调的程度更强一些。 &lt;a&gt;标签定义超链接，用于从一张页面链接到另一张页面。 &lt;p&gt;标签定义段落。 &lt;section&gt; 标签定义文档中的节（section、区段）。 &lt;nav&gt; 标签定义导航链接的部分。 &lt;ul&gt; 标签定义无序列表。 &lt;ol&gt; 标签定义有序列表。</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> `button`不建议嵌套`a` </summary>              <div class='content'>              <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A：&lt;p&gt; 元素的父元素不能是 &lt;a&gt; 元素（最后一个 &lt;p&gt; 元素不满足这条件），见 MDN</span><br><span class="line">B: &lt;button&gt; 是行内块元素，可以嵌套行内元素。但是，不推荐嵌套 &lt;a&gt; 元素！！！</span><br><span class="line">   在比较多的 UI 库中，都是 &lt;a&gt; 元素嵌套 &lt;button&gt; 元素的。（自己试一下就知道区别了）</span><br><span class="line">C：正确</span><br><span class="line">D：&lt;dl&gt;、&lt;dt&gt;、&lt;dd&gt; 、&lt;h&gt;这些 标题标签 不推荐嵌套块级元素</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> `img` </summary>              <div class='content'>              <p><code>img</code>是<code>src</code>不是<code>href</code></p>              </div>            </details><details class="folding-tag" blue><summary> 定位 </summary>              <div class='content'>              <p>relative是相对于自身进行偏移的</p>              </div>            </details><h1 id="基础不牢，地动山摇Day2"><a href="#基础不牢，地动山摇Day2" class="headerlink" title="基础不牢，地动山摇Day2"></a>基础不牢，地动山摇Day2</h1><div class="note primary flat"><p>今天先回顾一下day1的错题，然后今天开始有每日总结</p></div><details class="folding-tag" blue><summary> H5元素 </summary>              <div class='content'>              <p>h5没有删除small元素<br>废除了能用css代替的元素：basefont、big、center、font、s、strike、tt、u</p>              </div>            </details><details class="folding-tag" cyan><summary> 空元素 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220223104325.png" alt=""><br><code>address</code>用于定义文档或文章的作者/拥有者的联系信息。<br><code>&lt;embed&gt;</code> 标签定义嵌入的内容，比如插件。<br><code>&lt;wbr&gt;</code>元素来添加 Word Break Opportunity（单词换行时机）。</p>              </div>            </details><details class="folding-tag" cyan><summary> date </summary>              <div class='content'>              <p><code>&lt;input type=&quot;datetime-local&quot; &gt;</code>可以用来显示本地时间，且时间不可以修改</p>              </div>            </details><details class="folding-tag" cyan><summary> meta标签 </summary>              <div class='content'>              <p>meta标签是描述一些基本的元数据<br>head标签可以包含，title、meta、link、script 等<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220223110914.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> dl标签 </summary>              <div class='content'>              <p>dl标签定义一个描述列表<br>dl标签和dt标签（定义项目/名字）和dd标签（描述每一个项目/名字）一起使用<br>且dt和dd同级，但dt要在dd前面</p>              </div>            </details><details class="folding-tag" cyan><summary> radio属性与label绑定 </summary>              <div class='content'>              <p>input中的radio属性以name来划分组，有且仅有一个被选中<br>label和radio绑定有两种方法</p><ol><li>label和input同级，label的for属性值与input的id相同<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;radioA&quot;</span> <span class="attr">name</span>=<span class="string">&quot;radio1&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;radioA&quot;</span>&gt;</span>这是radioA<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;radioB&quot;</span> <span class="attr">name</span>=<span class="string">&quot;radio1&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;radioB&quot;</span>&gt;</span>这是radioB<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>label里面嵌套input<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;radio2&quot;</span>&gt;</span>这是radioA<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;radio2&quot;</span>&gt;</span>这是radioB<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>另外注意label只有两个属性for（规定 label 绑定到哪个表单元素）和form（规定 label 字段所属的一个或多个表单）</li></ol>              </div>            </details><details class="folding-tag" cyan><summary> 注释问题 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220223105322.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> object元素 </summary>              <div class='content'>              <p>称为html嵌入对象元素，表示引入一个外部资源，这个资源可能是一张图片，一个嵌入的浏览上下文，亦或是一个插件所使用的资源<br><code>param</code>用来为object或applet元素定义的对象或小程序进行初始化参数设置，param为object、applet的子元素，因此param只可以放置在object、applet元素的标签内容中。</p>              </div>            </details><details class="folding-tag" cyan><summary> contextmenu 和 spellcheck </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220223105622.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> 脱标 </summary>              <div class='content'>              <p>浮动（float）、固定定位（fixed）和绝对定位（absolute）都会使元素脱离文档流</p>              </div>            </details><details class="folding-tag" cyan><summary> track标签 </summary>              <div class='content'>              <p><track> 标签为诸如 video 元素之类的媒介规定外部文本轨道。</p><p>用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。</p><p><track> 标签是 HTML 5 中的新标签。<br>目前所有主流浏览器都不支持 <track> 标签</p>              </div>            </details><details class="folding-tag" cyan><summary> canvas和svg比较 </summary>              <div class='content'>              <p>Canvas 与 SVG 的比较<br>下表列出了 canvas 与 SVG 之间的一些不同之处。</p><p>Canvas<br>依赖分辨率<br>不支持事件处理器<br>弱的文本渲染能力<br>能够以 .png 或 .jpg 格式保存结果图像<br>最适合图像密集型的游戏，其中的许多对象会被频繁重绘<br>Canvas 是逐像素进行渲染的。</p><p>在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</p><p>什么是SVG?<br>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)<br>SVG 用来定义用于网络的基于矢量的图形<br>SVG 使用 XML 格式定义图形<br>SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失<br>SVG 是万维网联盟的标准<br>SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体<br>(SVG是HTML下的一个分支)</p><p>SVG<br>不依赖分辨率<br>支持事件处理器<br>最适合带有大型渲染区域的应用程序（比如谷歌地图）<br>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）<br>不适合游戏应用</p>              </div>            </details><details class="folding-tag" cyan><summary> 高亮显示 </summary>              <div class='content'>              <p>mark<br>jquery的话是highlight<br>（1）highlight jQuery中的，突出特效，通过改变背景颜色来隐藏或者显示一个元素<br>（2）mark h5中的标签，定义带有记号的文本，文本高亮显示<br>（3）strong HTML中的标签，定义重要文本，用来加粗文本<br>（4）blink 是js中的方法，用于显示闪动的字符串，不能用于ie，Chrome，Safari</p>              </div>            </details><details class="folding-tag" cyan><summary> form属性 </summary>              <div class='content'>              <p>首先form的methods里面只有get和post 其他的方法是在ajax里面的<br>然后enctype属性规定发送到服务器之前一个如何对表单数据进行编码，它的默认值是<code>application/x-www-form-urlencoded</code></p>              </div>            </details><details class="folding-tag" cyan><summary> h5新特性 </summary>              <div class='content'>              <p>audio和video支持<br>Canvas<br>localStorage<br>WebSocket<br>…</p>              </div>            </details><details class="folding-tag" cyan><summary> 属性值顺序 </summary>              <div class='content'>              <p>上右下左 顺时针</p>              </div>            </details><details class="folding-tag" cyan><summary> 获取selected文本框的值或文本 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220223123244.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> extra 知识 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220223123424.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> 父类高度塌陷问题 </summary>              <div class='content'>              <p>如果子元素都是浮动</p><ol><li>直接给父元素设置高度，在子元素改变的情况下，此方法使用起来比较繁杂。</li><li>给父元素直接设置 overflow:hidden;样式 </li><li>父元结束标签之前加空div，样式为 clear：both； </li><li>伪元素选择器,父元素加上clearfix</li></ol>              </div>            </details><details class="folding-tag" cyan><summary> jq滑动 </summary>              <div class='content'>              <p><code>slideUp()</code>和<code>slideDown</code>都是jQuery函数，<code>slideUp()</code>通过使用滑动效果，隐藏被选元素，如果元素已显示出来的话。<code>slideDown()</code> 方法通过使用滑动效果，显示隐藏的被选元素。</p>              </div>            </details><details class="folding-tag" cyan><summary> WebStorage </summary>              <div class='content'>              <p>其实就是localStorage和sessionStorage的统称。<br>WebStorage存储是HTML5为数据存储在客户端提供的一项重要功能，分为两种：sessionStorage(保存会话数据)和loaclStorage(在客户端长期保存数据)。</p>              </div>            </details><details class="folding-tag" cyan><summary> svg标签 </summary>              <div class='content'>              <p>SVG 即 Scalable Vector Graphics，是一种用来绘制 矢量图 的 HTML5 标签。你只需定义好XML属性，就能获得一致的图像元素。<br>svg的嵌入：使用object标签才行 不能直接嵌入</p>              </div>            </details><details class="folding-tag" cyan><summary> 怪异模式/兼容模式 </summary>              <div class='content'>              <p>在 HTML 中，文档类型 doctype 的声明是必要的。在所有文档的头部，你都将会看到”&lt;!DOCTYPE html&gt;” 的身影。这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“怪异模式(兼容模式)”的渲染模式。“&lt;!DOCTYPE html&gt;” 确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。<br>也就是没有声明的话是进入怪异模式</p>              </div>            </details><details class="folding-tag" cyan><summary> h5跨文档消息传输 </summary>              <div class='content'>              <p>h5提供了网页文档之间发送信息和相互接收的功能。使用这个功能，只要获得网页窗口所在对象的实例，既可以实现同域 跨域的通信</p>              </div>            </details><details class="folding-tag" cyan><summary> 权重计算 </summary>              <div class='content'>              <p>1.通配符选择器和继承:权重为0， 2.标签选择器:权重为0001 3.类选择器:权重为0010 4.id选择器:权重为0100 5.行内样式:权重为1000 6.!important:权重为无穷大<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220223200820.png" alt=""><br>另外值得一提的是 继承的优先级是没有自身设置的高的 即使继承的是<code>!important</code></p>              </div>            </details><details class="folding-tag" cyan><summary> h5新增 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220223195547.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220223195557.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> border边框 </summary>              <div class='content'>              <p>none 无边框样式 自然没有宽度这一说<br>0 边框宽度0<br>定义边框的时候除了设置宽度还要设置边框的样式才行</p>              </div>            </details><details class="folding-tag" cyan><summary> 默认加粗 </summary>              <div class='content'>              <p>h1-6和th<br>em是斜体<br>caption是表格标题</p>              </div>            </details><details class="folding-tag" cyan><summary> hidden和none </summary>              <div class='content'>              <p>hidden的元素没有被渲染 但是元素内容是被创建了<br>none会触发回流<br>hidden会触发重绘<br>repaint(重绘) ，repaint发生更改时，元素的外观被改变，且在没有改变布局的情况下发生，如改变outline,visibility,background color，不会影响到dom结构渲染。</p><p>reflow(渲染)，与repaint区别就是他会影响到dom的结构渲染，同时他会触发repaint，他会改变他本身与所有父辈元素(祖先)，这种开销是非常昂贵的，导致性能下降是必然的，页面元素越多效果越明显。<br>回流一定会重绘 重绘不一定回流</p>              </div>            </details><details class="folding-tag" cyan><summary> dom中htmldivelement的正确继承关系是 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220223200333.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> link标签的加载和解析 </summary>              <div class='content'>              <p>link标签是同时加载的 先加载完成的优先解析<br>js才是先加完一个再加另外一个</p>              </div>            </details><details class="folding-tag" cyan><summary> input标签的readonly </summary>              <div class='content'>              <p>readonly只读，用户不可以修改，但可以复制，也可以通过tab切换到该字段，还可以用js设置条件控制用户是否可以更改输入内容<br>step规定输入字段的合法数字间隔 比如说2 那么合法数字就是-2 0 2 4等<br>为负数或0的时候默认为1<br>disabled指当 input 元素加载时禁用此元素。input内容不会随着表单提交<br>readonly规定输入字段为只读。input内容会随着表单提交。<br>无论设置readonly还是disabled，通过js脚本都能更改input的value（亲测可以）</p>              </div>            </details><details class="folding-tag" cyan><summary> h5新增的input元素的type属性 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220223201207.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> h5大小写 </summary>              <div class='content'>              <p>h5对大小写不敏感 但为了规范推荐小写</p>              </div>            </details><details class="folding-tag" cyan><summary> h5的`data-` </summary>              <div class='content'>              <p>h5允许使用<code>data-xx</code>来自定义数据</p>              </div>            </details><details class="folding-tag" cyan><summary> h5之前的版本是 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220223210854.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> 优化滚动性能 </summary>              <div class='content'>              <p>重绘重排节流防抖<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220223210917.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> p元素a元素包含问题 </summary>              <div class='content'>              <p>p不能包含任何块级元素包括自身<br>a可以包含任何其他元素除了自身</p>              </div>            </details><details class="folding-tag" cyan><summary> document </summary>              <div class='content'>              <p>dom树的根节点是document<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220224162234.png" alt=""><br><code>getElementsByName()</code>是获取name<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220224162317.png" alt=""></p>              </div>            </details><h1 id="基础不牢，地动山摇Day3"><a href="#基础不牢，地动山摇Day3" class="headerlink" title="基础不牢，地动山摇Day3"></a>基础不牢，地动山摇Day3</h1><details class="folding-tag" cyan><summary> a标签 </summary>              <div class='content'>              <p>有href才有下划线<br>href 属性的可选有：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 绝对路径（href = &quot;https://www.baidu.com&quot;）</span><br><span class="line">2. 相对路径（href = &quot;index.html&quot;）</span><br><span class="line">3. 锚（href = &quot;#top&quot;）</span><br></pre></td></tr></table></figure></p>              </div>            </details><details class="folding-tag" cyan><summary> 内容重要程度mark strong em b </summary>              <div class='content'>              <p>重要程度递减<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220224092010.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> 重绘和重排(重点) </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220224092054.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> td单元格 </summary>              <div class='content'>              <p>td标准意义指的是单元格 而不是列</p>              </div>            </details><details class="folding-tag" cyan><summary> textarea标签 </summary>              <div class='content'>              <p>textarea不能设置宽度 但是可以通过cols控制宽度</p>              </div>            </details><details class="folding-tag" cyan><summary> embed标签 </summary>              <div class='content'>              <p>定义嵌入的内容 比如插件 可以设置高度和宽度</p>              </div>            </details><details class="folding-tag" cyan><summary> head间的代码 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220224092628.png" alt=""><br>其实页面是有能力进行响应式设计的，但是只是没有规范到合适的大小</p>              </div>            </details><details class="folding-tag" cyan><summary> vm视口单位 </summary>              <div class='content'>              <p>vm是视口单位，将视口分为100份</p>              </div>            </details><details class="folding-tag" cyan><summary> 无继承性的属性值 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220224092829.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> 有继承性的属性值 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220224092849.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220224092906.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> q标签 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220224093116.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> 定义滑块range </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220224093154.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> 上标文本sup下标文本sub </summary>              <div class='content'>              <p>如上</p>              </div>            </details><details class="folding-tag" cyan><summary> manifest标签 </summary>              <div class='content'>              <p>应用缓存资源清单<br>带有缓存 manifest 的 HTML 文档（用于离线浏览）<br>manifest 文件是一个简单的文本文件，列举出了浏览器用于离线访问而缓存的资源。<br>HTML5 引入了应用程序缓存，即意味着 Web 应用程序可以被缓存，然后在无互联网连接的时候进行访问。<br>应用程序缓存使得应用程序有三个优点：</p><ol><li>离线浏览 - 用户可以在离线时使用应用程序</li><li>快速 - 缓存的资源可以更快地加载</li><li>减少服务器加载 - 浏览器只从服务器上下载已更新/已更改的资源</li></ol>              </div>            </details><details class="folding-tag" cyan><summary> h5新特性 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220224094058.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> HTML5 是作为Flash的替代技术出现 </summary>              <div class='content'>                            </div>            </details><details class="folding-tag" cyan><summary> 浏览器渲染流程 </summary>              <div class='content'>              <ol><li>解析HTML并构建DOM树</li><li>构建render树</li><li>布局render树</li><li>绘制render树</li></ol>              </div>            </details><details class="folding-tag" cyan><summary> 创建带有id的dom元素有什么副作用 </summary>              <div class='content'>              <p>首先会增加内存负担，然后是会创建同名的全局变量，可以用<code>window[&#39;xx&#39;]</code>访问</p>              </div>            </details><details class="folding-tag" cyan><summary> css加载 </summary>              <div class='content'>              <p>css加载不会阻塞DOM树的解析<br>css加载会阻塞DOM树的渲染<br>css加载会阻塞后面js语句的执行</p>              </div>            </details><details class="folding-tag" cyan><summary> 优化滚动性能 </summary>              <div class='content'>              <ol><li>在滚动中对滚动函数进行节流处理</li><li>滚动中减少导致重绘的操作</li><li>滚动中减少导致重排的操作</li><li>对滚动事件进行防抖处理</li></ol>              </div>            </details><details class="folding-tag" cyan><summary> web表单的图形验证码 </summary>              <div class='content'>              <p>最好不要把验证码文本放在客户端 否则虫或者是恶意程序依旧可以通过各种手段获取你嵌入在html文本或者保存在cookie中的正确验证码文本，模拟表单提交来达到攻击的目的。<br>浏览器也不能判断验证码<br>正确的方式是：发送到客户端的只有图片形式的验证码，服务器端保存cookie对应的图形验证码的正确文本。客户端表单提交时到服务器端验证。</p>              </div>            </details><details class="folding-tag" cyan><summary> 外边距塌陷问题 </summary>              <div class='content'>              <p>当两个在标准流中相邻（兄弟或父子关系）的块级元素的外边距组合在一起的时候，垂直方向上会发生外边距塌陷的问题，计算方式：</p><ol><li>两个都为正，取最大</li><li>一正一负加起来</li><li>两个负 取绝对值最大</li></ol>              </div>            </details><details class="folding-tag" cyan><summary> clientWidth和offsetWidth </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220224153703.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> window对象 </summary>              <div class='content'>              <p>如果页面中包含框架，那么每个框架都拥有自己的window对象</p>              </div>            </details><details class="folding-tag" cyan><summary> a标签 </summary>              <div class='content'>              <p>在a标签的href中添加<code>javascript:;</code>可以使页面不跳转<br><code>#</code>不是，是当前位置</p>              </div>            </details><details class="folding-tag" cyan><summary> json和xml比较 </summary>              <div class='content'>              <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON 和 XML 优缺点的比较 （1）【XML】的优缺点 优点： （1）格式统一，符合标准； （2）容易与其他系统进行远程交互，数据传输比较方便。 缺点： （1）XML文件庞大，文件格式复杂，传输占带宽； （2）服务器端和客户端都需要花费大量代码来解析XML，导致服务器端和客户端代码变得异常复杂且不易维护； （3）客户端不同浏览器之间解析XML的方式不一致，需要重复编写很多代码； （4）服务器端和客户端解析XML花费较多的资源和时间。 那么除了XML格式，还有一种叫JSON （2）【JSON】的优缺点 优点： （1）数据格式比较简单，易于读写，格式都是压缩的，占用带宽小； （2）易于解析，客户端JavaScript可以简单的通过eval_r()进行JSON数据的读取； （3）支持多种语言，包括ActionScript, C, C#, ColdFusion, Java, JavaScript, Perl, PHP, Python, Ruby等服务器端语言，便于服务器端的解析； （4）在PHP世界，已经有PHP-JSON和JSON-PHP出现了，偏于PHP序列化后的程序直接调用，PHP服务器端的对象、数组等能直接生成JSON格式，便于客户端的访问提取； （5）因为JSON格式能直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量，且完成任务不变，并且易于维护。 缺点： （1） 没有XML格式这么推广的深入人心和喜用广泛，没有XML那么通用性； （2）JSON格式目前在Web Service中推广还属于初级阶段</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" cyan><summary> 跨域 </summary>              <div class='content'>              <p>字体有的可能会受到影响<br>图片和css这类的 采用src的一般不会 因为src本质是get请求</p>              </div>            </details><details class="folding-tag" cyan><summary> enctype属性 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220224162843.png" alt=""></p>              </div>            </details><details class="folding-tag" cyan><summary> html全局属性 </summary>              <div class='content'>              <p>html全局属性就是所有标签都能用的属性</p>              </div>            </details><h2 id="css-part"><a href="#css-part" class="headerlink" title="css part"></a>css part</h2><details class="folding-tag" blue><summary> margin外边距 </summary>              <div class='content'>              <p><code>margin:auto</code>是根据剩余的长度居中对齐 并不是0</p>              </div>            </details><details class="folding-tag" blue><summary> 定位 </summary>              <div class='content'>              <p>absolute是基于第一个static定位以外的父元素进行定位<br>static定位就是默认值 没有定位</p>              </div>            </details><details class="folding-tag" blue><summary> overflow </summary>              <div class='content'>              <p>参数是scroll时候，必会出现滚动条。<br>参数是auto时候，子元素内容大于父元素时出现滚动条。<br>参数是visible时候，溢出的内容出现在父元素之外。<br>参数是hidden时候，溢出隐藏。</p>              </div>            </details><details class="folding-tag" blue><summary> 页面元素的优先显示以及优先级 </summary>              <div class='content'>              <p>在不涉及样式的情况下 优先显示指的是html文档加载时从上到下加载 只与标签的上下顺序有关，与标签的选用无关。<br>优先级是帧元素比表单元素优先 表单元素比非表单元素优先</p>              </div>            </details><details class="folding-tag" blue><summary> 浮动元素重叠 </summary>              <div class='content'>              <ol><li>行内元素和浮动元素发生重叠的时候，行内元素的边框 背景 内容都会在浮动元素之上</li><li>块状元素和浮动元素发生重叠的时候，边框，背景在浮动元素之下，内容在浮动元素之上</li></ol>              </div>            </details><details class="folding-tag" blue><summary> `:before`选择器 </summary>              <div class='content'>              <p>早在css2.1的时候就已经定义了</p>              </div>            </details><details class="folding-tag" blue><summary> `background-position`背景定位 </summary>              <div class='content'>              <p>用处：配合<code>background-image</code>属性一起使用，用于设置背景图片在盒子中的位置<br>参数：<code>xpos ypos |x% y% |x y三种,</code><br>如果只写第一个参数 那么第二个参数会默认为<code>center|50%|容器高度一半的px</code><br>Xpos：规定水平方向的对齐方式,值有left,right,center<br>Ypos：规定垂直方向的对齐方式,值有top,bottom,center<br>x%:规定图片水平方向的距离。<br>你会不会以为这个x%就是父级容器宽度的x%？那你就想错了哦，这里的x%指的是父级容器的宽度减去图片的宽度后的差值的x%。<br>举个栗子：background-position：50%，20%；<br>图片的宽度为     imgwidth：100px；高度为     imgheight：100px；<br>容器的宽度为     conwidth：200px；高度为     conheight：200px；<br>那么此时图片的左顶点距离容器的左顶点的水平距离就是(conwidth-imgwidth)<em>50%=50px,而不是conwidth</em>50%=100px；(很好理解的吧，不然盒子宽度200px，图片宽度100px，又距离左边100px，岂不是50%没实现水平居中而紧靠右了吗？)<br>由此也可以算出图片的左顶点距离容器的左顶点的垂直距离为20px<br>y%:对应x%<br>x:图片距离容器水平方向距离<br>y:图片距离容器垂直方向距离</p>              </div>            </details><details class="folding-tag" blue><summary> 字体三个单位 </summary>              <div class='content'>              <p>em的值并不是固定的， 会继承父级元素的字体大小。px为固定单位。 pt 绝对长度单位 </p>              </div>            </details><details class="folding-tag" blue><summary> 动画 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220224203730.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> css sprite </summary>              <div class='content'>              <p>CSS Sprites在国内很多人叫css精灵，是一种网页图片应用处理方式。它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。<br>利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字精确的定位出背景图片的位置。<br>利用CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能，这也是CSS Sprites最大的优点，也是其被广泛传播和应用的主要原因；<br>CSS Sprites能减少图片的字节，曾经比较过多次3张图片合并成1张图片的字节总是小于这3张图片的字节总和。所以C错误<br>解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素进行命名，从而提高了网页的制作效率。<br>更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变。维护起来更加方便。</p>              </div>            </details><details class="folding-tag" blue><summary> cellpadding和cellspacing </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220224212442.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> div 元素的哪些 CSS 属性的默认值为 0？ </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220224212703.png" alt=""></p>              </div>            </details><h1 id="基础不牢，地动山摇Day4"><a href="#基础不牢，地动山摇Day4" class="headerlink" title="基础不牢，地动山摇Day4"></a>基础不牢，地动山摇Day4</h1><p>今天不出意外css应该就结束然后进入js篇章<br>承接上面的css继续写<br><details class="folding-tag" blue><summary> `text-shadow`属性 </summary>              <div class='content'>              <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-shadow</span>: h-shadow v-shadow blur color;</span><br></pre></td></tr></table></figure><p>h-shadow指的是水平阴影，必需<br>v-shadow是垂直阴影，必需<br>blur模糊 color颜色<br>可以说是：<br>阴影离开文字的横方向距离，阴影离开文字的纵方向距离，阴影的模糊半径，阴影的颜色</p>              </div>            </details><details class="folding-tag" blue><summary> 百分比单位 </summary>              <div class='content'>              <p>宽泛的讲这个百分比单位应该是相对于父元素的，但也有特例的情况：</p><ol><li>line-height的百分比是相对于自身字体的大小</li><li>fixed定位的百分比是相对于视口的</li></ol>              </div>            </details><details class="folding-tag" blue><summary> 理论上的最小动画间隔 </summary>              <div class='content'>              <p>多数显示器的刷新率是60hz 即每秒刷新60次，所以理论上最小间隔是<code>1/60*1000ms=16.7ms</code></p>              </div>            </details><details class="folding-tag" blue><summary> css预编译工具 </summary>              <div class='content'>              <p>CSS 预编译工具有stylus，sass，less</p>              </div>            </details><details class="folding-tag" blue><summary> `list-style-type` </summary>              <div class='content'>              <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//标记圆圈（默认）</span><br><span class="line"><span class="attribute">list-style-type</span>:circle;</span><br><span class="line">//方块</span><br><span class="line"><span class="attribute">list-style-type</span>:square;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220225152635.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> 伪类和伪元素的区别 </summary>              <div class='content'>              <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">伪类  :link  :hover         伪元素  ::before    ::after</span><br></pre></td></tr></table></figure><p>其中伪类和伪元素的根本区别在于：它们是否创造了新的元素,,   这个新创造的元素就叫  “伪无素” 。<br>伪元素/伪对象：不存在在DOM文档中，是虚拟的元素，是创建新元素。 这个新元素(伪元素)  是某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中.<br>伪类：存在DOM文档中，(无标签,找不到,  只有符合触发条件时才能看到 ),  逻辑上存在但在文档树中却无须标识的“幽灵”分类。</p>              </div>            </details><details class="folding-tag" blue><summary> css继承 </summary>              <div class='content'>              <p>只有颜色，文字，字体间距行高对齐方式，和列表的样式可以继承<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220225154948.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> `text-overflow` </summary>              <div class='content'>              <p><code>text-overflow: ellipsis;</code>使超出的文字部分变成<code>「…」()</code></p>              </div>            </details><details class="folding-tag" blue><summary> `@font-face` </summary>              <div class='content'>              <p>css使用服务端字体的方式<code>@font-face</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220225160740.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> `currentColor` </summary>              <div class='content'>              <p>css3拓展了颜色值包括了currentColor关键字，它的值是计算之后的color值，当它被应用在color属性自身，相当于<code>color: inherit</code></p>              </div>            </details><details class="folding-tag" blue><summary> css注释 </summary>              <div class='content'>              <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*this is a comment*/</span></span><br></pre></td></tr></table></figure>              </div>            </details></p><h2 id="js篇"><a href="#js篇" class="headerlink" title="js篇"></a>js篇</h2><details class="folding-tag" blue><summary> 变量提升，函数提升 </summary>              <div class='content'>              <p>用var声明的变量会先在全局创建好然后赋值为undefined，最后在赋值为相应的值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jojo = <span class="string">&#x27;jostar&#x27;</span>;</span><br><span class="line"><span class="comment">//其实是</span></span><br><span class="line"><span class="keyword">var</span> jojo = <span class="literal">undefined</span>;</span><br><span class="line">jojo = <span class="string">&#x27;jostar&#x27;</span></span><br></pre></td></tr></table></figure><br>这就是变量提升。如果有多个同名变量提升，后面会覆盖前面的<br>函数提升的话，是js引擎把函数声明提前到了整个作用域的顶部，<br>举例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoistFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo(); <span class="comment">// output: I am hoisted</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;I am hoisted&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistFunction();</span><br><span class="line"><span class="comment">//实际上是</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoistFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;I am hoisted&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foo(); <span class="comment">// output: I am hoisted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistFunction();</span><br></pre></td></tr></table></figure><br>如果有多个同名函数提升 后面的会覆盖前面的<br>那么会考察到变量提升和函数提升是什么时候呢？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">3</span>);&#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">4</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = fn();</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure><br>这个时候是输出什么呢？<br>可以知道函数提升是大于变量提升的，所以此时的预编译应该是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">4</span>);&#125;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    a=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line">a=<span class="number">1</span>;</span><br><span class="line">b=fn();</span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>              </div>            </details><details class="folding-tag" blue><summary> ==与null与undefined </summary>              <div class='content'>              <p>在==的情况下，null和undefined与其他任何有意义的值比较都是返回false，只有它们两个比较的时候会返回true</p>              </div>            </details><details class="folding-tag" blue><summary> split </summary>              <div class='content'>              <p>split方法只能检测正则或者字符串，如果不是则返回typeerror</p>              </div>            </details><details class="folding-tag" blue><summary> history的back go forward </summary>              <div class='content'>              <p>go里面带数字 正数表示前进 负数表示后退</p>              </div>            </details><details class="folding-tag" blue><summary> JavaScript的全局函数 </summary>              <div class='content'>              <p>个人记忆方法：6（编码相关）+ 2（数据处理）+ 4（数字相关）+ 1（特殊）<br>编码相关：<br>    escape()、unescape()、encodeURI()、decodeURI()、<br>    encodeURIComponent()、decodeURIComponent()<br>数据处理：<br>    Number()、String()<br>数字相关：<br>    isFinite()、isNaN()、parseFloat()、parseInt()<br>特殊：<br>    eval()</p><p>ps:对于 getClass() 方法不确定，菜鸟教程上没有，Chrome 控制台也没提示。</p>              </div>            </details><h1 id="基础不牢，地动山摇Day5"><a href="#基础不牢，地动山摇Day5" class="headerlink" title="基础不牢，地动山摇Day5"></a>基础不牢，地动山摇Day5</h1><details class="folding-tag" blue><summary> 类型转换 </summary>              <div class='content'>              <p>在js中任何对象转化为布尔值都是true<br>只有<code>0,-0,NaN,&quot;&quot;,null,undefined</code>这六个值转化为布尔值才是false<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220226092430.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> js原始值 </summary>              <div class='content'>              <p>ECMAScript中，变量可以存放两种类型的值，即原始值和引用值。<br>原始值是存储在栈中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。<br>引用值是存储在堆中的对象，也就是说，存储在变量处的值是一个指针，指向存储对象的内存处。<br>ECMAScript中有5种原始类型，即undefined、null、number、string、boolean。<br>选项中的值分别是：string、number、null，而最后一个是数组，数组是一个对象，所以是引用值。</p>              </div>            </details><details class="folding-tag" blue><summary> 对话框 </summary>              <div class='content'>              <p><code>prompt()</code></p>              </div>            </details><details class="folding-tag" blue><summary> defineProperty </summary>              <div class='content'>              <p><code>defineProperty</code>为对象设置属性后，该属性的描述符<code>writable</code>、<code>configurable</code>以及<code>enumberable</code>默认为false。<br><code>configurable</code>：可否修改，false则不能被删除等<br><code>enumberable</code>：可否枚举，false则不能被遍历，输出长度没有该项，不能打印该项</p>              </div>            </details><details class="folding-tag" blue><summary> Math函数 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220226095854.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> call 、bind 、 apply </summary>              <div class='content'>              <p>返回的第一个参数都是this指向的对象，区别在第二个参数，<br>call的第二个参数必须用逗号分割<code>p1,&#39;xx1&#39;,&#39;xx2&#39;</code><br>apply的第二个参数必须用数组<code>p1,[&#39;xx1&#39;,&#39;xx2&#39;]</code><br>bind和call一样 除了返回是函数<br>有两种情况需要注意，传null或undefined时，将是JS执行环境的全局变量。浏览器中是window，其它环境（如node）则是global。</p>              </div>            </details><details class="folding-tag" blue><summary> 请求头 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220226100314.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> 支持冒泡的函数 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220226100451.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> symbol </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220226142636.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> this </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220226142958.png" alt=""><br>在本题中，<code>var func = user.getCount</code>其实相当于<code>var func = function(){return this.count}</code>this指向的是window而不是user 所以会返回undefined</p>              </div>            </details><details class="folding-tag" blue><summary> `var a=b=3` </summary>              <div class='content'>              <p>相当于<code>var a=3 b=3</code>此时b是全局变量</p>              </div>            </details><details class="folding-tag" blue><summary> 定义函数的方式 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220226143955.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> 点操作符 </summary>              <div class='content'>              <p>通过点操作符添加的属性 会添加到数组最后一位<br>不可以用foreach遍历<br>不会影响length的值<br>可以用forin遍历 此时遍历出来的只有点操作符添加的属性</p>              </div>            </details><details class="folding-tag" blue><summary> +和- </summary>              <div class='content'>              <p>在+的情况下，如果有一者为字符串 那么最后返回的结果是字符串<br>在-的情况下，返回数字</p>              </div>            </details><details class="folding-tag" blue><summary> ==的隐式转化 </summary>              <div class='content'>              <p>在<code>==</code>的隐式转化中，是对两边进行<code>Number()</code>,<br><code>Number(true) = 1</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220226152448.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220228150026.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> 闭包 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220226152753.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> in操作符 </summary>              <div class='content'>              <p>对于数组属性需要指定数字形式的索引值来表示数组的属性名称所以<code>1 in [1]</code>,其中<code>[1]</code>的索引是0 返回false</p>              </div>            </details><details class="folding-tag" blue><summary> &&和> </summary>              <div class='content'>              <p><code>&gt;</code>的权重大于<code>&amp;&amp;</code>优先执行</p>              </div>            </details><details class="folding-tag" blue><summary> 微任务和宏任务 </summary>              <div class='content'>              <p><code>promise</code>是微任务 在当轮事件循环结束前执行<br><code>setTimeout</code>是宏任务 在下一轮事件循环执行</p>              </div>            </details><details class="folding-tag" blue><summary> isNaN方法 </summary>              <div class='content'>              <p>如果不是数字，才返回true<br>escape方法： 该方法返回对一个字符串编码后的结果字符串<br>eval方法：该方法将某个参数字符串作为一个JavaScript执行</p>              </div>            </details><details class="folding-tag" blue><summary> `Object.is()` </summary>              <div class='content'>              <p>其行为与<code>===</code>基本一致，不过有两处不同： <code>+0</code>不等于<code>-0</code>。 <code>NaN</code>等于自身。</p>              </div>            </details><details class="folding-tag" blue><summary> CommonJS规范，在任何模块代码的作用域下内置了以下哪些变量？ </summary>              <div class='content'>              <p>浏览器不兼容CommonJS的根本原因，在于缺少四个Node.js环境的变量。 module exports require global 来自阮一峰</p>              </div>            </details><details class="folding-tag" blue><summary> onerror事件 </summary>              <div class='content'>              <p><code>onerror</code>   事件 当图片不存在时,将触发；</p>              </div>            </details><h1 id="基础不牢，地动山摇Day6"><a href="#基础不牢，地动山摇Day6" class="headerlink" title="基础不牢，地动山摇Day6"></a>基础不牢，地动山摇Day6</h1><details class="folding-tag" blue><summary> delete篇 </summary>              <div class='content'>              <p>delete删除的是对象的属性 或者说如果不是对象上的 比如let const 这种 不会挂载到window对象上面的属性 就不能删除<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220228152622.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> js中的内置对象 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220227144314.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> `'0\0'` </summary>              <div class='content'>              <p>在js中允许0作为除数，只有<code>&#39;0\0&#39;</code>的结果为NaN 其他都是Infinitely<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220227151024.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> 动态语言和静态语言 </summary>              <div class='content'>              <p>看变量使用之前需不需要类型声明，需要的是静态 不需要的是动态<br>静态语言（强类型语言）<br>静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。<br>例如：C++、Java、Delphi、C#等。</p><p>动态语言（弱类型语言）<br>动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。<br>例如PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。</p>              </div>            </details><details class="folding-tag" blue><summary> 运算 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220227160505.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220227160531.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> 块内声明函数 </summary>              <div class='content'>              <p>在非严格模式下，块内声明函数可以用函数表达式的形式声明</p>              </div>            </details><details class="folding-tag" blue><summary> 构造器 </summary>              <div class='content'>              <p>构造函数的原型对象的构造器指回构造函数本身<br>构造函数里面如果不写return 那么返回创建的实例对象<br>写return 且return是一个基本数据类型的话 还是返回创建的实例对象<br>return的是一个对象的话 则返回该对象 原本指向实例对象的this会被无效化<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220228142935.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> trycatch </summary>              <div class='content'>              <p>try后面一定要接catch或者finally 也可以先catch后finally<br>然后如果存在finally 就一定会执行finally里面的内容<br>且如果finally是return的话，那么后面的内容就不会执行了。没有return才会执行后面的内容</p>              </div>            </details><details class="folding-tag" blue><summary> 数组api </summary>              <div class='content'>              <p><code>filter</code>是过滤出符合条件的元素。<br><code>every</code>是检测数组是否所有元素都满足条件。<br><code>some</code>是检测数组是否有满足条件的元素。<br><code>map</code>是遍历数组，且对每个元素进行操作。</p>              </div>            </details><details class="folding-tag" blue><summary> NaN相关 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220227202155.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> 会改变数组的方法以及不会改变数组的方法 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220227202308.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> 原型覆盖 </summary>              <div class='content'>              <p>如果用点操作符提前定义了原型中的一个属性，那么后面再定义原型的话会开辟新的空间覆盖掉原先的点操作符属性<br>如果点操作符后定义，那么原型中会增加属性</p>              </div>            </details><details class="folding-tag" blue><summary> typeof </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220227212201.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> length </summary>              <div class='content'>              <p>length是数组的属性不是方法 且不用带括号</p>              </div>            </details><h1 id="基础不牢，地动山摇Day7"><a href="#基础不牢，地动山摇Day7" class="headerlink" title="基础不牢，地动山摇Day7"></a>基础不牢，地动山摇Day7</h1><details class="folding-tag" blue><summary> class </summary>              <div class='content'>              <p>在class的方法里，前面有static 那么this指向类本身<br>没有static this指向类的实例化对象<br>类方法中有static 只能通过类调用 不能通过实例化对象调用<br>类方法前面没有static 那该方法只能通过实例化对象调用 不能通过类调用</p>              </div>            </details><details class="folding-tag" blue><summary> foreach </summary>              <div class='content'>              <p>该方法会忽略掉空元素</p>              </div>            </details><details class="folding-tag" blue><summary> toString </summary>              <div class='content'>              <p>toString会优先将小数点解析为数字小数点<br>所以存在这种情况会报错<br><code>2.toString()</code><br>正确的写法应该是<br><code>2. toString()</code><br>or<br><code>(2).toString()</code></p>              </div>            </details><details class="folding-tag" blue><summary> 跨域 </summary>              <div class='content'>              <p>只要 协议 、 域名 、 端口 有任何一个 不同, 都被当作是 不同 的域。</p>              </div>            </details><details class="folding-tag" blue><summary> 函数的执行与赋值 </summary>              <div class='content'>              <p>以一道题来讲解<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220228094341.png" alt=""><br>如果此时注释掉1<br>那么对于11行来说 只是将a这个函数赋值给了btn，所以会在整个执行结束之后输出1，点击的时候不会执行b的内容<br>如果此时注释掉2<br>那么对于10行来说，函数a执行 输出1 返回一个函数给btn 所以点击btn的时候 会输出2</p>              </div>            </details><details class="folding-tag" blue><summary> join方法 </summary>              <div class='content'>              <p>join是针对数组的 把数组的内容拼接成字符串 如果join内不加符号或者<code>undefined</code>默认用逗号隔开，如果是<code>&#39;&#39;</code>则没有间隔</p>              </div>            </details><details class="folding-tag" blue><summary> 不支持冒泡 </summary>              <div class='content'>              <p>妈（mouseenter）妈（mouseleave）不（blur）（unload）让（resize）浪（load）费（focus）</p>              </div>            </details><details class="folding-tag" blue><summary> eval </summary>              <div class='content'>              <p>eval 将会返回对最后一个表达式的求值结果。</p>              </div>            </details><details class="folding-tag" blue><summary> `hasOwnProperty`和`isPrototypeOf` </summary>              <div class='content'>              <p><code>hasOwnProperty</code>： 是用来判断一个对象是否有你给出名称的属性或对象。不过需要注意的是，此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员。<br><code>isPrototypeOf</code> : 是用来判断要检查其原型链的对象是否存在于指定对象实例中，是则返回true，否则返回false。</p>              </div>            </details><details class="folding-tag" blue><summary> 函数加括号调用 引号调用 不加括号调用 </summary>              <div class='content'>              <p>加括号 相当于立刻执行<br>不加括号 正常执行<br>引号调用 正常执行<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220228143047.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> `parseInt` </summary>              <div class='content'>              <p><code>parseInt</code>在第一个字符是非数字的时候 返回NaN<br>在后面有字符是非数字的时候 返回前面的数字<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 2. parseInt(string,raix)函数有两个参数</span><br><span class="line"> // 2.1 注意:string字符串只会被解析从第一个字符开始直到不是数字的字符部分</span><br><span class="line"> console.log(parseInt(&#x27;223&#x27;));//223</span><br><span class="line"> // 2.2 当字符串中间存在非数字,那么就只解析前面是数字的部分字符</span><br><span class="line"> console.log(parseInt(&#x27;22e3&#x27;));//22</span><br><span class="line"> // 2.3 如果字符串中第一个字符就不是数字,那么返回NaN </span><br><span class="line"> console.log(parseInt(&#x27;e21&#x27;));//NaN</span><br></pre></td></tr></table></figure></p>              </div>            </details><details class="folding-tag" blue><summary> 原型和隐式原型 </summary>              <div class='content'>              <p>注意只有实例化的对象才有隐式原型</p>              </div>            </details><details class="folding-tag" blue><summary> 判断一个对象是否存在 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220228150210.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> symbol </summary>              <div class='content'>              <p>symbol不参与运算 会报错</p>              </div>            </details><details class="folding-tag" blue><summary> 集合A转化为数组？ </summary>              <div class='content'>              <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Array.from(arr, mapfn,thisArg)方法，用于将两类可以把对象转换为真正的数组：类似数组的对象和可遍历的对象（部署了Iterator接口的，String，ES6新增的Map和Set）。可以传3个参数，其中第一个是数组，必传；第二个是一个函数（类似map函数），对数组元素进行操作后再返回数组，可选；第三个是对于this关键字的指向，可选。</span><br><span class="line">slice() 方法可从已有的数组中返回选定的元素。</span><br><span class="line">返回值：返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</span><br><span class="line">说明</span><br><span class="line">请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。</span><br><span class="line">所以在这里就是对集合A应用slice，返回一个新的数组，不对数组做任何改变。</span><br><span class="line">展开运算符，把A集合的元素展开后，用数组[]承载，返回新的数组。</span><br><span class="line">map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</span><br><span class="line">map() 方法按照原始数组元素顺序依次处理元素。</span><br><span class="line">注意： map() 不会对空数组进行检测。</span><br><span class="line">注意： map() 不会改变原始数组。</span><br><span class="line">所以map方法返回了一个新的数组，并且数组中每个元素是A里面的元素。</span><br></pre></td></tr></table></figure>              </div>            </details><h1 id="基础不牢，地动山摇Day8"><a href="#基础不牢，地动山摇Day8" class="headerlink" title="基础不牢，地动山摇Day8"></a>基础不牢，地动山摇Day8</h1><p>昨天有点小感冒 导致学习没太久，今天补上vue的专题</p><h2 id="vue篇"><a href="#vue篇" class="headerlink" title="vue篇"></a>vue篇</h2><details class="folding-tag" blue><summary> `Object.defineProperty(obj </summary>              <div class='content'>              <p>不能监视数组的变化。原因：defineProperty是监视对象的属性，且对于数组来说，要监听到length的变化首先就必须设置<code>configurable</code>为真，但是各大浏览器不允许这样设置吗，所以导致<code>push``pop</code>等修改数组原长度的方法无法被监听到。<br>vue能实现数组的监听原理是将一个新数组赋值给旧数组 而不是修改原数组，这样的话性能开销其实还是有点大。</p>              </div>            </details><details class="folding-tag" blue><summary> hash模式原理 </summary>              <div class='content'>              <p>通过<code>onhashchange</code>事件，监听url的修改<br>优点是可以快速上线，直接使用 缺点是不美观 且移动端有限制会报错<br><code>history</code>模式是传统的url模式，优点是不会影响到url的美感，缺点是需要后端的配合。</p>              </div>            </details><details class="folding-tag" blue><summary> 挂载 </summary>              <div class='content'>              <p>如果不是在脚手架环境下，vue的挂载需要el（重要！！）</p>              </div>            </details><details class="folding-tag" blue><summary> nextTick </summary>              <div class='content'>              <p>在created等还没生成dom的钩子中，想要操作dom可以将操作放到nextTick的回调函数里。<br>因为nextTick是等dom更新完后才执行操作</p>              </div>            </details><details class="folding-tag" blue><summary> 父子组件的生命周期 </summary>              <div class='content'>              <p>加载渲染过程：（注意是子先挂载完毕）<br>父beforeCreate 父created 父beforeMount 子beforeCreate 子created 子beforeMount<br>子mounted 父mounted<br>子组件更新过程：<br>父 beforeUpdate 子beforeUpdate 子updated 父updated<br>父组件更新过程：<br>父 beforeUpdate 父updated<br>销毁过程：（子先销毁完毕）<br>父beforeDestroy 子beforeDestroy 子destoryed 父destoryed</p>              </div>            </details><details class="folding-tag" blue><summary> watch初始化监听第一次 </summary>              <div class='content'>              <p>加<code>immediate:true</code></p>              </div>            </details><details class="folding-tag" blue><summary> `vue-lazyload` </summary>              <div class='content'>              <p>vue的懒加载插件<br>img标签中使用懒加载：<code>v-lazy</code> 代替 <code>v-bind:src</code> ；<br>背景图片中使用懒加载：<code>v-lazy:background-image = &quot;&quot;</code>  ==&gt;&gt; 注意图片和盒子大小问题，否则显示可能有问题哦。<br>使用的时候不一定要加上<code>:key</code>属性 因为可能会由于key相同导致图片不刷新</p>              </div>            </details><details class="folding-tag" blue><summary> 全局路由守卫的钩子 </summary>              <div class='content'>              <p>全局路由守卫的钩子函数有： <code>beforeEach</code>（全局前置守卫）、<code>beforeResolve</code>（全局解析守卫）、<code>afterEach</code>（全局后置守卫）</p>              </div>            </details><details class="folding-tag" blue><summary> 服务端渲染和客户端渲染 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220301103139.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> vuex的ajax </summary>              <div class='content'>              <p>actions一般操作异步 mutations同步 所以写在actions里面</p>              </div>            </details><details class="folding-tag" blue><summary> 钩子间共享数据 </summary>              <div class='content'>                            </div>            </details><details class="folding-tag" blue><summary> `keep-alive` </summary>              <div class='content'>              <p>组件设置了该属性才会有<code>activated和deactivated</code>两个钩子<br><code>max</code>属性控制最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉</p>              </div>            </details><details class="folding-tag" blue><summary> show和if </summary>              <div class='content'>              <p><code>v-show</code>本质是通过设置css中的<code>display:none</code>来控制隐藏<br><code>v-if</code>本质是动态的向dom树添加或者删除元素<br>经常切换用show 反之用if</p>              </div>            </details><h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1><details class="folding-tag" blue><summary> promise的状态 </summary>              <div class='content'>              <p>pending进行中<br>fulfilled已成功<br>rejected已失败</p>              </div>            </details><details class="folding-tag" blue><summary> promise的固化 </summary>              <div class='content'>              <p>如果已经走了resolve 就不会继续走下一步了<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220301153036.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> 返回值 </summary>              <div class='content'>              <p>promise的return值如果是个常量 会包装成一个成功的promise对象<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220301153536.png" alt=""><br>如果没有return 那么默认是return一个undefined 而undefined也属于常量 所以是成功的回调<br>如果返回的不是常量 就看情况定 </p>              </div>            </details><details class="folding-tag" blue><summary> 宏任务和微任务 </summary>              <div class='content'>              <p>微任务：promise<br>宏任务：setTime系列<br>微任务在js机制中会被放到宏任务的前面，所以微任务先执行<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220301154635.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> `async`和`await` </summary>              <div class='content'>              <p><code>await</code>返回的是一个promise 然后包括<code>async</code>之后返回的也是一个promise<br>并且<code>await</code>的函数执行完才执行下一步，且下一步的任务是微任务（！！！）<br>如果<code>await</code>执行的函数没有返回<code>return Promise.reject(new Error())</code>那么就是一个成功的回调<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220301161026.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220301162533.png" alt=""><br><code>async</code>是同步函数 </p>              </div>            </details><details class="folding-tag" blue><summary> promise的return和throw </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220301161529.png" alt=""><br>此时它是return一个错误 看上去好像会执行catch的内容 实际是执行了then的内容<br>因为它实际上是返回了一个对象 而不是抛出了一个错误<br>所以正确的做法应该是<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220301161627.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> execution </summary>              <div class='content'>              <p>在promise的execution函数中是同步代码</p>              </div>            </details><details class="folding-tag" blue><summary> 综合 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220301163007.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary> promise的赋值 </summary>              <div class='content'>              <p>如果有<code>xx = promise对象</code>的话,那么赋值操作在同步任务执行完之后再执行赋值‘<br>如果promise没有resolve也没有reject状态的话 那么它是pending<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220301185339.png" alt=""></p>              </div>            </details><details class="folding-tag" blue><summary>  </summary>              <div class='content'>                            </div>            </details>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue静态资源上传+GitHub</title>
    <link href="https://zlinni.github.io/posts/5a2ea4345d0a/"/>
    <id>https://zlinni.github.io/posts/5a2ea4345d0a/</id>
    <published>2022-02-22T07:46:08.000Z</published>
    <updated>2022-02-27T06:46:03.312Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>记录用vue-cli打包vue项目之后上传静态资源到github的踩坑向</p></div><h1 id="开始踩坑"><a href="#开始踩坑" class="headerlink" title="开始踩坑"></a>开始踩坑</h1><p>首先对于新版的vue-cli打包，指令是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><br>这个是没有变的<br>在打包之前 必须注意的一点是，新版的cli已经没有config文件夹了，需要自己新建<code>vue.config.js</code>然后配置参数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个是为了防止服务端找不到地址</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;./&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>必须注意的第二点：在<code>.gitignore</code>文件夹下面，把有关<code>dist</code>的行数删掉<br>必须注意的第三点：如果你的路由是history模式，建议直接注释掉或者改hash模式<br>接着执行<code>npm run build</code> 会生成一个<code>dist</code>文件夹，检查里面的<code>index.html</code>的css和js路径是否正确。<br>如果完全是静态的可以<code>live server</code>打开，动态的需要用<code>tomcat</code>或者<code>node</code>进行测试<br>下面贴一个用node测试的<br><details class="folding-tag" cyan><summary> node test </summary>              <div class='content'>              <ol><li>新建文件夹</li><li>初始化 可以直接一直回车<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></li><li>安装express<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save express</span><br></pre></td></tr></table></figure></li><li>新建<code>server.js</code>输入代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(express.static(__dirname+<span class="string">&#x27;/static&#x27;</span>))</span><br><span class="line">app.get(<span class="string">&#x27;/person&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3040</span>,<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)<span class="built_in">console</span>.log(<span class="string">&#x27;qidong&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>新建static文件夹 复制所有dist目录下面的文件到该文件夹</li><li>run</li></ol>              </div>            </details><br>确保你的网页在本地可以运行之后，打开github新建仓库…这一步就省略了，网上很多教程<br>当你已经把远程仓库和本地建立连接之后，在本地文件夹右键打开git命令窗口<br>接下来有两种方法可以上传到github 第一种是将dist重命名为docs（推荐） 另外一种是将dist里面的内容上传到分支，下面演示第一种<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//创建分支 且一定要是这个名字</span><br><span class="line">git branch gh-pages</span><br><span class="line">//切换到该分支</span><br><span class="line">git checkout gh-pages</span><br><span class="line">//强制提交dist</span><br><span class="line">git add -f docs</span><br><span class="line">//commit</span><br><span class="line">git commit -m &quot;message&quot;</span><br><span class="line">git push origin gh-pages </span><br></pre></td></tr></table></figure><br>然后打开你的github 点开仓库的setting 将目录改为docs 然后直接访问它提供的网址即可<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220222163700.png" alt=""></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>网上现在很多的教程说的都是旧版的cli 那个时候还有webpack的配置文件，现在只能通过js修改，导致在这块踩了很久的坑，然后就是github默认是不允许上传dist文件夹的，所以推荐还是使用docs来放静态资源，后续会更新关于vue打包的优化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>MileStone项目杂谈</title>
    <link href="https://zlinni.github.io/posts/844c2cfdc4a5/"/>
    <id>https://zlinni.github.io/posts/844c2cfdc4a5/</id>
    <published>2022-02-09T10:14:58.000Z</published>
    <updated>2022-02-25T04:13:14.356Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>最近博客没更新的原因是，emm在搞一个新的项目，完全的从0开始没有参考任何项目视频，然后现在也是项目大体功能要做完了，就在这里写一下本次项目踩过的坑以及一些经验，算是一期杂谈。<br>源码地址：<a href="https://github.com/Zlinni/MileStone">传送门1</a><br>项目演示地址:<a href="https://zlinni.github.io/MileStone/#/">传送门2</a></p></div><h1 id="主体演示"><a href="#主体演示" class="headerlink" title="主体演示"></a>主体演示</h1><div class="note primary flat"><p>制作完毕~</p></div><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">效果展示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/milestone预览.gif" alt="不知道为什么自己很喜欢这种纯黑风格"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="构建工具-技术栈"><a href="#构建工具-技术栈" class="headerlink" title="构建工具+技术栈"></a>构建工具+技术栈</h1><p>编译软件：vscode<br>开发框架: vue2<br>打包工具：vue-cli<br>UI：vuetify<br>icon：阿里巴巴<br>其他：vuex， vue-router，git<br>插件：pubsub，nanoid，less-loader，vuex-persist</p><h1 id="组件列表"><a href="#组件列表" class="headerlink" title="组件列表"></a>组件列表</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220222102652.png" alt=""></p><h1 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h1><div class="note primary flat"><p>本次项目综合了很多方面的问题，比如vuex模块化加数据持久化，对所有任务的时间排序，以及vuetify的栅格系统等等，各种方面的问题哈哈，但好在最后都能够解决出来</p></div><h2 id="vuex模块化结合本地化存储"><a href="#vuex模块化结合本地化存储" class="headerlink" title="vuex模块化结合本地化存储"></a>vuex模块化结合本地化存储</h2><div class="note primary flat"><p>vuex是一个很方便的官方提供的数据管理插件，但在使用的时候一遇到刷新就会导致数据丢失的问题。于是想到了<code>localStorage</code>结合本地存储的方式进行数据持久化。</p></div><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">方案一 localStorage</button></li><li class="tab"><button type="button" data-href="#test-2">方案2 vuex-presist</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>原理很简单 对于自己设置的数据先使用<code>JSON.parse(localStorage.getItem(&#39;xxx&#39;))</code><br>然后在mutations里面对于需要增删改查的操作最后进行一次<code>localStorage.setItem(&quot;xxx&quot;, JSON.stringify(state.xxx));</code><br>部分代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> todoObj =  <span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;todoObj&quot;</span>)) || [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="string">&quot;X5DX4v8Wz4r97xjs&quot;</span>, <span class="attr">title</span>: <span class="string">&quot;阿斯顿&quot;</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">];</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">    <span class="function"><span class="title">updatedType</span>(<span class="params">state, [people, subject, typeId, typeValue]</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(typeValue);</span><br><span class="line">      state.dataList.forEach(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.people === people) &#123;</span><br><span class="line">          data.kemu.forEach(<span class="function"><span class="params">kemu</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (kemu.subject === subject) &#123;</span><br><span class="line">              kemu.typeList.forEach(<span class="function"><span class="params">typelist</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (typelist.id === typeId) &#123;</span><br><span class="line">                  Vue.set(typelist, <span class="string">&#x27;type&#x27;</span>, typeValue[<span class="number">0</span>]);</span><br><span class="line">                  Vue.set(typelist, <span class="string">&#x27;time&#x27;</span>, typeValue[<span class="number">2</span>]);</span><br><span class="line">                  Vue.set(typelist, <span class="string">&#x27;remarks&#x27;</span>, typeValue[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">       <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;dataList&#x27;</span>, <span class="built_in">JSON</span>.stringify(state.dataList));</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><br>但是这个方法也有一个弊端，就是每次执行增删改查的操作都需要进行一次手动存储，在操作多的情况下非常不适合。于是找到了这个vuex的插件<code>vuex-presist</code>来帮助模块进行本地存储</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>实质上就是进行了本地存储，当然也有新的类型比如session和cookie<br>安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save vuex-persist</span><br></pre></td></tr></table></figure><br>引入<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VuexPersistence <span class="keyword">from</span> <span class="string">&#x27;vuex-persist&#x27;</span></span><br></pre></td></tr></table></figure><br>定义 (此处是根据我的两个模块来使用)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vuexLocal = <span class="keyword">new</span> VuexPersistence(&#123;</span><br><span class="line">  <span class="attr">storage</span>: <span class="built_in">window</span>.localStorage,</span><br><span class="line">  <span class="attr">modules</span>: [<span class="string">&#x27;dataListOptions&#x27;</span>, <span class="string">&#x27;todoOptions&#x27;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>引入到vuex<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> vuex.Store(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    dataListOptions,</span><br><span class="line">    todoOptions</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [vuexLocal.plugin]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>注意此处的引入位置</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="vuex模块化踩坑"><a href="#vuex模块化踩坑" class="headerlink" title="vuex模块化踩坑"></a>vuex模块化踩坑</h2><div class="note primary flat"><p>当vuex要使用很多options的时候，会采用模块化的方式来写代码会比较方便管理。<br>比如定义一个todoOptions 里面就要有store的全部方法 以及一个<code>namespaced</code>属性</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoOptions =&#123;</span><br><span class="line">  <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>:&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">todoObj</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> vuex.Store(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    dataListOptions,</span><br><span class="line">    todoOptions</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>到这一步其实大多数时候都没有问题 出问题在于使用到mutation或者actions的时候<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处需要使用名字/方法否则不行</span></span><br><span class="line"> <span class="built_in">this</span>.$store.dispatch(</span><br><span class="line">        <span class="string">&quot;dataListOptions/transType&quot;</span>,</span><br><span class="line">        <span class="built_in">this</span>.$route.params.people</span><br><span class="line">      );</span><br><span class="line">      </span><br></pre></td></tr></table></figure><br>如果用到了mapState插件或者其他的，也需要加名字 注意是要用双引号<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...mapState(<span class="string">&quot;todoOptions&quot;</span>, [<span class="string">&quot;todoObj&quot;</span>]),</span><br></pre></td></tr></table></figure><br>以及最后其实vuex的value是可以传多个参数的，用数组或者对象的形式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&quot;dataListOptions/addType&quot;</span>, [</span><br><span class="line">  <span class="built_in">this</span>.$route.params.people,</span><br><span class="line">  <span class="built_in">this</span>.subject,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p><h2 id="准确获取时区"><a href="#准确获取时区" class="headerlink" title="准确获取时区"></a>准确获取时区</h2><div class="note primary flat"><p>一般大家使用时间都是直接用<code>new Date()</code>但这个方法获取的并不是完全准确的时区时间，采用下面的方法可以获取更为准确的时间</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">selectTimezone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="comment">//得到1970年一月一日到现在的秒数</span></span><br><span class="line">  <span class="keyword">var</span> len = d.getTime();</span><br><span class="line">  <span class="comment">//确定时区</span></span><br><span class="line">  <span class="keyword">var</span> timezone = -d.getTimezoneOffset() / <span class="number">60</span>;</span><br><span class="line">  <span class="comment">//本地时间与GMT时间的时间偏移差</span></span><br><span class="line">  <span class="keyword">var</span> offset = d.getTimezoneOffset() * <span class="number">60000</span>;</span><br><span class="line">  <span class="comment">//得到现在的格林尼治时间</span></span><br><span class="line">  <span class="keyword">var</span> utcTime = len + offset;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(utcTime + <span class="number">3600000</span> * timezone);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="时间排序"><a href="#时间排序" class="headerlink" title="时间排序"></a>时间排序</h2><div class="note primary flat"><p>项目中需要将自定义的任务进行一个时间的排序最后呈现到学习计划页面</p></div><p>预览<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220222122336.png" alt=""><br>当一开始的时间格式是<code>14:00-15:00</code>这样的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">subject: <span class="string">&quot;数学&quot;</span>,</span><br><span class="line"><span class="attr">typeList</span>: [&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;001&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;高等数学&quot;</span>,</span><br><span class="line">    <span class="attr">time</span>: <span class="string">&#x27;14:00-15:00&#x27;</span>,</span><br><span class="line">    <span class="attr">remarks</span>: <span class="string">&#x27;暂无&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;002&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;线性代数&quot;</span>,</span><br><span class="line">    <span class="attr">time</span>: <span class="string">&#x27;15:00-16:00&#x27;</span>,</span><br><span class="line">    <span class="attr">remarks</span>: <span class="string">&#x27;暂无&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;003&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;概率论&quot;</span>,</span><br><span class="line">    <span class="attr">time</span>: <span class="string">&#x27;16:00-17:00&#x27;</span>,</span><br><span class="line">    <span class="attr">remarks</span>: <span class="string">&#x27;暂无&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>于是想到了<code>split</code>方法去分割第一个时间点，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = [];</span><br><span class="line"><span class="keyword">let</span> indexArr = [];</span><br><span class="line"><span class="built_in">this</span>.$store.state.dataListOptions.typeList.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> hhmm = item.time.split(<span class="string">&quot;-&quot;</span>, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> hh = hhmm.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> sum = hh.reduce(<span class="function">(<span class="params">total, val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (total += val);</span><br><span class="line">  &#125;, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  res.push(<span class="built_in">parseInt</span>(sum));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>然后将第一个时间点化为<code>1400</code>的形式，以此类推。只要对比第一个时间点就可以完成排序，这样一来就可以使用sort方法，但问题又出现了，这样比较之后需要将时间还原回去才能在原本的数组里面找到对应的任务名称。或者是知道数组下标的形式？那么如何知道排序后原先时间数组的下标呢？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> typeMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"> typeMap.set(<span class="built_in">parseInt</span>(sum), index);</span><br></pre></td></tr></table></figure><br>使用到map类里面的set方法，将原先的数据和下标传入到map中，最后遍历排序后的时间数组，通过get方法去查找数据原先对应的下标<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">typeList</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> typeMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> indexArr = [];</span><br><span class="line">  <span class="built_in">this</span>.$store.state.dataListOptions.typeList.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> hhmm = item.time.split(<span class="string">&quot;-&quot;</span>, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> hh = hhmm.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> sum = hh.reduce(<span class="function">(<span class="params">total, val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (total += val);</span><br><span class="line">    &#125;, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    res.push(<span class="built_in">parseInt</span>(sum));</span><br><span class="line">    typeMap.set(<span class="built_in">parseInt</span>(sum), index);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;排序前的res&quot;</span>, res);</span><br><span class="line">  res.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;排序后的res&quot;</span>, res);</span><br><span class="line">  res.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    indexArr.push(typeMap.get(item));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;下标&quot;</span>, indexArr);</span><br><span class="line">  <span class="keyword">let</span> finalArr = [];</span><br><span class="line">  indexArr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.state.dataListOptions.typeList.forEach(<span class="function">(<span class="params">data, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (index === item) &#123;</span><br><span class="line">        finalArr.push(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;最终数组&quot;</span>, finalArr);</span><br><span class="line">  <span class="keyword">return</span> finalArr;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h2 id="时间排序2"><a href="#时间排序2" class="headerlink" title="时间排序2"></a>时间排序2</h2><div class="note primary flat"><p>项目中还有一个地方需要用到时间排序，就是页面中这个introduce的地方，它会随着任务的执行判断时间，然后返回相应的内容到页面上</p></div><p>预览<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220222122836.png" alt=""><br>需求是有三种判断<br>一是任务没有开始 那么就显示下个任务还有xx时xx分开始，如果不到1小时，则返回xx分<br>二是任务正在执行中 那么显示该任务还有xx时xx分结束，如果不到1小时，则返回xx分<br>三是任务都执行完了 此时显示今日任务已完毕，查看今日总结</p><p>获取任务数组这块就不说了 用的是消息的订阅和发布，收到的是已经排序好时间的任务数组<br>那么为了执行现在的时间是否在某个任务时间段内，就需要三个变量，一个是现在时间，一个是当前任务开始时间，结束时间<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">this</span>.pid = pubsub.subscribe(</span><br><span class="line">      <span class="string">&quot;judgeTime&quot;</span>,</span><br><span class="line">      <span class="function">(<span class="params">msg, [timeArr, typeNameArr, len]</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          timeArr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> hhmm = item.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> strTime1 = hhmm[<span class="number">0</span>].split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> strTime2 = hhmm[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> b = <span class="built_in">this</span>.selectTimezone();</span><br><span class="line">            <span class="keyword">var</span> e = <span class="built_in">this</span>.selectTimezone();</span><br><span class="line">            <span class="keyword">var</span> n = <span class="built_in">this</span>.selectTimezone();</span><br><span class="line">            b.setHours(strTime1[<span class="number">0</span>]);</span><br><span class="line">            b.setMinutes(strTime1[<span class="number">1</span>]);</span><br><span class="line">            b.setSeconds(<span class="number">0</span>);</span><br><span class="line">            b.setMilliseconds(<span class="number">0</span>);</span><br><span class="line">            e.setHours(strTime2[<span class="number">0</span>]);</span><br><span class="line">            e.setMinutes(strTime2[<span class="number">1</span>]);</span><br><span class="line">            e.setSeconds(<span class="number">0</span>);</span><br><span class="line">            e.setMilliseconds(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (b.getTime() - n.getTime() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="built_in">this</span>.typeName = <span class="string">&quot;还未到学习时间&quot;</span>;</span><br><span class="line">              <span class="built_in">console</span>.log(b);</span><br><span class="line">              <span class="built_in">this</span>.beginTime = b;</span><br><span class="line">              <span class="built_in">this</span>.state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">······</span><br></pre></td></tr></table></figure><br>然后比较它们的时间戳，细节上为了准确的比较还得把秒和毫秒设置0<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">calTime</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="built_in">this</span>.selectTimezone();</span><br><span class="line">  <span class="keyword">var</span> chazhi = <span class="built_in">this</span>.beginTime - n;</span><br><span class="line">  <span class="built_in">this</span>.minutes = <span class="built_in">Math</span>.floor((chazhi / <span class="number">1000</span> / <span class="number">60</span>) % <span class="number">60</span>);</span><br><span class="line">  <span class="built_in">this</span>.hours = <span class="built_in">Math</span>.floor((chazhi / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span>) % <span class="number">24</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.hours &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;start&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.endTime = <span class="string">`距离下一个任务开始还有<span class="subst">$&#123;<span class="built_in">this</span>.hours&#125;</span>小时<span class="subst">$&#123;<span class="built_in">this</span>.minutes&#125;</span>分钟`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;end&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.endTime = <span class="string">`距离学习结束还有<span class="subst">$&#123;<span class="built_in">this</span>.hours&#125;</span>小时<span class="subst">$&#123;<span class="built_in">this</span>.minutes&#125;</span>分钟`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;start&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.endTime = <span class="string">`距离下一个任务开始还有<span class="subst">$&#123;<span class="built_in">this</span>.minutes&#125;</span>分钟`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;end&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.endTime = <span class="string">`距离学习结束还有<span class="subst">$&#123;<span class="built_in">this</span>.minutes&#125;</span>分钟`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (chazhi &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.calTime();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$router.go(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br>此处有个难点，就是在定时器代码那里，如果使用的是<code>setInterval</code>那么可能在下个时间段的时候，前面的代码计算比较复杂，他会跳过当前的这个时间应该执行的任务（代码队列之前的任务没有处理完，js引擎只能允许一份未执行的代码），这方面的问题要去了解js的事件循环机制，于是这里采用了<code>setTimeout</code>来反复调用自身，最后当差值小于或等于0的时候利用routergo刷新页面<br>最后在补充一下剩下的判断代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (b.getTime() - n.getTime() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">this</span>.typeName = <span class="string">&quot;还未到学习时间&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="built_in">this</span>.beginTime = b;</span><br><span class="line">  <span class="built_in">this</span>.state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.calTime();</span><br><span class="line">  <span class="built_in">localStorage</span>.removeItem(<span class="string">&quot;dayEnd&quot;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  n.getTime() - b.getTime() &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">  n.getTime() - e.getTime() &lt; <span class="number">0</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="built_in">this</span>.typeName = typeNameArr[index];</span><br><span class="line">  <span class="built_in">this</span>.beginTime = e;</span><br><span class="line">  <span class="built_in">this</span>.state = <span class="string">&quot;end&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.calTime();</span><br><span class="line">  <span class="built_in">localStorage</span>.removeItem(<span class="string">&quot;dayEnd&quot;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === len - <span class="number">1</span> &amp;&amp; n.getTime() - e.getTime() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">this</span>.typeName = <span class="string">&quot;今日任务已完成&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.endTime = <span class="string">&quot;点击查看今日总结~&quot;</span>;</span><br><span class="line">  <span class="built_in">localStorage</span>.setItem(<span class="string">&quot;dayEnd&quot;</span>, <span class="string">&quot;end&quot;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><ol><li>采用了插件webpack-bundle-analyzer分析了项目中js文件占据的空间，又利用了bootcdn将插件以cdn的方式引入，减小了打包的时候生成的js体积。</li><li>echarts采用了按需引入的方式，减少了所需的js体积</li></ol><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><p>本次项目是对vue2练手的独立项目，从该项目中我收获到了有关vuex模块化以及数据持久化的处理，时间算法和事件循环的操作，并加深了vuetify-ui的使用，尤其是栅格系统和断点系统，最后针对项目进行了打包优化，结合cdn提升了访问速度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="vue" scheme="https://zlinni.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue3</title>
    <link href="https://zlinni.github.io/posts/725dcb7bbb15/"/>
    <id>https://zlinni.github.io/posts/725dcb7bbb15/</id>
    <published>2022-01-25T02:28:40.000Z</published>
    <updated>2022-03-18T11:44:20.356Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>本文主要用于记录vue3的使用，参考视频<a href='https://www.bilibili.com/video/BV1Zy4y1K7SH?p=1'>【尚硅谷Vue2.0+Vue3.0全套教程丨vuejs从入门到精通】</a></p></div><h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">Vue3的提升</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220125103708.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220125103846.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220125103919.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="创建Vue3工程"><a href="#创建Vue3工程" class="headerlink" title="创建Vue3工程"></a>创建Vue3工程</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">vuecli</button></li><li class="tab"><button type="button" data-href="#test-3">vite</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>两种方法 一种是传统的vuecli 另外一种是vite</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>使用vuecli创建该工程需要确保脚手架的版本在4.5以上<br>使用指令可以查看<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue -V</span><br><span class="line">or</span><br><span class="line">vue --version</span><br></pre></td></tr></table></figure><br>否则重新安装<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><br>创建<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create vue_test</span><br></pre></td></tr></table></figure><br>启动<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> vue_test</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><p>先看一图流<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220125104523.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220125105053.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="分析工程解构"><a href="#分析工程解构" class="headerlink" title="分析工程解构"></a>分析工程解构</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>主要查看vue3和2有什么结构和写法上面的区别</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>从mainjs上面看 引入和实例化app的方法不一样了 而且也不能用vue2的形式写了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入的不再是vue构造函数了 而是一个精简版的createApp工厂函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">createApp(App).mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>vue3不需要根标签了 在vue2里面需要用div当做根标签编写<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220125111435.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>setup是vue3使用组合api的地方 结合了之前2中的data methods等</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>setup是一个函数 里面可以直接定义变量 方法等<br>返回有两种情况 一种是返回定义的变量 此时模板中可以直接使用该变量<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;这是a值&#123;&#123; a &#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;h1&gt;这是b值&#123;&#123; b &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    let b = 2;</span><br><span class="line">    return &#123;</span><br><span class="line">      a,</span><br><span class="line">      b,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>返回的第二种情况是 返回一个渲染函数 该函数的html元素可以直接被渲染<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; h &#125; from &quot;vue&quot;;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">    return () =&gt; h(&quot;h1&quot;, &quot;hahahah&quot;);</span><br></pre></td></tr></table></figure><br>除此之外 data methods写法可以正常访问setup的数据 但是反过来不行 即vue2可以访问vue3 但3不能访问2 而且最好两者不要混用！<br>总结一图流<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220125132019.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="ref函数"><a href="#ref函数" class="headerlink" title="ref函数"></a>ref函数</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>ref函数可以将数据变成响应式的，还用于处理对象类型。如果不设置ref直接修改变量 那么修改后的变量不会响应式的出现在页面上。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>案例如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;学习ref&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;jojoname is &#123;&#123;jojo&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;button @click=&quot;changeJOJO&quot;&gt;点击改变jojo&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 引入ref</span><br><span class="line">import &#123; h, ref &#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // 将数据变成响应式</span><br><span class="line">    let jojo = ref(&quot;jotaro&quot;);</span><br><span class="line">    console.log(jojo);</span><br><span class="line">    function changeJOJO() &#123;</span><br><span class="line">      // 改变数据的方式</span><br><span class="line">      jojo.value = &#x27;jostar&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      jojo,</span><br><span class="line">      changeJOJO</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>注意的点是 初学使用setup容易忘记最后将模板需要的变量和方法返回出去<br>然后 数据变成响应式之后 修改数据需要<code>xxx.value</code>的方式修改<br>最后是ref的数据 看上去像是做了数据代理之后的结果 这个RefImpl的意思是reference 和 implement的组合 全称是引用实现的实例，我们称之为引用对象<br>类似于单例的加工返回单例，将函数交给ref处理后返回响应式</p><ul><li>ref实现响应式也是通过getter和setter即<code>object.defineProperty</code></li><li>将getter和setter藏在原型对象中 更简洁了<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314095628.png" alt=""><br>总结一图流<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220125134254.png" alt=""></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="reative函数-处理对象类型数据"><a href="#reative函数-处理对象类型数据" class="headerlink" title="reative函数 处理对象类型数据"></a>reative函数 处理对象类型数据</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li><li class="tab"><button type="button" data-href="#test-3">抛出疑惑</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>vue3对不同类型的数据有不同类型的响应式处理，处理对象的时候用的是ref则是Proxy形式，本质上是求助了reactive函数。<br>reactive函数主要用于处理对象类型数据 并且它是深层次处理的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>用ref处理对象<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;学习ref&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;jojoname is &#123;&#123;jojo&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;jojo author is &#123;&#123;jojoHome.author&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;button @click=&quot;changeJOJO&quot;&gt;点击改变jojo&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 引入ref</span><br><span class="line">import &#123; h, ref &#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // 将数据变成响应式</span><br><span class="line">    let jojo = ref(&quot;jotaro&quot;);</span><br><span class="line">    let jojoHome = ref(&#123;</span><br><span class="line">      author:&#x27;huangmu&#x27;,</span><br><span class="line">      jojoone:&#x27;幻影之血&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    console.log(jojoHome);</span><br><span class="line">    function changeJOJO() &#123;</span><br><span class="line">      // 改变数据的方式</span><br><span class="line">      jojo.value = &#x27;jostar&#x27;;</span><br><span class="line">      jojoHome.value.author = &#x27;dio哒&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      jojo,</span><br><span class="line">      jojoHome,</span><br><span class="line">      changeJOJO</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>在上述ref的使用过程我们知道 用ref将对象变成响应式的 修改的时候需要对象点value点具体的属性<br>而reactive则不需要点value 而且可以检测到深度的数据<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;学习ref&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;jojoname is &#123;&#123;jojo&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;jojo author is &#123;&#123;jojoHome.author&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;find 套娃 is &#123;&#123;jojoHome.a.b.c&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;button @click=&quot;changeJOJO&quot;&gt;点击改变jojo&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 引入ref</span><br><span class="line">import &#123; h, reactive, ref &#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // 将数据变成响应式</span><br><span class="line">    let jojo = ref(&quot;jotaro&quot;);</span><br><span class="line">    let jojoHome = reactive(&#123;</span><br><span class="line">      author:&#x27;huangmu&#x27;,</span><br><span class="line">      jojoone:&#x27;幻影之血&#x27;,</span><br><span class="line">      a:&#123;</span><br><span class="line">        b:&#123;</span><br><span class="line">          c:&#x27;套娃呢？&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    console.log(jojoHome);</span><br><span class="line">    function changeJOJO() &#123;</span><br><span class="line">      // 改变数据的方式</span><br><span class="line">      jojo.value = &#x27;jostar&#x27;;</span><br><span class="line">      jojoHome.author = &#x27;dio哒&#x27;;</span><br><span class="line">      jojoHome.a.b.c = &#x27;对啊&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      jojo,</span><br><span class="line">      jojoHome,</span><br><span class="line">      changeJOJO</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>一图流<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220125161054.png" alt=""></p><ul><li>reactive将源对象转化为代理对象</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><ul><li>为什么基本类型数据最好用<code>ref</code> 对象类型要用<code>reactive</code>?</li><li>首先ref都能处理这两者 但是在处理对象类型的时候借用了<code>reactive</code>，而<code>reactive</code>只能处理对象类型，不能处理基本类型</li><li><code>ref</code>和<code>reactive</code>处理对象类型有什么区别</li><li>如果同样都是包裹了一个对象，比如说<code>obj</code>，那么访问的时候ref需要使用<code>obj.value</code>才能访问到<code>Proxy</code>下的<code>obj</code>对象 而reactive直接使用<code>obj</code>就可以访问。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="vue3中的响应式原理"><a href="#vue3中的响应式原理" class="headerlink" title="vue3中的响应式原理"></a>vue3中的响应式原理</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>回顾vue2的响应式，我们用对对象类型的数据用<code>object.defineProperty</code>对属性进行读取，修改和拦截。对数组类型的数据进行包裹然后使用原生的方法修改数组。<br>弊端：</p><ol><li>不支持删除delete，以及新增(点操作符)</li><li>不能通过下标直接修改数组，需要用数组原生的几个方法才行</li></ol><p>vue3中的响应式是通过Proxy代理，拦截</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314140322.png" alt=""><br>对比vue2的修改方法，有以下几点不同</p><ul><li>proxy的get和set接收了对象和属性值两个参数 通过键值对的方式修改</li><li>proxy对于增加的操作包含在了set方法中，意思是set方法可以检测到增加 </li><li>proxy有了delete操作 返回值最好写删除的结果<br>上面是简略版<br>实际上底层不是这样实现的<br>就需要讲解到Reflect反射这个东西了，首先这个Reflect是可以和Object一样进行数据的属性增删改查操作<br>如：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314141154.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314141206.png" alt=""><br>但是又有点不同在于 如果重复写了<code>Object.defineProperty</code>那么会报错 而<code>Reflect</code>会返回一个布尔值 所以可以存在两个一样的reflect 但是只会执行第一个<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314142805.png" alt=""><br>最后<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314142833.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314142930.png" alt=""></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="setup的两个注意点"><a href="#setup的两个注意点" class="headerlink" title="setup的两个注意点"></a>setup的两个注意点</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>setup在<code>beforeCreate</code>之前调用，且<code>this</code>的值是<code>undefined</code><br>接收两个参数 一个是<code>props</code>一个是<code>context</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>对于<code>props</code>，接收的是一个Proxy类型的的数据，如果没有和<code>props</code>对应会有警告出现，如果没有传该值则是<code>undefined</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314144248.png" alt=""><br>对于<code>context</code>参数，有三个值接收<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314145920.png" alt=""><br>对于emit属性，就是触发事件，它可以使用<code>context.emit</code>触发，用于父子通信<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314150241.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314150406.png" alt=""><br>对于slot属性，插槽，需要注意和vue2不同的一点是 传递具名插槽的时候不再使用<code>slot=&quot;xxx&quot;</code>而是使用<code>v-slot:xxx</code>这个是一个兼容性的问题<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314150617.png" alt=""><br>总结一图流：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314150657.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>可以像vue2一样使用computed，但vue3里面使用可以import之后使用箭头函数的形式使用</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314154516.png" alt=""><br>注意 因为结合了reative函数，所以计算属性赋值可以是响应式对象的属性的形式 且最后不用返回<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314154740.png" alt=""><br>但是这样一来有一个问题出现 就是这个computed之后的属性是可读不可写的，这样就导致修改数据会出错，那么如何让他可读可写呢？<br>使用computed的全称写法 里面包裹的是一个对象<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314155030.png" alt=""><br>总结一图流：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314155044.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="watch监视属性"><a href="#watch监视属性" class="headerlink" title="watch监视属性"></a>watch监视属性</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>vue3中依然可以在setup外面写watch方法<br>在vue3自身中,watch方法可以写为如下形式</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>检测ref数据<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314185851.png" alt=""><br>注意 以上是检测ref数据 不是reactive的数据</p><ul><li>不同于computed不需要接收值 所以不用变量收集</li><li>检测多个数据的时候采用数组的形式</li><li>如果输出new和old的值 会发现它们是用数组的形式存储,即,修改后存在数组里面显示</li></ul><ol><li>那么抛出疑问 vue2有immediate 那vue3应该怎么写?<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setup()&#123;</span><br><span class="line">watch(sum,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">console.log(newValue,oldValue);</span><br><span class="line">&#125;,&#123;immediate:true&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在watch里面写第三个属性即可</li><li>那么deep应该如何写?会出现什么问题?<br>在reactive生成的响应式数据自动开启了deep监视,导致deep配置项无效 且无法关闭</li><li>那么reative的数据是如何监视以及出现的问题?<br>如果直接写watch一个reactive的对象 那么会出现new和old值一样的问题<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314190806.png" alt=""><br>暂时没有办法解决这个问题<br>4 因为深度监视没办法关闭 开着会浪费性能的问题,所以如果想监视一个reative响应式对象中的一个数据 直接使用<code>对象.属性</code>是不行的,vue3规定必须要返回这个值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(<span class="function">()=&gt;</span>person.age,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;xxx变化了&#x27;</span>,newValue,oldValue);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>如果要监视reactive定义的一个对象中的某些属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch([<span class="function">()=&gt;</span>person.age,<span class="function">()=&gt;</span>person.name],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;xxx变化了&#x27;</span>,newValue,oldValue);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>看起来很麻烦= =</li><li>特殊情况<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314192351.png" alt=""></li><li>watch中的value问题<br>如果是一个ref定义的基本数据,那么取出来我们需要用到<code>xx.value</code><br>而在watch里面想监视它 则不能写点value 因为watch监视的是一个结构 而不是一个具体的数据<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(sum,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;aaa&#x27;</span>,newValue,oldValue);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>但是如果是ref定义的obj类型 即对象类型 那么用watch监视有两种方法<br>一是监视<code>obj.value</code>,为什么呢?因为我们知道 ref定义的对象类型数据,直接输出是一个RefImplll即引用对象,它是再借助了reactive生成了proxy类型数据 即它的响应式来自reactive中的proxy 所以单单监视<code>obj</code>是行不通的,必须监视<code>obj.value</code>让他访问到响应式数据<br>二是开启deep配置项,从1我们知道,ref生成的对象类型数据必须监视到其value里面的proxy 那么换个角度来说只要他能深度检测到obj里面的value里面的proxy即可 所以开启这个深度监视也奏效<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314193642.png" alt=""></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="wacthEffect"><a href="#wacthEffect" class="headerlink" title="wacthEffect"></a>wacthEffect</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li><li class="tab"><button type="button" data-href="#test-3">抛出疑问</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>watchEffect方法的功能用一句话来说就是用谁就监视谁</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>首先它区别于watch 不需要传入任何参数<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(()=&gt;&#123;</span><br><span class="line">const x1 = sum;</span><br><span class="line">const x2 = person.job.j1.salary;</span><br><span class="line">console.log(&#x27;回调执行&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>刚刚说了 用到谁就去监视谁 所以在这里面 用到了sum 和<code>person.job.j1.salary</code>这两个变量,前者好理解 就是一个基本的数据检测 但后者是深度的数据 结果是也能检测出来.说明这个方法非常的智能,可以深度检测.<br>总结一图流:<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314194918.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><ul><li>computed和watchEffect很像的原因?<br>前者是有数据变化了,整个都要重新计算然后返回结果<br>后者也是一样 有东西变了 就执行回调</li><li>两者不一样的地方?<br>前者更注重的是回调的结果 所以要有一个返回值<br>而后者更注重过程 所以不用写返回值</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="vue3生命周期"><a href="#vue3生命周期" class="headerlink" title="vue3生命周期"></a>vue3生命周期</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要区别</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><ol><li>在vue3里面 原先vue2中的<code>beforeDestroy和destroyed</code>变成了<code>beforeUnmounted和unmounted</code></li><li>原先在vue2里面 如果创建了<code>new Vue</code>并且传入了配置项,但不写el 也不在vm中挂载el,意味着此时模板没有被解析 但是它经过了<code>beforeCreate和created</code>两个钩子 这样的情况是不必要的,在vue3中得到了改善,vue3需要app挂载完后才能走下一步<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314195722.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314195816.png" alt=""></li><li>vue3也提供了组合api形式的生命周期钩子 和vue2中的对应如下<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314202556.png" alt=""></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>其实本质上就是js的模块化</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>定义一个hook文件夹 将需要的函数放进去并暴露方法最后return<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314204651.png" alt=""><br>和mixins有点类似<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314204907.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li><li class="tab"><button type="button" data-href="#test-3">抛出疑问</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>解决响应式丢失的问题</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>如果我们return变量的时候想调用的时候简写,比如:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return &#123;</span><br><span class="line">name:person.name,</span><br><span class="line">age:person.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个时候数据虽然能用 但因为只是把响应式的数据赋值给了变量,而变量不是响应式的 所以就丢失了响应式.<br>使用<code>toRef</code>或者<code>toRefs</code>方法 即可把数据变成响应式的,从而return的变量也是响应式的<br>并且非常需要注意的是 toRef之后修改的数据 对应原先的数据也会修改!!!.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const name = toRef(person,&#x27;name&#x27;);</span><br><span class="line">console.log(name)//输出的是一个RefImpl对象</span><br></pre></td></tr></table></figure><br>注意 对于深层次的数据变成响应式需要这样写<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const salary = toRef(person.job.j1,&#x27;salary&#x27;);</span><br></pre></td></tr></table></figure><br>如果需要抛出的变量很多 那么建议使用<code>toRefs</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const x = toRefs(person);</span><br><span class="line">//这样就抛出了person的全部属性了 且属性里面的数据也是Proxy的</span><br><span class="line">//或者</span><br><span class="line">return &#123;</span><br><span class="line">...toRefs(person)</span><br><span class="line">&#125;</span><br><span class="line">//利用...运算符将person全部展开 但是需要注意的是 多层级的数据依旧需要在模板中一层一层写 比如job.j1.salary 暴露出来的只有job</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><ul><li>为什么不在return的时候用ref包装呢?不是比toRef写法更简单吗?<br>结果上是可以的 但是这样会有个很严重的问题 ref只是将传过来的数据进行响应式 如果当前的数据改变页面也会变动 但是!!原先的数据并没有改变 改变的是ref新建的对象里面的数据<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314210835.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314211005.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220314211035.png" alt=""></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="shallowReactive和shallowRef"><a href="#shallowReactive和shallowRef" class="headerlink" title="shallowReactive和shallowRef"></a>shallowReactive和shallowRef</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><code>shallowReactive</code>只考虑第一层的数据，意味着只对第一层做响应式，比较节能。<br><code>shallowRef</code>如果是基本类型 那么和<code>ref</code>没有区别 但是如果是对象类型 <code>shallowRef</code>不会使其变成响应式<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220316213307.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="readonly和shallowReadonly"><a href="#readonly和shallowReadonly" class="headerlink" title="readonly和shallowReadonly"></a>readonly和shallowReadonly</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><code>readonly</code>可以使得数据变成只读，虽然它是响应式的但是不允许更改<br>引申出页面没有变化的两种情况</p><ol><li>数据不是响应式的 vue就检测不到</li><li>数据不可以被修改 <code>readonly</code>属于这种情况<br><code>shallowReadonly</code>让数据的第一层不能被修改 但深层次可以被修改<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220316214755.png" alt=""></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="toRaw还原对象"><a href="#toRaw还原对象" class="headerlink" title="toRaw还原对象"></a>toRaw还原对象</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><code>toRaw</code>用于还原对象或者变量的响应式。<br>只能处理reactive定义的响应式对象<br><code>markRaw</code><br>用之前讲讲不用它的时候的需求<br>如果已经将对象变成响应式并且暴露出去了，那么后面有个function想在刚刚的对象中添加新数据进去是不行的，因为<code>toRefs</code>只把第一层的数据暴露了出去，新添加的数据是没有暴露的。解决方法有两种</p><ol><li>给原先的对象赋一个空的新数据，这样就会把空数据暴露出去且是响应式，所以后面增加也会变动</li><li>将对象重新交出去(交了两次 一次是源对象 一次是<code>toRefs</code>)这样一来就是把整个响应式对象交了出去，既然是响应式的对象，那么也能检测到添加和删除的元素。</li></ol><p>那么<code>markRaw</code>的业务是什么呢？<br>上面说了新添加的响应式数据 如果这个数据特别庞大，层次特别丰富，只是展示到页面上，且不用变动数据的时候，那么这时候这个数据最好就不用响应式。这样一来就需要用到<code>markRaw</code>标记这个数据，这样一来不管这个数据是进入到了响应式对象里，还是一开始给了它响应式，最后它都不会是响应式的。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220316220630.png" alt="">    </p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>创建一个自定义的ref 一般用于防抖的业务场景</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">setup()&#123;</span><br><span class="line">function myRef(value,delay)&#123;</span><br><span class="line">let timer;</span><br><span class="line">return customRef((track,trigger)=&gt;&#123;</span><br><span class="line">return&#123;</span><br><span class="line">get()&#123;</span><br><span class="line">track();//告诉vue这个值需要被追踪</span><br><span class="line">&#125;,</span><br><span class="line">set(newValue)&#123;</span><br><span class="line">clearTimeout(timer);</span><br><span class="line">timer = setTimeout(()=&gt;&#123;</span><br><span class="line">value = newValue;</span><br><span class="line">trigger();//告诉vue去更新页面</span><br><span class="line">&#125;,delay)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">let keyword = myRef(&#x27;hello&#x27;,500)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="provide和inject"><a href="#provide和inject" class="headerlink" title="provide和inject"></a>provide和inject</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>提供了祖孙通信的方式<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220318193604.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="响应式数据的判断"><a href="#响应式数据的判断" class="headerlink" title="响应式数据的判断"></a>响应式数据的判断</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220318193651.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="composition-API的优势"><a href="#composition-API的优势" class="headerlink" title="composition API的优势"></a>composition API的优势</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li><li class="tab"><button type="button" data-href="#test-3">经典案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>讲到组合api，那么就要讲到这个option api了。后者是vue2的，和它的中文含义一样，是将数据和方法进行一项一项的配置。但是这样存在一定的劣势，比如当变量很多的时候，数据就不好维护了。如下图，绿色的数据对应绿色的功能，但它们的位置不一样 很难维护。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220318194106.png" alt=""><br>而到了vue3,借助了hook 就不会造成这样的问题<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220318194253.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Router</title>
    <link href="https://zlinni.github.io/posts/8bf806511a1a/"/>
    <id>https://zlinni.github.io/posts/8bf806511a1a/</id>
    <published>2022-01-19T05:45:03.000Z</published>
    <updated>2022-02-23T06:19:37.137Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tip cogs"><p>本文主要用于记录vue路由的使用，参考视频<a href='https://www.bilibili.com/video/BV1Zy4y1K7SH?p=1'>【尚硅谷Vue2.0+Vue3.0全套教程丨vuejs从入门到精通】</a></p></div><h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">SPA</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>是vue的一个插件库 专门用于实现spa应用</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>全称single page web application<br>整个应用只有一个完整的页面<br>点击页面的xx链接不会刷新页面 只会做局部更新<br>数据需要通过ajax请求获取</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li><li class="tab"><button type="button" data-href="#test-3">注意事项</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>下面以单页面多组件跳转为例子讲解router的基本使用</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>安装vuerouter<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-router</span><br></pre></td></tr></table></figure><br>创建router文件夹 写入indexjs 并导入相关组件的地址和名字<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入vuerouter</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="comment">// 导入相关组件</span></span><br><span class="line"><span class="keyword">import</span> JOJO <span class="keyword">from</span> <span class="string">&#x27;../components/JOJO.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> DIO <span class="keyword">from</span> <span class="string">&#x27;../components/DIO.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/jojo&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:JOJO</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/dio&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:DIO</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>mainjs中导入以及应用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">render</span>:<span class="function"><span class="params">h</span>=&gt;</span>h(App),</span><br><span class="line">    <span class="attr">router</span>:router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>在app需要显示组件跳转的链接a标签改为<code>router-link</code>标签 并设置<code>to=&#39;/xxx地址&#39;</code><br>可以自行添加<code>active-class</code>属性(前提是css里面有这个样式)跳转后实现效果<br>最后在要显示组件的地方 换成<code>&lt;router-view&gt;&lt;/router-view&gt;</code>标签<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;开始学习router&lt;/h1&gt;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">    &lt;div class=&quot;middle&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;navi&quot;&gt;</span><br><span class="line">        &lt;router-link to=&quot;/jojo&quot; class=&quot;list-item&quot; active-class=&quot;active&quot;&gt;点我显示jojo组件&lt;/router-link&gt;</span><br><span class="line">        &lt;router-link to=&quot;/dio&quot; class=&quot;list-item&quot; active-class=&quot;active&quot;&gt;点我显示dio组件&lt;/router-link&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;compon&quot;&gt;</span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure><br>总结一图流<br><img src="./Vue-route/Snipaste_2022-01-19_19-30-10.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><ol><li>开发当中 被路由使用的组件叫做路由组件 其他的自己亲自注册亲自写的叫做一般组件<br>前者放在pages文件夹中 后者放在components文件夹中</li><li>被路由使用的组件 会在页面需要的时候挂载 不需要的时候销毁</li><li>每个路由器都有自己的<code>$route</code>属性 里面存着自己的路由信息</li><li>整个应用只有一个router 可以通过组件的<code>$router</code>属性获取</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>嵌套路由为了解决组件中想继续显示子组件的问题 使用到了children配置项</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>定义好子组件<br>在路由中引入子组件 注意这里使用了children配置项 也是配置数组对象 且path不写斜杠<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入vuerouter</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="comment">// 导入相关组件</span></span><br><span class="line"><span class="keyword">import</span> JOJO <span class="keyword">from</span> <span class="string">&#x27;../pages/JOJO.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> DIO <span class="keyword">from</span> <span class="string">&#x27;../pages/DIO.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Msg <span class="keyword">from</span> <span class="string">&#x27;../pages/Msg.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> News <span class="keyword">from</span> <span class="string">&#x27;../pages/News.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/jojo&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:JOJO,</span><br><span class="line">            <span class="attr">children</span>:[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 这里不用写斜杠了</span></span><br><span class="line">                    <span class="attr">path</span>:<span class="string">&#x27;msg&#x27;</span>,</span><br><span class="line">                    <span class="attr">component</span>:Msg</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">                    <span class="attr">component</span>:News</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/dio&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:DIO</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>引入在组件中引入子组件 注意routerlink标签要写对应的组件下子组件的地址<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;bo ku wa jojo哒&lt;/h1&gt;</span><br><span class="line">    &lt;ul class=&quot;jojotab&quot;&gt;</span><br><span class="line">      &lt;!-- 这里不是写/msg了 是写/组件/子组件 --&gt;</span><br><span class="line">      &lt;li&gt;&lt;router-link to=&quot;/jojo/msg&quot; class=&quot;tabshow&quot;&gt;Msg&lt;/router-link&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;router-link to=&quot;/jojo/news&quot;  class=&quot;tabshow&quot;&gt;News&lt;/router-link&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;ul&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><br>注意的点 需要写routerview标签指定位置显示</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="路由的query参数"><a href="#路由的query参数" class="headerlink" title="路由的query参数"></a>路由的query参数</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li><li class="tab"><button type="button" data-href="#test-3">命名路由</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>利用路由的query可以实现同个组件点击切换不同的内容</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>先定义好组件 这里是以messageList为例子 点击列表中的选项 下方显示出传递的内容<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220120131547.png" alt=""><br>下方是组件Detail显示传递过来的信息 注意符号的使用<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;消息id是：&#123;&#123;$route.query.id&#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;消息title是：&#123;&#123;$route.query.title&#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><br>然后在路由的news下面导入以及定义detail<br>回到news 定义好列表 修改跳转的地址<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;老东西你的替身最强啦&lt;/li&gt;</span><br><span class="line">      &lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;</span><br><span class="line">        &lt;!-- 跳转路由并携带query参数 to的字符串写法--&gt;</span><br><span class="line">        &lt;!-- &lt;router-link :to=&quot;`/jojo/news/detail?id=$&#123;m.id&#125;&amp;title=$&#123;m.title&#125;`&quot;&gt;&#123;&#123; m.title &#125;&#125;&lt;/router-link&gt; --&gt;</span><br><span class="line">        &lt;!-- 跳转路由并携带query参数 to的对象写法--&gt;</span><br><span class="line">        &lt;router-link</span><br><span class="line">          :to=&quot;&#123;</span><br><span class="line">            path: &#x27;/jojo/news/detail&#x27;,</span><br><span class="line">            query: &#123;</span><br><span class="line">              id: m.id,</span><br><span class="line">              title: m.title,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;&quot;</span><br><span class="line">          &gt;&#123;&#123; m.title &#125;&#125;&lt;/router-link</span><br><span class="line">        &gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      messageList: [</span><br><span class="line">        &#123; id: &quot;001&quot;, title: &quot;msg001&quot; &#125;,</span><br><span class="line">        &#123; id: &quot;002&quot;, title: &quot;msg002&quot; &#125;,</span><br><span class="line">        &#123; id: &quot;003&quot;, title: &quot;msg003&quot; &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>注意跳转路由携带query参数的写法 推荐第二种 比较清晰<br>必须注意绑定to</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220120132306.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="params参数和路由器的props配置"><a href="#params参数和路由器的props配置" class="headerlink" title="params参数和路由器的props配置"></a>params参数和路由器的props配置</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>params参数接收基本和query相同 但是路径path要写成name<br>路由的props配置可以简化路由组件的编写</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>params<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220120134626.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220120134658.png" alt=""><br>props<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220120134727.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="开启replace操作"><a href="#开启replace操作" class="headerlink" title="开启replace操作"></a>开启replace操作</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220120162259.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>不借助routerlink的路由导航就是编程式路由导航<br>如果要使用button或者其他非a标签进行跳转实现的时候，routerlink就没有作用了<br>以及定时器自动跳转（没有点击用不到a标签）</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>主要内容<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220124102705.png" alt=""><br>push和replace部分<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">        &lt;button @click=&quot;pushShow(m)&quot;&gt;push&lt;/button&gt;</span><br><span class="line">        &lt;button @click=&quot;replaceShow(m)&quot;&gt;replace&lt;/button&gt;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">methods: &#123;</span><br><span class="line">    pushShow(m) &#123;</span><br><span class="line">      this.$router.push(&#123;</span><br><span class="line">        path: &quot;/jojo/news/detail&quot;,</span><br><span class="line">        query: &#123;</span><br><span class="line">          id: m.id,</span><br><span class="line">          title: m.title,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    replaceShow(m) &#123;</span><br><span class="line">      this.$router.replace(&#123;</span><br><span class="line">        path: &quot;/jojo/news/detail&quot;,</span><br><span class="line">        query: &#123;</span><br><span class="line">          id: m.id,</span><br><span class="line">          title: m.title,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><br>前进后退和go部分<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    &lt;button @click=&quot;back&quot;&gt;后退&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;forward&quot;&gt;前进&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;testGo&quot;&gt;测试一下go&lt;/button&gt;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">  methods: &#123;</span><br><span class="line">    back()&#123;</span><br><span class="line">      this.$router.back();</span><br><span class="line">    &#125;,</span><br><span class="line">    forward()&#123;</span><br><span class="line">      this.$router.forward();</span><br><span class="line">    &#125;,</span><br><span class="line">    testGo()&#123;</span><br><span class="line">      // 正数前进 负数后退</span><br><span class="line">      this.$router.go(3)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><br>总结一波流<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220124102914.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="路由缓存"><a href="#路由缓存" class="headerlink" title="路由缓存"></a>路由缓存</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>为了解决当页面中输入了相关内容后进行跳转最后回去还保留内容的问题<br>原因是组件的切换会重新挂载和销毁<br>利用到keepalive标签以及include属性</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>msg里面定义输入框<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;name:&lt;input type=&quot;text&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;stand:&lt;input type=&quot;text&quot;&gt;&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><br>jojo里面 （使用到输入框的父组件）设置keepalive<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;bo ku wa jojo哒&lt;/h1&gt;</span><br><span class="line">    &lt;ul class=&quot;jojotab&quot;&gt;</span><br><span class="line">      &lt;!-- 这里不是写/msg了 是写/组件/子组件 --&gt;</span><br><span class="line">      &lt;li&gt;&lt;router-link to=&quot;/jojo/msg&quot; class=&quot;tabshow&quot;&gt;Msg&lt;/router-link&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;router-link to=&quot;/jojo/news&quot; class=&quot;tabshow&quot;&gt;News&lt;/router-link&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;keep-alive include=&quot;Msg&quot;&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/keep-alive&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><br>注意 keepalive包裹的是routerview标签<br>include属性是指定缓存哪个组件 不写的话默认全部<br>最后特别注意 使用到include的时候 对应的组件要设置name<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name:&#x27;Msg&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>总结一图流<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220124104807.png" alt=""></p><p>补充说明<br>如果想缓存多个路由组件 使用到<code>v-bind</code>和数组写法<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220124104954.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="两个新的生命周期钩子"><a href="#两个新的生命周期钩子" class="headerlink" title="两个新的生命周期钩子"></a>两个新的生命周期钩子</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>如果使用上述的缓存路由就会出现一个问题 缓存组件中的东西没有执行销毁<br>引出两个路由的生命周期钩子 activated 和 deactivated</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>激活 activated<br>将之前需要写在mounted里面的功能写入 当切换到该组件就生效<br>失活 deactivated<br>将之前需要写在销毁之前的功能写入 当离开该组件生效<br>一图流<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220124111225.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="全局路由守卫"><a href="#全局路由守卫" class="headerlink" title="全局路由守卫"></a>全局路由守卫</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>用于判断某些条件的执行是否满足才进入到路由的下一级</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>全局前置路由：每一次切换前都被调用<br>要用到全局路由守卫就必须接收路由再暴露出去<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> router =  <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="attr">routes</span>: [&#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/jojo&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: JOJO,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">                    <span class="comment">// 这里不用写斜杠了</span></span><br><span class="line">                    <span class="attr">path</span>: <span class="string">&#x27;msg&#x27;</span>,</span><br><span class="line">                    <span class="attr">component</span>: Msg</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">path</span>: <span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">                    <span class="attr">component</span>: News,</span><br><span class="line">                    <span class="attr">children</span>: [&#123;</span><br><span class="line">                        <span class="attr">path</span>: <span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">                        <span class="attr">component</span>: Detail,</span><br><span class="line">                        <span class="function"><span class="title">props</span>(<span class="params">$route</span>)</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> &#123;</span><br><span class="line">                                <span class="attr">id</span>: $route.query.id,</span><br><span class="line">                                <span class="attr">title</span>: $route.query.title</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/dio&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: DIO</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(to,<span class="keyword">from</span>);</span><br><span class="line">    <span class="keyword">if</span>(to.path === <span class="string">&#x27;/jojo/news&#x27;</span>)&#123;</span><br><span class="line">        next();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;去往news&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><br>用到了beforeEach的方法 值得一提的是三个参数<br>to代表的是去往的位置<br>from代表从哪里来<br>next代表是否执行下一步<br>example：先点击jojo 后点击dio 就出现to里面有dio from里面有jojo<br>对于to 和 from 两者携带的参数如下<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220124151706.png" alt=""><br>其中name指的是路由的名字 这里没有定义所以是undefined<br>可以在meta里面放入个人定义的信息 这个属性称之为路由元信息<br>就不用逐个判断这么复杂了 只要路由守卫判断路由信息里面是否有存在这么个meta里面的属性 就可以执行或不执行下面的步骤<br>且注意没有定义的时候 就是undefined 自然为假 所以只用定义真的情况<br>此处在news里面设置meta<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router =  <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="attr">routes</span>: [&#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/jojo&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: JOJO,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">                    <span class="comment">// 这里不用写斜杠了</span></span><br><span class="line">                    <span class="attr">path</span>: <span class="string">&#x27;msg&#x27;</span>,</span><br><span class="line">                    <span class="attr">component</span>: Msg</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">path</span>: <span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">                    <span class="attr">component</span>: News,</span><br><span class="line">                    <span class="attr">children</span>: [&#123;</span><br><span class="line">                        <span class="attr">path</span>: <span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">                        <span class="attr">component</span>: Detail,</span><br><span class="line">                        <span class="function"><span class="title">props</span>(<span class="params">$route</span>)</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> &#123;</span><br><span class="line">                                <span class="attr">id</span>: $route.query.id,</span><br><span class="line">                                <span class="attr">title</span>: $route.query.title</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;],</span><br><span class="line">                    <span class="attr">meta</span>:&#123;<span class="attr">isAuth</span>:<span class="literal">true</span>&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/dio&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: DIO</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(to,<span class="keyword">from</span>);</span><br><span class="line">    <span class="keyword">if</span>(to.meta.isAuth)&#123;</span><br><span class="line">        next();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;去往news&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><br>全局后置守卫<br>没有next功能 常用于网页标题的切换<br>如果只使用前置守卫去切换这个标题的话 会出现一瞬间的网页标题错误等细节问题<br>所以使用后置守卫写比较好<br>另外修改标题的方法是<code>document.title = xxx</code>这里最好使用meta定义的title<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220124153523.png" alt=""><br>总结一波流<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220124153608.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="独享路由守卫"><a href="#独享路由守卫" class="headerlink" title="独享路由守卫"></a>独享路由守卫</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>如果只想对单个路由进行权限操作 则可以使用独享路由守卫来执行</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>beforeEnter 也有to from next三个参数 类似于beforeEach<br>但独享路由守卫只有前置路由守卫 没有后置<br>一图流：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220124154108.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li><li class="tab"><button type="button" data-href="#test-3">经典案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="组件路由守卫"><a href="#组件路由守卫" class="headerlink" title="组件路由守卫"></a>组件路由守卫</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>顾名思义就是在组件里面写路由守卫</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>两个方法<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220124154242.png" alt=""><br>与前置后置守卫不同的一点是<br>从jojo到dio 会产生一次前置 一次后置<br>而组件路由守卫的话<br>从jojo到dio 会产生一次beforeRouteEnter 然后 当点击到其他的内容 比如msg 才会产生beforeRouteLeave<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220124154607.png" alt=""><br>注意一点 如果不next 放行 那么就是进不去也出不来<br>一图流<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220124155056.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="history模式与hash模式"><a href="#history模式与hash模式" class="headerlink" title="history模式与hash模式"></a>history模式与hash模式</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li><li class="tab"><button type="button" data-href="#test-3">经典案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>vue的路由有两种工作模式 hash 和 history 默认是hash</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>hash模式 地址栏井号斜杠后面的所有参数都是hash值 特点是不随http请求发给服务器<br>意味着如果后面写了很多东西 它也不会发给服务器的<br>history模式 没有井号 比较美观<br>默认hash模式 切换成history模式<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220124155759.png" alt=""><br>此外 hash模式的兼容性比history好<br>且 如果项目上线的时候 打包为history模式 会在刷新的时候出现404问题 因为服务端没有配置相关地址 但hash 就不会 因为井号后面不会发给服务端<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220124162251.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>数组去重的八种方法</title>
    <link href="https://zlinni.github.io/posts/1bdac88a9cd9/"/>
    <id>https://zlinni.github.io/posts/1bdac88a9cd9/</id>
    <published>2022-01-14T07:57:18.000Z</published>
    <updated>2022-02-23T06:43:06.741Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>本文主要用于讲解以及记录js数组去重的八种方法 主要学习其中的编程思想</p></div><h1 id="方法总览"><a href="#方法总览" class="headerlink" title="方法总览"></a>方法总览</h1><ol><li>第三方库<br>下面推荐underscore和loadash，这两个库也是官网直接下载下来然后引入即可<br>效果如下<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220114160343.png" alt=""><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./underscore-min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">500</span>];</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">getUniqueArray</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> result = _.uniq(arr);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(result);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    getUniqueArray();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>es6的set方法<br>set方法里面的东西是独一无二的 利用这个特性去重<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">500</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUniqueArray</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 两种都可以 推荐上面的</span></span><br><span class="line">    <span class="comment">// var result = [...new Set(arr)]</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">Array</span>.from(<span class="built_in">Set</span>(arr));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line">getUniqueArray();</span><br></pre></td></tr></table></figure></li><li>遍历数组再用indexOf判断 如果不存在相同的就push进去<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">500</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUniqueArray</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(result.indexOf(item) === -<span class="number">1</span>)result.push(item);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line">getUniqueArray();</span><br></pre></td></tr></table></figure></li><li>利用filter过滤 原理是利用indexOf会返回数组下标 并且有两个一样的元素的时候 只会返回第一个的下标 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">500</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUniqueArray</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = arr.filter(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr.indexOf(item) === index</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line">getUniqueArray();</span><br></pre></td></tr></table></figure></li><li>利用reduce方法 以及include方法 迭代的结果里面是否有相同<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">500</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUniqueArray</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = arr.reduce(<span class="function">(<span class="params">pre,current</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre.includes(current)?pre:[...pre,current]</span><br><span class="line">    &#125;,[])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line">getUniqueArray();</span><br></pre></td></tr></table></figure></li><li>利用对象的特性 对象中的key是唯一的 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">500</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUniqueArray</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">item,index</span>) =&gt;</span> &#123;</span><br><span class="line">        result[arr[index]] = <span class="string">&#x27;sss&#x27;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    result = <span class="built_in">Object</span>.keys(result).map(<span class="function"><span class="params">item</span>=&gt;</span>~~item);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line">getUniqueArray();</span><br></pre></td></tr></table></figure></li><li>基本的算法 数组去重 对比两数组<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">500</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUniqueArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    loop: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] === arr[j]) <span class="keyword">continue</span> loop;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line">getUniqueArray();</span><br></pre></td></tr></table></figure></li><li>利用排序后的数组 相邻有相同的则重复的特性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">500</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUniqueArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    sortArr = arr.sort();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sortArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sortArr[i] !== sortArr[i + <span class="number">1</span>]) result.push(sortArr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br><span class="line">getUniqueArray();</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>上面写到的八种方法还是看需求使用比较好 有的方法虽然可以解决问题 但没有考虑到时间复杂度之类的 尽量使用简单的方法或者第三方库的方法吧</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>LandingPage落地页</title>
    <link href="https://zlinni.github.io/posts/660fac1a5939/"/>
    <id>https://zlinni.github.io/posts/660fac1a5939/</id>
    <published>2022-01-09T02:35:44.000Z</published>
    <updated>2022-02-27T02:52:57.554Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>本文介绍了落地页的内容，设计风格以及落地页对用户的吸引作用。</p></div><h1 id="何为LandingPage"><a href="#何为LandingPage" class="headerlink" title="何为LandingPage"></a>何为LandingPage</h1><p>landingpage是一种网页设计风格制作的网页，中文名是落地页，像下面这几种<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220209180635.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220209180709.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220209180741.png" alt=""><br>它们都有非常鲜明的特点，就是非常集中式的引导用户进入某个选项。相比起传统的网页，落地页不需要用户去探索页面的各种内容，而是专于某种目的，比如推销产品，展现简历内容等。</p><h1 id="LandingPage的制作"><a href="#LandingPage的制作" class="headerlink" title="LandingPage的制作"></a>LandingPage的制作</h1><p>其实landingpage的制作并不太需要很好的前端能力，甚至现在很多开发网页都可以使用框架生成或者软件生成，这样有助于设计者更专注于界面的设计而非功能的使用，并且因为落地页基本不需要后台的功能，所以落地页基本是静态的网站，也就加快了网页的访问速度，减少用户的等待时间，进一步留住用户提高访问量。<br>另外，正常的网页中目标导向太多，导致用户不知道应该点哪个以进行下一步的选择，这样不仅会导致使用者的流失，也会导致设计者投资的广告费用白白浪费，所以一个正确的landingpage应该具有以下几点要求</p><ol><li>精美的设计</li><li>收集信息的表格</li><li>详细的产品或服务描述</li><li>以往客户评价</li></ol><p>关于实际制作landing page 需要使用到wordpress软件里面的一个插件brizy<br>下面提供视频演示地址<br><div class="note primary flat"><p><a href="https://www.bilibili.com/video/BV17h411R7vF?from=search&amp;seid=10740205905332206372&amp;spm_id_from=333.337.0.0">视频地址</a></p></div></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>依我个人而言，更喜欢landing page这种类型的页面制作，因为它的美感肯定是大于常规的电商网站的，而且也不会用到很多的功能，但是要练手项目的话，还是建议选择功能制作比较多的页面，这样能够体现自己的编程能力，以及解决问题的能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="设计" scheme="https://zlinni.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>每日一面，快乐无限</title>
    <link href="https://zlinni.github.io/posts/427f696eb6e1/"/>
    <id>https://zlinni.github.io/posts/427f696eb6e1/</id>
    <published>2022-01-09T02:35:44.000Z</published>
    <updated>2022-04-11T10:49:42.333Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>本文主要用于记录前端面试常考题</p></div><h1 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h1><h2 id="HTTP-HTML-浏览器"><a href="#HTTP-HTML-浏览器" class="headerlink" title="HTTP/HTML/浏览器"></a>HTTP/HTML/浏览器</h2><h3 id="说一下http和https"><a href="#说一下http和https" class="headerlink" title="说一下http和https"></a>说一下http和https</h3><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">基本概念</button></li><li class="tab"><button type="button" data-href="#test-2">区别</button></li><li class="tab"><button type="button" data-href="#test-3">https的工作原理</button></li><li class="tab"><button type="button" data-href="#test-4">https协议的优缺点</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>http 超文本传输协议 是互联网上应用最广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（tcp），用于从www服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少<br>https 是以安全为目标的http通道，简单讲是http的安全版，即http下加入ssl层，https的安全基础是ssl，因此加密的详细内容就需要ssl<br>https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>https协议需要ca证书 费用比较高<br>http的信息是明文传输，https是经过ssl协议加密传输的<br>端口不同 一般来讲http是80端口 https是443端口</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><p>客户使用https url访问服务器，则要求web服务器建立ssl连接<br>web服务器收到客户端的请求后，将网站的证书（里面包含公钥）返回or传输给客户端<br>客户端和web服务器端开始协商ssl链接的安全等级<br>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥加密会话密钥，并传送给网站<br>web服务器通过自己的私钥解密出会话密钥<br>web服务器通过会话密钥加密与客户端之间的通信</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-4"><p>优点：使用https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。<br>缺点：https握手阶段比较费时，会使得页面加载时间延长50%，增加10%-20%的耗电<br>https缓存不如http高效，会增加数据开销<br>ssl证书要钱 功能越强的证书费用越高<br>ssl证书要绑定ip 不能在同个ip上绑定多个域名，ipv4资源支持不了这种消耗</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="tcp三次握手"><a href="#tcp三次握手" class="headerlink" title="tcp三次握手"></a>tcp三次握手</h3><p>一句话概括：<br>客户端和服务端都需要直到各自可收发，因此需要三次握手</p><h3 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h3><ol><li>tcp是面向链接的 udp是无连接的即发送数据前不需要建立连接</li><li>tcp提供可靠的服务，也就是说通过tcp连接发送的数据，无差错，不丢失，不重复，且按序到达，udp尽最大的努力交付，即不保证可靠交付。并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换</li><li>tcp是面向字节流，udp面向报文，并且网络出现拥塞不会使得发送速率降低（因此会产生丢包，对实时的应用比如ip电话和视频会议等）</li><li>tcp只能是一对一的，udp支持1对1 1对多</li><li>tcp的首部较大为20字节 udp只有8字节</li><li>tcp是面向连接的可靠性传输，udp是不可靠的</li></ol><h3 id="websocket的实现和应用"><a href="#websocket的实现和应用" class="headerlink" title="websocket的实现和应用"></a>websocket的实现和应用</h3><p>应用：多人聊天室，客服咨询<br><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">什么是websocket</button></li><li class="tab"><button type="button" data-href="#test-2">websocket是怎么样的协议？具体有什么优点</button></li><li class="tab"><button type="button" data-href="#test-3">websocket的作用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>websocket是h5中的一种协议，支持持久性连接，而http协议不支持。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>首先，Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说</p><p>HTTP的生命周期通过 Request 来界定，也就是一个 Request 一个 Response ，那么在 HTTP1.0 中，这次HTTP请求就结束了。</p><p>在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。但是请记住 Request = Response ， 在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是被动的，不能主动发起。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><p>（1）ajax轮询</p><p>ajax轮询的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。</p><p>（2）long poll（长轮询）</p><p>long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端（对于PHP有最大执行时间，建议没消息，执行到一定时间也返回）。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。</p><p>从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，关闭HTTP协议，由于HTTP是非状态性的，每次都要重新传输 identity info （鉴别信息），来告诉服务端你是谁。然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。</p><p>何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。</p><p>ajax轮询 需要服务器有很快的处理速度和资源。（速度）long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）</p><p>（3）WebSocket</p><p>Websocket解决了HTTP的这几个难题。首先，被动性，当服务器完成协议升级后（HTTP-&gt;Websocket），服务端就可以主动推送信息给客户端啦。解决了上面同步有延迟的问题。</p><p>解决服务器上消耗资源的问题：其实我们所用的程序是要经过两层代理的，即HTTP协议在Nginx等服务器的解析下，然后再传送给相应的Handler（php等）来处理。简单地说，我们有一个非常快速的 接线员（Nginx） ，他负责把问题转交给相应的 客服（Handler） 。Websocket就解决了这样一个难题，建立后，可以直接跟接线员建立持久连接，有信息的时候客服想办法通知接线员，然后接线员在统一转交给客户。</p><p>由于Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。</p><p>目前唯一的问题是：不兼容低版本的IE</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><h3 id="http请求的HEAD方式"><a href="#http请求的HEAD方式" class="headerlink" title="http请求的HEAD方式"></a>http请求的HEAD方式</h3><p>head：类似于get请求，只不过返回的响应中没有具体的内容，用户获取报头<br>options： 允许客户端查看服务器的性能 比如服务器支持的请求方式等等</p><h3 id="一个图片url访问后下载怎样实现"><a href="#一个图片url访问后下载怎样实现" class="headerlink" title="一个图片url访问后下载怎样实现"></a>一个图片url访问后下载怎样实现</h3><p>请求的返回头里面，用于浏览器解析的重要参数就是oss的api文档里面的返回http头，决定用户下载行为的参数<br>下载的情况下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. x-oss-object-type</span><br><span class="line">Normal</span><br><span class="line">2. x-oss-request-id:</span><br><span class="line">3. x-oss-storage-class</span><br><span class="line">Standard</span><br></pre></td></tr></table></figure></p><h3 id="web-quality-无障碍"><a href="#web-quality-无障碍" class="headerlink" title="web quality(无障碍)"></a>web quality(无障碍)</h3><p>能够被残障人士使用的网站才能称得上是一个易用的网站<br>使用alt属性<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;person,jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;this is a person&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="几个实用的BOM属性对象方法"><a href="#几个实用的BOM属性对象方法" class="headerlink" title="几个实用的BOM属性对象方法"></a>几个实用的BOM属性对象方法</h3><p>1.location对象<br>2.history对象<br>3.Navigator对象</p><h3 id="H5的drag-api"><a href="#H5的drag-api" class="headerlink" title="H5的drag api"></a>H5的drag api</h3><h3 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h3><p>访问速度更快<br>允许多路复用<br>二进制分帧<br>首部压缩<br>服务器端推送</p><h3 id="400-401-403状态码"><a href="#400-401-403状态码" class="headerlink" title="400 401 403状态码"></a>400 401 403状态码</h3><ol><li>400：请求无效<br>产生原因：<br>前端提交数据的字段名称和字段类型与后台的实体没有保持一致<br>前端提交到后台的数据应该是json字符串类型 但是前端没有将对象<code>JSON.stringfy</code>转化成字符串<br>解决方法：<br>对照字段的名称 保持一致性<br>将obj对象通过<code>JSON.stringfy</code>实现序列化</li><li>401：当前请求需要用户验证</li><li>403：服务器已经得到请求，但是拒绝执行</li></ol><h3 id="fetch发送两次请求的原因"><a href="#fetch发送两次请求的原因" class="headerlink" title="fetch发送两次请求的原因"></a>fetch发送两次请求的原因</h3><p>fetch发送post请求的时候 总是发送两次，第一次的状态码是204 第二次才成功？<br>原因：<br>因为用fetch的post请求的时候，导致fetch第一次发送了一个options请求 询问服务器是否支持修改的请求头 如果服务器支持 则在第二次中发送真正的请求</p><h3 id="cookie-sessionStorage-localStorage的区别"><a href="#cookie-sessionStorage-localStorage的区别" class="headerlink" title="cookie sessionStorage localStorage的区别"></a>cookie sessionStorage localStorage的区别</h3><p>共同点：都是保存在浏览器 而且是同源的<br>cookie：cookie数据始终在同源的http请求中携带（即使不需要）即cookie在浏览器和服务器之间来回传递，而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存 cookie数据还有路径path的概念，可以限制cookie只属于某个路径下，存储的大小很小只有4k左右<br>（key：可以在浏览器和服务器之间来回传递 存储容量小 只有4k左右）<br>sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持<br>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭<br>（key：本身就是一个会话过程，关闭浏览器后消失 ，session为一个会话，当页面不同即使是同一页面打开两次，也被视为同一次会话）</p><h3 id="web-worker"><a href="#web-worker" class="headerlink" title="web worker"></a>web worker</h3><h3 id="对html语义化标签的理解"><a href="#对html语义化标签的理解" class="headerlink" title="对html语义化标签的理解"></a>对html语义化标签的理解</h3><p>h5语义化标签是指正确的标签包含了正确的内容 结构良好 便于阅读 比如nav表示导航条 类似的还有artical header footer等等</p><h3 id="iframe是什么？有什么缺点？"><a href="#iframe是什么？有什么缺点？" class="headerlink" title="iframe是什么？有什么缺点？"></a>iframe是什么？有什么缺点？</h3><p>定义：iframe元素会创建包含另一个文档的内联框架<br>提示：可以将提示文字放在iframe标签之间，来提示某些不支持iframe的浏览器<br>缺点：</p><ol><li>会阻塞主页面的onload事件</li><li>搜索引擎无法解读这种页面 不利于SEO</li><li>iframe和主页面共享连接池 而浏览器对相同区域有限制所以会影响性能</li></ol><h3 id="Doctype的作用？严格模式与混杂模式如何区分？它们有何意义？"><a href="#Doctype的作用？严格模式与混杂模式如何区分？它们有何意义？" class="headerlink" title="Doctype的作用？严格模式与混杂模式如何区分？它们有何意义？"></a>Doctype的作用？严格模式与混杂模式如何区分？它们有何意义？</h3><p>Doctype声明于文档最前面 告诉浏览器以何种方式来渲染页面 有两种模式 混杂模式和严格模式<br>严格模式的排版和js运作模式是以该浏览器支持的最高标准运行<br>混杂模式则向后兼容 模拟老实浏览器 防止浏览器无法兼容页面</p><h3 id="cookie如何防范xss攻击"><a href="#cookie如何防范xss攻击" class="headerlink" title="cookie如何防范xss攻击"></a>cookie如何防范xss攻击</h3><p>xss 跨站脚本攻击 是指攻击者在返回的html中嵌入js脚本，为了减轻这些攻击，需要在http的头部配上，<code>set-cookie:httponly</code>这个属性可以防止xss，他会禁止js脚本来访问cookie<br><code>secure</code>这个属性告诉浏览器仅在请求为https的时候发送cookie</p><h3 id="一句话概括RESTFUL"><a href="#一句话概括RESTFUL" class="headerlink" title="一句话概括RESTFUL"></a>一句话概括RESTFUL</h3><p>就是用url定位资源 用http描述操作</p><h3 id="讲讲viewport和移动端布局"><a href="#讲讲viewport和移动端布局" class="headerlink" title="讲讲viewport和移动端布局"></a>讲讲viewport和移动端布局</h3><p>常用解决方案<br>媒体查询<br>百分比<br>rem<br>vw和vh</p><h3 id="click在ios上有300ms延迟-原因以及如何解决"><a href="#click在ios上有300ms延迟-原因以及如何解决" class="headerlink" title="click在ios上有300ms延迟 原因以及如何解决"></a>click在ios上有300ms延迟 原因以及如何解决</h3><h3 id="addEventListener的参数"><a href="#addEventListener的参数" class="headerlink" title="addEventListener的参数"></a>addEventListener的参数</h3><p>代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(event,<span class="keyword">function</span>.useCapture)</span><br><span class="line"><span class="comment">//event事件名</span></span><br><span class="line"><span class="comment">//function指定事件触发时执行的函数</span></span><br><span class="line"><span class="comment">//useCapture是否在捕获或者冒泡阶段执行</span></span><br></pre></td></tr></table></figure></p><h3 id="讲讲304"><a href="#讲讲304" class="headerlink" title="讲讲304"></a>讲讲304</h3><p>如果客户端发送了一个带条件的get请求且该请求已被允许，而文档的内容并没有改变，则服务器应该返回这个304状态码</p><h3 id="强缓存-协商缓存什么时候用哪个？"><a href="#强缓存-协商缓存什么时候用哪个？" class="headerlink" title="强缓存 协商缓存什么时候用哪个？"></a>强缓存 协商缓存什么时候用哪个？</h3><h3 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h3><ol><li>降低请求量：合并资源，减少http请求数，minify/gzip压缩，webP，lazyLoad</li><li>加快请求速度：预解析DNS，减少域名数，并行加载，CDN分发。</li><li>缓存：HTTP协议缓存请求，离线缓存，manifest，离线数据缓存localStorage</li><li>渲染：JS/CSS优化，加载顺序，服务端渲染，pipeline</li></ol><h3 id="post和get的区别"><a href="#post和get的区别" class="headerlink" title="post和get的区别"></a>post和get的区别</h3><ol><li>get参数通过url传递，post放在request body中</li><li>get请求在url中传递的参数是有长度限制的 post没有</li><li>get比post更不安全，因为参数直接暴露在url中，所以不能用来传输敏感信息</li><li>get请求只能进行url编码 post支持多种编码方式</li><li>get请求会浏览器主动cache</li><li>get请求的参数会被完整的保留在浏览器的历史记录里，而post不会</li><li>get和post本质上都是TCP连接，没有差别。但由于http的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同</li><li>get产生一个TCP数据包 post产生两个</li></ol><h3 id="301-和-302的区别"><a href="#301-和-302的区别" class="headerlink" title="301 和 302的区别"></a>301 和 302的区别</h3><h3 id="HTTP支持的方法"><a href="#HTTP支持的方法" class="headerlink" title="HTTP支持的方法"></a>HTTP支持的方法</h3><p>get post head options put delete trace connect</p><h3 id="如何画一个三角形"><a href="#如何画一个三角形" class="headerlink" title="如何画一个三角形"></a>如何画一个三角形</h3><p>三角形原理，边框的均分原理<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">0px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">0px</span>;</span><br><span class="line"><span class="attribute">border-top</span>:<span class="number">10px</span> solid red;</span><br><span class="line"><span class="attribute">border-right</span>:<span class="number">10px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-bottom</span>:<span class="number">10px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-left</span>:<span class="number">10px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="状态码304和200"><a href="#状态码304和200" class="headerlink" title="状态码304和200"></a>状态码304和200</h3><p>200：请求已经成功 请求所希望的响应头或数据体岁此响应返回<br>304：如果客户端发送了一个带条件的get请求且该请求已被允许，而文档的内容并没有改变，则返回这个状态码</p><h3 id="说一下浏览器缓存"><a href="#说一下浏览器缓存" class="headerlink" title="说一下浏览器缓存"></a>说一下浏览器缓存</h3><h3 id="HTML5新增的元素"><a href="#HTML5新增的元素" class="headerlink" title="HTML5新增的元素"></a>HTML5新增的元素</h3><p>首先html5为了更好的实践web语义化，增加了<code>header</code>，<code>footer</code>，<code>nav</code>，<code>aside</code>，<code>section</code>等语义化标签，在表单方面，为了增强表单，为input增加了<code>color</code>,<code>emial</code>, <code>data</code>,<code>range</code> 等类型。在存储方面，提供了<code>sessionStorage</code>，<code>localStorage</code>和离线存储，通过这些存储方式方便数据在客户端的存储和获取，在多媒体方面规定了音频和视频元素<code>audio</code>和<code>video</code>，另外还有地理定位，<code>canvas</code>画布，拖放，多线程编程的web worker和websocket协议</p><h3 id="在地址栏里输入一个url-到这个页面呈现出来，中间会发生什么？"><a href="#在地址栏里输入一个url-到这个页面呈现出来，中间会发生什么？" class="headerlink" title="在地址栏里输入一个url 到这个页面呈现出来，中间会发生什么？"></a>在地址栏里输入一个url 到这个页面呈现出来，中间会发生什么？</h3><p>DNS解析<br>TCP连接<br>发送HTTP请求<br>服务器处理请求并返回http报文<br>浏览器解析渲染页面<br>连接结束</p><h3 id="浏览器在生成页面的时候会生成哪两颗树"><a href="#浏览器在生成页面的时候会生成哪两颗树" class="headerlink" title="浏览器在生成页面的时候会生成哪两颗树"></a>浏览器在生成页面的时候会生成哪两颗树</h3><p>构造两棵树，DOM树和CSSOM规则树<br>当浏览器接收到服务器相应来的HTML文档后，会遍历文档节点，生成DOM树<br>CSSOM规则树则由浏览器解析css文件生成</p><h3 id="csrf和xss网络攻击及防范"><a href="#csrf和xss网络攻击及防范" class="headerlink" title="csrf和xss网络攻击及防范"></a>csrf和xss网络攻击及防范</h3><p>csrf 跨站请求伪造，理解为攻击者盗用了用户的身份，以用户的名义发送了恶意请求，比如用户登陆了一个网站后，立刻在另一个tab页面访问攻击者用来制造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候csrf就产生了。<br>防范方式：使用验证码，检查http头部的refer，使用token<br>xss 跨站脚本攻击 可以理解为攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击，比如获取cookie，或者其他用户身份信息，可以分为存储型和反射型。<br>防范方式：cookie设置httponly属性，对用户的输入进行检查，进行特殊字符过滤</p><h3 id="怎么看网站的性能如何"><a href="#怎么看网站的性能如何" class="headerlink" title="怎么看网站的性能如何"></a>怎么看网站的性能如何</h3><p>检测页面加载事件一般有两种方式：</p><ol><li>被动去测：就是在被检测的页面置入脚本或探针，当用户访问网页时，探针自动菜鸡数据并传回到数据库进行分析。</li><li>主动检测，即主动搭建分布式受控环境，模拟用户发起页面访问请求，主动采集性能数据并分析，在检测的精准度上，专业的第三方工具效果更佳，比如性能极客。</li></ol><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>1xx 信息状态码<br>100 continue 继续 一般在发送post请求的时候 已发送了http header 之后服务端返回此信息 表示确认，之后发送具体的参数消息<br>2xx 成功状态码<br>200 ok 正常返回信息<br>201 created 请求服务器已经成功并且创建了新的资源<br>202 accepted 服务器已接受请求 但未响应<br>3xx 重定向<br>301 moved permanently 请求的网页已永久移到新的位置<br>302 found 临时性重定向<br>303 see other 临时性重定向 且总是使用get请求新的url<br>304 not modified 自从上次的请求过后     请求的网页未修改过<br>4xx 客户端错误<br>400 bad request 服务端不理解客户端请求的格式 客户端不应该继续使用相同的内容发起请求<br>401 unauthorized 请求未授权<br>403 forbidden 禁止访问<br>404 not found 找不到与url匹配的资源<br>5xx 服务器错误<br>500 Internal server error 最常见的服务器错误<br>503 service unavailable 服务端暂时无法处理请求</p><h3 id="严格模式和混杂模式之doctype"><a href="#严格模式和混杂模式之doctype" class="headerlink" title="严格模式和混杂模式之doctype"></a>严格模式和混杂模式之doctype</h3><p>严格模式 以浏览器支持的最高标准执行 混杂模式也称怪异模式 向后兼容<br>没有<code>!Doctype</code>位于文档首部或者格式不正确 那么就是以混杂模式执行</p><h3 id="web标准以及w3c标准是什么"><a href="#web标准以及w3c标准是什么" class="headerlink" title="web标准以及w3c标准是什么"></a>web标准以及w3c标准是什么</h3><p>标签闭合 标签小写 不乱嵌套 使用外链的js/css 结构行为表现的分离</p><h3 id="行内元素-行内块-块元素-空元素"><a href="#行内元素-行内块-块元素-空元素" class="headerlink" title="行内元素 行内块 块元素 空元素"></a>行内元素 行内块 块元素 空元素</h3><p>行内元素：<code>a b span br i em strong label q code cite var</code><br>行内块:<code>img input</code><br>块元素:<code>div p h1-6 ol ul dl table form</code><br>行内元素 在一行上显示 不能设置宽高 元素的大小就是内容撑开的大小<br>行内块 在一行上显示 可设置宽高<br>块元素 独占一行 可以设置宽高 嵌套的情况下子默认和父宽度一致</p><p>空元素：不用写闭合标签的元素<br>常见空元素:<code>img input hr br link meta</code></p><h3 id="html全局属性"><a href="#html全局属性" class="headerlink" title="html全局属性"></a>html全局属性</h3><h2 id="CSS篇"><a href="#CSS篇" class="headerlink" title="CSS篇"></a>CSS篇</h2><h3 id="css盒模型"><a href="#css盒模型" class="headerlink" title="css盒模型"></a>css盒模型</h3><p>就是用来装页面上的元素的矩形区域，css中的盒模型包括ie盒子模型和标准的w3c盒子模型<br>标准盒子模型：<br>只有content<br>ie盒子模型:<br>包含了content padding 和 border</p><h3 id="画一条0-5px的线"><a href="#画一条0-5px的线" class="headerlink" title="画一条0.5px的线"></a>画一条0.5px的线</h3><ol><li>采用<code>meta viewport</code>的方法</li><li>采用<code>border-image</code>的方式</li><li>采用<code>transform:scale()</code></li></ol><h3 id="link标签和import标签的区别"><a href="#link标签和import标签的区别" class="headerlink" title="link标签和import标签的区别"></a>link标签和import标签的区别</h3><p><code>link</code>属于html标签 而<code>@import</code>是css提供的<br>页面被加载的时候，<code>link</code>会同时被加载，而<code>@import</code>引用的css会等页面加载结束后加载<br><code>link</code>是html标签，因此没有兼容性的问题，而<code>@import</code>只有ie5以上才能识别<br>link方式的权重高于import方式</p><h3 id="transition和animation的区别"><a href="#transition和animation的区别" class="headerlink" title="transition和animation的区别"></a>transition和animation的区别</h3><p><code>animation</code>和<code>transition</code>大部分属性都是相同的，它们都是随着事件改变元素的属性值，主要区别是<code>transition</code>需要触发一个事件才能改变属性，而<code>animation</code>不需要触发事件<br><code>transition</code>为2帧 从<code>from...to...</code> 而<code>animation</code>是一帧一帧的</p><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>弹性布局<br><code>flex-direction</code>主轴方向<br><code>flex-wrap</code>换行原则<br><code>flex-flow</code><br><code>justify-content</code>水平主轴对齐方式<br><code>align-items</code>垂直对齐方式<br>属性<br><code>order</code>：定义项目的排列顺序 越小越前 默认0<br><code>flex-grow</code>定义项目的放大比例 即使存在空间也不会放大<br><code>flex-shrink</code>定义了项目的缩小比例，当空间不足的情况下会等比例缩小，如果为0则不缩小<br><code>flex-basis</code> 定义了在分配多余的空间，项目占据的空间<br><code>flex</code>前三者的简称 默认值为<code>0 1 auto</code><br><code>align-self</code>允许单个项目与其他项目不一样的对齐方式 可以覆盖<code>align-items</code>默认属性为auto 表示继承父元素的<code>align-items</code><br>圣杯布局</p><h3 id="BFC块级格式化上下文"><a href="#BFC块级格式化上下文" class="headerlink" title="BFC块级格式化上下文"></a>BFC块级格式化上下文</h3><p>用于清除浮动防止margin重叠等</p><h1 id="JS篇章"><a href="#JS篇章" class="headerlink" title="JS篇章"></a>JS篇章</h1><h2 id="类型及检测方式及栈和堆"><a href="#类型及检测方式及栈和堆" class="headerlink" title="类型及检测方式及栈和堆"></a>类型及检测方式及栈和堆</h2><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">类型</button></li><li class="tab"><button type="button" data-href="#test-2">栈和堆</button></li><li class="tab"><button type="button" data-href="#test-3">检测方式</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>首先js的类型有基本数据类型和引用类型<br>前者有七种 后者是一种<br>根据以前的USONB理论 大致是<br><code>Undefined</code>,<code>String</code>,<code>Symbol</code>,<code>Object</code>,<code>Null</code>,<code>Number</code>,<code>BigInt</code>,<code>Boolean</code></p><ul><li>基本数据类型的作用？<br>基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</li><li><code>object</code>为什么是引用类型？<br>而引用类型 在创建对象的时候会在堆内存中开辟一个空间 用来存放对象的属性 在为对象添加属性的时候，是将属性放在堆内存中开辟的空间里。<br>在栈内存中保存显示 对象名+一个地址 类似于指针 执行堆内存中对象开辟的空间<br>引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念；占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。<br>引申出栈和堆的概念！</li><li><code>BigInt</code>?</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>在js的执行过程中，主要有三种类型的内存空间，一是代码空间，二是栈空间，三是堆空间。代码空间顾名思义就是存储代码用的，栈空间是用来保存变量和变量值的，堆空间是保存地址的。<br>对于栈空间来说，原始类型存储的是变量的值，而引用类型存储的是在堆空间中的地址，所以当js需要访问数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手程序</p><ul><li>闭包是怎么存储<br>js引擎对于闭包的处理，是当遇到一个闭包的时候，在堆空间中创建一个<code>closure(fn)</code>对象，用来保存闭包中的变量，所以闭包中的变量是存储在堆空间中的。这就是为什么闭包可以常驻在内存的原因。</li><li>js为什么需要栈和堆<br>首先知道栈是让变量循环利用，通常也是设置一些小数据来放入栈中，而我们知道引用类型数据obj一般占用的空间都比较大。所以js引擎需要栈和堆来维持内存的平衡。</li><li>题目1<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lee&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(a.name);  <span class="comment">//第一个console</span></span><br><span class="line">b.name = <span class="string">&#x27;son&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.name);  <span class="comment">//第二个console</span></span><br><span class="line"><span class="built_in">console</span>.log(b.name);  <span class="comment">//第三个console</span></span><br></pre></td></tr></table></figure>第一个是lee显而易见，第二个console是son 第三个也是。这是因为a是对象 是引用类型 在赋值给b的时候 实际上是给了a在堆中的地址 所以b访问的是堆空间中a的变量 那么修改了b 自然a也会发生变动，这里就引出了堆空间共享的概念</li><li>题目2<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Julia&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o.age = <span class="number">24</span>;</span><br><span class="line">  o = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Kath&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = change(a);     <span class="comment">// 注意这里没有new，后面new相关会有专门文章讲解</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age);    <span class="comment">// 第一个console</span></span><br><span class="line"><span class="built_in">console</span>.log(a.age);    <span class="comment">// 第二个console</span></span><br></pre></td></tr></table></figure>第一个输出30 第二个输出24<br>原因是function里面传入的是a在堆中的地址，那么自然a的age就会变成24 但是到了return这一步 它会把传入的内存地址修改 导致o变成另外一个内存地址 将o的数据存放在该内存中， 所以b就是kath和30</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><p>数据类型检测有很多种，常用的是<code>typeof instanceof constructor Object.prototype.toString.call([])</code></p><ol><li><code>typeof</code>方法是基于计算机底层的数据类型的二进制进行判断。 用于判断除了<code>array null</code>之外的类型,即可以判断除了<code>null</code>之外的基础数据类型和除了<code>array</code>之外的应用数据类型<br>下面看一下它对于所有类型的处理 注意它可以处理function<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object     []数组的数据类型在 typeof 中被解释为 object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object     null 的数据类型被 typeof 解释为 object</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>为什么null会被<code>typeof</code>识别成<code>object</code>？<br>这个是一个历史遗留问题 js底层是二进制存储的 前三位代表的是数据的存储类型 对于object来说则是000 而刚好null也是全0 正好代表object类型的数据格式 所以null才会输出object</li></ul><ol><li><code>instanceof</code><br>由于上面的方法不能精确判断数组和null的原因 所以产生了新的方法<code>instanceof</code><br>康康它对于所有类型的处理<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false  </span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true    </span></span><br><span class="line"><span class="comment">// console.log(undefined instanceof Undefined);</span></span><br><span class="line"><span class="comment">// console.log(null instanceof Null);</span></span><br></pre></td></tr></table></figure>和由此可见 <code>instanceof</code>方法能准确的判断引用数据类型 但是不能判断基础数据类型<br>因为它的原理是和原型链相关的 ,相当于判断是不是这个类的实例，所以对于<code>undefined和null</code>来说，这两者是没有原型的 所以无法判断。<br>引申一下 <code>null</code>是所有原型的终点 <code>undefined</code>是表示没有这个值 缺少这个值 </li><li><code>constructor</code><br>构造器判断方法 注意带括号 否则会报错<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">2</span>).constructor === <span class="built_in">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).constructor === <span class="built_in">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="string">&#x27;str&#x27;</span>).constructor === <span class="built_in">String</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(([]).constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).constructor === <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;).constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>弊端是 如果改变了对象原型，该方法会失效<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">Fn.prototype=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> f=<span class="keyword">new</span> Fn();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===Fn);    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===<span class="built_in">Array</span>); <span class="comment">// true </span></span><br></pre></td></tr></table></figure></li><li><code>Object.prototype.toString.call()</code><br>使用<code>Object</code>上面的<code>toString</code>方法 会返回一个格式为<code>[object Xxx]</code>的字符串，通过call重新调用就可以精确判断对象类型<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString(&#123;&#125;)       <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;)  <span class="comment">// 同上结果，加上call也ok</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>)    <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;1&#x27;</span>)  <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>)  <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)  <span class="comment">// &quot;[object Function]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)   <span class="comment">//&quot;[object Null]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">//&quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/123/g</span>)    <span class="comment">//&quot;[object RegExp]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">//&quot;[object Date]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([])       <span class="comment">//&quot;[object Array]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>)  <span class="comment">//&quot;[object HTMLDocument]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>)   <span class="comment">//&quot;[object Window]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面这段代码可以看出，Object.prototype.toString.call() 可以很好地判断引用类型，甚至可以把 document 和 window 都区分开来。</span></span><br></pre></td></tr></table></figure>由于代码过长 推荐封装一下<code>Object.prototype.toString</code><br>实现一个全局通用的判断方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> type = <span class="keyword">typeof</span> obj;</span><br><span class="line"><span class="comment">//如果是基本类型 直接返回</span></span><br><span class="line"><span class="keyword">if</span>(type!==<span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toStirng.call(obj).replace(<span class="regexp">/^\[object (\S+)\]$/</span>, <span class="string">&#x27;$1&#x27;</span>);  <span class="comment">// 注意正则中间有个空格</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 代码验证，需要注意大小写，哪些是typeof判断，哪些是toString判断？思考下 */</span></span><br><span class="line">getType([])     <span class="comment">// &quot;Array&quot; typeof []是object，因此toString返回</span></span><br><span class="line">getType(<span class="string">&#x27;123&#x27;</span>)  <span class="comment">// &quot;string&quot; typeof 直接返回</span></span><br><span class="line">getType(<span class="built_in">window</span>) <span class="comment">// &quot;Window&quot; toString返回</span></span><br><span class="line">getType(<span class="literal">null</span>)   <span class="comment">// &quot;Null&quot;首字母大写，typeof null是object，需toString来判断</span></span><br><span class="line">getType(<span class="literal">undefined</span>)   <span class="comment">// &quot;undefined&quot; typeof 直接返回</span></span><br><span class="line">getType()            <span class="comment">// &quot;undefined&quot; typeof 直接返回</span></span><br><span class="line">getType(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// &quot;function&quot; typeof能判断，因此首字母小写</span></span><br><span class="line">getType(<span class="regexp">/123/g</span>)      <span class="comment">//&quot;RegExp&quot; toString返回</span></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220316104931.png" alt=""></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">防抖</button></li><li class="tab"><button type="button" data-href="#test-2">节流</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>防抖主要是为了不让事件同一时间内触发多次导致请求多次的问题<br>防抖有两种情况<br>第一种是只触发第一次<br>第二种是只触发最后一次<br>防抖的主要写法如下: 但会产生一个问题 就是一开始必须等待才能进行<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>点我发送请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">    <span class="comment">// const msg = document.getElementById(&#x27;msg&#x27;);</span></span></span><br><span class="line"><span class="javascript">    btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, debounce(submit), <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">submit</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> t = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (t) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">clearTimeout</span>(t);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            t = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="number">1000</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ol><li>用<code>debounce</code>传入参数 并且注意最后返回的是一个函数</li><li>设置t来决定定时器的销毁和开启</li><li>定时器用箭头函数 让<code>this</code>指向<code>window</code></li><li>apply将<code>this</code>和<code>arguments</code>传给<code>submit</code></li></ol><p>解决上面问题的做法如下<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>点我发送请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">    <span class="comment">// const msg = document.getElementById(&#x27;msg&#x27;);</span></span></span><br><span class="line"><span class="javascript">    btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, debounce(submit, <span class="number">2000</span>), <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">submit</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, timer</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> t = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> firstclick = !t;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (firstclick) &#123;</span></span><br><span class="line"><span class="javascript">                fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            t = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                t = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, timer);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><br>原理是判断是否为第一次执行 如果是的话直接请求 然后让定时器将t经过一定时间还原，这样下一次就又是第一次 否则的话 因为t还没还原 所以不会输出；</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>节流是指函数在一定时间间隔内只能执行一次，从而减少一段时间内的触发频率<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>点我发送请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">    <span class="comment">// const msg = document.getElementById(&#x27;msg&#x27;);</span></span></span><br><span class="line"><span class="javascript">    btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, throttle(submit, <span class="number">2000</span>), <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">submit</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e, <span class="built_in">this</span>);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> begin = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> cur = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (cur - begin &gt;= delay) &#123;</span></span><br><span class="line"><span class="javascript">                fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">                begin = cur;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ol><li>用<code>throttle</code>传入参数 并且注意最后返回的是一个函数</li><li>用<code>begin</code>定义一开始的时间，用<code>cur</code>定义当前时间 </li><li>最后<code>begin</code>要变成<code>cur</code></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="手写深浅拷贝"><a href="#手写深浅拷贝" class="headerlink" title="手写深浅拷贝"></a>手写深浅拷贝</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">浅拷贝</button></li><li class="tab"><button type="button" data-href="#test-2">深拷贝</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>浅拷贝顾名思义就是直接拷贝对象上面的内容 但是如果新的对象的属性发生了改变，原先对象上面的属性也会随之改变<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldObj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;jotaro&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="attr">color</span>:[<span class="string">&#x27;orange&#x27;</span>,<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>],</span><br><span class="line">    <span class="attr">friend</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;jostar&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newObj = oldObj;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;oldObj&#x27;</span>,oldObj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;newObj&#x27;</span>,newObj);</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>深拷贝的话，新的对象发生改变不会影响旧的对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldObj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;jotaro&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="attr">color</span>:[<span class="string">&#x27;orange&#x27;</span>,<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>],</span><br><span class="line">    <span class="attr">friend</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;jostar&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 深拷贝的话 在复制对象属性的基础上 不能对原先对象的属性进行改变</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果传进来的参数不是对象 或者是 空 直接返回原先参数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>||obj===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义一个result 用于复制参数</span></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="comment">// 那么只剩数组和对象两种可能 继续判断 并改变result的类型</span></span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        result = [];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 之后就是把obj里面的key拿出来放到result里面 这样就完成了初步的深拷贝</span></span><br><span class="line">    <span class="comment">// for(let key in obj)&#123;</span></span><br><span class="line">    <span class="comment">//     result[key] = obj[key];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 会发现有一点缺陷就是 如果对象里面包含了对象 那么最后做出的修改 还是浅拷贝类型的修改</span></span><br><span class="line">    <span class="comment">// 解决方法是 递归obj[key] 让他继续判断再传递</span></span><br><span class="line">    <span class="comment">// 还有一个可以优化的地方 就是对象原型上面的属性不应该去拷贝 所以使用到一个方法</span></span><br><span class="line">    <span class="comment">// 只会拷贝对象自身的属性</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">            result[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj = deepClone(oldObj);</span><br><span class="line">newObj.age = <span class="number">99</span>;</span><br><span class="line">newObj.color[<span class="number">0</span>] = <span class="string">&#x27;yellow&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;oldObj&#x27;</span>,oldObj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;newObj&#x27;</span>,newObj);</span><br></pre></td></tr></table></figure><br>分几步走</p><ol><li>判断obj不为对象 和 为空的情况 直接返回obj</li><li>定义一个result用来放结果 再根据传进来的obj 判断它是否为对象或者数组 相应的改变result的类型</li><li>for循环将obj的key传给result的key 注意要用递归的形式</li><li>优化 只拷贝对象的属性 不拷贝对象原型的属性 </li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">经典案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>需求 已知数组<code>arr[1,2,[3,[4,[5,6]]]]</code> 将其扁平化处理成<code>[1,2,3,4,5,6]</code><br>方法一 flat函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>]]]];</span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="literal">Infinity</span>));</span><br></pre></td></tr></table></figure><br>方法2 reduce加递归<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatfn</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">res,item</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// return res.concat((item instanceof Array)?flatfn(item):item)</span></span><br><span class="line">        <span class="comment">// 也可以写成</span></span><br><span class="line">        <span class="keyword">return</span> res.concat(<span class="built_in">Array</span>.isArray(item)?flatfn(item):item);</span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatfn(arr))</span><br></pre></td></tr></table></figure><br>方法3 数组转字符串<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatfn</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">&#x27;,&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>).map(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parseInt</span>(item);</span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatfn(arr))</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="单例模式-设计模式"><a href="#单例模式-设计模式" class="headerlink" title="单例模式(设计模式)"></a>单例模式(设计模式)</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>单例模式算是编程思想中的一种设计模式，简单来讲就是一个类只能有一个实例对象，这个实例对象最终也只会被新建一次，并且要提供一个能访问到这个实例的入口</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>假设有个person类 里面构造器传入的是姓名 设计单例模式 让两个人的名字都用的同一个<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;zzz&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;yyy&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1===p2);</span><br><span class="line">返回<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Person.getInstance = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.instance) <span class="keyword">return</span> <span class="built_in">this</span>.instance;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.instance = <span class="keyword">new</span> Person(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = Person.getInstance(<span class="string">&#x27;zzz&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = Person.getInstance(<span class="string">&#x27;yyy&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1===p2);</span><br><span class="line">返回<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>提高版本 假设有个女朋友类 里面传入的是姓名和年龄 设计单例模式 让女朋友类变成单例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> danli = <span class="function"><span class="keyword">function</span>(<span class="params">customClass</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance)<span class="keyword">return</span> instance;</span><br><span class="line">            <span class="keyword">return</span> instance = <span class="keyword">new</span> customClass(...arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let g1 = new GF(&#x27;2b&#x27;,20);</span></span><br><span class="line"><span class="comment">// let g2 = new GF(&#x27;3b&#x27;,18);</span></span><br><span class="line"><span class="comment">// console.log(g1===g2)</span></span><br><span class="line"><span class="comment">// 返回false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> DanliGF = danli(GF);</span><br><span class="line"><span class="keyword">let</span> g1 = <span class="keyword">new</span> DanliGF(<span class="string">&#x27;2b&#x27;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">let</span> g2 = <span class="keyword">new</span> DanliGF(<span class="string">&#x27;3b&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g1===g2)</span><br><span class="line"><span class="comment">// 返回ture</span></span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><div class="note primary flat"><p><a href="https://zlinni.github.io/posts/1bdac88a9cd9/">数组去重的八种方法</a></p></div><h1 id="手写promise-all和promise-race"><a href="#手写promise-all和promise-race" class="headerlink" title="手写promise.all和promise.race"></a>手写promise.all和promise.race</h1><h1 id="模拟实现new"><a href="#模拟实现new" class="headerlink" title="模拟实现new"></a>模拟实现new</h1><h1 id="实现call-apply-bind"><a href="#实现call-apply-bind" class="headerlink" title="实现call/apply/bind"></a>实现call/apply/bind</h1><h1 id="模拟Object-create-的实现"><a href="#模拟Object-create-的实现" class="headerlink" title="模拟Object.create()的实现"></a>模拟Object.create()的实现</h1><h1 id="千分位分隔符"><a href="#千分位分隔符" class="headerlink" title="千分位分隔符"></a>千分位分隔符</h1><h1 id="实现三角形"><a href="#实现三角形" class="headerlink" title="实现三角形"></a>实现三角形</h1><h1 id="实现三栏布局-双栏布局"><a href="#实现三栏布局-双栏布局" class="headerlink" title="实现三栏布局/双栏布局"></a>实现三栏布局/双栏布局</h1><h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><h2 id="判断一个数组是否是数组"><a href="#判断一个数组是否是数组" class="headerlink" title="判断一个数组是否是数组"></a>判断一个数组是否是数组</h2><p>关键：结合<code>Object.prototype.toString.call(arr)</code>判断。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judgeArr</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> arr === <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arr) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><p>每次比较相邻的数 如果后一个比前一个小 换位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j+<span class="number">1</span>]&lt;arr[j])&#123;</span><br><span class="line"><span class="keyword">var</span> temp;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort(arr));</span><br></pre></td></tr></table></figure></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>思路 二分数组 找个基准点 遍历数组小于基准点在左反之在又 之后继续递归左数组和右数组最后concat起来<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cIndex = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> c = arr.splice(cIndex,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> l = [];</span><br><span class="line">    <span class="keyword">var</span> r = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span> ;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;c)&#123;</span><br><span class="line">            l.push(arr[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(l).concat(c,quickSort(r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(quickSort(arr));</span><br></pre></td></tr></table></figure></p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>先序遍历 根左右<br>中序遍历 左根右<br>后序遍历 左右根<br>关键：了解递归边界<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> root = &#123;</span><br><span class="line">        <span class="attr">val</span>:<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">        <span class="attr">left</span>:&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">            <span class="attr">left</span>:&#123;</span><br><span class="line">                <span class="attr">val</span>:<span class="string">&#x27;d&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">right</span>:&#123;</span><br><span class="line">                <span class="attr">val</span>:<span class="string">&#x27;e&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">right</span>:&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">            <span class="attr">left</span>:&#123;</span><br><span class="line">                <span class="attr">val</span>:<span class="string">&#x27;f&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">right</span>:&#123;</span><br><span class="line">                <span class="attr">val</span>:<span class="string">&#x27;g&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="comment">// function preorder(root)&#123;</span></span><br><span class="line"><span class="comment">//     if(!root)&#123;</span></span><br><span class="line"><span class="comment">//         return;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;当前遍历的节点值是&#x27;,root.val);</span></span><br><span class="line"><span class="comment">//     preorder(root.left);</span></span><br><span class="line"><span class="comment">//     preorder(root.right);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="comment">// function inorder(root)&#123;</span></span><br><span class="line"><span class="comment">//     if(!root)&#123;</span></span><br><span class="line"><span class="comment">//         return;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     inorder(root.left);</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;当前遍历的节点值是&#x27;,root.val);</span></span><br><span class="line"><span class="comment">//     inorder(root.right);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// inorder(root);</span></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postorder</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(root.left);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;当前遍历的节点值是&#x27;</span>,root.val);</span><br><span class="line">    postorder(root.right);</span><br><span class="line">&#125;</span><br><span class="line">postorder(root);</span><br></pre></td></tr></table></figure></p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>下列代码会执行几次？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverse</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++) &#123; <span class="comment">//1,n+1,n</span></span><br><span class="line">        <span class="built_in">console</span>.log(arr[i]) <span class="comment">//n</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>T(n) = 1 + n +1 +(n+1) +n = 3n+3</code>次<br>规则：如果n是常数 无脑化为1 如果n不是常熟 取最高项的值且常数项化为1<br>所以时间复杂度 <code>O(n) = n</code><br>注意 判断语句比递增语句执行多一次 因为要多判断最后一次。<br>下面代码会执行多少次？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverse</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> outLen = arr.length <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;outLen;i++) &#123; <span class="comment">//1,n+1,n</span></span><br><span class="line">        <span class="keyword">var</span> inLen = arr[i].length <span class="comment">//n </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;inLen;j++) &#123; <span class="comment">//由上知循环n 所以这部分总的是n，即n,n(n+1),n²</span></span><br><span class="line">            <span class="built_in">console</span>.log(arr[i][j]) <span class="comment">//n²</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>T(n) = 1 + n +1 +(n+1) +n + n(3n+2) = 3n²+5n+3</code><br><code>O(n) = n²</code><br>所以综上得知只要计算最高项的就可以<br>再看<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length  <span class="comment">//不看</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;len;i=i*<span class="number">2</span>) &#123; <span class="comment">//看i*2 已知i++是i一直加 所以是n次 而这里相当于2的n次 而跳出循环的条件是i&gt;=len 所以这里不妨设2的x次&gt;=n来计算 得log2(n) = x 去掉常数项 则On为log(n)</span></span><br><span class="line">        <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>看代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverse</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>里面有三个变量<code>arr len i</code><br>而这三个变量在执行的时候是恒定的并没有开辟新的空间 都是时间上的开销 所以是空间复杂度是<code>O(1)</code><br>看代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        arr[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而在这个代码中 数组的大小不是恒定的 是随n变化的 所以它的空间复杂度是<code>O(n)</code></p><h1 id="http1-2"><a href="#http1-2" class="headerlink" title="http1 2"></a>http1 2</h1><h2 id="http的请求头"><a href="#http的请求头" class="headerlink" title="http的请求头"></a>http的请求头</h2><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><p>get post put head delete options trace connect<br>put 指定了在服务器上面的位置<br>head只请求页面首部<br>delete删除某个资源</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
