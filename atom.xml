<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鱼与前端🐟</title>
  
  <subtitle>摸鱼和工作不可得兼~</subtitle>
  <link href="https://zlinni.github.io/atom.xml" rel="self"/>
  
  <link href="https://zlinni.github.io/"/>
  <updated>2022-04-30T14:53:00.728Z</updated>
  <id>https://zlinni.github.io/</id>
  
  <author>
    <name>Zlinni</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从0到1TypeScript</title>
    <link href="https://zlinni.github.io/posts/2090815300/"/>
    <id>https://zlinni.github.io/posts/2090815300/</id>
    <published>2022-04-26T14:23:37.000Z</published>
    <updated>2022-04-30T14:53:00.728Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>TS入门教程，从0到1</p></div><h1 id="TS介绍"><a href="#TS介绍" class="headerlink" title="TS介绍"></a>TS介绍</h1><h2 id="TS是什么？"><a href="#TS是什么？" class="headerlink" title="TS是什么？"></a>TS是什么？</h2><p>ts是js的超集，超集指的是他包含了es前面所有版本的内容并有自己的拓展。</p><h2 id="TS做到了什么？"><a href="#TS做到了什么？" class="headerlink" title="TS做到了什么？"></a>TS做到了什么？</h2><p>首先js是弱类型，很多错误在运行的时候才能发现。<br>ts使用了他的静态类型检测机制（后面提及）帮助我们提早发现错误。</p><h2 id="TS特点"><a href="#TS特点" class="headerlink" title="TS特点"></a>TS特点</h2><ol><li>支持最新的js特性（超集）</li><li>静态代码检查（解决弱类型）</li><li>有其他后端语言的特性（枚举，泛型，类型转化，命名空间，声明文件…)</li></ol><h1 id="静态类型检测"><a href="#静态类型检测" class="headerlink" title="静态类型检测"></a>静态类型检测</h1><p>为什么会产生这个问题？<br>js在运行代码的时候，需要我们人为的知道代码的返回值是什么，才能做出响应的操作（执行函数才能知道）。不能在我们书写的过程就立刻给出编译错误的反馈。</p><p>ts就能在（编译之前）告诉我们</p><h2 id="非异常故障"><a href="#非异常故障" class="headerlink" title="非异常故障"></a>非异常故障</h2><p>ts不仅能告诉我们哪些函数的值错误，还能识别类似于错别字，未调用函数和基本逻辑错误<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;ber&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">user.location</span><br></pre></td></tr></table></figure><br>上面这段代码在js中返回<code>undefined</code>,而在ts中提前告诉你这个变量没有定义不能使用</p><p>错别字：告诉你对象上面某个方法拼写错误等</p><p>未调用函数：函数没有加括号就使用，会提示未调用错误</p><p>逻辑错误：比如只有两种条件的情况下，if一个条件又elseif另外一个条件，就会报错</p><h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><h2 id="安装ts"><a href="#安装ts" class="headerlink" title="安装ts"></a>安装ts</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g typescript</span><br></pre></td></tr></table></figure><h2 id="安装ts-node"><a href="#安装ts-node" class="headerlink" title="安装ts-node"></a>安装ts-node</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g ts-node</span><br></pre></td></tr></table></figure><h2 id="创建一个tsconfig-json"><a href="#创建一个tsconfig-json" class="headerlink" title="创建一个tsconfig.json"></a>创建一个<code>tsconfig.json</code></h2><p>解决变量名or函数名相同报错的问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure></p><h2 id="官方playground"><a href="#官方playground" class="headerlink" title="官方playground"></a>官方playground</h2><p>官方提供的ts在线编译云环境—<a href="">playground</a></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>在对应的目录终端运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure></p><p>得到对应的js文件,执行node命令就可以执行js代码</p><h2 id="ts和js的冲突"><a href="#ts和js的冲突" class="headerlink" title="ts和js的冲突"></a>ts和js的冲突</h2><div class="note primary flat"><p>当我们将ts代码修改为一个函数并调用的时候，再次编译运行js文件，会产生冲突</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220430175814.png" alt=""></p><p>原因：函数名or变量名相同，重复定义</p><p>解决方法：</p><ol><li><code>tsc --init</code>生成配置文件</li><li>注释掉<code>&quot;strict&quot;: true,  o9</code></li></ol><h2 id="自动编译"><a href="#自动编译" class="headerlink" title="自动编译"></a>自动编译</h2><p><code>tsc --watch</code></p><h2 id="发出错误"><a href="#发出错误" class="headerlink" title="发出错误"></a>发出错误</h2><div class="note primary flat"><p>我们在ts里面报了错，但是在编译完之后，还是能运行js文件，如果我们要优化这个过程，结果为：ts编译报错就不生成js文件的话，需要如下：</p></div><p><code>tsc -noEmitOnError hello.ts</code></p><p>or</p><p><code>tsc -noEmitOnError --watch</code></p><h2 id="降级编译"><a href="#降级编译" class="headerlink" title="降级编译"></a>降级编译</h2><p>设置json里面的target为<code>es5</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220430195603.png" alt=""></p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><div class="note primary flat"><p>不同的用户希望在ts里面检查的严格程度是不一样的，配置如下</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220430195741.png" alt=""></p><p><code>strict</code>是包含了下面两个类型的模式</p><p><code>noImplicitAny</code>是指不可以忽略any，也就是要定义类型</p><p><code>strictNullChecks</code>意思是<code>null undefined</code>只能赋值给对应的类型</p><h1 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h1><h2 id="显式类型"><a href="#显式类型" class="headerlink" title="显式类型"></a>显式类型</h2><p>ts给我们提供了类型定义的注释，比如说<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">conflit</span>(<span class="params">person:<span class="built_in">string</span>,date:<span class="built_in">Date</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello,<span class="subst">$&#123;person&#125;</span>,<span class="subst">$&#123;date&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">conflit(<span class="string">&#x27;jojo&#x27;</span>,<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br></pre></td></tr></table></figure></p><p>但是在编译成js之后就会删去，可以方便程序员查看。</p><p>根据上面显式类型的说法我们知道了ts可以定义很多数据类型，比如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: string = <span class="string">&quot;jimmy&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> num: number = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">let</span> bool: boolean = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> obj: object = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> big: bigint = <span class="number">100n</span>;</span><br><span class="line"><span class="keyword">let</span> sym: symbol = <span class="built_in">Symbol</span>(<span class="string">&quot;me&quot;</span>); </span><br></pre></td></tr></table></figure></p><h2 id="几个需要留意的数据"><a href="#几个需要留意的数据" class="headerlink" title="几个需要留意的数据"></a>几个需要留意的数据</h2><div class="note primary flat"><p>当我们定义好类型的时候，如果给变量赋值别的类型是会报错提示的，但是有两个类型不一样</p></div><h3 id="null-amp-undefined"><a href="#null-amp-undefined" class="headerlink" title="null&amp;undefined"></a><code>null&amp;undefined</code></h3><p><code>null undefined</code>这两个类型可以作为其他所有类型的子类型,也就是可以把它们赋给别的值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// null和undefined赋值给string</span></span><br><span class="line"><span class="keyword">let</span> str:<span class="built_in">string</span> = <span class="string">&quot;666&quot;</span>;</span><br><span class="line">str = <span class="literal">null</span></span><br><span class="line">str= <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined赋值给number</span></span><br><span class="line"><span class="keyword">let</span> num:<span class="built_in">number</span> = <span class="number">666</span>;</span><br><span class="line">num = <span class="literal">null</span></span><br><span class="line">num= <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined赋值给object</span></span><br><span class="line"><span class="keyword">let</span> obj:<span class="built_in">object</span> =&#123;&#125;;</span><br><span class="line">obj = <span class="literal">null</span></span><br><span class="line">obj= <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined赋值给Symbol</span></span><br><span class="line"><span class="keyword">let</span> sym: symbol = <span class="built_in">Symbol</span>(<span class="string">&quot;me&quot;</span>); </span><br><span class="line">sym = <span class="literal">null</span></span><br><span class="line">sym= <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined赋值给boolean</span></span><br><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">isDone = <span class="literal">null</span></span><br><span class="line">isDone= <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined赋值给bigint</span></span><br><span class="line"><span class="keyword">let</span> big: bigint =  <span class="number">100n</span>;</span><br><span class="line">big = <span class="literal">null</span></span><br><span class="line">big= <span class="literal">undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>但如果在<code>tsconfig.json</code>里面指定了<code>&quot;strictNullChecks&quot;:true</code>那么它们只能被赋值给自己的类型或者void</p></div><h3 id="number-amp-bigint"><a href="#number-amp-bigint" class="headerlink" title="number&amp;bigint"></a><code>number&amp;bigint</code></h3><div class="note primary flat"><p>这两个值互不兼容，也就是说不能相互赋值，会报错</p></div><h2 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><div class="note primary flat"><p>对数组的定义有两种方式</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arr:type[]</span></span><br><span class="line"><span class="keyword">let</span> arr:<span class="built_in">string</span>[] = [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>];</span><br><span class="line"><span class="comment">//arr:Array&lt;type&gt;</span></span><br><span class="line"><span class="keyword">let</span> arr2:<span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>]</span><br></pre></td></tr></table></figure><p>定义联合类型数组<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arr:(type1|type2)[]</span></span><br><span class="line"><span class="keyword">let</span> arr3:(<span class="built_in">number</span> | <span class="built_in">string</span>)[];</span><br><span class="line">arr3 = [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;sdcas&quot;</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br></pre></td></tr></table></figure></p><p>定义对象类型数组<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Arrobj &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr4:Arrobj[] = [&#123;<span class="attr">name</span>:<span class="string">&#x27;jojo&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;]</span><br></pre></td></tr></table></figure></p><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>定义成any类型的时候表示你不希望某个特定值导致类型错误的产生。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>具名函数<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>,y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="note primary flat"><p>这个是告诉我们函数的返回值也可以指定类型，但一般不需要，因为ts会给我们自动判断返回值的类型</p></div><p>匿名函数：会自动根据上下文判断读取的数据类型是什么。</p><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用接口定义函数类型"><a href="#用接口定义函数类型" class="headerlink" title="用接口定义函数类型"></a>用接口定义函数类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc&#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用函数表达式接口定义函数类型的数据的时候，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数，参数类型，返回值类型不变。</p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>使用<code>变量名?: type</code>的形式<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">number</span>,y?: <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y)&#123;</span><br><span class="line">      <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myFun(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(myFun(<span class="number">33</span>))</span><br></pre></td></tr></table></figure></p><div class="note warning flat"><p>注意可选参数后面不能再跟必需参数</p></div><h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><p>在type后面加<code>= 默认值</code><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span> = <span class="number">22</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myFun(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(myFun(<span class="number">33</span>))</span><br></pre></td></tr></table></figure></p><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>注意需要用any来指定rest<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;, ...items: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">        arr.push(item);</span><br><span class="line">    &#125;)    </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(myFun(arr,<span class="number">3</span>,<span class="number">4</span>,<span class="number">543414</span>,<span class="number">123</span>))</span><br></pre></td></tr></table></figure></p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>js是动态语言，会根据不同的参数返回不同类型的调用结果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line">add(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>); <span class="comment">//&quot;12&quot;</span></span><br></pre></td></tr></table></figure></p><p>but如果开启了noImplicitAny的话，ts不能用上述代码，因为需要指定类型，所以就诞生了联合类型帮助我们根据不同的情况返回不同的结果</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Combination = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: Combination, y: Combination</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> y === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.toString() + y.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myFun(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(myFun(<span class="number">1</span>,<span class="string">&quot;3&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但其实到这一步，看似没有问题了，实际上新的问题又产生了<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Combination = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: Combination, y: Combination</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> y === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.toString() + y.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = myFun(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line">result.split(<span class="string">&quot; &quot;</span>);<span class="comment">//报错</span></span><br></pre></td></tr></table></figure></p><p>查看提示可以知道number类型上面没有方法split，为什么是number类型呢？因为我们这个参数虽然定义了组合类型，但是我们的ts并不知道返回值是什么类型，所以产生了函数重载</p><div class="note primary flat"><p>函数重载就是使用相同函数名称和不同参数类型或不同参数个数创建方法的一种能力</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Combination = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">number</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: Combination, y: Combination</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> y === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.toString() + y.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = myFun(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="keyword">const</span> res = result.split(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure><p>上述实现了函数的重载</p><h1 id="配置输出"><a href="#配置输出" class="headerlink" title="配置输出"></a>配置输出</h1><p>在Emit下面找到<code>&quot;outDir&quot;: &quot;./dist&quot;,</code>并配置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端登陆指南</title>
    <link href="https://zlinni.github.io/posts/3355969119/"/>
    <id>https://zlinni.github.io/posts/3355969119/</id>
    <published>2022-04-24T02:15:14.000Z</published>
    <updated>2022-04-25T02:41:30.129Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>前端登陆的四种方式介绍以及应用</p></div><p>关键词：Cookie/Session、Token、SSO单点登录、OAuth第三方登陆<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220424211445.png" alt=""></p><h1 id="验证登陆"><a href="#验证登陆" class="headerlink" title="验证登陆"></a>验证登陆</h1><ul><li>Cookie/Session</li><li>Token </li><li>SSO 单点登陆</li><li>OAuth第三方登陆</li></ul><h1 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie session"></a>cookie session</h1><p>登陆流程：首次登陆<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414092439.png" alt=""></p><ol><li>用户访问<code>a.com/pageA</code>并输入密码登陆</li><li>服务器验证密码无误后，会创建Session ID并将其保存起来</li><li>服务端响应这个请求，并通过Set-Cookie将Session ID写入Cookie中</li></ol><p>再次登陆：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414092643.png" alt=""></p><ol><li>用户访问<code>a.com/pageB</code>自动带上第一次登陆写入的Cookie</li><li>服务端对比Cookie中的SessionID和保存在服务端的SessionID是否一致</li><li>一致则成功</li></ol><h2 id="cookie-session存在的问题"><a href="#cookie-session存在的问题" class="headerlink" title="cookie session存在的问题"></a>cookie session存在的问题</h2><ul><li>服务器需要对接大量的客户端，导致服务器压力大。</li><li>如果服务器是一个集群，为了同步登陆态，就需要将SessionID同步到每一台机器上，无形中增加了服务器的维护成本。</li><li>由于SessionID存放在Cookie中所以无法避免CSRF攻击</li></ul><h1 id="token登陆"><a href="#token登陆" class="headerlink" title="token登陆"></a>token登陆</h1><p>为了解决cookie+session暴露出来的问题，我们可以使用token的登陆方式<br><div class="note primary flat"><p>token是服务端生成的一串字符串，以作为客户端请求的一个令牌。当第一次登陆完成后，服务器会生成一个token并返回给客户端，客户端后续访问只要带上这个token就可以完成身份验证。</p></div></p><h2 id="token机制实现流程"><a href="#token机制实现流程" class="headerlink" title="token机制实现流程"></a>token机制实现流程</h2><p>首次登陆：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414102745.png" alt=""></p><ol><li>用户输入账号密码，并点击登录。</li><li>服务器端验证账号密码无误，创建 Token。</li><li>服务器端将 Token 返回给客户端，由客户端自由保存。</li></ol><p>后续页面访问时：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414102830.png" alt=""></p><ol><li>用户访问 a.com/pageB 时，带上第一次登录时获取的 Token。</li><li>服务器端验证 Token ，有效则身份验证成功。</li></ol><h2 id="Token-机制的特点"><a href="#Token-机制的特点" class="headerlink" title="Token 机制的特点"></a>Token 机制的特点</h2><p>根据上面的案例，我们可以分析出Token的优缺点：</p><ul><li>服务器端不需要存放token，所以不会对服务器造成压力，即使服务器集群，也不需要增加维护成本。</li><li>Token可以存放在前端的任何地方，可以不用保存在Cookie中，提升了页面的安全性。</li><li>Token下发之后，只要在生效时间内，就一直有效，如果服务器想收回此token的权限，并不容易。</li></ul><h2 id="Token的生成方式"><a href="#Token的生成方式" class="headerlink" title="Token的生成方式"></a>Token的生成方式</h2><p>最常见的Token生成方式是使用JWT，他是一种简洁的，自包含的方法用于通信双方之间以JSON对象的形式安全的传递信息。</p><p>上文中我们说到，使用Token后，服务器端并不会存储Token，那怎么判断客户端的token是否合法有效？</p><p>答案其实就在Token字符串中，其实Token并不是一串杂乱无章的字符串，而是通过多种算法拼接组合而成的字符串。如下：</p><p>JWT算法主要分成了三个部分 </p><ul><li>header 头信息</li><li>payload 消息体</li><li>signature 签名</li></ul><p>header部分指定了JWT使用的签名算法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header = <span class="string">&#x27;&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;&#x27;</span>   <span class="comment">// `HS256` 表示使用了 HMAC-SHA256 来生成签名。</span></span><br></pre></td></tr></table></figure></p><p>payload部分指明了JWT的使用意图<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;&#123;&quot;loggedInAs&quot;:&quot;admin&quot;,&quot;iat&quot;:1422779638&#125;&#x27;</span>     <span class="comment">//iat 表示令牌生成的时间</span></span><br></pre></td></tr></table></figure></p><p>signature部分为JWT的签名 主要为了让JWT不能随意更改，签名的方法分为两个步骤</p><ol><li>输入base64url编码的header部分，base64url编码的payload部分，输出unsignedToken</li><li>输入服务器端私钥，unsignedToken,输出signature签名</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base64Header = encodeBase64(header)</span><br><span class="line"><span class="keyword">const</span> base64Payload = encodeBase64(payload)</span><br><span class="line"><span class="keyword">const</span> unsignedToken = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;服务器私钥&#x27;</span></span><br><span class="line"></span><br><span class="line">signature = HMAC(key, unsignedToken)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后Token计算如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base64Header = encodeBase64(header)</span><br><span class="line"><span class="keyword">const</span> base64Payload = encodeBase64(payload)</span><br><span class="line"><span class="keyword">const</span> base64Signature = encodeBase64(signature)</span><br><span class="line"></span><br><span class="line">token = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>.<span class="subst">$&#123;base64Signature&#125;</span>`</span></span><br></pre></td></tr></table></figure></p><p>服务器在判断token的时候<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [base64Header, base64Payload, base64Signature] = token.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> signature1 = decodeBase64(base64Signature)</span><br><span class="line"><span class="keyword">const</span> unsignedToken = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> signature2 = HMAC(<span class="string">&#x27;服务器私钥&#x27;</span>, unsignedToken)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(signature1 === signature2) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;签名验证成功，token 没有被篡改&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> payload =  decodeBase64(base64Payload)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Date</span>() - payload.iat &lt; <span class="string">&#x27;token 有效期&#x27;</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;token 有效&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有了 Token 之后，登录方式已经变得非常高效，接下来我们介绍另外两种登录方式。</p><h1 id="SSO单点登陆"><a href="#SSO单点登陆" class="headerlink" title="SSO单点登陆"></a>SSO单点登陆</h1><div class="note primary flat"><p>单点登陆指的是在公司内部搭建一个公共的认证中心，公司下的所有产品的登陆都可以在认证中心中完成，一个产品在认证中心登陆后，再去访问另外一个产品，可以不用再次登陆，即可获取登陆状态。</p></div><h2 id="SSO机制实现流程"><a href="#SSO机制实现流程" class="headerlink" title="SSO机制实现流程"></a>SSO机制实现流程</h2><p>分为同域和不同域。</p><h3 id="同域的单点登陆"><a href="#同域的单点登陆" class="headerlink" title="同域的单点登陆"></a>同域的单点登陆</h3><p>比如现在有一个域名叫<code>zlinni.cn</code>,然后我的其他页面分别为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.zlinni.cn</span><br><span class="line">b.zlinni.cn</span><br><span class="line">c.zlinni.cn</span><br><span class="line">login.zlinni.cn<span class="comment">//sso登陆系统</span></span><br></pre></td></tr></table></figure></p><p>那么此时我们只要满足在login中登陆，然后abc三个都登陆就完成了sso</p><p>实现的方式就是利用了cookie的path和domain，我们设置domain为<code>.zlinni.cn</code>，然后path为<code>/</code>就能实现所有的域名都共享login的cookie，就实现了单点登陆。</p><h3 id="不同域的单点登陆"><a href="#不同域的单点登陆" class="headerlink" title="不同域的单点登陆"></a>不同域的单点登陆</h3><p>用户首次访问需要在认证中心登陆：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220424182851.png" alt=""></p><ol><li>用户先访问<code>a.com</code>下面的pageA页面，然后系统发现它未登陆，给它重定向到sso认证中心</li><li>在sso中注册，提交登陆</li><li>sso验证账号密码有效，重定向到<code>a.com</code>并带上授权码ticket，再将sso的登录态写入cookie</li><li>此时a就拿着ticket去sso中验证是否有效。</li><li>在a的服务器中拿着ticket向sso验证确认真实性</li><li>验证成功后，服务器将写入两个信息到cookie，一个是ticket作为a的登录态，一个是sso的token记录sso的登录态</li></ol><p>抛出疑问：为什么要用ticket？这个问题我们后面再讲</p><p>然后登陆完成访问a下面的其他页面<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220424192857.png" alt=""></p><p>此时我们的cookie中携带了ticket，只要到服务端验证是否在有效的时间内即可。</p><p>访问b页面的时候（这个b页面是认证中心下面的不同产品，如果要做例子的话，可以认为a是新浪微博，b是新浪博客）<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220424193220.png" alt=""><br>此时由于我们的b是不同源的页面，所以cookie中是没有ticket的（！！！！非常重要），但是它重定向到sso中，sso中我们的cookie是存在登录态的，所以此时不需要再注册等操作，验证token之后，直接给b下发ticket即可。b再去验证ticket真实性即可完成登陆。</p><h2 id="为什么需要Ticket"><a href="#为什么需要Ticket" class="headerlink" title="为什么需要Ticket"></a>为什么需要Ticket</h2><p>ticket的存在是为了解决不同域携带的cookie不一样的问题</p><p>以上过程就解释了我们要用ticket的理由，因为a和b不是同源页面所以不会携带同样的ticket，但是sso中拥有登录态token所以我们会下发ticket到b中验证。</p><h2 id="SSO单点登陆退出"><a href="#SSO单点登陆退出" class="headerlink" title="SSO单点登陆退出"></a>SSO单点登陆退出</h2><p>单点登陆使得多个产品共享登录态，但是怎么做到在一个产品中退出登陆，其他的产品也退出呢？</p><p>这里其实要做的事情很简单，比如说退出这个bcom的登陆：</p><ol><li>首先我们要清除掉b中的ticket</li><li>认证中心sso中清除对应的cookie</li><li>sso遍历所有对应cookie下发了ticket的产品并删除。</li></ol><h2 id="总结sso"><a href="#总结sso" class="headerlink" title="总结sso"></a>总结sso</h2><p>sso就是类似于<code>Nginx+ticket+token</code>的组合.其中，我们利用它的重定向规则，可以将token存在sso的cookie中，将ticket返回到具体的页面存在cookie中，然后再认证完成登陆</p><h1 id="OAuth第三方登陆"><a href="#OAuth第三方登陆" class="headerlink" title="OAuth第三方登陆"></a>OAuth第三方登陆</h1><p>由于sso实际上还是比较麻烦的，所以我们可以利用大厂提供的第三方登陆系统实现登陆</p><p>我们不关心这个完成授权的过程，但是要知道用户点击到返回登陆的这个过程发生了什么</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220424204420.png" alt=""></p><ol><li>首先用户在acom点击用户登陆，跳转到OAuth，并带上回调地址acom</li><li>用户二维码验证之后，微信返回临时票据code</li><li>a带着code和自己申请的appid、appsecret，向微信的服务器申请token，验证成功微信下发token</li><li>有了token之后，a就可以向微信服务器获取用户的头像和昵称等信息。并将用户的登录态写入cookie以便下一次登陆。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试指南" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>融会贯通八大排序</title>
    <link href="https://zlinni.github.io/posts/3106196216/"/>
    <id>https://zlinni.github.io/posts/3106196216/</id>
    <published>2022-04-23T06:37:29.000Z</published>
    <updated>2022-04-26T12:20:35.003Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>记录常用排序算法的算法思想和实现，力争基础达标，往后深入的点分开补充~</p></div><p>关键词：常用算法、sort排序、冒泡排序、插入排序、选择排序、快速排序、归并排序、桶排序、希尔排序</p><h1 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h1><p>直接使用api就能进行排序，注意的点是：<br>不传参，默认是unicode排序，所以常用来排序字母<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;asbcascacsac&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> sortArr = arr.sort();</span><br><span class="line"><span class="built_in">console</span>.log(sortArr)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">    &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;b&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;c&#x27;, &#x27;s&#x27;, &#x27;s&#x27;, &#x27;s&#x27;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>传参，默认两个参，名字无所谓，这里举例是a和b，看返回值来决定升序降序<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">116516</span>,<span class="number">1213</span>,<span class="number">123</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr))</span><br><span class="line"><span class="keyword">let</span> upArr = arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);</span><br><span class="line"><span class="keyword">let</span> downArr = arr2.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>b-a);</span><br><span class="line"><span class="built_in">console</span>.log(upArr)</span><br><span class="line"><span class="built_in">console</span>.log(downArr)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">     1,      4,   5,</span></span><br><span class="line"><span class="comment">     8,      8, 123,</span></span><br><span class="line"><span class="comment">  1213, 116516</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  116516, 1213, 123,</span></span><br><span class="line"><span class="comment">       8,    8,   5,</span></span><br><span class="line"><span class="comment">       4,    1</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>思想：从第一个元素开始比较相邻的元素大小，大则交换(升序)<br>时间复杂度：O(n²)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">116516</span>,<span class="number">1213</span>,<span class="number">123</span>]</span><br><span class="line"><span class="keyword">const</span> bubblesort = (<span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;len-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j+<span class="number">1</span>]&lt;arr[j])&#123;</span><br><span class="line">                [arr[j],arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>],arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(bubblesort(arr))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">     1,      4,   5,</span></span><br><span class="line"><span class="comment">     8,      8, 123,</span></span><br><span class="line"><span class="comment">  1213, 116516</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>优化：如果原数组已经是排序数组，就不必再排，用flag<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bubblesort = (<span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)<span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(bubblesort(arr))</span><br></pre></td></tr></table></figure></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>思想：每次都找到最小值放在头部，然后缩小范围继续操作 直到完全有序<br>时间复杂度：O(n²)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectsort = (<span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[minIndex]&gt;arr[j])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minIndex!==i)&#123;</span><br><span class="line">            [arr[minIndex],arr[i]] = [arr[i],arr[minIndex]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(selectsort(arr))</span><br></pre></td></tr></table></figure></p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>原理：当每次排序的时候，如果前面的元素大于当前的元素，那么将前面的元素转换成当前元素，继续比较，最后替换回最开始转换的元素<br>时间复杂度：O(n²)<br>eg<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line">经过第一轮（单个元素可以当成有序的数列所以忽略第一个元素） 从index1开始保存变量，也就是temp3和<span class="number">5</span>对比</span><br><span class="line">如果<span class="number">3</span>&lt;<span class="number">5</span>，<span class="number">5</span>就在前面腾出一个位置给<span class="number">3</span><span class="string">&#x27;5 5 2 4 1&#x27;</span> （arr[j-<span class="number">1</span>]=arr[j]）;</span><br><span class="line">最后还原temp就变成</span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line">第二轮 对比<span class="number">5</span>和<span class="number">2</span> 此时<span class="number">5</span>前面需要腾出一个位置给<span class="number">2</span>(<span class="number">2</span>&lt;<span class="number">5</span>)此时变成<span class="string">&#x27;3 5 5 4 1&#x27;</span> 然后又发现<span class="number">2</span>&lt;<span class="number">3</span>(j--) 则继续腾位置<span class="string">&#x27;3 3 5 4 1&#x27;</span>(使用<span class="keyword">while</span>的原因)最后</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> j=i;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (j&gt;<span class="number">0</span>&amp;&amp;arr[j-<span class="number">1</span>]&gt;temp) &#123;</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];<span class="comment">//arr[1]3-&gt;5</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;<span class="comment">//arr[0]5-&gt;3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>原理：分解每个子问题，整个数组可以对半分割，一直到分割最小的状态，然后开始逐渐合并，从规模1到规模2一直到还原回整个数组。<br>时间复杂度：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>浅谈TCP与UDP</title>
    <link href="https://zlinni.github.io/posts/2458362678/"/>
    <id>https://zlinni.github.io/posts/2458362678/</id>
    <published>2022-04-23T06:24:50.000Z</published>
    <updated>2022-04-25T02:41:30.113Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>web前端常考TCP与UDP的知识解析，力争基础达标，往后深入的点分开补充~</p></div><p>关键词:TCP/UDP、三次握手、四次挥手、流量控制、拥塞控制、TCP粘包<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423142857.png" alt=""></p><h1 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h1><ol><li>tcp是面向链接的 udp是无连接的即发送数据前不需要建立连接</li><li>tcp提供可靠的服务，也就是说通过tcp连接发送的数据，无差错，不丢失，不重复，且按序到达，udp尽最大的努力交付，即不保证可靠交付。并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换</li><li>tcp是面向字节流，udp面向报文，并且网络出现拥塞不会使得发送速率降低（因此会产生丢包，对实时的应用比如ip电话和视频会议等）</li><li>tcp只能是一对一的，udp支持1对1 1对多</li><li>tcp的首部较大为20字节 udp只有8字节</li><li>tcp是面向连接的可靠性传输，udp是不可靠的 </li></ol><h2 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h2><p>UDP：</p><ul><li>直播</li><li>游戏</li></ul><h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><div class="note primary flat"><p>建立连接前，客户端和服务端需要通过握手来确认对方</p></div><ul><li>客户端发送SYN同步序列编号请求，进入SYN_SEND状态，等待确认</li><li>服务端接收并确认SYN包之后发送SYN+ACK包，进入SYN_RECV状态</li><li>客户端接收SYN+ACK包之后，发送ACK包，双方进入ESTABLISHED状态</li></ul><h2 id="为什么采用三次握手？"><a href="#为什么采用三次握手？" class="headerlink" title="为什么采用三次握手？"></a>为什么采用三次握手？</h2><p>举例：已失效的连接请求报文段</p><ul><li>如果客户端发送请求报文但由于网络问题导致报文失效，服务端接收到请求后就会发送确认报文表示同意连接。此时如果是两次握手，那么此时服务端已经建立了新的连接，但由于这个请求是失效的，客户端并没有建立连接，服务端就会浪费很多资源。如果是三次握手，那么此时服务端收不到确认连接的信息，就知道客户端没有建立连接。这就是三次握手的作用。<div class="note primary flat"><p>TCP有六种标识SYN建立连接，ACK确认，PSH传送，FIN结束，RST重置，URG紧急</p></div></li></ul><h2 id="三次握手过程中可以携带数据吗？"><a href="#三次握手过程中可以携带数据吗？" class="headerlink" title="三次握手过程中可以携带数据吗？"></a>三次握手过程中可以携带数据吗？</h2><ul><li>第一次第二次握手不能携带数据，因为第一次握手和第二次握手服务端还没有建立连接，此时发送数据会让服务器受到攻击。</li><li>第三次握手服务器已经处于ESTABLISHED状态，对于客户端来说已经建立了连接，并且也知道服务器的接收发送能力是正常的了，所以能携带数据。</li></ul><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><div class="note primary flat"><p>为了确保数据能完成传输</p></div><ul><li>客户端—FIN—&gt;服务端，FIN——WAIT</li><li>服务端—ACK—&gt;客户端，CLOSE——WAIT</li><li>服务端—ACK，FIN—&gt;客户端，LAST——ACK</li><li>客户端—ACK—&gt;服务端，CLOSED</li></ul><h2 id="为什么连接的时候是三次握手，关闭的时候是四次挥手？"><a href="#为什么连接的时候是三次握手，关闭的时候是四次挥手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候是四次挥手？"></a>为什么连接的时候是三次握手，关闭的时候是四次挥手？</h2><ul><li>服务端接收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。</li><li>但是在关闭连接的时候，当服务端收到FIN报文的时候 ，很可能并不会立刻关闭连接，所以只能先回复一个ACK报文，告诉客户端，你发的FIN报文收到了，只有等服务器所有的报文发送完了才能发送FIN报文，因此不能一起发送，故需要四次挥手。 </li></ul><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><div class="note primary flat"><p>网络拥塞（congestion）是指在分组交换网络中传送分组的数目太多时，由于存储转发节点的资源有限而造成网络传输性能下降的情况。当网络发生拥塞时，一般会出现数据丢失，时延增加，吞吐量下降，严重时甚至会导致“拥塞崩溃”（congestion collapse）。通常情况下，当网络中负载过度增加致使网络性能下降时，就会发生网络拥塞。下图则描述了在有无拥塞控制的干预下，网络吞吐量随输入负载的增加的变化情况。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423112204.png" alt=""><br>通过以上的描述，我们大概可以得到以下信息：</p><ul><li>网络拥塞往往是由于对资源的请求超出了存储转发节点的能力而导致的。</li><li>网络拥塞可能会导致数据丢失，时延增加，吞吐量下降等问题。</li><li>若出现拥塞而不进行控制，有可能会使整个网络情况恶化，甚至网络吞吐降为0。</li><li>网络的拥塞状况与当前网络负载是密切相关的。</li></ul><h2 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h2><ol><li>慢启动</li><li>拥塞避免</li><li>快重传</li><li>快恢复</li></ol><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>如果发送方的数据发送过快，接收者来不及接收，就有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。</p><p>流量控制的根本目的是防止分组丢失，它是构成TCP可靠性的一方面</p><h2 id="实现流量控制"><a href="#实现流量控制" class="headerlink" title="实现流量控制"></a>实现流量控制</h2><p>滑动窗口协议（连续ARQ协议）实现。它保证了分组无差错，有序接收，也实现了流量控制。</p><p>主要的方式是 接收方返回的ack包会包含自己接收窗口的大小，并且利用大小来控制发送方的数据发送</p><h2 id="流量控制引发的死锁？怎么避免死锁发生？-没看明白"><a href="#流量控制引发的死锁？怎么避免死锁发生？-没看明白" class="headerlink" title="流量控制引发的死锁？怎么避免死锁发生？(没看明白)"></a>流量控制引发的死锁？怎么避免死锁发生？(没看明白)</h2><p>当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。</p><h2 id="拥塞控制和流量控制的区别"><a href="#拥塞控制和流量控制的区别" class="headerlink" title="拥塞控制和流量控制的区别"></a>拥塞控制和流量控制的区别</h2><p>拥塞控制就是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的方法是：慢开始，拥塞避免，快重传，快恢复。</p><p>流量控制就是作用于接收者的，它是控制发送者的发送速度从而使得接收者来得及接收，防止分组丢失</p><h1 id="TCP粘包"><a href="#TCP粘包" class="headerlink" title="TCP粘包"></a>TCP粘包</h1><h1 id="什么是TCP粘包"><a href="#什么是TCP粘包" class="headerlink" title="什么是TCP粘包"></a>什么是TCP粘包</h1><div class="note primary flat"><p>现在假设客户端连续发了两个数据包给服务端，用pack1和pack2来表示，那么就有以下几种情况：</p></div><ol><li>接收端正常收到了两个数据包，没有发生异常<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423102351.png" alt=""></li><li>接收端只收到一个数据包，因为TCP不会丢包所以这个数据包包含了发送端发送的两个数据包，这就是粘包。服务端不知道怎么划分这两个数据包所以很难处理。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423102618.png" alt=""></li><li>接收端收到两个数据包，但它们都不完整。这种情况下可能是pack1丢了一点到pack2，也有可能是pack2丢了一点到pack1，此时发生了粘包拆包<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423103042.png" alt=""></li></ol><h1 id="为什么会发生粘包拆包"><a href="#为什么会发生粘包拆包" class="headerlink" title="为什么会发生粘包拆包"></a>为什么会发生粘包拆包</h1><p>原因如下：</p><ol><li>本身套接字缓冲区大小不足，一次写入的数据多了，就发生了拆包</li><li>本身套接字缓冲区过大，多次写入数据，就发生了粘包</li><li>TCP连接复用，本来单独的连接中双方规定好了数据格式，但是因为复用导致多个进程以及不同的数据格式传输，就造成了粘包</li><li>接收方没及时接收数据，就发生了粘包</li></ol><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决方法就是处理这个边界问题。</p><ol><li>尾部标识法：通过协商的尾部标记，比如<code>\n\t\r</code>等来说明这是边界</li><li>头部标记法：不是不知道长度吗？直接在TCP头部加上标识数据长度</li><li>定长发送法：发送端封装数据包为指定长度发送</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="网络系列" scheme="https://zlinni.github.io/categories/%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="计算机网络" scheme="https://zlinni.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>面试官问我了解TCP粘包吗</title>
    <link href="https://zlinni.github.io/posts/1161612098/"/>
    <id>https://zlinni.github.io/posts/1161612098/</id>
    <published>2022-04-23T02:10:31.000Z</published>
    <updated>2022-04-25T02:41:30.117Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>有一天小明高兴的去面试，突然间面试官抛出一个问题：什么是TCP粘包？这下子好了，小明脑袋搜索了TCP的内容，发现只搜索到TCP和UDP的区别，流量控制，拥塞控制，和三握四挥这几个内容，小明尴尬的说：我不知道。于是回来恶补了TCP粘包的内容</p></div><p>关键词：TCP粘包、拆包<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423111651.png" alt=""></p><h1 id="什么是TCP粘包"><a href="#什么是TCP粘包" class="headerlink" title="什么是TCP粘包"></a>什么是TCP粘包</h1><div class="note primary flat"><p>现在假设客户端连续发了两个数据包给服务端，用pack1和pack2来表示，那么就有以下几种情况：</p></div><ol><li>接收端正常收到了两个数据包，没有发生异常<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423102351.png" alt=""></li><li>接收端只收到一个数据包，因为TCP不会丢包所以这个数据包包含了发送端发送的两个数据包，这就是粘包。服务端不知道怎么划分这两个数据包所以很难处理。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423102618.png" alt=""></li><li>接收端收到两个数据包，但它们都不完整。这种情况下可能是pack1丢了一点到pack2，也有可能是pack2丢了一点到pack1，此时发生了粘包拆包<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423103042.png" alt=""></li></ol><h1 id="为什么会发生粘包拆包"><a href="#为什么会发生粘包拆包" class="headerlink" title="为什么会发生粘包拆包"></a>为什么会发生粘包拆包</h1><p>原因如下：</p><ol><li>本身套接字缓冲区大小不足，一次写入的数据多了，就发生了拆包</li><li>本身套接字缓冲区过大，多次写入数据，就发生了粘包</li><li>TCP连接复用，本来单独的连接中双方规定好了数据格式，但是因为复用导致多个进程以及不同的数据格式传输，就造成了粘包</li><li>接收方没及时接收数据，就发生了粘包</li></ol><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决方法就是处理这个边界问题。</p><ol><li>尾部标识法：通过协商的尾部标记，比如<code>\n\t\r</code>等来说明这是边界</li><li>头部标记法：不是不知道长度吗？直接在TCP头部加上标识数据长度</li><li>定长发送法：发送端封装数据包为指定长度发送</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="网络系列" scheme="https://zlinni.github.io/categories/%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>三道题，入门async和await</title>
    <link href="https://zlinni.github.io/posts/1222301607/"/>
    <id>https://zlinni.github.io/posts/1222301607/</id>
    <published>2022-04-22T06:32:35.000Z</published>
    <updated>2022-04-25T02:41:30.127Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>各厂很喜欢考的async和await题，一般不了解他的做法都很容易踩坑。下面用三道题来讲解怎么解这类型的题目<br>关键词:async、await、题解</p></div><h1 id="题一"><a href="#题一" class="headerlink" title="题一"></a>题一</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>第一道门槛：<br>大部分人在前面都没问题，到await这里就会卡住，此时对于await的情况是这样的。<br>他会去看自己之后的代码，</p><ol><li>查看其中是否有同步代码，如果有，执行</li><li>如果没有 其中异步的直接放到任务栈</li><li>分析await下面的代码<br>然后跳出代码，继续往下查看</li></ol><p>其中关于await的操作，其实是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(async2());</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//这也就是await后面的代码能看成是微任务的原因</span></span><br></pre></td></tr></table></figure></p><p>它等待async2执行完回调这个输出</p><p>第二道门槛：<br>这里就来到下面看有没有同步代码了 这里就是第二步门槛，如果你认为，他直接输出’script end’，那么你就踩坑了。这里我们看到在此之前new了Promise，关键来了，他会立刻执行它的构造函数，也就是你可以把这个构造函数看成是同步代码，此时就会输出<code>promise1</code>.再到<code>script end</code></p><p>第三道门槛：<br>此时，我们得知道 所有的同步任务都执行完了，开始执行任务栈中的代码了<br>此时的任务栈中有await之后的代码，promise的成功回调，和settimeout，当然为什么是这个顺序呢。我们要知道微任务会插队在宏任务前面，也就是一开始的顺序是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">settimeout</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> code 插队</span><br><span class="line">settimeout</span><br><span class="line"></span><br><span class="line"><span class="comment">//遇到promise 插队在宏任务前面</span></span><br><span class="line"><span class="keyword">await</span> code</span><br><span class="line">promise </span><br><span class="line">settimeout</span><br></pre></td></tr></table></figure><p>所以按顺序执行 结果是<code>async1 end``promise2``setTimeout</code></p><p>最终答案：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220422151115.png" alt=""></p><h1 id="题二"><a href="#题二" class="headerlink" title="题二"></a>题二</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise3&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise4&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>第一道门槛：<br>async2中promise的构造器执行之后，将成功的回调放进任务栈，再去把await下面的code放进任务栈</p><p>任务栈的内容（异步）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line"></span><br><span class="line">promise2(插队)</span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line"></span><br><span class="line">promise2</span><br><span class="line">async1 end(插队)</span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line"></span><br><span class="line">promise2</span><br><span class="line">async1 end</span><br><span class="line">promise4(插队)</span><br><span class="line"><span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure></p><p>最终答案<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">promise1</span><br><span class="line">promise3</span><br><span class="line">script end</span><br><span class="line">promise2</span><br><span class="line">async1 end</span><br><span class="line">promise4</span><br><span class="line"><span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure></p><h1 id="题三"><a href="#题三" class="headerlink" title="题三"></a>题三</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout1&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout2&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout3&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>前面的一样，不过这次进入async2后是宏任务，我们依然把它放进任务栈，再把<br>踩坑点：<br>容易忽视掉setimeout3是第一个宏任务。<br>因此答案为setimeout2 1 3 实际上是3 2 1</p><p>最终答案<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">promise2</span><br><span class="line">setTimeout3</span><br><span class="line">setTimeout2</span><br><span class="line">setTimeout1</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>三道基本的题，掌握了await的基本原理。其实就是promise的回调。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试指南" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>DNS域名系统</title>
    <link href="https://zlinni.github.io/posts/3906343608/"/>
    <id>https://zlinni.github.io/posts/3906343608/</id>
    <published>2022-04-21T07:29:56.000Z</published>
    <updated>2022-04-25T02:41:30.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>web前端你必须了解的DNS，下面讲解DNS的一些过程和由来以及产生的安全问题<br>关键词：DNS是什么、DNS的分布式、层次数据库、本地DNS服务器、DNS递归查询和迭代查询、DNS缓存、DNS劫持</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220422103253.png" alt=""></p><h1 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS"></a>什么是DNS</h1><p>DNS即域名系统，全称是Domain Name System。当我们在浏览器输入一个URL地址的时候，浏览器要向这个URL的主机名对于的服务器发起请求，就得知道服务器的IP。对于浏览器来说，DNS的作用就是将主机名转换为IP地址。</p><div class="note primary flat"><p>DNS是：</p><ol><li>一个由分层的DNS服务器实现的分布式数据库</li><li>一个使得主机能够查阅分布式数据库的应用层协议</li></ol></div><p>也就是 DNS是一个应用层的协议，我们发送一个请求，其中包含我们要查询的主机名，他就会给我们返回这个主机名对应的IP。</p><p>其次，DNS是一个分布式数据库，整个DNS由分散在世界各地的很多台DNS服务器组成，每台DNS服务器上面都保存了一些数据，这些数据可以让我们查到最终主机名对应的IP</p><p>所以DNS的查询过程，本质上就是去向这些DNS服务器访问，直到查到这个IP为止。</p><h1 id="分布式、层次数据库"><a href="#分布式、层次数据库" class="headerlink" title="分布式、层次数据库"></a>分布式、层次数据库</h1><h2 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h2><p>因为所有的主机不可能全部ip都放在一台dns服务器上面，所以就一台一台分出来，每台存储不同的数据，负责不同的映射。</p><h2 id="什么是层次"><a href="#什么是层次" class="headerlink" title="什么是层次"></a>什么是层次</h2><p>DNS服务器有三种类型：根DNS服务器，顶级域DNS服务器和权威NDS服务器，<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421154505.png" alt=""></p><ul><li>根DNS服务器<br>首先我们要明确根域名是什么？比如<code>www.baidu.com</code>其实他的根域名是被隐藏的。真正的根域名是<code>www.baidu.com.root</code>后面的.root</li></ul><p>那么根DNS服务器的作用是什么?就是管理他的下一级，也就是顶级域DNS服务器。通过询问根DNS服务器，我们能查到该主机名对应的顶级域的ip是多少，从而继续向顶级域请求了解他的下一层。</p><ul><li><p>顶级域服务器<br>除了前面提到的com是顶级域名，常见的顶级域名还有cn，org，edu等。然后顶级域管理的是权威DNS</p></li><li><p>权威DNS<br>由各大厂商负责管理的域名，它可以返回最终的一个IP</p></li></ul><p>服务器之间是如何继续交互的，继续往下看：</p><h1 id="本地DNS服务器"><a href="#本地DNS服务器" class="headerlink" title="本地DNS服务器"></a>本地DNS服务器</h1><p>上一层没有讲到本地DNS服务器，是因为他严格意义上不属于DNS的层次结构。</p><p>什么是本地DNS服务器？</p><p>每个ISP都有一台本地DNS服务器，比如小区，大学，机构等。都有一台或多台本地DNS服务器。当主机发出DNS请求的时候，该请求被发往本地DNS服务器，本地DNS服务器代理这些请求，将它们转发到DNS服务器中。好比Nginx</p><h1 id="递归查询-迭代查询"><a href="#递归查询-迭代查询" class="headerlink" title="递归查询 迭代查询"></a>递归查询 迭代查询</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421155733.png" alt=""></p><p>其中com是顶级域名 n是权威域名 </p><p>这个过程中，主机向本地DNS服务器请求就是递归查询<br>本地服务器向根DNS，顶级DNS和权威DNS发出的请求就是迭代查询<br>迭代的特点就是所有的都是由本地DNS发出 所有的接收也是回到本地DNS</p><p>当然不是所有的DNS查询都是这样的模式 DNS查询可以是递归的，也可以是迭代的 如下图就只是递归的<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421160546.png" alt=""></p><h1 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h1><p>为了让我们更快的拿到想要的IP，DNS广泛使用了缓存技术。DNS的缓存原理就是，在一个DNS查询的过程中，某台DNS收到了一个DNS应答的时候，就能将映射缓存到本地，下次查询就能直接用到缓存的内容。</p><p>but 缓存不是永久的，他也会定时删除。</p><p>所以有了缓存，很多时候都绕开了根DNS，所以需要向根DNS发起的查询请求很少。</p><h1 id="DNS解析优化"><a href="#DNS解析优化" class="headerlink" title="DNS解析优化"></a>DNS解析优化</h1><p>主要分为两个方案</p><ul><li>DNS预解析</li><li>减少DNS请求</li></ul><h1 id="DNS预解析"><a href="#DNS预解析" class="headerlink" title="DNS预解析"></a>DNS预解析</h1><div class="note primary flat"><p>DNS解析也需要时间的，可以通过预解析的方式来预先获取域名所对应的IP</p></div><p>link方式：手动解析<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//blog.poetries.top&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>meta方式：https自动解析<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;x-dns-prefetch-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;on&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>设置响应头：自动解析<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.set(<span class="string">&#x27;X-DNS-Prefetch-Control&#x27;</span>, <span class="string">&#x27;on&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h1 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h1><p>域名劫持就是在劫持的范围内拦截解析的请求，分析请求的域名，把审查范围之外的请求放行，否则直接返回假的IP地址或者什么也不做使其失去响应，效果就是特定的网址不能访问或者访问的是假的网址</p><p>域名劫持会影响用户体验，一方面还有可能被诱骗到冒牌网站进行登陆导致隐私泄漏</p><p>DNS可以有本地DNS劫持，路由DNS劫持，攻击DNS服务器</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>加强本地的计算机病毒检查，开启防火墙，防止恶意软件，木马感染计算机等。</li><li>改变路由器默认密码，防止攻击者修改路由器的DNS配置指向恶意的DNS服务器。</li><li>企业可以准备两个or以上的域名，一个挂了用另外一个</li><li>用HTTP DNS 代替Local DNS</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>DNS的内容其实讲深了还是很多的，但是基本的原理和概念还是要清楚，熟悉一下DNS解析的过程以及这个递归和迭代，关于域名这块以后还是会出文章，有购买域名的打算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="网络系列" scheme="https://zlinni.github.io/categories/%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="网络" scheme="https://zlinni.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Flex弹性布局</title>
    <link href="https://zlinni.github.io/posts/1131280526/"/>
    <id>https://zlinni.github.io/posts/1131280526/</id>
    <published>2022-04-21T00:31:57.000Z</published>
    <updated>2022-04-25T02:41:30.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>详细记录flex弹性布局的具体属性和常考题。<br>关键词：flex属性、</p></div><h1 id="flex概念"><a href="#flex概念" class="headerlink" title="flex概念"></a>flex概念</h1><p>弹性盒子是一种按行或者按列布局元素的一种以为布局方法，容器里面的元素可以膨胀填充额外的空间，收缩来适应更小的空间，适用于任何元素。</p><p>元素使用flex布局就会在内部形成BFC，目前flex已经适配所有常规浏览器</p><h2 id="拓展：BFC"><a href="#拓展：BFC" class="headerlink" title="拓展：BFC"></a>拓展：BFC</h2><p>BFC：块级格式化上下文，是一个完全独立的空间，里面的子元素不会影响到外面的布局。</p><p>触发BFC的方式：</p><ul><li><code>overflow:hidden</code></li><li><code>display:inline-block,table-cell,flex</code></li><li><code>position:absolute,fixed</code></li></ul><p>BFC解决的问题：</p><ul><li>高度塌陷</li><li>margin边距重叠</li></ul><h1 id="flex和inline-flex"><a href="#flex和inline-flex" class="headerlink" title="flex和inline-flex"></a>flex和inline-flex</h1><p>display有两种设置方式：flex和inline-flex。</p><p>区别在于：<br>flex元素和宽度是父容器的100%<br>inline-flex是所有元素的宽度和<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421110404.png" alt=""></p><p>那么在元素溢出的情况下是怎么样呢？<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421110450.png" alt=""><br>可见inline-flex会撑大flex容器，造成溢出</p><p>使用inline-flex的时候，注意配合min-width和min-height一起使用。不建议显示设置height和width</p><h2 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h2><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421110628.png" alt=""><br>可以总结为 整个容器的设置flex 不占整个容器的或者容器的部分 设置为inline-flex</p><h1 id="主轴和交叉轴"><a href="#主轴和交叉轴" class="headerlink" title="主轴和交叉轴"></a>主轴和交叉轴</h1><p>flex布局有两个轴的概念：主轴和交叉轴。水平的叫做主轴，垂直的叫做交叉轴。主轴的开始位置叫做start 结束叫做end 交叉轴也是如此。<br>flex布局的元素称为容器container，他的所有子元素都是一个项目item</p><h1 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421085022.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421085431.png" alt=""></p><h2 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h2><ul><li>row:水平左 左对齐</li><li>row-reverse:水平右 右对齐</li><li>column: 垂直上 上对齐</li><li>column-reverse: 垂直下 下对齐</li></ul><p>场景<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421110854.png" alt=""></p><p>由于默认会携带<code>flex-direction:row</code>（代码冗余）所以在非row的时候再设置flex-direction做布局算法优化</p><h2 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h2><p>默认情况下元素不换行nowrap，加了wrap属性之后，会换行</p><ul><li>nowrap 不换</li><li>wrap 换行</li><li>wrap-reverse 换行 第一行在下方<br>eg<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="literal">null</span> <span class="literal">null</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span>    <span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h2><p>是direction和wrap属性的简写 默认为row nowrap<br>只设置一个值的时候 看匹配哪个属性值 来取值<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-flow</span>: row || nowrap</span><br></pre></td></tr></table></figure></p><h2 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h2><p>描述了元素在主轴上面的对齐方式</p><ul><li>flex-start 左对齐</li><li>flex-end 右对齐</li><li>center 居中</li><li>space-around 每个项目两端的间隔相等 意味着第一个和最后一个元素两侧的宽度不等</li><li>space-between 两端对齐 项目之间的间隔相等</li><li>space-evenly: 项目的间隔和容器的间隔相等</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421090432.png" alt=""></p><h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><p>描述元素在交叉轴上面的对齐方式</p><ul><li>flex-start 上对齐</li><li>flex-end 下对齐</li><li>center 居中</li><li>baseline 项目第一行文字的基线对齐</li><li>stretch 默认 如果没设置高度或者auto 则占满整个容器的高度</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421090724.png" alt=""></p><h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2><p>定义了多根轴线的对齐方式 前提设置flex-wrap：wrap 否则不生效</p><ul><li>flex-start 交叉轴起点</li><li>flex-end 交叉轴中终点</li><li>center 中点</li><li>space-between 两端对齐 轴线之间平均分 </li><li>space-around  轴线间间隔相等</li><li>stretch 默认值 占满整个交叉轴</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421091427.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421111124.png" alt=""></p><h2 id="gap"><a href="#gap" class="headerlink" title="gap"></a>gap</h2><p>gap用来控制flex项目之间的间距，但会忽略flex项目与flex容器边缘的间距<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421111332.png" alt=""></p><h1 id="项目的子项属性"><a href="#项目的子项属性" class="headerlink" title="项目的子项属性"></a>项目的子项属性</h1><h2 id="order"><a href="#order" class="headerlink" title="order"></a>order</h2><p>定义项目的排列顺序 数值越小越前 默认0 可以是负数<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421091444.png" alt=""></p><p>场景：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421111454.png" alt=""></p><h2 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h2><p>定义了容器中剩余空间应该有多少分配给项目，最终的宽度为：自身宽度+容器剩余空间分配宽度 该属性的最大值是1 超过1按1来拓展<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421091802.png" alt=""></p><h2 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h2><p>该属性指定了flex元素的收缩规则。只在项目的元素宽度和大于容器的时候才会触发。收缩的大小是依据该属性的值 默认为1</p><p>eg 两个div 第一个div宽度200 第二个div宽度300 容器400<br>容器设置了flex布局 两个div的shrink都设置为1<br>那么此时 两个div500大于400 所以触发收缩</p><p>那么收缩后子项的宽度怎么计算呢？<br>有公式如下</p><ol><li>所有子项宽度和-容器的宽度=<code>500 - 400 = 100</code></li><li>第一个子项的占比 <code>2/5</code> 第二个子项的占比 <code>3/5</code></li><li>第一个子项的宽度为<code>200-2/5*100=160</code>,第二个为:<code>300-3/5*100=240</code></li></ol><h2 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h2><p>指定子项目的在主轴的初始化大小，优先级高于自身宽度width<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-basis</span>: <span class="number">0</span> | <span class="number">100%</span> | auto | &lt;length&gt;</span><br></pre></td></tr></table></figure></p><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>flex是flex-grow flex-shrink 和 flex-basis的简写<br>单值的时候 数值被当作flexgrow 一个有效的宽度值被当作basis<br>双值的时候 一个无单位的数 被当成shrink 一个有效的宽度值被当成basis<br>三值 略</p><p>默认 0 1 auto</p><p>取值，除了自定义的三种外：<br><code>auto</code>根据自身的width和height来确定比例 相当于<code>1 1 auto</code><br><code>initial</code>相当于0 1 auto<br><code>none</code> 0 0 auto</p><h2 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h2><p>允许单个项目有和其他项目不一样的对齐方式，可以覆盖align-items属性，默认auto表示继承align-items 如果没有父元素 则等于stretch<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421092936.png" alt=""></p><p>常见使用场景<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421111420.png" alt=""></p><h1 id="Flex项目上的-margin"><a href="#Flex项目上的-margin" class="headerlink" title="Flex项目上的 margin"></a>Flex项目上的 margin</h1><p>在Flex项目显式设置 margin 的值为 auto 可以灵活的控制单个Flex项目在Flex容器中的位置：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421105904.png" alt=""><br>比如像下图这样的效果，使用 margin-left: auto 就非常的实用：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421105923.png" alt=""></p><h1 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h1><p>等高布局</p><p>左侧宽度固定 右侧宽度自适应布局（常见的tob系统布局，左侧菜单树右侧内容）<br>粘性页脚<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421105548.png" alt=""><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex__container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;coupon&quot;</span>&gt;</span>卷<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;divider&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;price&quot;</span>&gt;</span><span class="symbol">&amp;yen;</span>1000<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.flex__container &#123;</span><br><span class="line">  display: inline-flex;</span><br><span class="line">  min-width: 200px;</span><br><span class="line">  height: 60px;</span><br><span class="line">  </span><br><span class="line">  border: 1px solid rgba(255, 0, 54, 1);</span><br><span class="line">  background-color: rgba(255, 0, 54, 0.1);</span><br><span class="line">  border-radius: 4px;</span><br><span class="line">  color: #ff0036;</span><br><span class="line">  font-size: 24px;</span><br><span class="line">  font-weight: 400;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.flex__container &gt; span &#123;</span><br><span class="line">  display: inline-flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.divider &#123;</span><br><span class="line">  border-right: 1px dashed currentColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.coupon &#123;</span><br><span class="line">  min-width: 50px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.price &#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">  min-width: 0;</span><br><span class="line">  padding: 0 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="CSS系列" scheme="https://zlinni.github.io/categories/CSS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的JavaScript合集</title>
    <link href="https://zlinni.github.io/posts/3250811507/"/>
    <id>https://zlinni.github.io/posts/3250811507/</id>
    <published>2022-04-20T07:40:52.000Z</published>
    <updated>2022-04-25T02:44:03.713Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>将2w字长文分成了七个模块，方便今后补充内容，详见传送门。</p></div><h1 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h1><p><a href="https://zlinni.github.io/posts/3931945421/">你所不知道的JavaScript①—数据类型及周边</a><br><a href="https://zlinni.github.io/posts/961371178/">你所不知道的JavaScript②—this及周边</a><br><a href="https://zlinni.github.io/posts/1060178397/">你所不知道的JavaScript③—原型及周边</a><br><a href="https://zlinni.github.io/posts/3693633031/">你所不知道的JavaScript④—异步任务与事件</a><br><a href="https://zlinni.github.io/posts/3693633031/">你所不知道的JavaScript⑤—垃圾回收与内存泄漏</a><br><a href="https://zlinni.github.io/posts/3318597918/">你所不知道的JavaScript⑥—面向对象与模块化</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的JavaScript⑥--面向对象与模块化</title>
    <link href="https://zlinni.github.io/posts/3318597918/"/>
    <id>https://zlinni.github.io/posts/3318597918/</id>
    <published>2022-04-20T07:32:49.000Z</published>
    <updated>2022-04-25T02:41:30.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><div class="note simple"><p>面向对象、迭代器、模块化</p></div><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="对象遍历"><a href="#对象遍历" class="headerlink" title="对象遍历"></a>对象遍历</h2><ol><li><code>for in</code></li><li><code>Object.keys(xxx)</code>把key取出来作为一个数组。</li><li><code>Object.values(xxx)</code>遍历对象的值作为一个数组<h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2></li></ol><ul><li>基本思想是使用对象，类，继承，封装等基本概念来进行程序设计</li><li>优点：<ul><li>易维护：采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，维护也只是在局部模块，所以维护起来非常方便，成本较低</li><li>易拓展</li><li>开发工作的重用性，继承性高，降低重复工作量</li><li>缩短了开发周期<div class="note primary flat"><p>一般面向对象包括：继承，封装，多态，抽象</p></div></li></ul></li></ul><h2 id="对象形式的继承"><a href="#对象形式的继承" class="headerlink" title="对象形式的继承"></a>对象形式的继承</h2><div class="note primary flat"><p>讲深浅拷贝之前，我们需要知道，基本数据类型在栈里面，被复制了就算修改也不会改变原来的的值，引用数据类型在堆里面，因为共享内存所以复制后被修改会改变源对象的值，至此引申出深浅拷贝。</p></div><ul><li>浅拷贝<div class="note primary flat"><p>基本的浅拷贝就是对象的赋值，但我们需要注意，实际上我们的需求是复制源对象上面的属性，那么单纯的赋值，会把新对象的值给覆盖掉。参见下面</p></div></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;allin&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">home</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">        <span class="attr">office</span>: <span class="string">&#x27;office&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">sclools</span>: [<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;z&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> programer = &#123;</span><br><span class="line">    <span class="attr">language</span>: <span class="string">&#x27;js&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果不使用该方法 programmer里面的language会被覆盖掉</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">p, c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = c || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> prop <span class="keyword">in</span> p)&#123;</span><br><span class="line">        c[prop] = p[prop];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">extend(Person, programer);</span><br><span class="line"><span class="comment">//or </span></span><br><span class="line"><span class="comment">// programer = Object.assign(programer,Person);</span></span><br><span class="line">programer.name;  <span class="comment">// allin</span></span><br><span class="line">programer.address.home;  <span class="comment">// home</span></span><br><span class="line">programer.address.home = <span class="string">&#x27;house&#x27;</span>;  <span class="comment">//house</span></span><br><span class="line">Person.address.home;  <span class="comment">// house</span></span><br><span class="line"><span class="comment">//programmer依旧保留自己的language</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>注意 浅拷贝不是新对象的地址指向整个旧对象的地址，而是拷贝旧对象的属性的地址。即自己原先的内容不变，拷贝的过程中如果key重复覆盖，否则保留。<br>思路是遍历对象 赋值。</p></div><p>深拷贝<br><div class="note primary flat"><p>深拷贝是开辟一个新的内存地址，将源对象的各个属性复制进去<br>注意的点：对象原型上面的属性不应该去拷贝，使用到<code>Object.hasOwnProperty(key)</code></p></div></p><ol><li>通过<code>JSON.parse(JSON.stringfy())</code>进行深拷贝</li></ol><ul><li>是序列化和反序列化的过程，序列化是存储地址的一个映射，所以反序列化之后，修改并不会影响原先的地址。就可以达成深拷贝。</li><li>缺点：不能拷贝<code>undefined function 正则 Error对象</code></li></ul><ol><li>递归</li></ol><ul><li>通过判断引用类型数据进行初始化之后赋值的操作指向新的地址。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断是否是引用类型或者null 否则返回源对象进行浅拷贝</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>||obj===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是数组，初始化地址。</span></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        result = [];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归调用 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            result[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li>缺点：栈会溢出。</li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul><li>命名空间<ul><li>js是没有命名空间的，因此可以用对象来模拟</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = &#123;&#125;<span class="comment">//命名空间app</span></span><br><span class="line"><span class="comment">//模块1</span></span><br><span class="line">app.module1 = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;allin&#x27;</span>,</span><br><span class="line">  <span class="attr">f</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">app.module1.name;</span><br><span class="line">app.module1.f();</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>对象的属性外界是可读可写的，那么如何达到封装的目的？通过闭包和局部变量</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Girl</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//通过方法访问变量</span></span><br><span class="line">  <span class="keyword">var</span> love = <span class="string">&#x27;jojo&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.name =name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> love;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.movelove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    love = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Girl(<span class="string">&#x27;bb&#x27;</span>,<span class="number">19</span>);</span><br><span class="line">g.say();</span><br><span class="line">g.movelove();</span><br><span class="line">g.say();</span><br></pre></td></tr></table></figure><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><div class="note primary flat"><p>就是在函数外面定义静态方法，静态方法只有该类能够使用。</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员</span></span><br><span class="line">Person.walk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;static&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Person.walk();  <span class="comment">// static</span></span><br></pre></td></tr></table></figure><h2 id="私有与公有"><a href="#私有与公有" class="headerlink" title="私有与公有"></a>私有与公有</h2><div class="note primary flat"><p>对象的方法和属性分为私有和公有，公有的属性需要在实例化的时候传入对应的值去调用，私有的属性和方法只能通过公有的方法暴露出去。注意私有的方法如果返回的是公有的属性，还需要使用call改变this指向</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 私有属性与方法</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;allin&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//公有属性与方法</span></span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;say hello&#x27;</span>);</span><br><span class="line">        work.call(<span class="built_in">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="number">123</span>);</span><br><span class="line">p1.name; <span class="comment">// undefined</span></span><br><span class="line">p1.id;  <span class="comment">// 123</span></span><br><span class="line">p1.say();  <span class="comment">// say hello 123</span></span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><div class="note primary flat"><p>同一个父类继承出来的子类有各自的形态,写的时候注意<code>子类,prototype = new 父类()</code></p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.eat = <span class="string">&#x27;肉&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tiger</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.color = <span class="string">&#x27;黑黄相间&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cheetah</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.color = <span class="string">&#x27;报文&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Lion</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.color = <span class="string">&#x27;土黄色&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tiger.prototype =  Cheetah.prototype = Lion.prototype = <span class="keyword">new</span> Cat();<span class="comment">//共享一个祖先 Cat</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> T = <span class="keyword">new</span> Tiger();</span><br><span class="line"><span class="keyword">var</span> C = <span class="keyword">new</span> Cheetah();</span><br><span class="line"><span class="keyword">var</span> L = <span class="keyword">new</span> Lion();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(T.color);</span><br><span class="line"><span class="built_in">console</span>.log(C.color);</span><br><span class="line"><span class="built_in">console</span>.log(L.color);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(T.eat);</span><br><span class="line"><span class="built_in">console</span>.log(C.eat);</span><br><span class="line"><span class="built_in">console</span>.log(L.eat);</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><div class="note primary flat"><p>虚函数是类成员中的概念，是只做了一个声明而未实现的方法，具有虚函数的类称之为抽象类。抽象类不能被实例化因为其中的虚函数并不是一个完整的函数，不能被调用。<br>在js中实现抽象类就是在父类中调用一个未定义的方法，但这个方法在子类中必须被实现。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AbstractClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象类不能直接被调用&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">AbstractClass.prototype.detect = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">AbstractClass.prototype.stop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;stop&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">AbstractClass.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NormalClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  NormalClass.prototype = <span class="built_in">Object</span>.create(AbstractClass.prototype);</span><br><span class="line">  NormalClass.prototype.constructor = NormalClass;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> NormalClass();</span><br><span class="line"><span class="built_in">console</span>.log(n)</span><br><span class="line">n.detect();</span><br><span class="line">n.init();</span><br></pre></td></tr></table></figure><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><ol><li>面向对象的三个基本特征</li><li>手写一下函数的公有和私有方法以及调用的形式<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;jojo&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">    sayName.call(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h1><div class="note primary flat"><p>Iterator是一种接口，也可以说是一种规范，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。即依次处理该数据结构的所有成员</p></div><p>语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note primary flat"><p><code>[Symbol.iterator]</code>属性名是固定的写法，只要拥有了该属性的对象，就能用迭代器的方式进行遍历。</p></div></p><ul><li>迭代器的遍历方法是首先获得一个迭代器的指针。初始时该指针指向第一条数据之前，接着通过调用next方法，改变指针的指向，让他调用下一条数据。</li><li>每次的next都会返回一个对象 有两个属性<ul><li>value： 表示你想获取的数据</li><li>done：布尔值 代表遍历是否结束 true则结束<h2 id="iterator的作用"><a href="#iterator的作用" class="headerlink" title="iterator的作用"></a>iterator的作用</h2>三个作用</li></ul></li><li>创建一个指针对象指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的next方法 指针指向第二个成元</li><li>不断调用next 直到结束位置(假如有三个数据 需要next四次 最后一次的结果是<code>&#123; value: undefined, done: true &#125;</code>)<br>案例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123;<span class="attr">nums</span>:<span class="number">1</span>&#125;,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="built_in">Symbol</span>.iterator]();<span class="comment">//获取数组的迭代器</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: Object &#123; num: 1 &#125;, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h2 id="具有iterator接口的数据结构"><a href="#具有iterator接口的数据结构" class="headerlink" title="具有iterator接口的数据结构"></a>具有iterator接口的数据结构</h2><div class="note primary flat"><p>一个数据结构只要有iterator接口就能被认为是可以遍历的。可以用forof。</p></div>具有iterator接口的数据结构的有四种：</li></ul><ol><li>数组</li><li>类数组</li><li>Set</li><li>Map<h2 id="为什么对象没有iterator接口"><a href="#为什么对象没有iterator接口" class="headerlink" title="为什么对象没有iterator接口"></a>为什么对象没有iterator接口</h2></li></ol><ul><li>对象只能用forin和<code>Object.keys、values</code>遍历</li><li>因为一个对象的哪个属性先遍历和后便利是不确定的，需要开发者手动指定。</li><li>对对象部署iterator接口没有必要 因为map弥补了他的缺陷而且map有iterator接口<br>对对象部署iterator<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    <span class="attr">hobbie</span>: <span class="string">&#x27;睡觉&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keyArr = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> index&lt;keyArr.length?&#123;</span><br><span class="line">        <span class="attr">value</span>:&#123;</span><br><span class="line">          <span class="attr">key</span>:keyArr[index],</span><br><span class="line">          <span class="attr">val</span>:obj[keyArr[index++]]</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;:&#123;</span><br><span class="line">        <span class="attr">done</span>:<span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><div class="note primary flat"><p>四种方案：commonjs，AMD，CMD，ES6</p></div><ul><li><p>CommonJS，node的，通过require来引入模块，通过<code>module.exports</code>定义输出接口。是以同步的方式引入模块的。</p></li><li><p>AMD是采用异步的方式加载模块，模块的加载不影响后面语句的执行 所有依赖这个模块的语句都定义在一个回调函数里面，等加载完再执行回调函数。requirejs实现了AMD规范</p></li><li>CMD方案，也是解决异步加载的委托。代表有seajs。和requirejs的区别在于模块定义的时候堆依赖的处理不同和对依赖模块的执行时机处理不同。</li><li>最后是es6的，通过import和export进行导入导出。默认暴露统一暴露分别暴露。<ul><li>默认暴露：<code>export default</code></li><li>分别暴露：<code>export xxx1;exportxxx2</code>，引入<code>import &#123;xxx1,xxx2&#125; from &#39;xxx&#39;</code></li><li>统一暴露：<code>export &#123;aa1,aa1&#125;</code>，引入<code>import &#123;aa1,aa2&#125; from &#39;xxx&#39;</code></li></ul></li></ul><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><ul><li>写法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.a;<span class="comment">//1</span></span><br></pre></td></tr></table></figure></li><li>注意浏览器中使用的话用<code>browserify</code><div class="note primary flat"><p>和es6的区别如下：</p></div></li><li>前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案,前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。</li><li>而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li><li>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。</li><li>但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li><li>后者会编译成 require/exports 来执行的</li></ul><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><div class="note primary flat"><p>和CMD的区别：</p></div><ul><li>对依赖的处理不一样。AMD是依赖前置。定义模块的时候就要声明依赖的模块，CMD就近依赖，用到哪个才去require</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>); <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐</span></span><br><span class="line">define([<span class="string">&quot;./a&quot;</span>, <span class="string">&quot;./b&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>对于依赖模块的执行实际处理不同。AMD和CMD异步加载，但是AMD在模块加载完就立刻执行依赖模块，依赖模块的执行顺序和我们写的顺序不一定一致。而CMD在依赖模块加载完成后并不执行，只是下载。等全部的依赖模块都加载好后，再去执行，和我们的书写顺序一致。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的JavaScript⑤--垃圾回收与内存泄漏</title>
    <link href="https://zlinni.github.io/posts/1805418661/"/>
    <id>https://zlinni.github.io/posts/1805418661/</id>
    <published>2022-04-20T07:02:04.000Z</published>
    <updated>2022-04-27T15:07:14.198Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><div class="note simple"><p>垃圾回收、内存泄漏</p></div><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220427230620.png" alt=""></p><h2 id="为什么要垃圾回收？"><a href="#为什么要垃圾回收？" class="headerlink" title="为什么要垃圾回收？"></a>为什么要垃圾回收？</h2><div class="note primary flat"><p>js的变量没有固定大小，是动态分配的，所以需要进行垃圾回收，避免内存占用满了之后造成系统崩溃。</p></div><h2 id="垃圾回收的机制-特点"><a href="#垃圾回收的机制-特点" class="headerlink" title="垃圾回收的机制/特点"></a>垃圾回收的机制/特点</h2><div class="note primary flat"><p>对于栈内存 切换到别的上下文就回收<br>对于堆内存 分为新生代和老生代</p></div><p>含义：新生代指的是只经过一次垃圾回收的对象，老生代指的是经过多次垃圾回收的对象</p><p>具体：新生代被分为from和to两个空间。to一般闲置，在from的空间满了之后执行scavenge算法进行垃圾回收。</p><p>执行垃圾回收的时候应用逻辑将停止，等垃圾回收结束后继续执行</p><h2 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收?"></a>什么时候回收?</h2><div class="note primary flat"><p>利用浏览器的空闲时间</p></div><h2 id="scavenge算法"><a href="#scavenge算法" class="headerlink" title="scavenge算法"></a>scavenge算法</h2><div class="note primary flat"><p>算法分为三步：</p></div><ol><li>检测from空间的存活对象，查看是否满足老生代条件（to是否超过25%/是否经历过一次垃圾回收）?老生代:移动到to空间</li><li>如果对象不存活则释放对象的空间</li><li>最后将from和to空间进行角色交换</li></ol><h2 id="新生代到老生代"><a href="#新生代到老生代" class="headerlink" title="新生代到老生代"></a>新生代到老生代</h2><div class="note primary flat"><p>条件有两个</p></div><ol><li>我们知道新生代的条件是只经过一次垃圾回收，也就意味着它经历了一次Scavenge</li><li>to空间的内容使用占比。因为scavenge算法结束之后会交换fromto的位置，所以to的空间不能太小，影响到后续的内存分配。所以当从from到to的时候，如果to的空间超过25%，直接变成老生代。</li></ol><h2 id="老生代的回收机制"><a href="#老生代的回收机制" class="headerlink" title="老生代的回收机制"></a>老生代的回收机制</h2><div class="note primary flat"><p>老生代采用了标记清除和标记压缩法</p></div><p>标记清除：在回收的过程中标记存活的对象，结束后清除没有标记的对象（释放了空间）</p><p>不利：造成了很多内存碎片，不利于后续内存分配，引入标记压缩法</p><p>标记压缩法：</p><h2 id="其他的方法"><a href="#其他的方法" class="headerlink" title="其他的方法"></a>其他的方法</h2><div class="note primary flat"><p>增量标记法：垃圾回收的过程会暂停应用逻辑，对于新生代来说还好，对于老生代来说时间长，所以引入增量标记分割停顿的过程，执行一段分割就运行一会逻辑，交替。</p></div><h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><ul><li>意外的全局变量：无法被回收</li><li>定时器：未被正确关闭，导致所引用的外部变量无法被释放。</li><li>事件监听：没有正确销毁（低版本浏览器可能出现）</li><li>闭包<ul><li>第一种情况是我们使用未声明的变量，而意外的创建了一个全局变量，而使得这个变量一直留在内存中无法被回收</li><li>第二种情况是我们设置了setInterval定时器，而忘记取消他，如果循环函数对外部变量有引用的话，那么这个变量会被一直留在内存中，无法被回收。</li><li>第三种情况是我们获取一个DOM元素的引用。而后面的元素被删除。由于我们一直保留了对这个元素的引用，所以他也无法被回收。</li><li>第四种情况是不合理的使用闭包，从而导致某些变量一直被流在内存当中。</li></ul></li><li>dom引用：dom元素被删除时，内存中的引用未被正确清空。</li><li>控制台<code>console.log</code>打印的东西</li></ul><div class="note primary flat"><p>可以用chrome中的timeline进行内存标记，可视化查看内存的变化情况，找出异常点。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的JavaScript④--异步任务与事件</title>
    <link href="https://zlinni.github.io/posts/3693633031/"/>
    <id>https://zlinni.github.io/posts/3693633031/</id>
    <published>2022-04-20T07:01:52.000Z</published>
    <updated>2022-04-25T02:41:30.168Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><div class="note simple"><p>事件机制、Promise、Generator、async/await、事件循环</p></div><h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><div class="note primary flat"><p>事件的触发过程？事件代理？</p></div><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><div class="note primary flat"><p>事件流是一个事件沿着特定数据结构传播的过程。冒泡和捕获是事件流在DOM中的两种不同的传播方式。</p></div><h2 id="事件流的三个阶段"><a href="#事件流的三个阶段" class="headerlink" title="事件流的三个阶段"></a>事件流的三个阶段</h2><ul><li>事件捕获阶段</li><li>目标阶段</li><li>事件冒泡阶段</li></ul><h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><div class="note primary flat"><p>事件捕获通俗的理解就是鼠标点击或者触发dom事件的时候，浏览器从根节点开始由外到内的进行事件传播，即点击了子元素。如果父元素通过捕获方式注册了对应的事件的话，会先触发父元素绑定的事件</p></div><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><div class="note primary flat"><p>事件冒泡和事件捕获相反，顺序是由内到外直到根节点</p></div><p>无论是事件捕获还是冒泡，都有一个共同的特征就是事件传播<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220404101558.png" alt=""></p><h2 id="事件流阻止"><a href="#事件流阻止" class="headerlink" title="事件流阻止"></a>事件流阻止</h2><div class="note primary flat"><p>在一些情况下要阻止事件流的传播，阻止默认动作的发生</p></div><ul><li><code>event.preventDefault()</code>取消事件对象的默认动作以及继续传播</li><li><code>event.stopPropagation()/event.cancelBubble = true</code>阻止事件冒泡<h3 id="在不同浏览器的处理"><a href="#在不同浏览器的处理" class="headerlink" title="在不同浏览器的处理"></a>在不同浏览器的处理</h3></li><li>在IE下使用 <code>event.returnValue= false</code>，</li><li>在非IE下则使用 <code>event.preventDefault()</code>进行阻止<h3 id="preventDefault与stopPropagation的区别"><a href="#preventDefault与stopPropagation的区别" class="headerlink" title="preventDefault与stopPropagation的区别"></a><code>preventDefault</code>与<code>stopPropagation</code>的区别</h3></li><li><code>preventDefault</code>告诉浏览器不用执行与事件相关联的默认动作（如表单提交）</li><li><code>stopPropagation</code>是停止事件继续冒泡，但是对IE9以下的浏览器无效<h2 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h2></li><li>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 <code>false</code>。useCapture 决定了注册的事件是捕获事件还是冒泡事件</li><li>一般来说，我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件<div class="note warning flat"><p>注意<code>addEventListener</code>需要销毁，<code>onClick</code>则不需要因为每次都替换</p></div><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2></li><li>优化性能，当子节点过多的时候给父元素绑定事件通过冒泡只执行一次事件节省内存并且不需要给子节点注销事件。<h2 id="事件的兼容写法"><a href="#事件的兼容写法" class="headerlink" title="事件的兼容写法"></a>事件的兼容写法</h2><div class="note primary flat"><p>ie的event和非ie的event不太一样，也不能一起用</p></div></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gete</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//兼容ie的事件</span></span><br><span class="line">  e = e || <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="comment">//兼容ie的target</span></span><br><span class="line">  <span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><div class="note primary flat"><p>谈到promise的时候，除了将他解决的痛点以及常用的api之外，最好进行拓展吧eventloop带进来好好讲一下。微任务，任务的指向顺序，如果看过promise源码，最好可以谈一谈原生promise是如何实现的，还有就是promise的链式调用</p></div><ul><li>promise是es6新增的语法，解决了回调地狱的问题</li><li>promise可以被看成是一个状态机，初始是<code>pending</code>可以通过函数<code>resolve</code>和<code>reject</code>将状态转变为<code>resolved</code>or<code>rejected</code>状态。状态一旦发生改变就不能再次变化。</li><li>then函数会返回一个promise实例，并且该返回值是一个新的实例而不是之前的实例。因为promise规范规定除了pending状态，其他状态是不能改变的。如果返回的是一个相同实例的话，多个then调用就失去了意义。对于then来说，本质上可以看成是flatMap</li></ul><h2 id="promise的基本情况"><a href="#promise的基本情况" class="headerlink" title="promise的基本情况"></a>promise的基本情况</h2><div class="note primary flat"><p>简单来说他是一个容器，里面保存着某个未来才会结束的事件，通常是异步操作的结果。从语法上面来说，promise是一个对象，从他可以获取异步操作的消息。</p></div><p>一般 Promise 在执行过程中，必然会处于以下几种状态之一。</p><ul><li>待定（pending）：初始状态，既没有被完成，也没有被拒绝。</li><li>已完成（fulfilled）：操作成功完成。</li><li>已拒绝（rejected）：操作失败。<div class="note primary flat"><p>待定状态的promise对象指向的话，最后要么会通过一个值完成，要么会通过一个原因被拒绝。当其中一种情况发生的时候，我们用promise的then方法排列起来的相关处理程序就会被调用。因为最后<code>Promise.prototype.then</code> 和 <code>Promise.prototype.catch</code>方法返回的是一个<code>Promise</code>所以它们可以继续被链式调用。</p></div>关于 Promise 的状态流转情况，有一点值得注意的是，内部状态改变之后不可逆，你需要在编程过程中加以注意。文字描述比较晦涩，我们直接通过一张图就能很清晰地看出 Promise 内部状态流转的情况<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220405105526.png" alt=""><h2 id="then-catch"><a href="#then-catch" class="headerlink" title="then catch"></a>then catch</h2></li><li>thencatch都会返回一个新的promise</li><li>catch不管放在哪里都能捕获上层未捕获的错误</li><li>不写默认返回<code>return Promise.resolve(undefined)</code>也是成功回调</li><li>直接return 一个error对象不会抛出错误 所以不会被catch捕获</li><li>返回的值不能是promise本身 否则死循环</li><li>then可以接收两个参数的，在某些时候你可以认为catch是then第二个参数的简便写法。<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2></li><li>不管最后的状态如何都会执行</li><li>不接受任何参数 所以在finally中是没办法知道最终的状态的</li><li>默认返回上一次的promise对象值，如果抛出的是一个异常则返回异常的promise对象</li></ul><h2 id="new-Promise（大坑）"><a href="#new-Promise（大坑）" class="headerlink" title="new Promise（大坑）"></a><code>new Promise</code>（大坑）</h2><p>先看一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    reject()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;失败的状态&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><br>正确答案是1243<br>这是为什么呢？因为我们会忽略一个问题，就是在<code>new Promise</code>的时候，构造器的方法就已经开始执行了，虽然我们一般提倡用函数封装之后<code>return</code>出去这个promise对象。所以就是先执行<code>new Promise</code>里面的代码 输出12然后状态到<code>resolved</code>然后执行同步的4 最后因为成功的回调到3</p><h2 id="promise的静态方法"><a href="#promise的静态方法" class="headerlink" title="promise的静态方法"></a>promise的静态方法</h2><h3 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h3><ul><li>语法:<code>Promise.all(iterable)</code></li><li>参数：一个可迭代对象，例如Array（括号里面放数组）</li><li>描述：此方法对于汇总多个promise的结果很有用，在es6中可以将多个<code>Promise.all</code>异步请求并发操作，返回的结果一般有下面两种情况。<ol><li>当所有结果成功返回按照请求顺序返回成功结果</li><li>当其中一个方法失败就进入失败方法。</li></ol></li><li>业务场景 </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个页面中需要加载获取轮播列表、获取店铺列表、获取分类列表这三个操作，页面需要同时发出请求进行页面渲染，这样用 `Promise.all` 来实现，看起来更清晰、一目了然。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获取轮播数据列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBannerList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;轮播数据&#x27;</span>)</span><br><span class="line">      &#125;,<span class="number">300</span>) </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.获取店铺列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStoreList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">&#x27;店铺数据&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">500</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.获取分类列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCategoryList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">&#x27;分类数据&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">700</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initLoad</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">Promise</span>.all([getBannerList(),getStoreList(),getCategoryList()])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) </span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; </span><br><span class="line">initLoad()</span><br></pre></td></tr></table></figure><h4 id="all如果有一个抛出了异常会如何处理。"><a href="#all如果有一个抛出了异常会如何处理。" class="headerlink" title="all如果有一个抛出了异常会如何处理。"></a>all如果有一个抛出了异常会如何处理。</h4><div class="note primary flat"><p>all和race传入的数组中如果会有抛出异常的异步任务，那么只有最先抛出的错误会被捕获。并且是被then的第二个参数或者后面的catch捕获，但并不影响数组中其他的异步任务的执行。</p></div><h4 id="all是并发的还是串行的"><a href="#all是并发的还是串行的" class="headerlink" title="all是并发的还是串行的"></a>all是并发的还是串行的</h4><div class="note primary flat"><p>并发的。不过<code>promise.all().then()</code>结果中数组的顺序和<code>Promise.all()</code>接收到的数组顺序一致</p></div><h4 id="all的并发限制"><a href="#all的并发限制" class="headerlink" title="all的并发限制"></a>all的并发限制</h4><div class="note primary flat"><p>Promise.all可以保证，promises数组中所有promise对象都达到resolve状态，才执行then回调。</p><p>这时候考虑一个场景：如果你的promises数组中每个对象都是http请求，或者说每个对象包含了复杂的调用处理。而这样的对象有几十万个。</p><p>那么会出现的情况是，你在瞬间发出几十万http请求（tcp连接数不足可能造成等待），或者堆积了无数调用栈导致内存溢出。</p><p>这时候，我们就需要考虑对Promise.all做并发限制。</p><p>Promise.all并发限制指的是，每个时刻并发执行的promise数量是固定的，最终的执行结果还是保持与原来的Promise.all一致。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncPool</span>(<span class="params">poolLimit, array, iteratorFn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line">    <span class="keyword">const</span> executing = [];</span><br><span class="line">    <span class="keyword">const</span> enqueue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 边界处理，array为空数组</span></span><br><span class="line">        <span class="keyword">if</span> (i === array.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每调一次enqueue，初始化一个promise</span></span><br><span class="line">        <span class="keyword">const</span> item = array[i++];</span><br><span class="line">        <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> iteratorFn(item, array));</span><br><span class="line">        <span class="comment">// 放入promises数组</span></span><br><span class="line">        ret.push(p);</span><br><span class="line">        <span class="comment">// promise执行完毕，从executing数组中删除</span></span><br><span class="line">        <span class="keyword">const</span> e = p.then(<span class="function">() =&gt;</span> executing.splice(executing.indexOf(e), <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 插入executing数字，表示正在执行的promise</span></span><br><span class="line">        executing.push(e);</span><br><span class="line">        <span class="comment">// 使用Promise.rece，每当executing数组中promise数量低于poolLimit，就实例化新的promise并执行</span></span><br><span class="line">        <span class="keyword">let</span> r = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">        <span class="keyword">if</span> (executing.length &gt;= poolLimit) &#123;</span><br><span class="line">            r = <span class="built_in">Promise</span>.race(executing);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归，直到遍历完array</span></span><br><span class="line">        <span class="keyword">return</span> r.then(<span class="function">() =&gt;</span> enqueue());</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> enqueue().then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.all(ret));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allSettled方法"><a href="#allSettled方法" class="headerlink" title="allSettled方法"></a><code>allSettled</code>方法</h3><ul><li><code>Promise.allSettled</code>的语法及参数跟<code>Promise.all</code>类似.不同在于它执行完之后不会失败，会按顺序返回每个promise的状态</li><li>案例</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="built_in">Promise</span>.allSettled([resolved, rejected]);</span><br><span class="line">allSettledPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回结果：</span></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 2 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><h3 id="any方法-还在草案不能使用"><a href="#any方法-还在草案不能使用" class="headerlink" title="any方法(还在草案不能使用)"></a>any方法(还在草案不能使用)</h3><ul><li>语法：<code>Promise.any（iterable）</code></li><li>参数： iterable 可迭代的对象，例如 Array。</li><li>描述：any返回一个promise 只要参数promise实例中有一个变成fulfilled状态，最后any返回的实例就返回fulfilled状态，如果全部都是rejected，就返回rejected状态<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> anyPromise = <span class="built_in">Promise</span>.any([resolved, rejected]);</span><br><span class="line">anyPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回结果：</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="race方法"><a href="#race方法" class="headerlink" title="race方法"></a>race方法</h3><ul><li>语法：<code>Promise.race（iterable）</code></li><li>参数： iterable 可迭代的对象，例如 Array。</li><li>描述： race方法返回一个promise，只要参数的promise之中有一个实例率先改变状态，那么race方法的返回状态就跟着改变。那个率先改变的promise实例的返回值就传递给race方法的回调函数。</li><li>业务场景：图片加载 超时判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求某个图片资源</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestImg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; resolve(img); &#125;</span><br><span class="line">    img.src = <span class="string">&#x27;http://www.baidu.com/img/flexible/logo/pc/result.png&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//延时函数，用于给请求计时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; reject(<span class="string">&#x27;图片请求超时&#x27;</span>); &#125;, <span class="number">5000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([requestImg(), timeout()])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面的代码中可以看出，采用 Promise 的方式来判断图片是否加载成功，也是针对 Promise.race 方法的一个比较好的业务场</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220405111554.png" alt=""></p><h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><div class="note primary flat"><p>generator是es6新增的语法，和promise一样可以用来异步编程，最大的特点是它可以利用yield和next分段执行。</p></div><ul><li><code>function *foo(x)</code>使用<em>号来声明该函数是一个生成器函数，`</em>`的位置比较随意。</li><li><code>yield</code>关键字用来实现分段执行，它的意思是产出，当生成器函数遇到yield的时候会暂停并把他后面的表达式抛出去。（注意yield可以不写在生成器中）</li><li><code>next</code>表示将代码的控制权还给生成器函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = foo(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(it.next())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>过程：</p><ul><li>首先执行第一个next的时候传参会被忽略 因为赋值的时候已经传了参 所以参数就是5 且到第一个yield停止。返回后面的结果 就是6 此时x为5</li><li>来到第二个next 传入的参数覆盖上一次yield的结果 所以此时y为<code>12*2=24</code> 那么返回的结果就是8</li><li>第三个next 传入的参数覆盖上一次yield的结果 所以此时z为13 那么总体就是<code>5+24+13=42</code></li></ul><h2 id="简单实现generator"><a href="#简单实现generator" class="headerlink" title="简单实现generator"></a>简单实现generator</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cb 也就是编译过的 test 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generator</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> object = &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">stop</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = cb(object);</span><br><span class="line">        <span class="keyword">if</span> (ret === <span class="literal">undefined</span>) <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: ret,</span><br><span class="line">          <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果你使用 babel 编译后可以发现 test 函数变成了这样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="keyword">return</span> generator(<span class="function"><span class="keyword">function</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> ((_context.prev = _context.next)) &#123;</span><br><span class="line">        <span class="comment">// 可以发现通过 yield 将代码分割成几块</span></span><br><span class="line">        <span class="comment">// 每次执行 next 函数就执行一块代码</span></span><br><span class="line">        <span class="comment">// 并且表明下次需要执行哪块代码</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">          _context.next = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">          _context.next = <span class="number">6</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 执行完毕</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">          <span class="keyword">return</span> _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a><code>async/await</code></h1><div class="note primary flat"><p>Generator的语法糖，有更好的语义性和适用性，返回的是promise</p></div><ul><li>await和promise一样更多是笔试题</li><li>await相比直接使用promise来说 优势在于处理then的调用链，能够更清晰的写出代码。缺点在于await可能导致性能问题。因为await会阻塞代码。也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性，此时更应该使用<code>Promise.all</code></li><li>一个函数如果加上了async 那么就会返回一个promise<div class="note primary flat"><p><code>async =&gt; *</code> <code>await =&gt; yield</code></p></div>案例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + <span class="keyword">await</span> <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>, a) <span class="comment">// -&gt; &#x27;2&#x27; 10</span></span><br><span class="line">  a = (<span class="keyword">await</span> <span class="number">10</span>) + a</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>, a) <span class="comment">// -&gt; &#x27;3&#x27; 20</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>, a) <span class="comment">// -&gt; &#x27;1&#x27; 1</span></span><br></pre></td></tr></table></figure></li><li>首先函数b执行 但是遇到了<code>await</code>暂时返还了代码的控制权，所以到外面去执行了a++并输出a为1。</li><li>又因为await内部实现了generators，且它会保留堆栈中的东西，所以在返还之前的a=0被保留了下来。输出10 然后是20</li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><div class="note primary flat"><p>async/await的优势在于处理 then 的调用链，能够更清晰准确的写出代码，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。</p></div><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><div class="note primary flat"><p>首先js的任务分为同步任务和异步任务，异步中又分为宏任务和微任务，我们常见的settimeout，setinterval系列就是宏任务，promise，muationobserver系列就是微任务，微任务插队宏任务。</p></div><ul><li>默认代码从上到下执行，执行环境通过<code>script</code>来执行</li><li>代码执行过程中，先执行同步任务，再执行异步任务。</li><li>给异步任务划分队列，分别存在微任务（立即存放）和宏任务（时间到了或者事情发生了在存放）到队列中</li><li>script执行后清空所有微任务。</li><li>微任务执行完毕后渲染页面（不是每次都调用—）</li><li>再去宏任务队列中看看也没有到达时间的，拿出来其中一个执行。</li><li>执行完毕后按上述的步骤不停循环。<br>例子(UI渲染是宏任务)<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406095138.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406095150.png" alt=""><div class="note primary flat"><p>自动执行的情况 会输出 listener1 listener2 task1 task2</p></div><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406095222.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406100602.png" alt=""><div class="note primary flat"><p>如果手动点击click 会一个宏任务取出来一个个执行，先执行click的宏任务，取出微任务去执行。会输出 listener1 task1 listener2 task2</p></div></li></ul><p>案例1<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="comment">// await xx ==&gt; promise.resolve(()=&gt;&#123;console.log(3)&#125;).then()</span></span><br><span class="line">  <span class="comment">// console.log(3) 放到promise.resolve或立即执行</span></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="number">3</span>) </span><br><span class="line">  <span class="comment">// 相当于把console.log(4)放到了then promise.resolve(()=&gt;&#123;console.log(3)&#125;).then(()=&gt;&#123;</span></span><br><span class="line">  <span class="comment">//   console.log(4)</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line">  <span class="comment">// 微任务谁先注册谁先执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">  resolve(<span class="number">7</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">d</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(d)&#125;)</span><br><span class="line"></span><br><span class="line">asyncFunc()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 1 6 2 3 8 7 4 5</span></span><br></pre></td></tr></table></figure><br>案例2<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406101017.png" alt=""></p><h2 id="JS为什么是单线程？"><a href="#JS为什么是单线程？" class="headerlink" title="JS为什么是单线程？"></a>JS为什么是单线程？</h2><div class="note primary flat"><p>js的单线程和它的用途有关，作为浏览器脚本语言，JavaScript主要用途是与用户互动以及操作DOM。这决定了他只能是单线程，否则会带来很复杂的同步问题。比如假定js同时有两个线程，一个线程在某dom节点上添加内容，另外一个线程删除了节点。这个时候浏览器应该以哪个线程为准？所以为了避免复杂性，从一诞生，js就是单线程，这已经成为了这门语言的核心特征以后也不会改变。</p></div><h2 id="浏览器事件循环"><a href="#浏览器事件循环" class="headerlink" title="浏览器事件循环"></a>浏览器事件循环</h2><div class="note primary flat"><p>涉及面试题：异步代码的执行顺序？解释一下什么是Event Loop</p></div><ul><li>首先js是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来确保代码的有序进行。</li><li>在执行同步代码的时候，如果遇到了异步事件，js引擎并不会一致等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。</li><li>当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行</li><li>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行</li><li>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。<h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a><code>process.nextTick</code></h2><div class="note primary flat"><p><code>process.nextTick</code>指定的异步任务总是发生于所有异步任务之前。</p></div></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;);</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 2 5 4 3 1</span></span><br></pre></td></tr></table></figure><h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><ul><li><code>process.nextTick</code></li><li><code>promise</code></li><li><code>Object.observe</code></li><li><code>MutationObserver</code><h2 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h2></li><li><code>script</code></li><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code></li><li><code>I/O</code> 网络请求完成、文件读写完成事件</li><li><code>UI rendering</code></li><li>用户交互事件（比如鼠标点击、滚动页面、放大缩小等）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的JavaScript③--原型及周边</title>
    <link href="https://zlinni.github.io/posts/1060178397/"/>
    <id>https://zlinni.github.io/posts/1060178397/</id>
    <published>2022-04-20T07:01:39.000Z</published>
    <updated>2022-04-25T02:41:30.081Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><div class="note simple"><p>原型、原型链、继承</p></div><h1 id="原型、原型链"><a href="#原型、原型链" class="headerlink" title="原型、原型链"></a>原型、原型链</h1><p><code>__proto__</code>和prototype的关系：<code>__proto__</code>和<code>constructor</code>是对象独有的，<code>prototype</code>是函数独有的。</p><div class="note primary flat"><p>在js中我们使用构造函数来新建一个对象，每一个构造函数的内部都有一个prototype属性，这个属性是一个对象，这个对象包含了可以由该构造函数的所有实例共享的方法和属性。当我们使用构造函数新建一个对象之后，在这个对象的内部将包含一个指针，这个指针指向构造函数的prototype属性对应的值，在es5中这个指针被称为对象的原型。一般来说不能获取到这个值，但是浏览器下载都实现了<code>proto</code>属性让我们来访问，但是最好是不要使用这个属性，因为他不是规范的，最好使用<code>Object.getPrototypeOf()</code>来获取对象的原型</p></div><p>当我们访问一个对象的属性的时候，如果这个对象内部不存在这个属性，那么他就会去他的原型对象里面找这个属性，这个原型对象又会有自己的原型，于是就一直找下去，也就是原型链的概念。原型链的尽头一般来说是<code>Object.prototype</code>所以这就是我们新建的对象为什么能够使用<code>toString</code>等方法的原因</p><div class="note primary flat"><p>特点：js的对象都是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型的时候，与之相关的对象也会继承这一改变。</p></div><ul><li>原型，一个简单的对象，用于实现对象的属性继承。</li><li>构造函数 可以通过new来创建对象的一个函数</li><li>实例 通过构造函数和new创建出来的对象。通过<code>__proto__</code>指向原型，通过<code>constructor</code>指向构造函数。</li></ul><div class="note primary flat"><p>以<code>Object</code>为例，他是一个构造函数，因此可以用它创建实例</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>则此时， 实例为instance, 构造函数为Object，我们知道，构造函数拥有一个prototype的属性指向原型，因此原型为:</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型</span></span><br><span class="line"><span class="keyword">const</span> prototype = <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure><p>三者关系：</p><ul><li><code>实例.__proto__ === 原型</code></li><li><code>原型.constructor === 构造函数</code></li><li><code>构造函数.prototype = 原型</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402093146.png" alt=""></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><div class="note primary flat"><p>原型链是由原型对象组成，每个对象都有<code>__proto__</code>属性，指向了创建该对象的构造函数的原型。<code>__proto__</code>将对象连接起来组成了原型链，是一个用来实现继承和共享属性的有限的对象链。</p></div><ul><li>属性查找机制：当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象<code>Object.prototype</code>，如还是没找到，则输出<code>undefined</code>；</li><li>属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: <code>b.prototype.x = 2</code>；但是这样会造成所有继承于该对象的实例的属性发生改变。</li></ul><h2 id="js获取原型的方法"><a href="#js获取原型的方法" class="headerlink" title="js获取原型的方法"></a>js获取原型的方法</h2><ul><li><code>p.__proto__</code></li><li><code>p.constructor.prototype</code></li><li><code>Object.getPrototypeOf(p)</code></li></ul><p>另外：</p><ul><li>每个函数都有<code>prototype</code>属性，除了<code>Function.prototype.bind()</code> 该属性指向原型。</li><li>每个对象都有<code>__proto__</code>属性，指向了创建该对象的构造函数的原型</li><li>对象可以通过<code>__proto__</code>来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了原型链。</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402094159.png" alt=""><br><div class="note primary flat"><p>涉及面试题：原型如何实现继承？class如何实现继承？class本质</p></div><br>首先讲一下class，其实在js中不存在类，class只是语法糖，本质还是函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line">Person <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><div class="note primary flat"><p>组合继承是最常用的继承方式</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = value;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//通过call的方式来继承父类的属性(调用构造x1)</span></span><br><span class="line">    Parent.call(<span class="built_in">this</span>,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过改变子类的原型来继承父类的函数（x2 此时继承了构造函数，多了不必要的属性）</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> children = <span class="keyword">new</span> Child(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">children.getValue()</span><br><span class="line"><span class="built_in">console</span>.log(children <span class="keyword">instanceof</span> Parent)<span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>通过call来继承父类的属性，然后改变子类的原型来继承父类的函数。</li><li>优点：构造函数可以传参，不会和父类引用属性共享，可以复用父类的函数。</li><li>缺点：继承父类的时候调用了两次父类的构造函数，把父类不必要的属性也给继承了。内存上面浪费</li></ul><h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><div class="note primary flat"><p>这种方法对组合继承进行了优化，组合继承的缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点即可。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.val = value</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>,value);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype,&#123;</span><br><span class="line">  <span class="attr">constructor</span>:&#123;</span><br><span class="line">    <span class="attr">value</span>:Child,</span><br><span class="line">    <span class="attr">enumerable</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line">child.getValue();</span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Parent)</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>以上继承将父类的原型赋值给了子类，并且将构造函数设置成了子类，这样解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p></div><h2 id="Class继承"><a href="#Class继承" class="headerlink" title="Class继承"></a>Class继承</h2><div class="note primary flat"><p>以上两种方式都是通过原型去解决的，在es6中我们可以通过class去实现继承，并且实现起来很简单</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(value)</span><br><span class="line">    <span class="built_in">this</span>.val = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line">child.getValue();</span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Parent)</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>class实现继承的核心在于使用extends表明继承自哪个父类，并且在子类构造函数中必须调用super<br>super可以看作<code>Parent.call(this,value)</code></p></div><div class="note warning flat"><p>其实这样做还是有缺陷的，比如父类的静态方法还是不能继承。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寄生组合继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = value</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.val)</span><br><span class="line">&#125;</span><br><span class="line">Parent.staticMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是静态&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, value);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: Child,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line">child.getValue();</span><br><span class="line"><span class="comment">//Child.staticMethod()//报错</span></span><br><span class="line">Parent.staticMethod()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而class继承则可以<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">caseA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我是静态&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(value)</span><br><span class="line">    <span class="built_in">this</span>.val = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line">child.getValue();</span><br><span class="line">Child.caseA()</span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Parent)</span><br></pre></td></tr></table></figure></p><h2 id="其他继承"><a href="#其他继承" class="headerlink" title="其他继承"></a>其他继承</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的JavaScript②--this及周边</title>
    <link href="https://zlinni.github.io/posts/961371178/"/>
    <id>https://zlinni.github.io/posts/961371178/</id>
    <published>2022-04-20T07:01:23.000Z</published>
    <updated>2022-04-25T02:41:30.166Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><div class="note simple"><p>this关键字、apply/call/bind 原理、变量提升、执行上下文、作用域、闭包、new关键字</p></div><h1 id="This"><a href="#This" class="headerlink" title="This"></a><code>This</code></h1><div class="note primary flat"><p>this指向调用其的对象。顺带一提，es6中的箭头函数没有<code>this</code>,<code>argument</code>,<code>super</code>等。这些只依赖包含箭头函数最接近的函数。</p></div><div class="note primary flat"><p>先来看适用场景</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">foo()<span class="comment">//指向window window没有a 输出undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo() <span class="comment">//指向obj 输出2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> foo() <span class="comment">//指向c new绑定了c c没有a 输出undefined</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p>箭头函数中的this</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a()()())</span><br><span class="line"><span class="comment">//箭头函数的this指向第一个包含他的普通函数的this这里是window</span></span><br></pre></td></tr></table></figure><ul><li>另外对箭头函数使用bind这类函数是没有用的</li><li>那么说到bind 有没有考虑过一个函数多次bind的结果是什么？</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>) &#125;</span><br><span class="line">fn.bind().bind(a)() <span class="comment">// =&gt; window</span></span><br><span class="line"><span class="comment">//可以发现给函数bind几次 fn中的this永远由第一次bind决定</span></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="comment">// fn.bind().bind(a) 等于</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply()</span><br><span class="line">  &#125;.apply(a)</span><br><span class="line">&#125;</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>this的绑定优先级如下：<br><code>new</code>最高，然后是<code>bind</code>，之后是<code>obj.foo()</code> 最后是<code>foo()</code> 同时<code>this</code>一旦被绑定，就不会被任何方式改变。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220331091103.png" alt=""></p><p>因为满足不了业务需求 所以产生了三种方式让我们手动改变this的指向<code>call apply bind</code></p><h1 id="apply-call-bind-原理"><a href="#apply-call-bind-原理" class="headerlink" title="apply/call/bind 原理"></a>apply/call/bind 原理</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220331091536.png" alt=""></p><div class="note primary flat"><p>这三个方法都是挂载在Function对象上的三个方法，调用这三个方法的必须是一个函数。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func.call(thisArg, param1, param2, ...)</span><br><span class="line">func.apply(thisArg, [param1,param2,...])</span><br><span class="line">func.bind(thisArg, param1, param2, ...)</span><br></pre></td></tr></table></figure><ul><li>在浏览器中，全局范围内的this指向window对象</li><li>在函数中，this永远指向最后调用它的那个对象</li><li>构造函数中，this指向被new出来的新对象</li><li><code>call apply bind</code>中的this被强绑定在指定的那个对象上</li><li>箭头函数中的this比较特殊。箭头函数this作为父作用域的this，不是调用时的this，要知道前四种方式都是调用时确定，也就是动态的，然而箭头函数的this是静态的，声明的时候就确定了下来。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220331092027.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value)</span><br><span class="line">&#125;</span><br><span class="line">getValue.call(a, <span class="string">&#x27;poe&#x27;</span>, <span class="string">&#x27;24&#x27;</span>)</span><br><span class="line">getValue.apply(a, [<span class="string">&#x27;poe&#x27;</span>, <span class="string">&#x27;24&#x27;</span>])</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化</p></div><h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><div class="note primary flat"><p>用<code>Object.prototype.toStirng</code>来判断类型是最合适的，借用它我们几乎可以判断所有类型的数据。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="keyword">typeof</span> obj;</span><br><span class="line">  <span class="keyword">if</span>(type!==<span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).replace(<span class="regexp">/^$/</span>,<span class="string">&#x27;$1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类数组借用方法"><a href="#类数组借用方法" class="headerlink" title="类数组借用方法"></a>类数组借用方法</h2><div class="note primary flat"><p>var arrayLike = {<br>  0: ‘java’,<br>  1: ‘script’,<br>  length: 2<br>}<br>Array.prototype.push.call(arrayLike, ‘jack’, ‘lily’);<br>console.log(typeof arrayLike); // ‘object’<br>console.log(arrayLike);<br>// {0: “java”, 1: “script”, 2: “jack”, 3: “lily”, length: 4}</p></div><div class="note primary flat"><p>用call方法来借用Array原型链上面的push方法 实现一个类数组的push方法，给arrayLike添加元素</p></div><h2 id="获取数组最大值-最小值"><a href="#获取数组最大值-最小值" class="headerlink" title="获取数组最大值/最小值"></a>获取数组最大值/最小值</h2><div class="note primary flat"><p>我们可以用apply来实现数组中判断最大最小值，apply直接传递数组作为调用方法的参数。也可以减少一步展开数组，直接使用Math的方法来获取最大最小。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">13</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>];</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, arr); </span><br><span class="line"><span class="keyword">const</span> min = <span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, arr);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(max);  <span class="comment">// 16</span></span><br><span class="line"><span class="built_in">console</span>.log(min);  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h2 id="实现一个bind函数"><a href="#实现一个bind函数" class="headerlink" title="实现一个bind函数"></a>实现一个bind函数</h2><p>对于实现以下几个函数，可以从几个方面思考。</p><ul><li>不传入第一个参数，那么默认为window</li><li>改变了this指向，让新的对象可以执行该函数，那么思路是否可以变成给新的对象添加一个函数 最后执行完再删除。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否是new 是的话变成指向function 否则指向context</span></span><br><span class="line">        <span class="keyword">var</span> _this = <span class="built_in">this</span> <span class="keyword">instanceof</span> self ? <span class="built_in">this</span> : context;</span><br><span class="line">        <span class="comment">//改变f的原型链</span></span><br><span class="line">        F.prototype = self.prototype;</span><br><span class="line">        <span class="keyword">return</span> self.apply(_this, args.concat(...arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个call函数"><a href="#实现一个call函数" class="headerlink" title="实现一个call函数"></a>实现一个call函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(args)</span><br><span class="line">  <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个apply函数"><a href="#实现一个apply函数" class="headerlink" title="实现一个apply函数"></a>实现一个apply函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myapply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">Symbol</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line">    context[key] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> result = context[key](...args);</span><br><span class="line">    <span class="keyword">delete</span> context[key];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h1><div class="note primary flat"><p>当执行js代码的时候，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数的代码会产生函数执行环境，只此两种执行环境。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b() <span class="comment">// call b</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;Hello world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;call b&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>上面的输出是因为变量提升。通常的解释是声明的代码移动到顶部。但更准确的解释是，在生成执行环境时，会有两个阶段，一个是创建阶段:js解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为undefined，所以在第二个阶段，也就是代码执行阶段，我们可以提前使用。</p></div><ul><li>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b() <span class="comment">// call b second</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;call b fist&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;call b second&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;Hello world&#x27;</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p><code>var</code>会产生很多错误，所以在es6中引入了<code>let</code>，它不能在声明前使用，但并不是说它没有提升，他有提升，且也在声明的时候开辟了内存，但因为它的这个特性导致它不能在声明前使用。</p></div><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><div class="note primary flat"><p>当执行js代码的时候，会产生三种执行上下文</p></div><ul><li>全局执行上下文</li><li>函数执行上下文</li><li><code>eval</code>执行上下文</li></ul><div class="note primary flat"><p>每个执行上下文都有三种重要属性</p></div><ul><li>变量对象（VO),包含变量，函数声明和函数的形参，该属性只能在全局上下文中访问。</li><li>作用域链，js采用词法作用域链，也就是说变量的作用域是在定义的时候决定了。</li><li><code>this</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>对于上述代码代码中，执行栈中有两个上下文：全局上下文和函数foo上下文</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack = [</span><br><span class="line">    globalContext,</span><br><span class="line">    fooContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>对于全局上下文来说，VO大概是这样的</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">globalContext.VO === globe</span><br><span class="line">globalContext.VO = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="literal">undefined</span>,</span><br><span class="line"><span class="attr">foo</span>: &lt;<span class="built_in">Function</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>对于函数foo来说，VO不能访问，只能访问到活动对象AO</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fooContext.VO === foo.AO</span><br><span class="line">fooContext.AO &#123;</span><br><span class="line">    <span class="attr">i</span>: <span class="literal">undefined</span>,</span><br><span class="line"><span class="attr">b</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">arguments</span>: <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// arguments 是函数独有的对象(箭头函数没有)</span></span><br><span class="line"><span class="xml">// 该对象是一个伪数组，有 `length` 属性且可以通过下标访问元素</span></span><br><span class="line"><span class="xml">// 该对象中的 `callee` 属性代表函数本身</span></span><br><span class="line"><span class="xml">// `caller` 属性代表函数的调用者</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p>IIFE注意事项</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo = <span class="number">10</span></span><br><span class="line">    <span class="built_in">console</span>.log(foo)</span><br><span class="line">&#125;()) <span class="comment">// -&gt; ƒ foo() &#123; foo = 10 ; console.log(foo) &#125;</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p>js解释器在遇到IIFE的时候，会创建一个辅助的特定对象，然后将函数的名称（这里是foo）作为这个特定对象的属性。因此函数内部才可以访问到foo，但这个值是只读的，所以我们并不能修改 也不能像这样对他赋值改变，所以最后打印的还是这个函数，并且外部的值也没有改变</p></div><p>总结<br><div class="note primary flat"><p>执行上下文可以简单理解为一个对象</p></div></p><p>它包含三个部分</p><ul><li>变量对象VO</li><li>作用域链 词法作用域</li><li>this指向</li></ul><p>它的类型</p><ul><li>全局执行上下文</li><li>函数执行上下文</li><li><code>eval</code>执行上下文</li></ul><p>代码执行的过程</p><ul><li>创建全局执行上下文 （global EC）</li><li>全局执行上下文(caller)逐行 自上而下执行。遇到函数的时候，函数执行上下文(callee)被push到执行栈顶层</li><li>函数执行上下文被激活后，成为<code>active EC</code> 开始执行函数中的代码，<code>caller</code>被挂起</li><li>函数执行完后，<code>callee</code>被pop出执行栈，控制权还给全局上下文(caller)继续执行</li></ul><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><ul><li>作用域：作用域就是定义变量的区域，他有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找</li><li>作用域链：作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数</li></ul><div class="note primary flat"><p>作用域链本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象</p></div><ul><li>当我们查找一个变量的时候，如果在当前执行环境中没有找到，我们可以沿着作用域链向后查找</li><li>作用域链的创建过程和执行上下文的建立有关。</li></ul><div class="note primary flat"><p>作用域可以理解为变量的可访问性 总共分为三种类型 分别为：</p></div><ul><li>全局作用域</li><li>函数作用域</li><li>块级作用域</li></ul><h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><div class="note primary flat"><p>全局变量是挂载在window对象下的变量，所以在网页中的任何位置都可以使用并且访问到这个全局变量。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalName = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(globalName) <span class="comment">// global</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;inner&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(name) <span class="comment">// inner</span></span><br><span class="line">&#125; </span><br><span class="line">getName();</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// </span></span><br><span class="line"><span class="built_in">console</span>.log(globalName); <span class="comment">//global</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  vName = <span class="string">&#x27;setName&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">setName();</span><br><span class="line"><span class="built_in">console</span>.log(vName); <span class="comment">// setName</span></span><br></pre></td></tr></table></figure><ul><li>全局变量在什么地方可以被访问到</li><li>但是可能会引起命名冲突的问题，所以定义变量的时候注意作用域</li></ul><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><div class="note primary flat"><p>函数中定义的变量叫做函数变量，这个时候只有在函数内部才能访问到它，所以它的作用域也就是函数的内部称为函数作用域</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;inner&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">//inner</span></span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>除了这个函数内部，其他地方都是不能访问到它的，同时当这个函数被执行完之后，这个局部变量也会相应被销毁，所以外面访问不到这个局部变量</p></div><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><div class="note primary flat"><p>es6新增了块级作用域，直接的表现就是let关键字。使用它定义的变量只能在块级作用域中被访问。有暂时性死区的特点。也就是说这个变量在定义之前是不能被使用的。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//a is not defined</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&#x27;123&#x27;</span>；</span><br><span class="line">  <span class="built_in">console</span>.log(a)； <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//a is not defined</span></span><br><span class="line"><span class="comment">//如果这里是var 那么结果就是三个123</span></span><br></pre></td></tr></table></figure><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><div class="note primary flat"><p>闭包其实就是一个可以访问其他函数内部变量的函数。创建闭包的常见方式是在一个函数内创建另外一个函数，创建的函数可以访问到当前函数的局部变量。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br><span class="line"><span class="keyword">var</span> result = fun1();</span><br><span class="line">result();  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合闭包的概念，我们把这段代码放到控制台执行一下，就可以发现最后输出的结果是 1（即 a 变量的值）。那么可以很清楚地发现，a 变量作为一个 fun1 函数的内部变量，正常情况下作为函数内的局部变量，是无法被外部访问到的。但是通过闭包，我们最后还是可以拿到 a 变量的值</span></span><br></pre></td></tr></table></figure><h2 id="闭包的两个常用的用途"><a href="#闭包的两个常用的用途" class="headerlink" title="闭包的两个常用的用途"></a>闭包的两个常用的用途</h2><ul><li>闭包的第一个用途是使我们在函数外部能够访问到内部的变量。</li><li>另外一个用途是使得已经允许结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象 的引用，所以这个变量对象不会被回收。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// fn 是闭包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="comment">// 这里也是闭包</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn2 = fn1()</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure><h2 id="闭包产生的原因"><a href="#闭包产生的原因" class="headerlink" title="闭包产生的原因"></a>闭包产生的原因</h2><div class="note primary flat"><p>闭包产生的本质是：当前环境中存在指向父级作用域的引用。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">//2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fun2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = fun1();</span><br><span class="line">result();</span><br></pre></td></tr></table></figure><ul><li>在上面这段代码中，我们知道，result会拿到父级作用域的变量输出2。因为在当前的环境中，含有对fun2函数的引用，而fun2中又引用了window和fun1，fun2，那么此时fun2可以访问到fun1中的2 那么就输出2</li><li>那是不是只有返回函数才算是产生了闭包？其实不是，回到闭包的本质。我们只需要让父级作用域的引用存在即可。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun3;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  fun3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br><span class="line">fun3();</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>可以看出其中输出的结果还是2 因为在给fun3赋值的时候，fun3就可以访问到window fun1和本身的作用域，然后由下往上查找 找到了fun1中的2 输出2</p></div><p>结论：<br>不能通过最后有没有返回函数来判断闭包。</p><h2 id="闭包的表现形式"><a href="#闭包的表现形式" class="headerlink" title="闭包的表现形式"></a>闭包的表现形式</h2><ol><li>返回一个函数</li><li>在定时器，事件监听，ajax请求，webworkers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时器</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;，<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">$(<span class="string">&#x27;#app&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Event Listener&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>作为函数参数传递的形式<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(baz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 这就是闭包</span></span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 输出2，而不是1</span></span><br></pre></td></tr></table></figure></li><li>IIFE创建了闭包 保存了全局作用域window和当前函数的作用域。因此可以输出全局作用域的变量。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">// 输出2</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li></ol><div class="note primary flat"><p>IIFE 这个函数会稍微有些特殊，算是一种自执行匿名函数，这个匿名函数拥有独立的作用域。这不仅可以避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域，我们经常能在高级的 JavaScript 编程中看见此类函数。</p></div><h2 id="如何解决循环输出问题？"><a href="#如何解决循环输出问题？" class="headerlink" title="如何解决循环输出问题？"></a>如何解决循环输出问题？</h2><div class="note primary flat"><p>code如下</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现 最后的结果是五个6 那么为什么是五个6？如何实现输出12345？</p><ul><li>首先是事件循环机制 同步任务执行完之后再去执行任务栈中的宏任务微任务，settimeout是宏任务，因此循环结束后它的回调才依次执行。</li><li>因为settimeout是一种闭包，往上查找它的父级作用域是window，而变量i是var声明，是window对象上面的全局变量，所以开始执行settimeout的时候i已经是6了 所以最后连续输出的都是6</li></ul><div class="note primary flat"><p>那么如何依次输出12345呢？</p></div><ol><li>利用IIFE <div class="note primary flat"><p>可以利用IIFE 每次for循环的时候把此时的变量传递到定时器里面，然后执行。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>利用es6的let<div class="note primary flat"><p>let有块级作用域，代码以块级执行 相当于任务每次都是等待块级执行完再执行下一个块级</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>利用定时器传入第三个参数<div class="note primary flat"><p>定时器的第三个参数是传入的值，可以是一个function</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j)</span><br><span class="line">  &#125;, <span class="number">0</span>,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="New的原理"><a href="#New的原理" class="headerlink" title="New的原理"></a>New的原理</h1><h2 id="常见考点"><a href="#常见考点" class="headerlink" title="常见考点"></a>常见考点</h2><ul><li>new做了什么事情？</li><li>new返回不同的类型时有声明表现？</li><li>手写new的实现过程<div class="note primary flat"><p>new关键字的主要作用就是执行一个构造函数，返回一个实例对象，在new的过程中，根据构造函数的情况，来确定是否可以接收参数的传递。下面见例子。</p></div></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.log(p.name)  <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure><p>p是通过person这个构造函数生成的一个实例对象。</p><div class="note primary flat"><p>new可以帮助我们构建出一个实例，并且绑定上this，执行的步骤为以下：</p></div><ol><li>创建一个新的对象</li><li>将对象连接到构造函数原型上，并绑定this this指向新对象</li><li>执行构造函数的代码（为这个新对象添加属性）</li><li>返回新对象</li></ol><p>在第四步返回新对象的时候会有一个情况例外：<br><div class="note primary flat"><p>如果不用new关键字会怎么样？</p></div></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = Person();</span><br><span class="line"><span class="built_in">console</span>.log(p) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// &#x27;name&#x27; of undefined</span></span><br></pre></td></tr></table></figure><ul><li>从上面的代码可以看出，不用new 结果是undefined。因为默认情况下this指向window 所以name是Jack </li><li>那么如果构造函数中return一个对象，结果会是怎么样呢？</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&#x27;Jack&#x27;</span>; </span><br><span class="line">   <span class="keyword">return</span> &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.log(p)  <span class="comment">// &#123;age: 18&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p.age) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p>通过这段代码可以看出，当构造函数最后return出来的是一个和this无关的对象的时候，new会直接返回这个对象，而不是通过new执行步骤生成的this对象</p></div><p>但如果这里构造函数返回的不是一个对象 还是会按照new的原则返回新生成的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&#x27;Jack&#x27;</span>; </span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;tom&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.log(p)  <span class="comment">// &#123;name: &#x27;Jack&#x27;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p>总结：new关键字执行之后返回一个对象，要么是实例对象，要不是return语句指定的对象</p></div><h2 id="手写new的实现过程"><a href="#手写new的实现过程" class="headerlink" title="手写new的实现过程"></a>手写new的实现过程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">fn,...args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> fn != <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//我们知道obj.__proto__ = fn.prototype的</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">  <span class="keyword">var</span> res = fn.apply(obj,args);</span><br><span class="line">  <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用<code>Object.create</code>创建一个空对象并将obj的proto指定为构造函数原型</li><li>使用apply方法 将构造函数内的this指向为obj</li><li>在create返回的时候使用三目运算符决定返回结果</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>CSRF跨站点请求伪造</title>
    <link href="https://zlinni.github.io/posts/2161165336/"/>
    <id>https://zlinni.github.io/posts/2161165336/</id>
    <published>2022-04-20T06:53:53.000Z</published>
    <updated>2022-04-25T02:41:30.106Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>Web安全一直是老生常谈的一个问题，下面就讲解关于CSRF的内容<br>关键词：CSRF的由来、CSRF攻击流程、CSRF类型、CSRF特点、CSRF和XSS的区别、CSRF防御手段。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220420202734.png" alt=""></p><h1 id="CSRF是什么？"><a href="#CSRF是什么？" class="headerlink" title="CSRF是什么？"></a>CSRF是什么？</h1><p>跨站请求伪造（Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。如:攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><h1 id="CSRF攻击流程"><a href="#CSRF攻击流程" class="headerlink" title="CSRF攻击流程"></a>CSRF攻击流程</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220420160348.png" alt=""></p><p>综上所述，要想完成一次CSRF攻击，就要进行以下两个步骤：</p><ol><li>登陆受信任的网站A并在本地生成cookie</li><li>在没有登出a的情况下访问了b网站</li></ol><p>看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：</p><ol><li>你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。</li><li>你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）</li><li>上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</li></ol><h1 id="CSRF类型"><a href="#CSRF类型" class="headerlink" title="CSRF类型"></a>CSRF类型</h1><h2 id="GET类型"><a href="#GET类型" class="headerlink" title="GET类型"></a>GET类型</h2><p>只需要一个get请求<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;http://bank.example/withdraw?amount=10000&amp;for=hacker&quot;</span> &gt; </span><br></pre></td></tr></table></figure></p><p>受害者访问到这个页面的该img的时候就会向该链接发出一次HTTP请求。bankexample就会收到包含受害者登陆信息的一次跨域请求。</p><h2 id="POST类型"><a href="#POST类型" class="headerlink" title="POST类型"></a>POST类型</h2><p>这种类型的CSRF利用起来通常是一个自动提交的表单例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;form action=<span class="string">&quot;http://bank.example/withdraw&quot;</span> method=POST&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xiaoming&quot;</span> /&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;for&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="built_in">document</span>.forms[<span class="number">0</span>].submit(); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> </span><br></pre></td></tr></table></figure></p><p>访问该页面之后，表单会自动提交，相当于模拟用户完成了一次post操作。</p><p>post类型的攻击通常比get要求更严格一点，但是不复杂。任何个人网站，博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许post上面。</p><h2 id="链接类型的CSRF"><a href="#链接类型的CSRF" class="headerlink" title="链接类型的CSRF"></a>链接类型的CSRF</h2><p>链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况下，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常以比较夸张的词语诱骗用户点击eg<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker&quot;</span> taget=<span class="string">&quot;_blank&quot;</span>&gt;</span><br><span class="line">重磅消息！！</span><br><span class="line">&lt;a/&gt;</span><br></pre></td></tr></table></figure></p><h1 id="CSRF的特点"><a href="#CSRF的特点" class="headerlink" title="CSRF的特点"></a>CSRF的特点</h1><ul><li>攻击发生在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击利用受害在被攻击网站的登陆凭证，冒充受害者提交操作而不是直接窃取数据。</li><li>这个过程不能获取登陆凭证而是冒用</li><li>跨站请求可用各种方式：图片URL，超链接，CORS，form表单提交等等。部分请求可以直接嵌入在第三方论坛，文章中，难以进行跟踪。</li></ul><p>CSRF攻击通常是跨域的，因为外域更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下面进行，而且这种攻击更加危险。</p><h1 id="CSRF和XSS的区别"><a href="#CSRF和XSS的区别" class="headerlink" title="CSRF和XSS的区别"></a>CSRF和XSS的区别</h1><ul><li>通常来说CSRF是由XSS实现的，CSRF也时常被称为XSRF</li><li>本质上讲，XSS是代码问题，CSRF是HTTP问题。XSS是内容没有过滤导致浏览器将攻击者的输入当代码执行。CSRF则是因为，浏览器在发送请求的时候自动带上了cookie，而一般网站的session都存在cookie里面（token验证可以避免）</li></ul><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><ul><li>验证码：强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制csrf但用户体验不好。</li><li>Referer check：请求来源限制，此种方法成本最低，但并不能保证100%有效，因为服务器并不是什么时候都能取到referer，而且低版本的浏览器野村在伪造referer的风险</li><li>token；token验证的CSRF机制是公认最合适的方案。若网站存在XSS漏洞，这个方法也没有用。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="网络系列" scheme="https://zlinni.github.io/categories/%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="网络安全" scheme="https://zlinni.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>XSS跨站脚本攻击</title>
    <link href="https://zlinni.github.io/posts/3679159268/"/>
    <id>https://zlinni.github.io/posts/3679159268/</id>
    <published>2022-04-20T02:33:01.000Z</published>
    <updated>2022-04-25T02:41:30.111Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>Web安全一直是老生常谈的一个问题，下面就讲解关于XSS的内容<br>关键词：XSS的由来、XSS类型、XSS预防手段、XSS检测。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220420122304.png" alt=""></p><h1 id="XSS是什么？"><a href="#XSS是什么？" class="headerlink" title="XSS是什么？"></a>XSS是什么？</h1><p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击，攻击者通过在目标网站上面注入恶意的脚本，让其在用户的浏览器上面运行。利用这些脚本就能轻易获取到用户的cookie，sessionID等，产生进一步安全威胁。</p><p>在命名上为了和css区分，改为了xss</p><p>在处理输入的时候，以下内容不可信：</p><ul><li>来自用户的 UGC 信息</li><li>来自第三方的链接</li><li>URL 参数</li><li>POST 参数</li><li>Referer （可能来自不可信的来源）</li><li>Cookie （可能来自其他子域注入）</li></ul><h1 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h1><p>根据攻击来源，可以分为存储型，反射型和DOM型</p><h2 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h2><p>攻击流程：</p><ol><li>攻击者将恶意代码提交到网站的数据库中</li><li>用户响应服务端的恶意代码</li><li>恶意代码窃取用户敏感信息发送到攻击者网站，或冒充用户行为执行操作。</li></ol><p>常见场景：<br>论坛发帖，商品评论，用户私信</p><h2 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h2><p>攻击流程：</p><ol><li>攻击者构造出特殊的URL里面包含恶意代码</li><li>用户被诱导点击特殊URL，执行恶意操作。</li></ol><p>反射型和存储型的区别在于，一个是存在URL里面，一个是存在数据库里面。</p><p>常见场景：<br>网站搜索，跳转。</p><p>需要用户主动去点击，所以攻击者常有多种手段诱导用户点击。</p><p>另外注意POST也可以诱发反射型XSS，不过需要构建表单提交界面所以少见。</p><h2 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h2><p>攻击流程：</p><ol><li>攻击者构造出特殊的URL里面包含恶意代码</li><li>用户打开带有恶意代码的URL</li><li>浏览器执行恶意代码</li></ol><p>DOM型和前两种的区别在于，DOM型的攻击是由浏览器端完成的，属于js自身的漏洞，其他两种都是服务器端的安全漏洞</p><h1 id="XSS攻击预防"><a href="#XSS攻击预防" class="headerlink" title="XSS攻击预防"></a>XSS攻击预防</h1><p>上述了解到，XSS攻击有两种要素</p><ol><li>攻击者提交恶意代码</li><li>浏览器执行恶意代码</li></ol><p>针对第一个要素，有以下的防范措施</p><h2 id="输入过滤"><a href="#输入过滤" class="headerlink" title="输入过滤"></a>输入过滤</h2><p>前端过滤—&gt;后端？<br>不可行 绕过过滤，直接构造请求就可以提交了</p><p>数据库输入过滤—&gt;前端？<br>不一定可行。<br>eg 输入<code>5&lt;7</code> 在写入数据库前被转义成<code>5 &amp;lt; 7</code><br>问题是我们在提交阶段不清楚内容要输出到哪里。也就是意味着我们的内容</p><ol><li>用户提交到前端和客户端，经过了<code>escapeHTML()</code>转义，客户端就乱码了</li><li>前端不同地方需要的编码也不一样<ul><li>当 <code>5 &amp;lt; 7</code> 作为 HTML 拼接页面时，可以正常显示：</li><li>当作为AJAX返回的时候，这个内容要经过处理才可以显示。</li></ul></li></ol><p>所以在输入侧是可以解决这个问题但是有乱码和不确定性的问题，导致工程量加大。</p><p>输入侧不行就要通过浏览器来防范</p><ol><li>防止HTML注入</li><li>防止JS执行的时候执行恶意代码</li></ol><h2 id="预防存储型和反射型"><a href="#预防存储型和反射型" class="headerlink" title="预防存储型和反射型"></a>预防存储型和反射型</h2><p>存储型和反射型都是在服务端取出恶意代码后插入到HTML里，攻击者将数据内嵌到代码中，被浏览器执行</p><p>解决方法</p><ol><li>纯前端渲染，数据和代码隔离</li><li>对HTML做充分转义</li></ol><h3 id="纯前端渲染"><a href="#纯前端渲染" class="headerlink" title="纯前端渲染"></a>纯前端渲染</h3><p>过程：</p><ol><li>加载静态HTML，没有任何业务数据</li><li>浏览器执行HTML中的js代码</li><li>数据通过AJAX加载</li></ol><p>关键在于，我们要告诉浏览器下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。</p><div class="note warning flat"><p>注意避免DOM型XSS 比如onload事件和herf中的<code>javascript:xxx</code></p></div><p>在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。</p><h3 id="转义HTML"><a href="#转义HTML" class="headerlink" title="转义HTML"></a>转义HTML</h3><p>利用转义库来进行防护</p><h3 id="预防DOM型XSS"><a href="#预防DOM型XSS" class="headerlink" title="预防DOM型XSS"></a>预防DOM型XSS</h3><p>不要用<code>innerHTML</code>，<code>document.write</code>系列代码<br>用<code>textContent</code>,<code>setAttribute</code>系列代码</p><p>在vue/react中且不使用<code>v-html/dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML、outerHTML</code> 的 XSS 隐患。</p><p>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等<br>都能进行xss攻击，注意防范字符串拼接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 内联事件监听器中包含恶意代码 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onclick</span>=<span class="string">&quot;UNTRUSTED&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;UNTRUSTED&quot;</span> <span class="attr">src</span>=<span class="string">&quot;data:image/png,&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 链接内包含恶意代码 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;UNTRUSTED&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// setTimeout()/setInterval() 中调用恶意代码</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">setTimeout</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">setInterval</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// location 调用恶意代码</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">location.href = <span class="string">&#x27;UNTRUSTED&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// eval() 中调用恶意代码</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">eval</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="其他防范"><a href="#其他防范" class="headerlink" title="其他防范"></a>其他防范</h2><div class="note primary flat"><p>以下是一些通用方案</p></div><h3 id="Content-Security-Policy"><a href="#Content-Security-Policy" class="headerlink" title="Content Security Policy"></a>Content Security Policy</h3><p>严格的 CSP 在 XSS 的防范中可以起到以下的作用：</p><ul><li>禁止加载外域代码，防止复杂的攻击逻辑。</li><li>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。</li><li>禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。</li><li>禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。</li><li>合理使用上报可以及时发现 XSS，利于尽快修复问题。</li></ul><p>关于 CSP 的详情，请关注前端安全系列后续的文章。</p><h3 id="输入内容长度控制"><a href="#输入内容长度控制" class="headerlink" title="输入内容长度控制"></a>输入内容长度控制</h3><p>对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。</p><h3 id="其他安全措施"><a href="#其他安全措施" class="headerlink" title="其他安全措施"></a>其他安全措施</h3><ul><li>HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。</li><li>验证码：防止脚本冒充用户提交危险操作。</li></ul><h1 id="XSS检测"><a href="#XSS检测" class="headerlink" title="XSS检测"></a>XSS检测</h1><ol><li>使用通用 XSS 攻击字符串手动检测 XSS 漏洞。</li><li>使用扫描工具自动检测 XSS 漏洞。</li></ol><p>在<a href="https://github.com/0xsobky/HackVault/wiki/Unleashing-an-Ultimate-XSS-Polyglot">Unleashing an Ultimate XSS</a> Polyglot一文中，小明发现了这么一个字符串：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/0xsobky/HackVault/wiki/Unleashing-an-Ultimate-XSS-Polyglot</span></span><br></pre></td></tr></table></figure></p><p>它能够检测到存在于 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等多种上下文中的 XSS 漏洞，也能检测 <code>eval()、setTimeout()、setInterval()、Function()、innerHTML、document.write()</code> 等 DOM 型 XSS 漏洞，并且能绕过一些 XSS 过滤器。</p><p>小明只要在网站的各输入框中提交这个字符串，或者把它拼接到 URL 参数上，就可以进行检测了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//xxx/search?keyword=jaVasCript%3A%2F*-%2F*%60%2F*%60%2F*%27%2F*%22%2F**%2F(%2F*%20*%2FoNcliCk%3Dalert()%20)%2F%2F%250D%250A%250d%250a%2F%2F%3C%2FstYle%2F%3C%2FtitLe%2F%3C%2FteXtarEa%2F%3C%2FscRipt%2F--!%3E%3CsVg%2F%3CsVg%2FoNloAd%3Dalert()%2F%2F%3E%3E</span></span><br></pre></td></tr></table></figure><p>除了手动检测之外，还可以使用自动扫描工具寻找 XSS 漏洞，例如 <code>Arachni、Mozilla HTTP Observatory、w3af</code> 等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们回到最开始提出的问题，相信同学们已经有了答案：<br><div class="note primary flat"><p>XSS 防范是后端 RD 的责任，后端 RD 应该在所有用户提交数据的接口，对敏感字符进行转义，才能进行下一步操作。</p></div></p><p>不正确。因为：</p><p>防范存储型和反射型 XSS 是后端 RD 的责任。而 DOM 型 XSS 攻击不发生在后端，是前端 RD 的责任。防范 XSS 是需要后端 RD 和前端 RD 共同参与的系统工程。<br>转义应该在输出 HTML 时进行，而不是在提交用户输入时。</p><div class="note primary flat"><p>所有要插入到页面上的数据，都要通过一个敏感字符过滤函数的转义，过滤掉通用的敏感字符后，就可以插入到页面中。</p></div><p>不正确。<br>不同的上下文，如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等，所需要的转义规则不一致。<br>业务 RD 需要选取合适的转义库，并针对不同的上下文调用不同的转义规则。</p><p>整体的 XSS 防范是非常复杂和繁琐的，我们不仅需要在全部需要转义的位置，对数据进行对应的转义。而且要防止多余和错误的转义，避免正常的用户输入出现乱码。<br>虽然很难通过技术手段完全避免 XSS，但我们可以总结以下原则减少漏洞的产生：</p><ul><li>利用模板引擎<br>开启模板引擎自带的 HTML 转义功能。例如：<br>在 ejs 中，尽量使用 <code>&lt;%= data %&gt;</code>而不是 <code>&lt;%- data %&gt;</code>；<br>在 doT.js 中，尽量使用 <code>&#123;&#123;! data &#125;` 而不是` &#123;&#123;= data &#125;`；在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 `freemarker.core.OutputFormat`。* 避免内联事件尽量不要使用` onLoad="onload('&#123;&#123;data&#125;&#125;&#39;)&quot;</code>、<code>onClick=&quot;go(&#39;&#123;&#123;action&#125;&#125;&#39;)&quot;</code> 这种拼接内联事件的写法。在 JavaScript 中通过 <code>.addEventlistener()</code> 事件绑定会更安全。</li><li>避免拼接 HTML<br>前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 <code>createElement、setAttribute</code> 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。</li><li>时刻保持警惕<br>在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。</li><li>增加攻击难度，降低攻击后果<br>通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。</li><li>主动检测和发现<br>可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="网络系列" scheme="https://zlinni.github.io/categories/%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="网络安全" scheme="https://zlinni.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>春招落幕，暑期已至---日常篇①</title>
    <link href="https://zlinni.github.io/posts/308272463/"/>
    <id>https://zlinni.github.io/posts/308272463/</id>
    <published>2022-04-19T14:31:19.000Z</published>
    <updated>2022-04-25T02:41:30.122Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>emm,最近都在忙活八股算法,没什么时间去梳理一下最近发生的事情,以此来做个记录吧.</p></div><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>时至四月,春招可以说是完完全全的走掉了,这个春招里我就拿到过一个小厂的offer,由于自己自信后面能够拿到更好的就拒掉了(事实证明并没有),所以这段时间是没有好好把握住的,有点可惜.不过实际上八股文加算法总共的学习时间也就从3月份开始的一个半月,这一个半月的知识浓度比之前大特别多.每天都在消化吸收,挑战自己不熟练的,没有见过的一些新事物,比如算法,比如计网.这两个东西应该是很多人不想面对的吧.好在我坚持了下来,这段时间陆陆续续的刷了一百多道中等加简单难度的leetcode,感悟非常的深,其实部分算法题也不见得特别困难,可能是我做的难度原因.甚至有些题目能让我回想起以前OJ刷题时候的记忆,除开比较用智商的题目,大多数的题都有专门的方法去解决,也算是比较套路化.截到目前为止,我能罗列出来的算法有滑动窗口,动态规划,dfs,bfs,贪心,回溯以及部分排序,虽然不能说完全熟悉他的做题方法,但是碰到类似的题目也知道该用什么方法去解决了.算是这段时间的一点小进步.数据结构方面大概就是一些简单题显露出来的,常考的二叉树,链表,栈.这些题好像也会出现在面经中,但是基本不会出现在笔试中,经过前一段时间的笔试(腾讯+字节),深刻的明白了,动态规划和贪心才是笔试的重点,所以后面要多刷这方面的题目.</p><p>然后说一件比较痛苦的事情,就是字节的笔试用的是acm模式,导致数据没办法读出来,然后就寄掉了…</p><p>这段时间八股文方面写了JS的知识点总结,HTTP灵魂之问,Vue灵魂之问,手撕Javascript合集,其中特别有意思的是,在HTTP灵魂之问中,讲到数字证书和数字签名的这个部分,我居然和女朋友争辩了半个晚上才明白具体的原理,虽然大部分是我的问题,不过也算是一种收获了.写完了这些之后,特别是Vue的部分,因为没有手写源码的关系吧,其实对于他的面试题还是有点虚的,得多找些面经再补一补,最后感觉还是得根据一些点,细致的写一篇文章来理解.比如之后想写的关于Object的方法详解,数组api的方法详解,map和weakmap..等.但不知道排期到什么时候,毕竟人的消化吸收能力是有限的,目前我想先找到一份实习,空余之下再去补充这些知识点.</p><p>前不久还想着看webpack,但是冗长的网络视频让我失去了学习的兴趣,大致看了个开头到css抽离压缩的部分就没看下去了.虽然我也知道面试的时候会问相关的问题,只能说亡羊补牢吧,或者说面向面经学习.</p><p>现在的形式真是一言难尽啊,互联网大厂裁员,hc少,今年还是当初研究生扩招最大的一年,大家都抢着一个饭碗,导致旱的旱死涝的涝死,投出去的简历一封封也都石沉大海.远没有想到19年的疫情对我们而言影响这么大.</p><p>在牛客上面看到一个评论:”今年或许是往年来最差的一年,也有可能是今后最好的一年了”,大环境差表示我们要付出更多的努力才能换到成果了,加油吧打工人!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="日常杂谈" scheme="https://zlinni.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="日常" scheme="https://zlinni.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>手撕万物Javascript篇</title>
    <link href="https://zlinni.github.io/posts/972193328/"/>
    <id>https://zlinni.github.io/posts/972193328/</id>
    <published>2022-04-15T06:27:16.000Z</published>
    <updated>2022-04-28T10:22:07.815Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>本篇关于尽可能手撕一切可以实现的代码，先从js开始下手</p></div><h1 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h1><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,timer</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> t = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> firstClick = !t;</span><br><span class="line">    <span class="keyword">if</span>(firstClick)&#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    t = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      t = <span class="literal">null</span>;</span><br><span class="line">    &#125;, timer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> begin = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cur = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span>(cur-begin&gt;=delay)&#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">      begin = cur;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">oldObj,newObj=&#123;&#125;</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> oldObj) &#123;</span><br><span class="line">    newObj[item] = oldObj[item];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><h2 id="api版本"><a href="#api版本" class="headerlink" title="api版本"></a>api版本</h2><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringfy(oldObj));</span><br></pre></td></tr></table></figure></p><p>缺陷：</p><ul><li>无法实现对函数，正则等特殊对象的克隆</li><li>会抛弃对象的constructor,所有的构造函数会指向Object</li><li>对象有循环引用会报错</li></ul><h2 id="1-0版本"><a href="#1-0版本" class="headerlink" title="1.0版本"></a>1.0版本</h2><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断是否是引用类型或者null 否则返回源对象进行浅拷贝</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>||obj===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是数组，初始化地址。</span></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        result = [];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归调用 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            result[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p><h2 id="2-0版本-解决循环引用"><a href="#2-0版本-解决循环引用" class="headerlink" title="2.0版本 解决循环引用"></a>2.0版本 解决循环引用</h2><p>循环引用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">b</span>:<span class="number">122</span>&#125;;</span><br><span class="line">a.target = a;</span><br><span class="line">deepClone(obj);<span class="comment">//报错: RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure><br>先方法判断复杂类型<br>然后用map存储对象 如果已经存在则直接返回<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> judObj = (<span class="function">(<span class="params">target</span>)=&gt;</span>(<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>||<span class="keyword">typeof</span> target === <span class="string">&#x27;function&#x27;</span>)&amp;&amp; target!==<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">const</span> deepClone2 = (<span class="function">(<span class="params">target,map=<span class="keyword">new</span> <span class="built_in">Map</span>()</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(map.get(target))<span class="keyword">return</span> target;</span><br><span class="line">  <span class="keyword">if</span>(judObj(target))&#123;</span><br><span class="line">    map.set(target,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Array</span>.isArray(target)?[]:&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> target)&#123;</span><br><span class="line">      <span class="keyword">if</span>(target.hasOwnProperty(key))&#123;</span><br><span class="line">        res[key] = deepClone2(target[key],map);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//测试数据</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">val</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a.target = a;</span><br><span class="line"><span class="keyword">let</span> newA = deepClone2(a);</span><br><span class="line"><span class="built_in">console</span>.log(newA)<span class="comment">//&#123; val: 2, target: &#123; val: 2, target: [Circular] &#125; &#125;</span></span><br></pre></td></tr></table></figure></p><p>but存在一个潜在的问题，就是map上的key和map构成了强引用关系，是很危险的。<br>科普强引用和弱引用的关系<br><div class="note primary flat"><p>被弱引用的对象在什么时候都可以被回收，但强引用的不行，上面的代码在程序结束之前都不会释放a的空间</p></div></p><p>所以需要用到weekMap构成弱引用，把Map改成weekMap即可</p><h2 id="拷贝特殊对象"><a href="#拷贝特殊对象" class="headerlink" title="拷贝特殊对象"></a>拷贝特殊对象</h2><p>特殊对象<br>可遍历的特殊对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;object Map&quot;</span>]</span><br><span class="line">[<span class="string">&quot;object Set&quot;</span>]</span><br><span class="line">[<span class="string">&quot;object Array&quot;</span>]</span><br><span class="line">[<span class="string">&quot;object Object&quot;</span>]</span><br><span class="line">[<span class="string">&quot;object Arguments&quot;</span>]</span><br></pre></td></tr></table></figure><br>不可遍历的特殊对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> boolTag = <span class="string">&#x27;[object Boolean]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">&#x27;[object Number]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">&#x27;[object String]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">&#x27;[object Date]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">&#x27;[object Error]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">&#x27;[object RegExp]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">&#x27;[object Function]&#x27;</span>;</span><br></pre></td></tr></table></figure><br>用最准确的那个方法判断<br>然后对于不能遍历的对象直接返回<br>对于能遍历的对象分类<br>如果是map的话 foreach 他的item和index赋值<br>如果是set foreach 他的item<br>其他的数组和对象 就直接用之前的方法遍历递归<br>注意要保留对象的原型<br>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> judObj = (<span class="function">(<span class="params">target</span>)=&gt;</span>(<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>||<span class="keyword">typeof</span> target === <span class="string">&#x27;function&#x27;</span>)&amp;&amp; target!==<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getObj = (<span class="function">(<span class="params">target</span>)=&gt;</span><span class="built_in">Object</span>.prototype.toString.call(target));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canTranverse = &#123;</span><br><span class="line">    <span class="string">&#x27;[object Map]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Set]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Array]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Object]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Arguments]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone3 = (<span class="function">(<span class="params">target,map=<span class="keyword">new</span> <span class="built_in">Map</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!judObj)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> type = getObj(target);</span><br><span class="line">    <span class="keyword">let</span> cloneTarget;</span><br><span class="line">    <span class="keyword">if</span>(!canTranverse[type])&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> ctor = target.prototype;</span><br><span class="line">        cloneTarget = <span class="keyword">new</span> ctor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(map.get(cloneTarget))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        map.set(cloneTarget,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(type === <span class="string">&#x27;[object Map]&#x27;</span>)&#123;</span><br><span class="line">        target.forEach(<span class="function">(<span class="params">item,index</span>) =&gt;</span> &#123;</span><br><span class="line">            cloneTarget.set(deepClone3(item),deepClone3(index));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">&#x27;[object Set]&#x27;</span>)&#123;</span><br><span class="line">        target.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">            cloneTarget.add(deepClone3(item));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">                cloneTarget[key] = deepClone3(target[key],map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="3-0-final"><a href="#3-0-final" class="headerlink" title="3.0 final"></a>3.0 final</h2><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getType = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isObject = <span class="function">(<span class="params">target</span>) =&gt;</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> target === <span class="string">&#x27;function&#x27;</span>) &amp;&amp; target !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canTraverse = &#123;</span><br><span class="line">  <span class="string">&#x27;[object Map]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;[object Set]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;[object Array]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;[object Object]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;[object Arguments]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> mapTag = <span class="string">&#x27;[object Map]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">&#x27;[object Set]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">&#x27;[object Boolean]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">&#x27;[object Number]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">&#x27;[object String]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">&#x27;[object Symbol]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">&#x27;[object Date]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">&#x27;[object Error]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">&#x27;[object RegExp]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">&#x27;[object Function]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleRegExp = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; source, flags &#125; = target;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> target.constructor(source, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleFunc = <span class="function">(<span class="params">func</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 箭头函数直接返回自身</span></span><br><span class="line">  <span class="keyword">if</span>(!func.prototype) <span class="keyword">return</span> func;</span><br><span class="line">  <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>;</span><br><span class="line">  <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span>;</span><br><span class="line">  <span class="keyword">const</span> funcString = func.toString();</span><br><span class="line">  <span class="comment">// 分别匹配 函数参数 和 函数体</span></span><br><span class="line">  <span class="keyword">const</span> param = paramReg.exec(funcString);</span><br><span class="line">  <span class="keyword">const</span> body = bodyReg.exec(funcString);</span><br><span class="line">  <span class="keyword">if</span>(!body) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (param) &#123;</span><br><span class="line">    <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(...paramArr, body[<span class="number">0</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(body[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleNotTraverse = <span class="function">(<span class="params">target, tag</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> Ctor = target.constructor;</span><br><span class="line">  <span class="keyword">switch</span>(tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> boolTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Boolean</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> numberTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Number</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> stringTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">String</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> symbolTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> errorTag: </span><br><span class="line">    <span class="keyword">case</span> dateTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">    <span class="keyword">case</span> regexpTag:</span><br><span class="line">      <span class="keyword">return</span> handleRegExp(target);</span><br><span class="line">    <span class="keyword">case</span> funcTag:</span><br><span class="line">      <span class="keyword">return</span> handleFunc(target);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!isObject(target)) </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  <span class="keyword">let</span> type = getType(target);</span><br><span class="line">  <span class="keyword">let</span> cloneTarget;</span><br><span class="line">  <span class="keyword">if</span>(!canTraverse[type]) &#123;</span><br><span class="line">    <span class="comment">// 处理不能遍历的对象</span></span><br><span class="line">    <span class="keyword">return</span> handleNotTraverse(target, type);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这波操作相当关键，可以保证对象的原型不丢失！</span></span><br><span class="line">    <span class="keyword">let</span> ctor = target.constructor;</span><br><span class="line">    cloneTarget = <span class="keyword">new</span> ctor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(map.get(target)) </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  map.set(target, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(type === mapTag) &#123;</span><br><span class="line">    <span class="comment">//处理Map</span></span><br><span class="line">    target.forEach(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.set(deepClone(key, map), deepClone(item, map));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(type === setTag) &#123;</span><br><span class="line">    <span class="comment">//处理Set</span></span><br><span class="line">    target.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.add(deepClone(item, map));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理数组和对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">        cloneTarget[prop] = deepClone(target[prop], map);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="实现发布订阅EventEmitter"><a href="#实现发布订阅EventEmitter" class="headerlink" title="实现发布订阅EventEmitter"></a>实现发布订阅EventEmitter</h1><p>订阅 取消 只能订阅一次 触发<br>代码如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.event = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">type,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.event)<span class="built_in">this</span>.event = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.event[type])&#123;</span><br><span class="line">      <span class="built_in">this</span>.event[type]=[callback]</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.event[type].push(callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">type,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.event)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">this</span>.event[type] = <span class="built_in">this</span>.event[type].find(<span class="function"><span class="params">item</span>=&gt;</span>item!==callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">once</span>(<span class="params">type,callback</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      callback();</span><br><span class="line">      <span class="built_in">this</span>.off(type,fn); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.on(type,fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">type,...args</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.event[type]&amp;&amp;<span class="built_in">this</span>.event[type].forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn.apply(<span class="built_in">this</span>,args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p>原理 找到实例对象的原型然后不断往上查找,如果和类实例的原型相同则为真,如果是null则为假<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myinstanceof</span>(<span class="params">example,classFunc</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(example);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(proto===<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span>(proto===classFunc.prototype)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      proto = <span class="built_in">Object</span>.getPrototypeOf(proto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><p>模拟new就要知道new操作符做了什么事情</p><ul><li>将对象的隐式原型指向构造函数的原型prototype</li><li>执行构造函数，使用call/apply改变this指向</li><li>返回值为object类型则作为new方法的返回值返回，否则返回上述全新对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mynew</span>(<span class="params">fn,...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">    <span class="keyword">let</span> res = fn.apply(instance,args);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span>?res:instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="call"><a href="#call" class="headerlink" title="call"></a>call</h1><p>call不传入参数则默认绑定的window<br>新建函数将函数设置当前this<br>然后删除该函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用法：f.call(obj,arg1)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">f.myCall(obj, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">//否则this指向window</span></span><br></pre></td></tr></table></figure></p><h1 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h1><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myapply = <span class="function"><span class="keyword">function</span>(<span class="params">context,args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">Symbol</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line">    context[key] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> res = context[key](...args);</span><br><span class="line">    <span class="keyword">delete</span> context[key];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否是new 是的话变成指向function 否则指向context</span></span><br><span class="line">        <span class="keyword">var</span> _this = <span class="built_in">this</span> <span class="keyword">instanceof</span> self ? <span class="built_in">this</span> : context;</span><br><span class="line">        <span class="comment">//改变f的原型链</span></span><br><span class="line">        F.prototype = self.prototype;</span><br><span class="line">        <span class="keyword">return</span> self.apply(_this, args.concat(...arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">proto</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    F.prototype = proto;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><h1 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a><code>Promise.resolve</code></h1><ol><li>值是promise对象则直接返回</li><li>返回一个new promise且如果他是then调用，则返回then方法</li><li>其他情况，返回成功状态的promise<br>code<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. promise return</span></span><br><span class="line"><span class="comment">// =&gt; new promise</span></span><br><span class="line"><span class="comment">// 2. param.then === &#x27;fun&#x27;</span></span><br><span class="line"><span class="comment">// =&gt; param.then(res,rej)</span></span><br><span class="line"><span class="comment">// 3. return resolve(param) </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve = (<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (param <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) <span class="keyword">return</span> param;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (param &amp;&amp; param.then &amp;&amp; <span class="keyword">typeof</span> param.then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> param.then(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> resolve(param)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h1 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a><code>Promise.reject</code></h1><p>reject传入的参数会作为一个reason原封不动的往下传<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a><code>Promise.prototype.finally</code></h1><p>不管状态如何都会执行并且往下传值.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve((cb()).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;,<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve((cb()).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a><code>Promise.all</code></h1><p>code如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.myall = <span class="function"><span class="keyword">function</span>(<span class="params">iterable</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">//传入的是可迭代对象</span></span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">//这里不一定是数组,不一定有length,所以要变量计算.</span></span><br><span class="line">      <span class="keyword">let</span> elementCount = <span class="number">0</span>; <span class="comment">//解决的promise数量</span></span><br><span class="line">      <span class="keyword">let</span> anErrorOccurred = <span class="literal">false</span>;<span class="comment">//判断是否错误</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> promise <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">            <span class="keyword">const</span> curIndex = index; <span class="comment">//封闭index的作用域</span></span><br><span class="line">            promise.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(anErrorOccurred)<span class="keyword">return</span>;</span><br><span class="line">                result[curIndex] = value;</span><br><span class="line">                elementCount++;</span><br><span class="line">                <span class="keyword">if</span>(elementCount === result.length)&#123;</span><br><span class="line">                    resolve(result)<span class="comment">//如果全部任务都成功,返回数组</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(anErrorOccurred)<span class="keyword">return</span>;</span><br><span class="line">                anErrorOccurred=<span class="literal">true</span>;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;)</span><br><span class="line">            index++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(index === <span class="number">0</span>)&#123;</span><br><span class="line">          resolve([]);<span class="comment">//长度是0 返回空数组</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(index);<span class="comment">//要在最后写result 因为index是在循环后才计算出来.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a><code>Promise.race</code></h1><p>race方法只要有一个率先改变了状态,后面就直接resolve<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.myrace = <span class="function"><span class="keyword">function</span> (<span class="params">iterable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> settlementOccurred = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> promise <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (settlementOccurred) <span class="keyword">return</span>;</span><br><span class="line">      settlementOccurred = <span class="literal">true</span>;</span><br><span class="line">      resolve(value);<span class="comment">//直接resolve</span></span><br><span class="line">    &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (settlementOccurred) <span class="keyword">return</span>;</span><br><span class="line">      settlementOccurred = <span class="literal">true</span>;</span><br><span class="line">      reject(err);<span class="comment">//直接reject</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a><code>Promise.allSettled</code></h1><p>执行完后不会失败,按顺序返回每个promise状态<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="built_in">Promise</span>.allSettled([resolved, rejected]);</span><br><span class="line">allSettledPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回结果：</span></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 2 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure></p><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.allSettled = <span class="function"><span class="keyword">function</span> (<span class="params">promiseArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!promiseArgs.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve([]);</span><br><span class="line">  <span class="comment">// 包装不是promise的项</span></span><br><span class="line">  <span class="keyword">const</span> promises = promiseArgs.map(<span class="function"><span class="params">p</span> =&gt;</span> p <span class="keyword">instanceof</span> <span class="built_in">Promise</span> ? p : <span class="built_in">Promise</span>.resolve(p));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> unSettledCount = promises.length;</span><br><span class="line">    promises.forEach(<span class="function">(<span class="params">p, index</span>) =&gt;</span> &#123;</span><br><span class="line">      p.then(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        res[index] = &#123;</span><br><span class="line">          <span class="attr">status</span>: <span class="string">&quot;resolve&quot;</span>,</span><br><span class="line">          reason</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        res[index] = &#123;</span><br><span class="line">          <span class="attr">status</span>: <span class="string">&quot;reject&quot;</span>,</span><br><span class="line">          reason</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        --unSettledCount;</span><br><span class="line">        <span class="keyword">if</span> (!unSettledCount) <span class="keyword">return</span> resolve(res);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Promise-retry超时请求"><a href="#Promise-retry超时请求" class="headerlink" title="Promise.retry超时请求"></a>Promise.retry超时请求</h1><p>简易版<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.retrySimple = <span class="function"><span class="keyword">function</span> (<span class="params">fn, maxRetry, timeout</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Expected a function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  maxRetry = maxRetry || <span class="number">3</span>;</span><br><span class="line">  timeout = timeout || <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> retryCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn().then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">      &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retryCount &gt;= maxRetry) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">setTimeout</span>(run,timeout);</span><br><span class="line">        retryCount++;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    run();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有缓存版<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整版 - 有缓存</span></span><br><span class="line"><span class="built_in">Promise</span>.retry = <span class="function"><span class="keyword">function</span> (<span class="params">fn, options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 参数检查</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Expected a function&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    options = options || &#123;&#125;;</span><br><span class="line">    <span class="comment">// 默认参数</span></span><br><span class="line">    options = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">        <span class="attr">maxRetry</span>: <span class="number">3</span>, <span class="comment">// 默认重试次数</span></span><br><span class="line">        <span class="attr">retryDelay</span>: <span class="number">1000</span>, <span class="comment">// 默认重试时间间隔</span></span><br><span class="line">        <span class="attr">cache</span>: <span class="literal">false</span>, <span class="comment">// 是否缓存结果</span></span><br><span class="line">        <span class="attr">cacheKey</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 缓存 key</span></span><br><span class="line">        <span class="attr">cacheExpire</span>: <span class="number">0</span>, <span class="comment">// 缓存过期时间，单位：毫秒</span></span><br><span class="line">        <span class="attr">cacheMax</span>: <span class="number">0</span> <span class="comment">// 缓存最大值，超过后清空缓存</span></span><br><span class="line">    &#125;, options);</span><br><span class="line">    <span class="keyword">let</span> retryCount = <span class="number">0</span>; <span class="comment">// 已重试次数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 内部函数，进行一次尝试</span></span><br><span class="line">        <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn().then(</span><br><span class="line">                <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 成功收到响应，如果需要缓存，则缓存结果，同时设置缓存过期时间</span></span><br><span class="line">                    <span class="keyword">if</span> (options.cache) &#123;</span><br><span class="line">                        <span class="built_in">localStorage</span>.setItem(options.cacheKey, <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">                            value,</span><br><span class="line">                            <span class="attr">expire</span>: <span class="built_in">Date</span>.now() + options.cacheExpire</span><br><span class="line">                        &#125;));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 封装的 promise 解决</span></span><br><span class="line">                    resolve(value);</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 超过了最大重试次数，拒绝</span></span><br><span class="line">                    <span class="keyword">if</span> (retryCount &gt;= options.maxRetry) &#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 没有超过重试次数，如果有缓存，则读取缓存</span></span><br><span class="line">                    <span class="keyword">if</span> (options.cache) &#123;</span><br><span class="line">                        <span class="keyword">const</span> cache = <span class="built_in">localStorage</span>.getItem(options.cacheKey);</span><br><span class="line">                        <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">                            <span class="keyword">const</span> cacheObj = <span class="built_in">JSON</span>.parse(cache);</span><br><span class="line">                            <span class="keyword">if</span> (cacheObj.expire &gt; <span class="built_in">Date</span>.now()) &#123;</span><br><span class="line">                                resolve(cacheObj.value);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 重试</span></span><br><span class="line">                    <span class="built_in">setTimeout</span>(run, options.retryDelay);</span><br><span class="line">                    retryCount++;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">        run();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="解析URL-Params对象"><a href="#解析URL-Params对象" class="headerlink" title="解析URL Params对象"></a>解析URL Params对象</h1><h1 id="实现JS函数柯里化"><a href="#实现JS函数柯里化" class="headerlink" title="实现JS函数柯里化"></a>实现JS函数柯里化</h1><div class="note primary flat"><p>柯里化的定义：接收一部分参数，返回一个函数接收剩余参数，接收足够参数后，返回原函数。</p></div><p>思路如下：</p><ol><li>利用length属性获取函数的形参个数</li><li>手动指定需要的形参个数</li></ol><p>ES5版本（涉及到arguments的es5转换法）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mycurry</span>(<span class="params">fn,args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = fn.length;</span><br><span class="line">    <span class="keyword">var</span> args = args || [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//arguments的逐次分割</span></span><br><span class="line">        <span class="keyword">var</span> newArgs = args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="comment">//不满足携带newArgs递归</span></span><br><span class="line">        <span class="keyword">if</span>(newArgs.length&lt;len)&#123;</span><br><span class="line">            <span class="keyword">return</span> mycurry.call(<span class="built_in">this</span>,fn,newArgs);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//满足直接返回</span></span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>,newArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiFn</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b*c</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = mycurry(multiFn);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>,<span class="number">3</span>)(<span class="number">4</span>))</span><br></pre></td></tr></table></figure></p><p>ES6版本<br>es6可以直接用拓展运算符所以会写起来简单一点<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h1><p>要求：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>],<span class="number">5</span>],<span class="number">6</span>]</span><br><span class="line">=&gt;</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p><p>方法1：api版本<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>],<span class="number">5</span>],<span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="literal">Infinity</span>))</span><br></pre></td></tr></table></figure></p><p>方法2：reduce<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>],<span class="number">5</span>],<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre.concat(cur <span class="keyword">instanceof</span> <span class="built_in">Array</span>?flatten(cur):cur);</span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br></pre></td></tr></table></figure></p><p>方法3：转字符串<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>],<span class="number">5</span>],<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr = arr.join(<span class="string">&quot;,&quot;</span>).split(<span class="string">&quot;,&quot;</span>).map(<span class="function"><span class="params">item</span>=&gt;</span>~~item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br></pre></td></tr></table></figure></p><h1 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h1><p>要求：可以传入数组或者对象，编写一个myURLSearchParams类，包含get，set，has，append<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;foo=1&amp;bar=2&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&quot;2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(searchParams.get(<span class="string">&quot;foo&quot;</span>)) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(searchParams2.get(<span class="string">&quot;foo&quot;</span>)) <span class="comment">//1</span></span><br><span class="line">searchParams.set(<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;33&quot;</span>); </span><br><span class="line">searchParams2.set(<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;33&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(searchParams) <span class="comment">//&#123; url: &#x27;foo=33&amp;bar=2&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(searchParams2) <span class="comment">//&#123; url: &#123; foo: &#x27;33&#x27;, bar: &#x27;2&#x27; &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(searchParams.has(<span class="string">&quot;foo&quot;</span>)) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(searchParams2.has(<span class="string">&quot;foo&quot;</span>)) <span class="comment">//true</span></span><br><span class="line">searchParams.append(<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;3casc3&quot;</span>); <span class="comment">//&#123; url: &#x27;foo=33&amp;bar=2&amp;foo=3casc3&#x27; &#125;</span></span><br><span class="line">searchParams2.append(<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;3casc3&quot;</span>); <span class="comment">// url: &#123; foo: &#x27;3casc3&#x27;, bar: &#x27;2&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure></p><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myURLSearchParams</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">url</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.url <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.url[target]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> arr = <span class="built_in">this</span>.url.split(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">                <span class="keyword">let</span> [key, val] = item.split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (key === target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> val;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">append</span>(<span class="params">key,value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.url <span class="keyword">instanceof</span> <span class="built_in">Object</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.url[key] = value;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.url+=(<span class="string">&quot;&amp;&quot;</span>+key+<span class="string">&quot;=&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">key,value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.url <span class="keyword">instanceof</span> <span class="built_in">Object</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.url[key] = value;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> arr = <span class="built_in">this</span>.url.split(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">                <span class="keyword">let</span> [keys, val] = item.split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (keys === key) &#123;</span><br><span class="line">                    <span class="keyword">let</span> rep = <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;val&#125;</span>`</span></span><br><span class="line">                    <span class="keyword">let</span> rep2 = <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;value&#125;</span>`</span></span><br><span class="line">                    <span class="built_in">this</span>.url = <span class="built_in">this</span>.url.replace(rep,rep2)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.url <span class="keyword">instanceof</span> <span class="built_in">Object</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.url[target]?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.url.match(target)?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> searchParams = <span class="keyword">new</span> myURLSearchParams(<span class="string">&quot;foo=1&amp;bar=2&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> searchParams2 = <span class="keyword">new</span> myURLSearchParams(&#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&quot;2&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h1 id="删除指定的URL中的某个参数"><a href="#删除指定的URL中的某个参数" class="headerlink" title="删除指定的URL中的某个参数"></a>删除指定的URL中的某个参数</h1><p>需求：删除URL中的某个参数并且确保没有重复的出现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> query = <span class="string">&#x27;https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;key2=99&amp;key2=99&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myQueryDelete</span>(<span class="params">query,target</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> queryArr = query.split(<span class="string">&quot;?&quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(queryArr)</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> len = queryArr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> queryArr) &#123;</span><br><span class="line">        <span class="keyword">let</span> [key,value] = item.split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(key === target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index===len)&#123;</span><br><span class="line">                query = query.replace(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;value&#125;</span>`</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                query = query.replace(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;value&#125;</span>&amp;`</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(query[query.length-<span class="number">1</span>]===<span class="string">&#x27;&amp;&#x27;</span>)&#123;</span><br><span class="line">        query = query.slice(<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(query)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myQueryDelete(query,<span class="string">&quot;key2&quot;</span>)</span><br><span class="line"><span class="comment">//https://www.baidu.com/s?ie=utf-8&amp;f=8</span></span><br></pre></td></tr></table></figure></p><h1 id="js生成二叉树"><a href="#js生成二叉树" class="headerlink" title="js生成二叉树"></a>js生成二叉树</h1><p>需求：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> testData = [&#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">parent</span>: <span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">parent</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">parent</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">parent</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="attr">parent</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">parent</span>: -<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line">转二叉结构</span><br></pre></td></tr></table></figure></p><p>code如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toTree = (<span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        map[item.id] = &#123;</span><br><span class="line">            ...item,</span><br><span class="line">            <span class="attr">children</span>: []</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">let</span> id = item.id;</span><br><span class="line">        <span class="keyword">let</span> pid = item.parent;</span><br><span class="line">        <span class="keyword">let</span> treeItem = map[id];</span><br><span class="line">        <span class="keyword">if</span> (pid === -<span class="number">1</span>) &#123;</span><br><span class="line">            res.push(treeItem);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map[pid].children.push(treeItem)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(map)</span><br><span class="line">&#125;)</span><br><span class="line">toTree(testData)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试指南" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Vuejs灵魂之问</title>
    <link href="https://zlinni.github.io/posts/4033900294/"/>
    <id>https://zlinni.github.io/posts/4033900294/</id>
    <published>2022-04-14T03:04:12.000Z</published>
    <updated>2022-04-28T03:10:36.154Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>本文整理了高频vue面试考点，并将难度分为简单中等困难三个难度。</p></div><h1 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h1><h1 id="MVC和MVVM的区别"><a href="#MVC和MVVM的区别" class="headerlink" title="MVC和MVVM的区别"></a>MVC和MVVM的区别</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC的全称是 Model View Controller 是模型，视图，控制器的缩写，是一种软件设计规范。</p><ul><li>Model模型:是应用程序中用于处理程序数据逻辑的部分。通常模型对象负责从数据库里面存取数据</li><li>View视图:是应用程序中处理数据显示的部分。通常视图是依据模型数据渲染的。</li><li>Controller:是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414153548.png" alt=""></p><p>MVC的思想:一句话就是Controller负责将Model的数据取出来用View显示出来，换句话说就是在Controller里面把Model的值赋给View</p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM新增了VM类<br>ViewModel层:做了两件事情完成了双向绑定。</p><ol><li>将Model模型转化为了View视图。即将后端的数据转化为所看到的页面。使用的方式是数据绑定。</li><li>将View视图转化为了Model模型。即将页面转化为了后端的数据。使用的方式是DOM事件监听。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414154052.png" alt=""></p><p>MVVM和MVC最大的区别就是:他实现了View和Model的自动同步，也就是当Model的属性改变的时候，我们不需要手动去操作DOM元素，来改变View的显示，而是改变了属性之后View中的元素也会随之改变。</p><div class="note warning flat"><p>注意 Vue并没有完全遵循MVVM的思想，因为MVVM的思想是不允许Model和View直接通信 但是Vue提供了<code>$refs</code>这个属性让我们可以通信操作dom</p></div><h1 id="为什么data是一个函数"><a href="#为什么data是一个函数" class="headerlink" title="为什么data是一个函数"></a>为什么data是一个函数</h1><p>数据以函数返回值的形式定义，每复用一次组件就返回一份全新的data，类似给组件的实例创建一个私有的数据空间，这样实例之间互不影响。如果直接写成对象的形式，实例之间就共享了同一份data数据。</p><h1 id="Vue组件通讯有那些方式？"><a href="#Vue组件通讯有那些方式？" class="headerlink" title="Vue组件通讯有那些方式？"></a>Vue组件通讯有那些方式？</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220428102007.png" alt=""></p><ol><li>props父子间向子组件传递通过props，</li><li>父通过<code>$refs</code>获取子组件信息用<code>$on</code>挂载事件回调函数，子通过emit触发事件。</li><li><code>$parent</code>,<code>$children</code>获取当前的父组件和子组件详细的方法并调用。</li><li>全局事件总线（mainjs的beforeCreate里面挂载到vue实例上）（vue3取消 使用mitt插件）。</li><li>localStorage</li><li>Vuex</li><li>provide和inject</li><li>pubsubjs</li></ol><h1 id="Vue的生命周期方法有那些？在那一步发送请求"><a href="#Vue的生命周期方法有那些？在那一步发送请求" class="headerlink" title="Vue的生命周期方法有那些？在那一步发送请求"></a>Vue的生命周期方法有那些？在那一步发送请求</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220428110928.png" alt=""></p><h2 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h2><p>在什么阶段被使用：实例初始化之前，数据检测和数据代理之前使用</p><p>不能做什么?不能访问data methods computed watch中的数据和方法</p><p>具体场景：</p><ol><li>页面的拦截，看情况判断能否通行，如果不能省掉创建vue实例</li><li>页面的重定向，不正确进入重定向到别的页面</li><li>loading 在mounted之后销毁</li></ol><h2 id="created"><a href="#created" class="headerlink" title="created"></a>created</h2><p>在什么阶段被使用：初始化之后，数据代理和数据检测开始</p><p>可以访问到data methods computed watch中的数据和方法</p><p>不能做什么？因为实例还没有被挂载 所以不能获取dom节点（非要获取nexttick）</p><p>具体场景：</p><ol><li>数据的初始化</li><li>数据交互 axios（不需要用到dom）</li></ol><h2 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h2><p>在什么阶段被使用：在挂载开始之前被调用</p><p>不能做什么？此时页面呈现的是未经vue编译的dom结构，所有对dom的操作最后都不奏效</p><h2 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h2><p>在什么阶段被使用：真实DOM挂载完毕，数据完成双向绑定，可以访问到DOM节点</p><p>具体场景：</p><ol><li>数据交互(涉及到dom)</li></ol><h2 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h2><p>在什么阶段使用：数据更新的时候调用，发生在虚拟DOM重新渲染和打补丁之前。</p><p>可以做什么：可以进一步更改状态不会触发重渲染</p><h2 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h2><p>在什么阶段使用：更新已经完成</p><p>不能做什么：避免对数据进行修改，否则造成无限循环。</p><h2 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h2><p>在什么阶段使用：实例销毁之前使用</p><p>具体场景：清除定时器，取消事件。</p><h2 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h2><p>在什么阶段使用：实例销毁后</p><h2 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h2><p>keep-alive专属，组件被激活的时候调用。</p><h2 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h2><p>keep-alive专属，组件被销毁的时候调用。</p><div class="note primary flat"><p>异步请求在哪一步发起？</p></div><p>可以在created，beforeMount，mounted中进行，因为在这三个钩子中data已经创建，可以将服务器返回的数据进行赋值。</p><ul><li>对DOM有需求的话一般是放在mouted中，此时DOM已经加载完毕</li><li>对DOM没有需求可以放created，但是只是在created发出了请求，真正的数据还是在mouted阶段才获取。</li></ul><h1 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a>v-if和v-show的区别</h1><p>v-if是真正的条件渲染，在编译过程中会转化成三元表达式，条件不满足不渲染此节点。<br>v-show会被编译成指令，如果条件不满足对应的节点隐藏，相当于<code>display:none</code></p><p>使用场景<br>v-if适用于运行的时候很少改变条件，不需要频繁切换的场景。因为会很影响性能。<br>v-show适用于频繁切换的场景。</p><p>拓展<br><div class="note primary flat"><p><code>display:none</code>,<code>opacity:0</code>,<code>visibility:hidden</code>之间的区别？</p></div></p><p>三者都是隐藏。</p><ol><li>是否占据空间<br>关键在于display隐藏后不占据位置。visibility和opacity还是占据元素位置。</li><li>子元素是否继承。<br>display的父元素都不存在了，自然子元素不会被继承。<br>visibility会被子元素继承，可以使用visible来显示子元素<br>opacity会被子元素继承，但不可以设置1来重新显示子元素。</li><li>事件绑定<br>display的元素不存在了，自然无法使用他绑定的元素<br>visibility不会触发他上面绑定的事件<br>opacity会触发。</li><li>过度动画<br>想要使一个元素慢慢消失，只能用opacity。</li></ol><h1 id="说说Vue的内置指令。"><a href="#说说Vue的内置指令。" class="headerlink" title="说说Vue的内置指令。"></a>说说Vue的内置指令。</h1><p>v-once 定义它的元素只渲染一次包括它的所有子节点，首次渲染完之后将视为静态内容。<br>v-clock 该指令保存在元素上直到关联实例结束编译，解决初始化慢导致页面闪动的最佳实践。<br>v-bind 绑定属性，动态更改HTML元素上的属性可以简写成:<br>v-on 监听dom事件 可以简写成@<br>v-html 和<code>innerHTML</code>一样 注意防止xss攻击<br>v-text 更新元素的textContent<br>v-model 变为value和input的语法糖<br>v-if/v-else/v-else-if 配合template使用。<br>v-show 使用指令来实现隐藏和显示<br>v-for </p><ul><li>循环显示渲染列表</li><li>优先级比v-if高，最好不要一起使用—用computed</li><li>注意增加唯一的key—不要使用index作为key<br>v-pre 跳过这个元素以及它的子元素的编译，加快编译速度。</li></ul><h1 id="怎么理解Vue的单向数据流"><a href="#怎么理解Vue的单向数据流" class="headerlink" title="怎么理解Vue的单向数据流"></a>怎么理解Vue的单向数据流</h1><p>数据总是从父组件流到子组件，子组件理应没有权限修改父组件的数据，因为这样会导致数据流错乱。<br>当然如果需要修改父组件props穿过来的数据。最好定义一个data接收这个值再改变。</p><h1 id="computed和watch的区别和运用的场景"><a href="#computed和watch的区别和运用的场景" class="headerlink" title="computed和watch的区别和运用的场景"></a>computed和watch的区别和运用的场景</h1><p>computed和watch都是对属性的变化做出改变的一个函数了。区别在于computed是计算属性，更偏向于计算的结果这个状态，而watch是监视属性，可以看属性的old和new值，偏向于知道这个过程中发生了什么。<br>场景：<br>computed用在模板渲染比较多，某个值有依赖其他的响应式对象甚至是计算属性计算而来。<br>watch用在观测某个值的变化完成复杂的逻辑功能。</p><p>computed不能计算异步 watch可以监视异步</p><h1 id="v-if和v-for为什么不建议一起使用。"><a href="#v-if和v-for为什么不建议一起使用。" class="headerlink" title="v-if和v-for为什么不建议一起使用。"></a>v-if和v-for为什么不建议一起使用。</h1><p>首先是v-for的优先级高于v-if 会先解析v-for在去解析v-if 所以每次判断都会遍历整个渲染的数据再去找里面不需要的内容。改进的方法是使用computed 不用if。</p><h1 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h1><h1 id="Vue响应式数据的原理"><a href="#Vue响应式数据的原理" class="headerlink" title="Vue响应式数据的原理"></a>Vue响应式数据的原理</h1><p>整体思路是数据劫持+观测者模式</p><p>在对象内部使用<code>Object.defineProperty</code>将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应的属性的时候，每个属性都有自己的dep属性，存放她所依赖的watcher，当属性变化后会通知watcher派发更新。</p><p>手写</p><h1 id="Vue如何检测数组变化"><a href="#Vue如何检测数组变化" class="headerlink" title="Vue如何检测数组变化"></a>Vue如何检测数组变化</h1><p>数组考虑性能原因没有使用defineProperty对数组每一项进行拦截，而是选择对7种数组方法进行重写(push,shift,pop,splice,unshift,sort,reverse)</p><p>所以在vue种修改数组的索引和长度是无法检测到的。需要通过以上七种变异方法触发数组对应的watcher才能更新。</p><p>换言之，如果使用了其他方法操作vue中的数组，都是不安全的。</p><h1 id="vue3-0用过吗-了解多少"><a href="#vue3-0用过吗-了解多少" class="headerlink" title="vue3.0用过吗 了解多少"></a>vue3.0用过吗 了解多少</h1><ul><li>响应式原理的改变。使用了Proxy替代了<code>Object.defineProperty</code></li><li>使用了Composition API，组件的入口变成了setup</li><li>生命周期函数的变化 setup的集成。</li><li>性能上面的提升</li></ul><h1 id="Vue3和2的响应式原理区别"><a href="#Vue3和2的响应式原理区别" class="headerlink" title="Vue3和2的响应式原理区别"></a>Vue3和2的响应式原理区别</h1><p>我们知道vue2种的响应式不能很好的解决数组的问题，修改数组索引和长度无法检测，且对象删除和增加的操作也无法检测到。</p><p>vue3就利用了Proxy针对这几项进行了改变。可以直接监听对象和数组的变化。并且有多达13种拦截方法。</p><h1 id="Vue的父子组件生命周期钩子执行顺序"><a href="#Vue的父子组件生命周期钩子执行顺序" class="headerlink" title="Vue的父子组件生命周期钩子执行顺序"></a>Vue的父子组件生命周期钩子执行顺序</h1><ul><li><p>加载过程 很容易理解 因为父组件需要先有雏形才能放子组件，可以理解为进行到beforeMount才能放子组件<br>父beforeCreate<br>父created<br>父beforeMount<br>子beforeCreate<br>子created<br>子beforeMount<br>子mounted<br>父mounted<br>注意在这个过程中是子先mounted</p></li><li><p>子组件更新过程<br>父beforeUpdate<br>子beforeUpdate<br>子updated<br>父updated</p></li><li><p>父组件更新过程<br>父beforeUpdate<br>父updated</p></li><li><p>销毁过程<br>父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p></li></ul><h1 id="虚拟DOM是什么-有什么优缺点"><a href="#虚拟DOM是什么-有什么优缺点" class="headerlink" title="虚拟DOM是什么 有什么优缺点"></a>虚拟DOM是什么 有什么优缺点</h1><p>我们知道，在浏览器中一直操作真实DOM是很浪费性能的，这就是虚拟DOM产生的原因。vue2的virtual DOM本质就是用一个原生的js对象去描述一个DOM节点，是对真实DOM的一层抽象。</p><p>优点：</p><ul><li>保护性能下限，框架的虚拟DOM需要适配任何上层API可能的操作，他的一些DOM操作必须是能够有配合的，所以他的性能并不是最优的。但是比起我们粗暴的操作DOM性能要好很多。因此框架的虚拟DOM至少能够保证在你不需要性能优化的前提下依然还可以提供不错的性能。</li><li>无需手动操作DOM，我们不需要手动操作DOM，只需要写好viewmodel的逻辑，框架就会根据虚拟DOM和数据进行双向绑定，帮助我们更新视图提高我们的开发效率。</li><li>跨平台：虚拟dom本质上是js对象，而DOM和平台强相关，相比之下，虚拟dom可以更方便的进行跨平台操作，比如服务器渲染，weex开发等。</li></ul><p>缺点：</p><ul><li>刚刚也说了，虚拟DOM只能保证我们的性能下限，因此对于性能要求高的引用来说，虚拟DOM无法针对性的进行性能优化；</li><li>当首次渲染大量DOM的时候，由于多了一层虚拟DOM的计算，所以会比innerHTML插入慢。</li></ul><h1 id="v-model的原理"><a href="#v-model的原理" class="headerlink" title="v-model的原理"></a>v-model的原理</h1><p>v-model本质上只是一个语法糖，处理value和input</p><p>他在内部为不同的输入元素使用不同的property并抛出不同的事件。</p><ul><li>text和textarea元素使用value property和input事件</li><li>checkbox和radio使用checked property和change事件</li><li>select字段将value作为prop并将change作为事件。</li></ul><div class="note primary flat"><p>注意对于需要使用输入法的语言，你会发现v-model并不会在输入法组合文字的过程中得到更新。</p></div><p>在普通标签上<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;sth&quot;</span> /&gt;  <span class="comment">//这一行等于下一行</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;sth&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;sth = $event.target.value&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>在组件上<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;currency-input v-model=<span class="string">&quot;price&quot;</span>&gt;&lt;/currentcy-input&gt;</span><br><span class="line">&lt;!--上行代码是下行的语法糖</span><br><span class="line"> &lt;currency-input :value=<span class="string">&quot;price&quot;</span> @input=<span class="string">&quot;price = arguments[0]&quot;</span>&gt;&lt;/currency-input&gt;</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 子组件定义 --&gt;</span><br><span class="line">Vue.component(<span class="string">&#x27;currency-input&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;span&gt;</span></span><br><span class="line"><span class="string">   &lt;input</span></span><br><span class="line"><span class="string">    ref=&quot;input&quot;</span></span><br><span class="line"><span class="string">    :value=&quot;value&quot;</span></span><br><span class="line"><span class="string">    @input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span><br><span class="line"><span class="string">   &gt;</span></span><br><span class="line"><span class="string">  &lt;/span&gt;</span></span><br><span class="line"><span class="string"> `</span>,</span><br><span class="line"> <span class="attr">props</span>: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="v-for为什么要加key"><a href="#v-for为什么要加key" class="headerlink" title="v-for为什么要加key"></a>v-for为什么要加key</h1><p>如果不使用key，vue会使用一种最大限度减少动态元素并且尝试就地修改复用相同类型元素的算法。key是为Vue中的vnode的唯一标记，通过这个标记，我们的diff操作可以更准确，更迅速。</p><p>更准确：因为带key就不是就地复用了，在sameNode函数a的key和b的key对比中可以避免就地复用的情况。所以会更加准确。</p><p>更快速：利用key的唯一性生成map对象来获取对应节点，比遍历方法更快。</p><h1 id="vue事件绑定原理"><a href="#vue事件绑定原理" class="headerlink" title="vue事件绑定原理"></a>vue事件绑定原理</h1><p>原生事件绑定是通过<code>addEventListener</code>绑定给真实元素的，组件事件绑定是通过Vue自定义的$on来实现的。如果要在组件上使用原生事件，需要加<code>.native</code>修饰符，这样就相当于在父组件中把子组件当作普通的HTML标签，然后加上原生事件。</p><p><code>$on</code>,<code>$emit</code>是基于发布订阅模式的，维护一个事件中心，on的时候将事件按名称存在事件中心中，称之为订阅者，然后emit将对应的事件进行发布，去执行事件中心里对应的的监听器。</p><p>手写发布订阅</p><h1 id="vue-router路由钩子函数是什么-执行顺序是什么"><a href="#vue-router路由钩子函数是什么-执行顺序是什么" class="headerlink" title="vue-router路由钩子函数是什么 执行顺序是什么"></a>vue-router路由钩子函数是什么 执行顺序是什么</h1><p>钩子函数种类有全局守卫，路由守卫，组件守卫</p><p>全局守卫3个：<br>1.router.beforeEach 全局前置守卫<br>2.router.beforeResolve 全局解析守卫 在beforeRouteEnter调用后调用。<br>3.router.afterEach 全局后置钩子 进入路由后</p><p>路由独享守卫1个：<br>beforeEnter</p><p>组件守卫3个：<br>1.beforeRouteEnter 进入路由前 不能访问this<br>2.beforeRouteUpdate 路由复用同一个组件时<br>3.beforeRouteLeave 离开当前路由时。我们用它来禁止用户离开，比如还未保存草稿，或者在用户离开前，将setInterval销毁，防止离开之后，定时器还在调用。</p><p>完整的导航解析过程：</p><ol><li>导航被触发</li><li>在失活的组件里调用beforeRouteLeave守卫<br>3，调用全局的beforeEach守卫</li><li>在重用的组件里调用beforeRouteUpdate守卫<br>5，在路由配置里调用beforeEnter</li><li>解析异步路由组件</li><li>在被激活的组件里调用beforeRouteEnter</li><li>调用全局的beforeResolve守卫</li><li>导航被确认</li><li>调用全局的afterEach守卫</li><li>触发DOM更新</li><li>调用beforeRouteEnter守卫中传给next的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220415100347.png" alt=""></p><h1 id="vue-router-动态路由是什么？有什么问题"><a href="#vue-router-动态路由是什么？有什么问题" class="headerlink" title="vue-router 动态路由是什么？有什么问题"></a>vue-router 动态路由是什么？有什么问题</h1><p>我们经常需要把某种模式匹配到的路由全部映射到同个组件。例如我们有一个User组件，对于所有ID各不相同的用户，都需要用这个组件来渲染。那么我们可以在vue-router的路由路径中使用动态路由参数来达到这个效果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&#x27;user.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>:[</span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">&quot;/user/:id&quot;</span>,<span class="attr">component</span>:User&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><div class="note primary flat"><p>vue-router组件复用导致路由参数失效怎么办？</p></div><ol><li>通过watch监听路由参数再发请求。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">  <span class="string">&quot;$route&quot;</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.getData(<span class="built_in">this</span>.$route.params.xxx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>用key来防止复用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view :key=<span class="string">&quot;$router.fullPath&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Vuex的理解"><a href="#Vuex的理解" class="headerlink" title="Vuex的理解"></a>Vuex的理解</h1><p>vuex是专门为vue设计的全局状态管理工具，用于多个组件中数据共享。数据缓存等。但无法持久化，内部的核心原理是创造一个全局实例new vue<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220415101158.png" alt=""></p><p>主要包括以下几个模块：</p><ul><li>State 定义了应用状态的数据结构，可以在这里设置默认的初始状态</li><li>Getter 允许组件从Store中获取数据，mapGetters辅助函数仅仅是将store中的getter映射到局部计算属性</li><li>Mutation 是唯一更改store中状态的方法，且必须是同步函数</li><li>Action 用于提交mutation 而不是直接变更状态，可以包含任意异步操作。</li><li>Module 允许将单一的Store拆分为多个store且同时保存在单一的状态树中。</li></ul><h1 id="Vuex页面刷新数据丢失怎么解决"><a href="#Vuex页面刷新数据丢失怎么解决" class="headerlink" title="Vuex页面刷新数据丢失怎么解决"></a>Vuex页面刷新数据丢失怎么解决</h1><p>数据持久化使用本地存储或者第三方插件vuex-persist</p><h1 id="Vuex为什么要分模块而且加命名空间"><a href="#Vuex为什么要分模块而且加命名空间" class="headerlink" title="Vuex为什么要分模块而且加命名空间"></a>Vuex为什么要分模块而且加命名空间</h1><p>模块：由于使用单一的状态树，应用的所有状态会集中到一个比较大的对象。当应用变得复杂的时候，store对象就有可能变得相当臃肿。为了解决以上的问题，Vuex允许我们将store分割成模块module。每个模块拥有自己的state，mutation，action和getter</p><p>命名空间：默认情况下，模块内部的action，mutation，getter是注册在全局命名空间的—-这样能够使得多个模块能够对同一个mutation或者action做出相应。如果想要模块有更高的封装度和复用性，建议添加namespaced:true的方式使得他成为命名空间。当模块被注册的时候，他的所有getter，action以及mutation都会更具模块注册的路径调整名字。</p><h1 id="使用过Vue-SSR吗？说一说SSR"><a href="#使用过Vue-SSR吗？说一说SSR" class="headerlink" title="使用过Vue SSR吗？说一说SSR"></a>使用过Vue SSR吗？说一说SSR</h1><p>SSR也就是服务端渲染，也就是将vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。</p><p>优点：<br>SSR有更好的SEO，并且是因为按需分配，首屏的加载速度更快</p><p>缺点：<br>开发条件受到限制。服务端渲染只支持beforeCreate和created两个钩子。当我们需要一些外部拓展库的时候需要进行特殊处理，服务端渲染应用程序也需要处于nodejs的运行环境。</p><p>且服务端会有更大的负载需求。</p><h1 id="Vue使用了哪些设计者模式"><a href="#Vue使用了哪些设计者模式" class="headerlink" title="Vue使用了哪些设计者模式"></a>Vue使用了哪些设计者模式</h1><ol><li>工厂模式-传入参数即可创建实例。<br>虚拟dom根据参数的不同返回基础标签的vnode和组件vnode</li><li>单例模式-整个程序有且仅有一个实例<br>vue和vue-router的插件注册方法install判断如果系统存在实例就直接返回掉</li><li>发布-订阅模式（vue事件机制）<br>4，观察者模式-响应式数据原理</li><li>装饰模式-@装饰器用法</li><li>策略模式-策略模式指对象有某个行为，但在不同的场景下，该行为有不同的实现方案，比如选项的合并策略。</li></ol><h1 id="你做过哪些vue的性能优化"><a href="#你做过哪些vue的性能优化" class="headerlink" title="你做过哪些vue的性能优化"></a>你做过哪些vue的性能优化</h1><div class="note primary flat"><p>以下针对vue</p></div><ul><li>对象层级不要太深，否则性能就会差。</li><li>不需要响应式的数据不要放在data中，可以使用<code>Object.freeze</code>冻结数据</li><li>v-if和v-show区别使用</li><li>computed和watch区别使用场景。</li><li>v-for遍历必须加key key最好是id 且避免使用v-if</li><li>大数据列表和表格性能优化-虚拟列表/虚拟表格</li><li>防止内部泄漏，组件销毁后把全局变量和事件销毁。</li><li>图片懒加载</li><li>路由懒加载</li><li>第三方插件按需引入</li><li>适当采用keep-alive缓存组件</li><li>防抖节流避免反复请求</li><li>服务端渲染SSR or 预渲染</li></ul><h1 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h1><h1 id="Vue-mixin的使用场景和原理"><a href="#Vue-mixin的使用场景和原理" class="headerlink" title="Vue.mixin的使用场景和原理"></a>Vue.mixin的使用场景和原理</h1><p>在日常的开发中，我们经常会遇到在不同的组件中会需要用到一些相同或者类似的代码，这些代码的功能相对独立，可以通过vue的mixin抽离公共的业务逻辑，原理类似于原型链的继承，当组件初始化的时候会调用mergeOptions方法进行合并，采用策略模式针对不同的属性进行和并。当组件和混入对象拥有同名的选项的时候，这些选项将以恰当的方式“合并”</p><p>手撕mixin</p><h1 id="nextTick的使用场景和原理"><a href="#nextTick的使用场景和原理" class="headerlink" title="nextTick的使用场景和原理"></a>nextTick的使用场景和原理</h1><p>nextTick中的回调是在下次DOM循环更新结束之后执行的回调。在修改数据之后立刻使用这个方法，获取更新后的DOM。主要的思路是采用微任务优先的方式调用异步方法去执行nextTick包装的方法。</p><p>手撕nextTick</p><h1 id="keep-alive使用场景"><a href="#keep-alive使用场景" class="headerlink" title="keep-alive使用场景"></a>keep-alive使用场景</h1><p>keep-alive是vue内置的一个组件，可以实现组件缓存，当组件切换的时候不会对当前组件进行卸载。</p><ul><li>常用的两个属性include和exclude 允许组件有条件的进行缓存</li><li>生命周期两个 activated 和 deactivated。用来知道组件是否处于激活状态</li><li>keep-alive中话运用了LRU算法，选择最近最久未使用的组件进行淘汰</li></ul><p>手撕keep-alive</p><div class="note primary flat"><p>拓展 LRU算法是什么？</p></div><p>LRU 的核心思想是如果数据最近被访问过，那么将来被访问的几率也更高，所以我们将命中缓存的组件 key 重新插入到 this.keys 的尾部，这样一来，this.keys 中越往头部的数据即将来被访问几率越低，所以当缓存数量达到最大值时，我们就删除将来被访问几率最低的数据，即 this.keys 中第一个缓存的组件。</p><h1 id="Vue-set方法原理"><a href="#Vue-set方法原理" class="headerlink" title="Vue.set方法原理"></a>Vue.set方法原理</h1><p>了解了vue响应式原理的同学都知道在两种情况下修改数据vue是不会触发视图更新的。</p><p>1是给实例添加新的属性<br>2是直接更改数组的下标来修改数组的值</p><p>而set的原理就是我们给数组和对象本身都增加了<em>ob</em>属性，代表的是observer实例。当给对象新增不存在的属性，首先会把新的属性进行响应式的跟踪，然后触发对象ob的dep收集到的watcher去更新，当修改数组索引的时候我们调用数组本身的splice方法去更新数组。</p><p>手撕vueset</p><h1 id="Vue-extend原理"><a href="#Vue-extend原理" class="headerlink" title="Vue.extend原理"></a>Vue.extend原理</h1><p>他的原理是使用基础vue构造器，创建一个子类，参数是一个包含组件选项的对象。</p><p>其实就是一个子类构造器，是vue组件的核心api</p><p>实现的思路是使用原型继承的方法返回了vue的子类，并且利用mergeOption把传入组件的options和父类的options进行了合并</p><p>手撕vueextend</p><h1 id="写过自定义指令吗-原理是啥"><a href="#写过自定义指令吗-原理是啥" class="headerlink" title="写过自定义指令吗 原理是啥"></a>写过自定义指令吗 原理是啥</h1><p>指令本质上是装饰器，是vue对html元素的拓展，给html元素增加自定义功能。vue编译dom的时候，会找到指令对象，执行指令相关的方法。</p><p>自定义指令有五个生命周期，分别是bind，inserted，update，componentUpdated，unbind<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> bind 只调用一次，指令第一次绑定到元素的时候调用，在这里可以进行一次性的初始化设置。</span><br><span class="line"><span class="number">2.</span> inserted 被绑定的元素插入父节点的时候调用，只保证父节点存在，但不一定已被插入文档中</span><br><span class="line"><span class="number">3.</span> update 被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的更新。</span><br><span class="line"><span class="number">4.</span> componentUpdated 被绑定元素所在模板完成一次更新的时候调用。</span><br><span class="line"><span class="number">5.</span> unbind：只调用一次，指令与元素解绑的时候调用。</span><br></pre></td></tr></table></figure></p><p>原理</p><ol><li>在生成ast语法树时，遇到指令会给当前元素添加directives属性</li><li>通过genDirectives生成指令代码</li><li>在patch前将指令的钩子提取到cbs中，在patch过程中调用对应的钩子</li><li>当执行指令对应的钩子函数的时候，调用对应指令定义的方法。</li></ol><h1 id="Vue修饰符有哪些"><a href="#Vue修饰符有哪些" class="headerlink" title="Vue修饰符有哪些"></a>Vue修饰符有哪些</h1><p>事件修饰符<br>为了方便 下面的指令都省略.</p><ul><li>stop阻止事件继续传播</li><li>prevent 阻止标签默认行为</li><li>capture 使用事件捕获模式，即元素自身触发的事件先在此处理，然后交由内部元素进行处理</li><li>self 只当在<code>event.target</code>是当前元素的时候才触发处理函数</li><li>once 事件只会触发一次</li><li>passive 告诉浏览器不要阻止事件的默认行为。</li></ul><p>v-model修饰符</p><ul><li>lazy 通过这个修饰符，转变为在change事件再同步</li><li>number 自动将用户输入的值转换为数值类型</li><li>trim 自动过滤用户输入的首位空格</li></ul><p>键盘事件的修饰符</p><ul><li>enter</li><li>tab</li><li>delete（捕获删除 和 退格键）</li><li>esc</li><li>space</li><li>up down left right</li></ul><p>系统修饰符</p><ul><li>ctrl </li><li>alt</li><li>shift</li><li>meta</li></ul><p>鼠标按键修饰符</p><ul><li>left right middle</li></ul><h1 id="Vue模板编译原理"><a href="#Vue模板编译原理" class="headerlink" title="Vue模板编译原理"></a>Vue模板编译原理</h1><p>vue的编译过程就是将template转化为render函数的过程，分为以下几步：<br>第一步 模板字符串 转化为elements ASTs—解析器<br>第二步 对AST进行静态节点标记，主要用来做虚拟DOM的渲染优化—优化器<br>第三步 使用elements ASTs 生成render函数代码字符串—代码生成器</p><p>手撕模板编译</p><h1 id="生命周期钩子是如何实现的"><a href="#生命周期钩子是如何实现的" class="headerlink" title="生命周期钩子是如何实现的"></a>生命周期钩子是如何实现的</h1><p>vue生命周期钩子的核心是利用发布订阅模式先把用户传入的生命周期钩子订阅好，内部采用数组的方式存储，然后在创建组件实例的过程中会一次执行对应的钩子方法—发布</p><p>手撕生命周期钩子实现</p><h1 id="函数式组件使用场景和原理"><a href="#函数式组件使用场景和原理" class="headerlink" title="函数式组件使用场景和原理"></a>函数式组件使用场景和原理</h1><p>函数式组件与普通组件的区别</p><ol><li>函数式组件需要在声明组件的时候指定<code>functional:true</code></li><li>不需要实例化，所以没有this，他的this通过render函数的第二个参数context来代替</li><li>没有生命周期钩子函数，不能使用computed和watch</li><li>不能通过emit对外暴露事件，调用事件只能通过<code>context.listeners.click</code>的方式调用外部传入的事件.</li><li>因为函数式组件是没有实例化的，所以在外部通过ref去引用组件的时候，实际引用的是HTMLElement</li><li>函数式组件的props可以不用显示声明，所以在没有props里面声明的属性都会被隐式的解析为prop。</li></ol><p>优点</p><ol><li>由于函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件</li><li>函数式组件的结构比较简单，代码结构清晰</li></ol><p>使用场景：<br>一个简单的展示组件，作为容器组件的使用，比如router-view就是一个函数式组件</p><p>高阶组件—用于接收一个组件作为参数，返回一个被包装的组件</p><p>相关代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isTrue(Ctor.options.functional)) &#123;</span><br><span class="line">  <span class="comment">// 带有functional的属性的就是函数式组件</span></span><br><span class="line">  <span class="keyword">return</span> createFunctionalComponent(Ctor, propsData, data, context, children);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> listeners = data.on;</span><br><span class="line">data.on = data.nativeOn;</span><br><span class="line">installComponentHooks(data); <span class="comment">// 安装组件相关钩子 （函数式组件没有调用此方法，从而性能高于普通组件）</span></span><br></pre></td></tr></table></figure></p><h1 id="能说下vue-router中常用的路由模式实现原理吗"><a href="#能说下vue-router中常用的路由模式实现原理吗" class="headerlink" title="能说下vue-router中常用的路由模式实现原理吗"></a>能说下vue-router中常用的路由模式实现原理吗</h1><p>hash模式</p><ol><li>location.hash的值实际就是URL后面#的东西，他的特点在于hash虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，所以改变hash不会重新加载页面</li><li>可以为hash的改变添加监听事件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;hashchange&quot;</span>, funcRef, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>3.每改变一次hash都会在浏览器的访问历史中增加一个记录利用hash的以上特点，就可以实现前端路由更新视图但不请求页面的功能了。</li></ol><div class="note primary flat"><p>特点：兼容性好但是不美观</p></div><p>history模式<br>利用了HTML5 History Interface 中新增的pushState和replaceState方法</p><p>这两个方法应用于浏览器的历史记录站，在当前已有的back，forward，go的基础上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用它们修改的浏览器历史记录栈后，虽然当前的URL改变了，但是浏览器不会刷新页面，这就为单页应用前端路由更新视图但不重新请求页面提供了基础。<br><div class="note primary flat"><p>特点，虽然美观，但是刷新后出现404需要后端配置</p></div></p><h1 id="diff算法了解吗"><a href="#diff算法了解吗" class="headerlink" title="diff算法了解吗"></a>diff算法了解吗</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220415135701.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络不完全指南</title>
    <link href="https://zlinni.github.io/posts/2992649876/"/>
    <id>https://zlinni.github.io/posts/2992649876/</id>
    <published>2022-04-14T00:20:38.000Z</published>
    <updated>2022-04-25T02:41:30.115Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>本文通过OSI七层模型阐述前端常考的计网知识点</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414082617.png" alt=""></p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><div class="tip cogs"><p>参见HTTP灵魂之问</p></div><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><div class="note primary flat"><p>DNS的作用就是通过域名查询到IP</p></div><p>因为IP存在数字和英文的组合IPv6，很不利于人类记忆，所以出现了域名。你可以把域名看成某个IP的别名，DNS就是去查询这个别名真正的名称是什么</p><div class="note primary flat"><p>在TCP握手之前就已经进行了DNS查询，这个查询是操作系统自己完成的，当在浏览器中想访问<code>www.google.com</code>会进行以下操作。</p></div><ul><li>本地客户端向服务器发起请求查询 IP 地址</li><li>查看浏览器有没有该域名的 IP 缓存</li><li>查看操作系统有没有该域名的 IP 缓存</li><li>查看 Host 文件有没有该域名的解析配置</li><li>如果这时候还没得话，会通过直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器</li><li>然后去该服务器查询 google.com 这个二级域名</li><li>接下来查询 www.google.com 这个三级域名的地址</li><li>返回给 DNS 客户端并缓存起来</li></ul><div class="note primary flat"><p>以上介绍的是DNS迭代查询，还有一种是递归查询，区别是前者是由客户端去请求，后者是由系统配置的DNS去请求，得到结果之后将数据返回给客户端。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414083618.png" alt=""></p><h3 id="DNS解析优化"><a href="#DNS解析优化" class="headerlink" title="DNS解析优化"></a>DNS解析优化</h3><p>主要分为两个方案</p><ul><li>DNS预解析</li><li>减少DNS请求</li></ul><h3 id="DNS预解析"><a href="#DNS预解析" class="headerlink" title="DNS预解析"></a>DNS预解析</h3><div class="note primary flat"><p>DNS解析也需要时间的，可以通过预解析的方式来预先获取域名所对应的IP</p></div><p>link方式：手动解析<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//blog.poetries.top&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>meta方式：https自动解析<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;x-dns-prefetch-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;on&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>设置响应头：自动解析<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.set(<span class="string">&#x27;X-DNS-Prefetch-Control&#x27;</span>, <span class="string">&#x27;on&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h1 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h1><h2 id="URL的加密和解密"><a href="#URL的加密和解密" class="headerlink" title="URL的加密和解密"></a>URL的加密和解密</h2><h2 id="图片编码和解码"><a href="#图片编码和解码" class="headerlink" title="图片编码和解码"></a>图片编码和解码</h2><h1 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h1><h2 id="验证登陆"><a href="#验证登陆" class="headerlink" title="验证登陆"></a>验证登陆</h2><ul><li>cookie session</li><li>token </li><li>sso 单点登陆</li><li>OAuth第三方登陆</li></ul><h3 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie session"></a>cookie session</h3><p>登陆流程：首次登陆<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414092439.png" alt=""></p><ol><li>用户访问<code>a.com/pageA</code>并输入密码登陆</li><li>服务器验证密码无误后，会创建Session ID并将其保存起来</li><li>服务端响应这个请求，并通过Set-Cookie将Session ID写入Cookie中</li></ol><p>再次登陆：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414092643.png" alt=""></p><ol><li>用户访问<code>a.com/pageB</code>自动带上第一次登陆写入的Cookie</li><li>服务端对比Cookie中的SessionID和保存在服务端的SessionID是否一致</li><li>一致则成功</li></ol><h3 id="cookie-session存在的问题"><a href="#cookie-session存在的问题" class="headerlink" title="cookie session存在的问题"></a>cookie session存在的问题</h3><ul><li>服务器需要对接大量的客户端，导致服务器压力大。</li><li>如果服务器是一个集群，为了同步登陆态，就需要将SessionID同步到每一台机器上，无形中增加了服务器的维护成本。</li><li>由于SessionID存放在Cookie中所以无法避免CSRF攻击</li></ul><h3 id="token登陆"><a href="#token登陆" class="headerlink" title="token登陆"></a>token登陆</h3><p>为了解决cookie+session暴露出来的问题，我们可以使用token的登陆方式<br><div class="note primary flat"><p>token是服务端生成的一串字符串，以作为客户端请求的一个令牌。当第一次登陆完成后，服务器会生成一个token并返回给客户端，客户端后续访问只要带上这个token就可以完成身份验证。</p></div></p><h4 id="token机制实现流程"><a href="#token机制实现流程" class="headerlink" title="token机制实现流程"></a>token机制实现流程</h4><p>首次登陆：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414102745.png" alt=""></p><ol><li>用户输入账号密码，并点击登录。</li><li>服务器端验证账号密码无误，创建 Token。</li><li>服务器端将 Token 返回给客户端，由客户端自由保存。</li></ol><p>后续页面访问时：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414102830.png" alt=""></p><ol><li>用户访问 a.com/pageB 时，带上第一次登录时获取的 Token。</li><li>服务器端验证 Token ，有效则身份验证成功。</li></ol><h4 id="Token-机制的特点"><a href="#Token-机制的特点" class="headerlink" title="Token 机制的特点"></a>Token 机制的特点</h4><p>根据上面的案例，我们可以分析出Token的优缺点：</p><ul><li>服务器端不需要存放token，所以不会对服务器造成压力，即使服务器集群，也不需要增加维护成本。</li><li>Token可以存放在前端的任何地方，可以不用保存在Cookie中，提升了页面的安全性。</li><li>Token下发之后，只要在生效时间内，就一直有效，如果服务器想收回此token的权限，并不容易。</li></ul><h4 id="Token的生成方式"><a href="#Token的生成方式" class="headerlink" title="Token的生成方式"></a>Token的生成方式</h4><p>最常见的Token生成方式是使用JWT，他是一种简洁的，自包含的方法用于通信双方之间以JSON对象的形式安全的传递信息。</p><p>上文中我们说到，使用Token后，服务器端并不会存储Token，那怎么判断客户端的token是否合法有效？</p><p>答案其实就在Token字符串中，其实Token并不是一串杂乱无章的字符串，而是通过多种算法拼接组合而成的字符串。如下：</p><p>JWT算法主要分成了三个部分 </p><ul><li>header 头信息</li><li>payload 消息体</li><li>signature 签名</li></ul><p>header部分指定了JWT使用的签名算法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header = <span class="string">&#x27;&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;&#x27;</span>   <span class="comment">// `HS256` 表示使用了 HMAC-SHA256 来生成签名。</span></span><br></pre></td></tr></table></figure></p><p>payload部分指明了JWT的使用意图<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;&#123;&quot;loggedInAs&quot;:&quot;admin&quot;,&quot;iat&quot;:1422779638&#125;&#x27;</span>     <span class="comment">//iat 表示令牌生成的时间</span></span><br></pre></td></tr></table></figure></p><p>signature部分为JWT的签名 主要为了让JWT不能随意更改，签名的方法分为两个步骤</p><ol><li>输入base64url编码的header部分，base64url编码的payload部分，输出unsignedToken</li><li>输入服务器端私钥，unsignedToken,输出signature签名</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base64Header = encodeBase64(header)</span><br><span class="line"><span class="keyword">const</span> base64Payload = encodeBase64(payload)</span><br><span class="line"><span class="keyword">const</span> unsignedToken = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;服务器私钥&#x27;</span></span><br><span class="line"></span><br><span class="line">signature = HMAC(key, unsignedToken)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后Token计算如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base64Header = encodeBase64(header)</span><br><span class="line"><span class="keyword">const</span> base64Payload = encodeBase64(payload)</span><br><span class="line"><span class="keyword">const</span> base64Signature = encodeBase64(signature)</span><br><span class="line"></span><br><span class="line">token = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>.<span class="subst">$&#123;base64Signature&#125;</span>`</span></span><br></pre></td></tr></table></figure></p><p>服务器在判断token的时候<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [base64Header, base64Payload, base64Signature] = token.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> signature1 = decodeBase64(base64Signature)</span><br><span class="line"><span class="keyword">const</span> unsignedToken = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> signature2 = HMAC(<span class="string">&#x27;服务器私钥&#x27;</span>, unsignedToken)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(signature1 === signature2) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;签名验证成功，token 没有被篡改&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> payload =  decodeBase64(base64Payload)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Date</span>() - payload.iat &lt; <span class="string">&#x27;token 有效期&#x27;</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;token 有效&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有了 Token 之后，登录方式已经变得非常高效，接下来我们介绍另外两种登录方式。</p><h3 id="SSO单点登陆"><a href="#SSO单点登陆" class="headerlink" title="SSO单点登陆"></a>SSO单点登陆</h3><div class="note primary flat"><p>单点登陆指的是在公司内部搭建一个公共的认证中心，公司下的所有产品的登陆都可以在认证中心中完成，一个产品在认证中心登陆后，再去访问另外一个产品，可以不用再次登陆，即可获取登陆状态。</p></div><h4 id="SSO机制实现流程"><a href="#SSO机制实现流程" class="headerlink" title="SSO机制实现流程"></a>SSO机制实现流程</h4><p>用户首次访问需要在认证中心登陆</p><h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h2><p><a href="https://juejin.cn/post/6844904046436843527">https://juejin.cn/post/6844904046436843527</a></p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h2><div class="note primary flat"><ol><li>tcp是面向链接的 udp是无连接的即发送数据前不需要建立连接</li><li>tcp提供可靠的服务，也就是说通过tcp连接发送的数据，无差错，不丢失，不重复，且按序到达，udp尽最大的努力交付，即不保证可靠交付。并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换</li><li>tcp是面向字节流，udp面向报文，并且网络出现拥塞不会使得发送速率降低（因此会产生丢包，对实时的应用比如ip电话和视频会议等）</li><li>tcp只能是一对一的，udp支持1对1 1对多</li><li>tcp的首部较大为20字节 udp只有8字节</li><li>tcp是面向连接的可靠性传输，udp是不可靠的 </li></ol></div><h3 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h3><p>UDP：</p><ul><li>直播</li><li>游戏</li></ul><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><div class="note primary flat"><p>建立连接前，客户端和服务端需要通过握手来确认对方</p></div><ul><li>客户端发送SYN同步序列编号请求，进入SYN_SEND状态，等待确认</li><li>服务端接收并确认SYN包之后发送SYN+ACK包，进入SYN_RECV状态</li><li>客户端接收SYN+ACK包之后，发送ACK包，双方进入ESTABLISHED状态</li></ul><h4 id="为什么采用三次握手？"><a href="#为什么采用三次握手？" class="headerlink" title="为什么采用三次握手？"></a>为什么采用三次握手？</h4><p>举例：已失效的连接请求报文段</p><ul><li>如果客户端发送请求报文但由于网络问题导致报文失效，服务端接收到请求后就会发送确认报文表示同意连接。此时如果是两次握手，那么此时服务端已经建立了新的连接，但由于这个请求是失效的，客户端并没有建立连接，服务端就会浪费很多资源。如果是三次握手，那么此时服务端收不到确认连接的信息，就知道客户端没有建立连接。这就是三次握手的作用。<div class="note primary flat"><p>TCP有六种标识SYN建立连接，ACK确认，PSH传送，FIN结束，RST重置，URG紧急</p></div></li></ul><h4 id="三次握手过程中可以携带数据吗？"><a href="#三次握手过程中可以携带数据吗？" class="headerlink" title="三次握手过程中可以携带数据吗？"></a>三次握手过程中可以携带数据吗？</h4><ul><li>第一次第二次握手不能携带数据，因为第一次握手和第二次握手服务端还没有建立连接，此时发送数据会让服务器受到攻击。</li><li>第三次握手服务器已经处于ESTABLISHED状态，对于客户端来说已经建立了连接，并且也知道服务器的接收发送能力是正常的了，所以能携带数据。</li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><div class="note primary flat"><p>为了确保数据能完成传输</p></div><ul><li>客户端—FIN—&gt;服务端，FIN——WAIT</li><li>服务端—ACK—&gt;客户端，CLOSE——WAIT</li><li>服务端—ACK，FIN—&gt;客户端，LAST——ACK</li><li>客户端—ACK—&gt;服务端，CLOSED</li></ul><h4 id="为什么连接的时候是三次握手，关闭的时候是四次挥手？"><a href="#为什么连接的时候是三次握手，关闭的时候是四次挥手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候是四次挥手？"></a>为什么连接的时候是三次握手，关闭的时候是四次挥手？</h4><ul><li>服务端接收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。</li><li>但是在关闭连接的时候，当服务端收到FIN报文的时候 ，很可能并不会立刻关闭连接，所以只能先回复一个ACK报文，告诉客户端，你发的FIN报文收到了，只有等服务器所有的报文发送完了才能发送FIN报文，因此不能一起发送，故需要四次挥手。 </li></ul><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><div class="note primary flat"><p>网络拥塞（congestion）是指在分组交换网络中传送分组的数目太多时，由于存储转发节点的资源有限而造成网络传输性能下降的情况。当网络发生拥塞时，一般会出现数据丢失，时延增加，吞吐量下降，严重时甚至会导致“拥塞崩溃”（congestion collapse）。通常情况下，当网络中负载过度增加致使网络性能下降时，就会发生网络拥塞。下图则描述了在有无拥塞控制的干预下，网络吞吐量随输入负载的增加的变化情况。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423112204.png" alt=""><br>通过以上的描述，我们大概可以得到以下信息：</p><ul><li>网络拥塞往往是由于对资源的请求超出了存储转发节点的能力而导致的。</li><li>网络拥塞可能会导致数据丢失，时延增加，吞吐量下降等问题。</li><li>若出现拥塞而不进行控制，有可能会使整个网络情况恶化，甚至网络吞吐降为0。</li><li>网络的拥塞状况与当前网络负载是密切相关的。</li></ul><h4 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h4><ol><li>慢启动</li><li>拥塞避免</li><li>快重传</li><li>快恢复</li></ol><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>如果发送方的数据发送过快，接收者来不及接收，就有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。</p><p>流量控制的根本目的是防止分组丢失，它是构成TCP可靠性的一方面</p><h4 id="实现流量控制"><a href="#实现流量控制" class="headerlink" title="实现流量控制"></a>实现流量控制</h4><p>滑动窗口协议（连续ARQ协议）实现。它保证了分组无差错，有序接收，也实现了流量控制。</p><p>主要的方式是 接收方返回的ack包会包含自己接收窗口的大小，并且利用大小来控制发送方的数据发送</p><h4 id="流量控制引发的死锁？怎么避免死锁发生？-没看明白"><a href="#流量控制引发的死锁？怎么避免死锁发生？-没看明白" class="headerlink" title="流量控制引发的死锁？怎么避免死锁发生？(没看明白)"></a>流量控制引发的死锁？怎么避免死锁发生？(没看明白)</h4><p>当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。</p><h4 id="拥塞控制和流量控制的区别"><a href="#拥塞控制和流量控制的区别" class="headerlink" title="拥塞控制和流量控制的区别"></a>拥塞控制和流量控制的区别</h4><p>拥塞控制就是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的方法是：慢开始，拥塞避免，快重传，快恢复。</p><p>流量控制就是作用于接收者的，它是控制发送者的发送速度从而使得接收者来得及接收，防止分组丢失</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="网络系列" scheme="https://zlinni.github.io/categories/%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="计算机网络" scheme="https://zlinni.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
