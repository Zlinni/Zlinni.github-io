<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zlinni&#39;s Blog For Study</title>
  
  <subtitle>一个专门做笔记的博客</subtitle>
  <link href="https://zlinni.github.io/atom.xml" rel="self"/>
  
  <link href="https://zlinni.github.io/"/>
  <updated>2022-04-23T07:23:26.818Z</updated>
  <id>https://zlinni.github.io/</id>
  
  <author>
    <name>Zlinni</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见排序算法思想</title>
    <link href="https://zlinni.github.io/posts/80170b36fe90/"/>
    <id>https://zlinni.github.io/posts/80170b36fe90/</id>
    <published>2022-04-23T06:37:29.000Z</published>
    <updated>2022-04-23T07:23:26.818Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>记录常用排序算法的算法思想和实现，力争基础达标，往后深入的点分开补充~</p></div><p>关键词：常用算法、sort排序、冒泡排序、插入排序、选择排序、快速排序、归并排序、桶排序、希尔排序</p><h1 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h1><p>直接使用api就能进行排序，注意的点是：<br>不传参，默认是unicode排序，所以常用来排序字母<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;asbcascacsac&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> sortArr = arr.sort();</span><br><span class="line"><span class="built_in">console</span>.log(sortArr)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">    &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;b&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;c&#x27;, &#x27;s&#x27;, &#x27;s&#x27;, &#x27;s&#x27;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>传参，默认两个参，名字无所谓，这里举例是a和b，看返回值来决定升序降序<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">116516</span>,<span class="number">1213</span>,<span class="number">123</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr))</span><br><span class="line"><span class="keyword">let</span> upArr = arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);</span><br><span class="line"><span class="keyword">let</span> downArr = arr2.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>b-a);</span><br><span class="line"><span class="built_in">console</span>.log(upArr)</span><br><span class="line"><span class="built_in">console</span>.log(downArr)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">     1,      4,   5,</span></span><br><span class="line"><span class="comment">     8,      8, 123,</span></span><br><span class="line"><span class="comment">  1213, 116516</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  116516, 1213, 123,</span></span><br><span class="line"><span class="comment">       8,    8,   5,</span></span><br><span class="line"><span class="comment">       4,    1</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>思想：从第一个元素开始比较相邻的元素大小，大则交换(升序)<br>时间复杂度：O(n²)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">116516</span>,<span class="number">1213</span>,<span class="number">123</span>]</span><br><span class="line"><span class="keyword">const</span> bubblesort = (<span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;len-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j+<span class="number">1</span>]&lt;arr[j])&#123;</span><br><span class="line">                [arr[j],arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>],arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(bubblesort(arr))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">     1,      4,   5,</span></span><br><span class="line"><span class="comment">     8,      8, 123,</span></span><br><span class="line"><span class="comment">  1213, 116516</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>优化：如果原数组已经是排序数组，就不必再排，用flag<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bubblesort = (<span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)<span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(bubblesort(arr))</span><br></pre></td></tr></table></figure></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>思想：每次都找到最小值放在头部，然后缩小范围继续操作 直到完全有序<br>时间复杂度：O(n²)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectsort = (<span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[minIndex]&gt;arr[j])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minIndex!==i)&#123;</span><br><span class="line">            [arr[minIndex],arr[i]] = [arr[i],arr[minIndex]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(selectsort(arr))</span><br></pre></td></tr></table></figure></p><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浅谈TCP与UDP</title>
    <link href="https://zlinni.github.io/posts/fc0d16b05cf3/"/>
    <id>https://zlinni.github.io/posts/fc0d16b05cf3/</id>
    <published>2022-04-23T06:24:50.000Z</published>
    <updated>2022-04-23T06:32:27.065Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>web前端常考TCP与UDP的知识解析，力争基础达标，往后深入的点分开补充~</p></div><p>关键词:TCP/UDP、三次握手、四次挥手、流量控制、拥塞控制、TCP粘包<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423142857.png" alt=""></p><h1 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h1><div class="note primary flat"><ol><li>tcp是面向链接的 udp是无连接的即发送数据前不需要建立连接</li><li>tcp提供可靠的服务，也就是说通过tcp连接发送的数据，无差错，不丢失，不重复，且按序到达，udp尽最大的努力交付，即不保证可靠交付。并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换</li><li>tcp是面向字节流，udp面向报文，并且网络出现拥塞不会使得发送速率降低（因此会产生丢包，对实时的应用比如ip电话和视频会议等）</li><li>tcp只能是一对一的，udp支持1对1 1对多</li><li>tcp的首部较大为20字节 udp只有8字节</li><li>tcp是面向连接的可靠性传输，udp是不可靠的 </li></ol></div><h2 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h2><p>UDP：</p><ul><li>直播</li><li>游戏</li></ul><h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><div class="note primary flat"><p>建立连接前，客户端和服务端需要通过握手来确认对方</p></div><ul><li>客户端发送SYN同步序列编号请求，进入SYN_SEND状态，等待确认</li><li>服务端接收并确认SYN包之后发送SYN+ACK包，进入SYN_RECV状态</li><li>客户端接收SYN+ACK包之后，发送ACK包，双方进入ESTABLISHED状态</li></ul><h2 id="为什么采用三次握手？"><a href="#为什么采用三次握手？" class="headerlink" title="为什么采用三次握手？"></a>为什么采用三次握手？</h2><p>举例：已失效的连接请求报文段</p><ul><li>如果客户端发送请求报文但由于网络问题导致报文失效，服务端接收到请求后就会发送确认报文表示同意连接。此时如果是两次握手，那么此时服务端已经建立了新的连接，但由于这个请求是失效的，客户端并没有建立连接，服务端就会浪费很多资源。如果是三次握手，那么此时服务端收不到确认连接的信息，就知道客户端没有建立连接。这就是三次握手的作用。<div class="note primary flat"><p>TCP有六种标识SYN建立连接，ACK确认，PSH传送，FIN结束，RST重置，URG紧急</p></div></li></ul><h2 id="三次握手过程中可以携带数据吗？"><a href="#三次握手过程中可以携带数据吗？" class="headerlink" title="三次握手过程中可以携带数据吗？"></a>三次握手过程中可以携带数据吗？</h2><ul><li>第一次第二次握手不能携带数据，因为第一次握手和第二次握手服务端还没有建立连接，此时发送数据会让服务器受到攻击。</li><li>第三次握手服务器已经处于ESTABLISHED状态，对于客户端来说已经建立了连接，并且也知道服务器的接收发送能力是正常的了，所以能携带数据。</li></ul><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><div class="note primary flat"><p>为了确保数据能完成传输</p></div><ul><li>客户端—FIN—&gt;服务端，FIN——WAIT</li><li>服务端—ACK—&gt;客户端，CLOSE——WAIT</li><li>服务端—ACK，FIN—&gt;客户端，LAST——ACK</li><li>客户端—ACK—&gt;服务端，CLOSED</li></ul><h2 id="为什么连接的时候是三次握手，关闭的时候是四次挥手？"><a href="#为什么连接的时候是三次握手，关闭的时候是四次挥手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候是四次挥手？"></a>为什么连接的时候是三次握手，关闭的时候是四次挥手？</h2><ul><li>服务端接收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。</li><li>但是在关闭连接的时候，当服务端收到FIN报文的时候 ，很可能并不会立刻关闭连接，所以只能先回复一个ACK报文，告诉客户端，你发的FIN报文收到了，只有等服务器所有的报文发送完了才能发送FIN报文，因此不能一起发送，故需要四次挥手。 </li></ul><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><div class="note primary flat"><p>网络拥塞（congestion）是指在分组交换网络中传送分组的数目太多时，由于存储转发节点的资源有限而造成网络传输性能下降的情况。当网络发生拥塞时，一般会出现数据丢失，时延增加，吞吐量下降，严重时甚至会导致“拥塞崩溃”（congestion collapse）。通常情况下，当网络中负载过度增加致使网络性能下降时，就会发生网络拥塞。下图则描述了在有无拥塞控制的干预下，网络吞吐量随输入负载的增加的变化情况。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423112204.png" alt=""><br>通过以上的描述，我们大概可以得到以下信息：</p><ul><li>网络拥塞往往是由于对资源的请求超出了存储转发节点的能力而导致的。</li><li>网络拥塞可能会导致数据丢失，时延增加，吞吐量下降等问题。</li><li>若出现拥塞而不进行控制，有可能会使整个网络情况恶化，甚至网络吞吐降为0。</li><li>网络的拥塞状况与当前网络负载是密切相关的。</li></ul><h2 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h2><ol><li>慢启动</li><li>拥塞避免</li><li>快重传</li><li>快恢复</li></ol><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>如果发送方的数据发送过快，接收者来不及接收，就有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。</p><p>流量控制的根本目的是防止分组丢失，它是构成TCP可靠性的一方面</p><h2 id="实现流量控制"><a href="#实现流量控制" class="headerlink" title="实现流量控制"></a>实现流量控制</h2><p>滑动窗口协议（连续ARQ协议）实现。它保证了分组无差错，有序接收，也实现了流量控制。</p><p>主要的方式是 接收方返回的ack包会包含自己接收窗口的大小，并且利用大小来控制发送方的数据发送</p><h2 id="流量控制引发的死锁？怎么避免死锁发生？-没看明白"><a href="#流量控制引发的死锁？怎么避免死锁发生？-没看明白" class="headerlink" title="流量控制引发的死锁？怎么避免死锁发生？(没看明白)"></a>流量控制引发的死锁？怎么避免死锁发生？(没看明白)</h2><p>当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。</p><h2 id="拥塞控制和流量控制的区别"><a href="#拥塞控制和流量控制的区别" class="headerlink" title="拥塞控制和流量控制的区别"></a>拥塞控制和流量控制的区别</h2><p>拥塞控制就是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的方法是：慢开始，拥塞避免，快重传，快恢复。</p><p>流量控制就是作用于接收者的，它是控制发送者的发送速度从而使得接收者来得及接收，防止分组丢失</p><h1 id="TCP粘包"><a href="#TCP粘包" class="headerlink" title="TCP粘包"></a>TCP粘包</h1><h1 id="什么是TCP粘包"><a href="#什么是TCP粘包" class="headerlink" title="什么是TCP粘包"></a>什么是TCP粘包</h1><div class="note primary flat"><p>现在假设客户端连续发了两个数据包给服务端，用pack1和pack2来表示，那么就有以下几种情况：</p></div><ol><li>接收端正常收到了两个数据包，没有发生异常<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423102351.png" alt=""></li><li>接收端只收到一个数据包，因为TCP不会丢包所以这个数据包包含了发送端发送的两个数据包，这就是粘包。服务端不知道怎么划分这两个数据包所以很难处理。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423102618.png" alt=""></li><li>接收端收到两个数据包，但它们都不完整。这种情况下可能是pack1丢了一点到pack2，也有可能是pack2丢了一点到pack1，此时发生了粘包拆包<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423103042.png" alt=""></li></ol><h1 id="为什么会发生粘包拆包"><a href="#为什么会发生粘包拆包" class="headerlink" title="为什么会发生粘包拆包"></a>为什么会发生粘包拆包</h1><p>原因如下：</p><ol><li>本身套接字缓冲区大小不足，一次写入的数据多了，就发生了拆包</li><li>本身套接字缓冲区过大，多次写入数据，就发生了粘包</li><li>TCP连接复用，本来单独的连接中双方规定好了数据格式，但是因为复用导致多个进程以及不同的数据格式传输，就造成了粘包</li><li>接收方没及时接收数据，就发生了粘包</li></ol><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决方法就是处理这个边界问题。</p><ol><li>尾部标识法：通过协商的尾部标记，比如<code>\n\t\r</code>等来说明这是边界</li><li>头部标记法：不是不知道长度吗？直接在TCP头部加上标识数据长度</li><li>定长发送法：发送端封装数据包为指定长度发送</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="计算机网络" scheme="https://zlinni.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>面试官问我了解TCP粘包吗</title>
    <link href="https://zlinni.github.io/posts/0946a1855d73/"/>
    <id>https://zlinni.github.io/posts/0946a1855d73/</id>
    <published>2022-04-23T02:10:31.000Z</published>
    <updated>2022-04-23T03:17:03.375Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>有一天小明高兴的去面试，突然间面试官抛出一个问题：什么是TCP粘包？这下子好了，小明脑袋搜索了TCP的内容，发现只搜索到TCP和UDP的区别，流量控制，拥塞控制，和三握四挥这几个内容，小明尴尬的说：我不知道。于是回来恶补了TCP粘包的内容</p></div><p>关键词：TCP粘包、拆包<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423111651.png" alt=""></p><h1 id="什么是TCP粘包"><a href="#什么是TCP粘包" class="headerlink" title="什么是TCP粘包"></a>什么是TCP粘包</h1><div class="note primary flat"><p>现在假设客户端连续发了两个数据包给服务端，用pack1和pack2来表示，那么就有以下几种情况：</p></div><ol><li>接收端正常收到了两个数据包，没有发生异常<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423102351.png" alt=""></li><li>接收端只收到一个数据包，因为TCP不会丢包所以这个数据包包含了发送端发送的两个数据包，这就是粘包。服务端不知道怎么划分这两个数据包所以很难处理。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423102618.png" alt=""></li><li>接收端收到两个数据包，但它们都不完整。这种情况下可能是pack1丢了一点到pack2，也有可能是pack2丢了一点到pack1，此时发生了粘包拆包<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423103042.png" alt=""></li></ol><h1 id="为什么会发生粘包拆包"><a href="#为什么会发生粘包拆包" class="headerlink" title="为什么会发生粘包拆包"></a>为什么会发生粘包拆包</h1><p>原因如下：</p><ol><li>本身套接字缓冲区大小不足，一次写入的数据多了，就发生了拆包</li><li>本身套接字缓冲区过大，多次写入数据，就发生了粘包</li><li>TCP连接复用，本来单独的连接中双方规定好了数据格式，但是因为复用导致多个进程以及不同的数据格式传输，就造成了粘包</li><li>接收方没及时接收数据，就发生了粘包</li></ol><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决方法就是处理这个边界问题。</p><ol><li>尾部标识法：通过协商的尾部标记，比如<code>\n\t\r</code>等来说明这是边界</li><li>头部标记法：不是不知道长度吗？直接在TCP头部加上标识数据长度</li><li>定长发送法：发送端封装数据包为指定长度发送</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>三道题，入门async和await</title>
    <link href="https://zlinni.github.io/posts/78bce575aa3c/"/>
    <id>https://zlinni.github.io/posts/78bce575aa3c/</id>
    <published>2022-04-22T06:32:35.000Z</published>
    <updated>2022-04-22T08:07:16.813Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>各厂很喜欢考的async和await题，一般不了解他的做法都很容易踩坑。下面用三道题来讲解怎么解这类型的题目<br>关键词:async、await、题解</p></div><h1 id="题一"><a href="#题一" class="headerlink" title="题一"></a>题一</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>第一道门槛：<br>大部分人在前面都没问题，到await这里就会卡住，此时对于await的情况是这样的。<br>他会去看自己之后的代码，</p><ol><li>查看其中是否有同步代码，如果有，执行</li><li>如果没有 其中异步的直接放到任务栈</li><li>分析await下面的代码<br>然后跳出代码，继续往下查看</li></ol><p>其中关于await的操作，其实是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(async2());</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//这也就是await后面的代码能看成是微任务的原因</span></span><br></pre></td></tr></table></figure></p><p>它等待async2执行完回调这个输出</p><p>第二道门槛：<br>这里就来到下面看有没有同步代码了 这里就是第二步门槛，如果你认为，他直接输出’script end’，那么你就踩坑了。这里我们看到在此之前new了Promise，关键来了，他会立刻执行它的构造函数，也就是你可以把这个构造函数看成是同步代码，此时就会输出<code>promise1</code>.再到<code>script end</code></p><p>第三道门槛：<br>此时，我们得知道 所有的同步任务都执行完了，开始执行任务栈中的代码了<br>此时的任务栈中有await之后的代码，promise的成功回调，和settimeout，当然为什么是这个顺序呢。我们要知道微任务会插队在宏任务前面，也就是一开始的顺序是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">settimeout</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> code 插队</span><br><span class="line">settimeout</span><br><span class="line"></span><br><span class="line"><span class="comment">//遇到promise 插队在宏任务前面</span></span><br><span class="line"><span class="keyword">await</span> code</span><br><span class="line">promise </span><br><span class="line">settimeout</span><br></pre></td></tr></table></figure><p>所以按顺序执行 结果是<code>async1 end``promise2``setTimeout</code></p><p>最终答案：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220422151115.png" alt=""></p><h1 id="题二"><a href="#题二" class="headerlink" title="题二"></a>题二</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise3&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise4&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>第一道门槛：<br>async2中promise的构造器执行之后，将成功的回调放进任务栈，再去把await下面的code放进任务栈</p><p>任务栈的内容（异步）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line"></span><br><span class="line">promise2(插队)</span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line"></span><br><span class="line">promise2</span><br><span class="line">async1 end(插队)</span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line"></span><br><span class="line">promise2</span><br><span class="line">async1 end</span><br><span class="line">promise4(插队)</span><br><span class="line"><span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure></p><p>最终答案<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">promise1</span><br><span class="line">promise3</span><br><span class="line">script end</span><br><span class="line">promise2</span><br><span class="line">async1 end</span><br><span class="line">promise4</span><br><span class="line"><span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure></p><h1 id="题三"><a href="#题三" class="headerlink" title="题三"></a>题三</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout1&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout2&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout3&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>前面的一样，不过这次进入async2后是宏任务，我们依然把它放进任务栈，再把<br>踩坑点：<br>容易忽视掉setimeout3是第一个宏任务。<br>因此答案为setimeout2 1 3 实际上是3 2 1</p><p>最终答案<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">promise2</span><br><span class="line">setTimeout3</span><br><span class="line">setTimeout2</span><br><span class="line">setTimeout1</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>三道基本的题，掌握了await的基本原理。其实就是promise的回调。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>DNS域名系统</title>
    <link href="https://zlinni.github.io/posts/1e69f2f0c754/"/>
    <id>https://zlinni.github.io/posts/1e69f2f0c754/</id>
    <published>2022-04-21T07:29:56.000Z</published>
    <updated>2022-04-23T02:52:32.016Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>web前端你必须了解的DNS，下面讲解DNS的一些过程和由来以及产生的安全问题<br>关键词：DNS是什么、DNS的分布式、层次数据库、本地DNS服务器、DNS递归查询和迭代查询、DNS缓存、DNS劫持</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220422103253.png" alt=""></p><h1 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS"></a>什么是DNS</h1><p>DNS即域名系统，全称是Domain Name System。当我们在浏览器输入一个URL地址的时候，浏览器要向这个URL的主机名对于的服务器发起请求，就得知道服务器的IP。对于浏览器来说，DNS的作用就是将主机名转换为IP地址。</p><div class="note primary flat"><p>DNS是：</p><ol><li>一个由分层的DNS服务器实现的分布式数据库</li><li>一个使得主机能够查阅分布式数据库的应用层协议</li></ol></div><p>也就是 DNS是一个应用层的协议，我们发送一个请求，其中包含我们要查询的主机名，他就会给我们返回这个主机名对应的IP。</p><p>其次，DNS是一个分布式数据库，整个DNS由分散在世界各地的很多台DNS服务器组成，每台DNS服务器上面都保存了一些数据，这些数据可以让我们查到最终主机名对应的IP</p><p>所以DNS的查询过程，本质上就是去向这些DNS服务器访问，直到查到这个IP为止。</p><h1 id="分布式、层次数据库"><a href="#分布式、层次数据库" class="headerlink" title="分布式、层次数据库"></a>分布式、层次数据库</h1><h2 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h2><p>因为所有的主机不可能全部ip都放在一台dns服务器上面，所以就一台一台分出来，每台存储不同的数据，负责不同的映射。</p><h2 id="什么是层次"><a href="#什么是层次" class="headerlink" title="什么是层次"></a>什么是层次</h2><p>DNS服务器有三种类型：根DNS服务器，顶级域DNS服务器和权威NDS服务器，<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421154505.png" alt=""></p><ul><li>根DNS服务器<br>首先我们要明确根域名是什么？比如<code>www.baidu.com</code>其实他的根域名是被隐藏的。真正的根域名是<code>www.baidu.com.root</code>后面的.root</li></ul><p>那么根DNS服务器的作用是什么?就是管理他的下一级，也就是顶级域DNS服务器。通过询问根DNS服务器，我们能查到该主机名对应的顶级域的ip是多少，从而继续向顶级域请求了解他的下一层。</p><ul><li><p>顶级域服务器<br>除了前面提到的com是顶级域名，常见的顶级域名还有cn，org，edu等。然后顶级域管理的是权威DNS</p></li><li><p>权威DNS<br>由各大厂商负责管理的域名，它可以返回最终的一个IP</p></li></ul><p>服务器之间是如何继续交互的，继续往下看：</p><h1 id="本地DNS服务器"><a href="#本地DNS服务器" class="headerlink" title="本地DNS服务器"></a>本地DNS服务器</h1><p>上一层没有讲到本地DNS服务器，是因为他严格意义上不属于DNS的层次结构。</p><p>什么是本地DNS服务器？</p><p>每个ISP都有一台本地DNS服务器，比如小区，大学，机构等。都有一台或多台本地DNS服务器。当主机发出DNS请求的时候，该请求被发往本地DNS服务器，本地DNS服务器代理这些请求，将它们转发到DNS服务器中。好比Nginx</p><h1 id="递归查询-迭代查询"><a href="#递归查询-迭代查询" class="headerlink" title="递归查询 迭代查询"></a>递归查询 迭代查询</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421155733.png" alt=""></p><p>其中com是顶级域名 n是权威域名 </p><p>这个过程中，主机向本地DNS服务器请求就是递归查询<br>本地服务器向根DNS，顶级DNS和权威DNS发出的请求就是迭代查询<br>迭代的特点就是所有的都是由本地DNS发出 所有的接收也是回到本地DNS</p><p>当然不是所有的DNS查询都是这样的模式 DNS查询可以是递归的，也可以是迭代的 如下图就只是递归的<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421160546.png" alt=""></p><h1 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h1><p>为了让我们更快的拿到想要的IP，DNS广泛使用了缓存技术。DNS的缓存原理就是，在一个DNS查询的过程中，某台DNS收到了一个DNS应答的时候，就能将映射缓存到本地，下次查询就能直接用到缓存的内容。</p><p>but 缓存不是永久的，他也会定时删除。</p><p>所以有了缓存，很多时候都绕开了根DNS，所以需要向根DNS发起的查询请求很少。</p><h1 id="DNS解析优化"><a href="#DNS解析优化" class="headerlink" title="DNS解析优化"></a>DNS解析优化</h1><p>主要分为两个方案</p><ul><li>DNS预解析</li><li>减少DNS请求</li></ul><h1 id="DNS预解析"><a href="#DNS预解析" class="headerlink" title="DNS预解析"></a>DNS预解析</h1><div class="note primary flat"><p>DNS解析也需要时间的，可以通过预解析的方式来预先获取域名所对应的IP</p></div><p>link方式：手动解析<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//blog.poetries.top&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>meta方式：https自动解析<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;x-dns-prefetch-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;on&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>设置响应头：自动解析<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.set(<span class="string">&#x27;X-DNS-Prefetch-Control&#x27;</span>, <span class="string">&#x27;on&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h1 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h1><p>域名劫持就是在劫持的范围内拦截解析的请求，分析请求的域名，把审查范围之外的请求放行，否则直接返回假的IP地址或者什么也不做使其失去响应，效果就是特定的网址不能访问或者访问的是假的网址</p><p>域名劫持会影响用户体验，一方面还有可能被诱骗到冒牌网站进行登陆导致隐私泄漏</p><p>DNS可以有本地DNS劫持，路由DNS劫持，攻击DNS服务器</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>加强本地的计算机病毒检查，开启防火墙，防止恶意软件，木马感染计算机等。</li><li>改变路由器默认密码，防止攻击者修改路由器的DNS配置指向恶意的DNS服务器。</li><li>企业可以准备两个or以上的域名，一个挂了用另外一个</li><li>用HTTP DNS 代替Local DNS</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>DNS的内容其实讲深了还是很多的，但是基本的原理和概念还是要清楚，熟悉一下DNS解析的过程以及这个递归和迭代，关于域名这块以后还是会出文章，有购买域名的打算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="网络" scheme="https://zlinni.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Flex弹性布局</title>
    <link href="https://zlinni.github.io/posts/9d84a5b2f0ac/"/>
    <id>https://zlinni.github.io/posts/9d84a5b2f0ac/</id>
    <published>2022-04-21T00:31:57.000Z</published>
    <updated>2022-04-21T08:30:45.081Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>详细记录flex弹性布局的具体属性和常考题。<br>关键词：flex属性、</p></div><h1 id="flex概念"><a href="#flex概念" class="headerlink" title="flex概念"></a>flex概念</h1><p>弹性盒子是一种按行或者按列布局元素的一种以为布局方法，容器里面的元素可以膨胀填充额外的空间，收缩来适应更小的空间，适用于任何元素。</p><p>元素使用flex布局就会在内部形成BFC，目前flex已经适配所有常规浏览器</p><h2 id="拓展：BFC"><a href="#拓展：BFC" class="headerlink" title="拓展：BFC"></a>拓展：BFC</h2><p>BFC：块级格式化上下文，是一个完全独立的空间，里面的子元素不会影响到外面的布局。</p><p>触发BFC的方式：</p><ul><li><code>overflow:hidden</code></li><li><code>display:inline-block,table-cell,flex</code></li><li><code>position:absolute,fixed</code></li></ul><p>BFC解决的问题：</p><ul><li>高度塌陷</li><li>margin边距重叠</li></ul><h1 id="flex和inline-flex"><a href="#flex和inline-flex" class="headerlink" title="flex和inline-flex"></a>flex和inline-flex</h1><p>display有两种设置方式：flex和inline-flex。</p><p>区别在于：<br>flex元素和宽度是父容器的100%<br>inline-flex是所有元素的宽度和<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421110404.png" alt=""></p><p>那么在元素溢出的情况下是怎么样呢？<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421110450.png" alt=""><br>可见inline-flex会撑大flex容器，造成溢出</p><p>使用inline-flex的时候，注意配合min-width和min-height一起使用。不建议显示设置height和width</p><h2 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h2><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421110628.png" alt=""><br>可以总结为 整个容器的设置flex 不占整个容器的或者容器的部分 设置为inline-flex</p><h1 id="主轴和交叉轴"><a href="#主轴和交叉轴" class="headerlink" title="主轴和交叉轴"></a>主轴和交叉轴</h1><p>flex布局有两个轴的概念：主轴和交叉轴。水平的叫做主轴，垂直的叫做交叉轴。主轴的开始位置叫做start 结束叫做end 交叉轴也是如此。<br>flex布局的元素称为容器container，他的所有子元素都是一个项目item</p><h1 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421085022.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421085431.png" alt=""></p><h2 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h2><ul><li>row:水平左 左对齐</li><li>row-reverse:水平右 右对齐</li><li>column: 垂直上 上对齐</li><li>column-reverse: 垂直下 下对齐</li></ul><p>场景<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421110854.png" alt=""></p><p>由于默认会携带<code>flex-direction:row</code>（代码冗余）所以在非row的时候再设置flex-direction做布局算法优化</p><h2 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h2><p>默认情况下元素不换行nowrap，加了wrap属性之后，会换行</p><ul><li>nowrap 不换</li><li>wrap 换行</li><li>wrap-reverse 换行 第一行在下方<br>eg<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="literal">null</span> <span class="literal">null</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span>    <span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h2><p>是direction和wrap属性的简写 默认为row nowrap<br>只设置一个值的时候 看匹配哪个属性值 来取值<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-flow</span>: row || nowrap</span><br></pre></td></tr></table></figure></p><h2 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h2><p>描述了元素在主轴上面的对齐方式</p><ul><li>flex-start 左对齐</li><li>flex-end 右对齐</li><li>center 居中</li><li>space-around 每个项目两端的间隔相等 意味着第一个和最后一个元素两侧的宽度不等</li><li>space-between 两端对齐 项目之间的间隔相等</li><li>space-evenly: 项目的间隔和容器的间隔相等</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421090432.png" alt=""></p><h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><p>描述元素在交叉轴上面的对齐方式</p><ul><li>flex-start 上对齐</li><li>flex-end 下对齐</li><li>center 居中</li><li>baseline 项目第一行文字的基线对齐</li><li>stretch 默认 如果没设置高度或者auto 则占满整个容器的高度</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421090724.png" alt=""></p><h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2><p>定义了多根轴线的对齐方式 前提设置flex-wrap：wrap 否则不生效</p><ul><li>flex-start 交叉轴起点</li><li>flex-end 交叉轴中终点</li><li>center 中点</li><li>space-between 两端对齐 轴线之间平均分 </li><li>space-around  轴线间间隔相等</li><li>stretch 默认值 占满整个交叉轴</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421091427.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421111124.png" alt=""></p><h2 id="gap"><a href="#gap" class="headerlink" title="gap"></a>gap</h2><p>gap用来控制flex项目之间的间距，但会忽略flex项目与flex容器边缘的间距<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421111332.png" alt=""></p><h1 id="项目的子项属性"><a href="#项目的子项属性" class="headerlink" title="项目的子项属性"></a>项目的子项属性</h1><h2 id="order"><a href="#order" class="headerlink" title="order"></a>order</h2><p>定义项目的排列顺序 数值越小越前 默认0 可以是负数<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421091444.png" alt=""></p><p>场景：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421111454.png" alt=""></p><h2 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h2><p>定义了容器中剩余空间应该有多少分配给项目，最终的宽度为：自身宽度+容器剩余空间分配宽度 该属性的最大值是1 超过1按1来拓展<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421091802.png" alt=""></p><h2 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h2><p>该属性指定了flex元素的收缩规则。只在项目的元素宽度和大于容器的时候才会触发。收缩的大小是依据该属性的值 默认为1</p><p>eg 两个div 第一个div宽度200 第二个div宽度300 容器400<br>容器设置了flex布局 两个div的shrink都设置为1<br>那么此时 两个div500大于400 所以触发收缩</p><p>那么收缩后子项的宽度怎么计算呢？<br>有公式如下</p><ol><li>所有子项宽度和-容器的宽度=<code>500 - 400 = 100</code></li><li>第一个子项的占比 <code>2/5</code> 第二个子项的占比 <code>3/5</code></li><li>第一个子项的宽度为<code>200-2/5*100=160</code>,第二个为:<code>300-3/5*100=240</code></li></ol><h2 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h2><p>指定子项目的在主轴的初始化大小，优先级高于自身宽度width<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-basis</span>: <span class="number">0</span> | <span class="number">100%</span> | auto | &lt;length&gt;</span><br></pre></td></tr></table></figure></p><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>flex是flex-grow flex-shrink 和 flex-basis的简写<br>单值的时候 数值被当作flexgrow 一个有效的宽度值被当作basis<br>双值的时候 一个无单位的数 被当成shrink 一个有效的宽度值被当成basis<br>三值 略</p><p>默认 0 1 auto</p><p>取值，除了自定义的三种外：<br><code>auto</code>根据自身的width和height来确定比例 相当于<code>1 1 auto</code><br><code>initial</code>相当于0 1 auto<br><code>none</code> 0 0 auto</p><h2 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h2><p>允许单个项目有和其他项目不一样的对齐方式，可以覆盖align-items属性，默认auto表示继承align-items 如果没有父元素 则等于stretch<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421092936.png" alt=""></p><p>常见使用场景<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421111420.png" alt=""></p><h1 id="Flex项目上的-margin"><a href="#Flex项目上的-margin" class="headerlink" title="Flex项目上的 margin"></a>Flex项目上的 margin</h1><p>在Flex项目显式设置 margin 的值为 auto 可以灵活的控制单个Flex项目在Flex容器中的位置：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421105904.png" alt=""><br>比如像下图这样的效果，使用 margin-left: auto 就非常的实用：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421105923.png" alt=""></p><h1 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h1><p>等高布局</p><p>左侧宽度固定 右侧宽度自适应布局（常见的tob系统布局，左侧菜单树右侧内容）<br>粘性页脚<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421105548.png" alt=""><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex__container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;coupon&quot;</span>&gt;</span>卷<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;divider&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;price&quot;</span>&gt;</span><span class="symbol">&amp;yen;</span>1000<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.flex__container &#123;</span><br><span class="line">  display: inline-flex;</span><br><span class="line">  min-width: 200px;</span><br><span class="line">  height: 60px;</span><br><span class="line">  </span><br><span class="line">  border: 1px solid rgba(255, 0, 54, 1);</span><br><span class="line">  background-color: rgba(255, 0, 54, 0.1);</span><br><span class="line">  border-radius: 4px;</span><br><span class="line">  color: #ff0036;</span><br><span class="line">  font-size: 24px;</span><br><span class="line">  font-weight: 400;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.flex__container &gt; span &#123;</span><br><span class="line">  display: inline-flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.divider &#123;</span><br><span class="line">  border-right: 1px dashed currentColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.coupon &#123;</span><br><span class="line">  min-width: 50px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.price &#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">  min-width: 0;</span><br><span class="line">  padding: 0 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的JavaScript合集</title>
    <link href="https://zlinni.github.io/posts/e1434c3cc724/"/>
    <id>https://zlinni.github.io/posts/e1434c3cc724/</id>
    <published>2022-04-20T07:40:52.000Z</published>
    <updated>2022-04-20T07:58:09.915Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>将2w字长文分成了七个模块，方便今后补充内容，详见传送门。</p></div><h1 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h1><p><a href="https://zlinni.github.io/posts/fee85c52fd07/">你所不知道的JavaScript①—数据类型及周边</a><br><a href="https://zlinni.github.io/posts/0c4c7b52a0ab/">你所不知道的JavaScript②—this及周边</a><br><a href="https://zlinni.github.io/posts/73e8e77b5cac/">你所不知道的JavaScript③—原型及周边</a><br><a href="https://zlinni.github.io/posts/4a3d108576f2/">你所不知道的JavaScript④—异步任务与事件</a><br><a href="https://zlinni.github.io/posts/9f52b30fe4c5/">你所不知道的JavaScript⑤—垃圾回收与内存泄漏</a><br><a href="https://zlinni.github.io/posts/01f1f2b3c139/">你所不知道的JavaScript⑥—面向对象与模块化</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的JavaScript⑥--面向对象与模块化</title>
    <link href="https://zlinni.github.io/posts/01f1f2b3c139/"/>
    <id>https://zlinni.github.io/posts/01f1f2b3c139/</id>
    <published>2022-04-20T07:32:49.000Z</published>
    <updated>2022-04-20T07:39:56.135Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><div class="note simple"><p>面向对象、迭代器、模块化</p></div><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="对象遍历"><a href="#对象遍历" class="headerlink" title="对象遍历"></a>对象遍历</h2><ol><li><code>for in</code></li><li><code>Object.keys(xxx)</code>把key取出来作为一个数组。</li><li><code>Object.values(xxx)</code>遍历对象的值作为一个数组<h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2></li></ol><ul><li>基本思想是使用对象，类，继承，封装等基本概念来进行程序设计</li><li>优点：<ul><li>易维护：采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，维护也只是在局部模块，所以维护起来非常方便，成本较低</li><li>易拓展</li><li>开发工作的重用性，继承性高，降低重复工作量</li><li>缩短了开发周期<div class="note primary flat"><p>一般面向对象包括：继承，封装，多态，抽象</p></div></li></ul></li></ul><h2 id="对象形式的继承"><a href="#对象形式的继承" class="headerlink" title="对象形式的继承"></a>对象形式的继承</h2><div class="note primary flat"><p>讲深浅拷贝之前，我们需要知道，基本数据类型在栈里面，被复制了就算修改也不会改变原来的的值，引用数据类型在堆里面，因为共享内存所以复制后被修改会改变源对象的值，至此引申出深浅拷贝。</p></div><ul><li>浅拷贝<div class="note primary flat"><p>基本的浅拷贝就是对象的赋值，但我们需要注意，实际上我们的需求是复制源对象上面的属性，那么单纯的赋值，会把新对象的值给覆盖掉。参见下面</p></div></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;allin&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">home</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">        <span class="attr">office</span>: <span class="string">&#x27;office&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">sclools</span>: [<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;z&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> programer = &#123;</span><br><span class="line">    <span class="attr">language</span>: <span class="string">&#x27;js&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果不使用该方法 programmer里面的language会被覆盖掉</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">p, c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = c || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> prop <span class="keyword">in</span> p)&#123;</span><br><span class="line">        c[prop] = p[prop];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">extend(Person, programer);</span><br><span class="line"><span class="comment">//or </span></span><br><span class="line"><span class="comment">// programer = Object.assign(programer,Person);</span></span><br><span class="line">programer.name;  <span class="comment">// allin</span></span><br><span class="line">programer.address.home;  <span class="comment">// home</span></span><br><span class="line">programer.address.home = <span class="string">&#x27;house&#x27;</span>;  <span class="comment">//house</span></span><br><span class="line">Person.address.home;  <span class="comment">// house</span></span><br><span class="line"><span class="comment">//programmer依旧保留自己的language</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>注意 浅拷贝不是新对象的地址指向整个旧对象的地址，而是拷贝旧对象的属性的地址。即自己原先的内容不变，拷贝的过程中如果key重复覆盖，否则保留。<br>思路是遍历对象 赋值。</p></div><p>深拷贝<br><div class="note primary flat"><p>深拷贝是开辟一个新的内存地址，将源对象的各个属性复制进去<br>注意的点：对象原型上面的属性不应该去拷贝，使用到<code>Object.hasOwnProperty(key)</code></p></div></p><ol><li>通过<code>JSON.parse(JSON.stringfy())</code>进行深拷贝</li></ol><ul><li>是序列化和反序列化的过程，序列化是存储地址的一个映射，所以反序列化之后，修改并不会影响原先的地址。就可以达成深拷贝。</li><li>缺点：不能拷贝<code>undefined function 正则 Error对象</code></li></ul><ol><li>递归</li></ol><ul><li>通过判断引用类型数据进行初始化之后赋值的操作指向新的地址。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断是否是引用类型或者null 否则返回源对象进行浅拷贝</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>||obj===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是数组，初始化地址。</span></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        result = [];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归调用 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            result[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li>缺点：栈会溢出。</li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul><li>命名空间<ul><li>js是没有命名空间的，因此可以用对象来模拟</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = &#123;&#125;<span class="comment">//命名空间app</span></span><br><span class="line"><span class="comment">//模块1</span></span><br><span class="line">app.module1 = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;allin&#x27;</span>,</span><br><span class="line">  <span class="attr">f</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">app.module1.name;</span><br><span class="line">app.module1.f();</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>对象的属性外界是可读可写的，那么如何达到封装的目的？通过闭包和局部变量</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Girl</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//通过方法访问变量</span></span><br><span class="line">  <span class="keyword">var</span> love = <span class="string">&#x27;jojo&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.name =name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> love;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.movelove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    love = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Girl(<span class="string">&#x27;bb&#x27;</span>,<span class="number">19</span>);</span><br><span class="line">g.say();</span><br><span class="line">g.movelove();</span><br><span class="line">g.say();</span><br></pre></td></tr></table></figure><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><div class="note primary flat"><p>就是在函数外面定义静态方法，静态方法只有该类能够使用。</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员</span></span><br><span class="line">Person.walk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;static&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Person.walk();  <span class="comment">// static</span></span><br></pre></td></tr></table></figure><h2 id="私有与公有"><a href="#私有与公有" class="headerlink" title="私有与公有"></a>私有与公有</h2><div class="note primary flat"><p>对象的方法和属性分为私有和公有，公有的属性需要在实例化的时候传入对应的值去调用，私有的属性和方法只能通过公有的方法暴露出去。注意私有的方法如果返回的是公有的属性，还需要使用call改变this指向</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 私有属性与方法</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;allin&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//公有属性与方法</span></span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;say hello&#x27;</span>);</span><br><span class="line">        work.call(<span class="built_in">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="number">123</span>);</span><br><span class="line">p1.name; <span class="comment">// undefined</span></span><br><span class="line">p1.id;  <span class="comment">// 123</span></span><br><span class="line">p1.say();  <span class="comment">// say hello 123</span></span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><div class="note primary flat"><p>同一个父类继承出来的子类有各自的形态,写的时候注意<code>子类,prototype = new 父类()</code></p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.eat = <span class="string">&#x27;肉&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tiger</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.color = <span class="string">&#x27;黑黄相间&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cheetah</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.color = <span class="string">&#x27;报文&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Lion</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.color = <span class="string">&#x27;土黄色&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tiger.prototype =  Cheetah.prototype = Lion.prototype = <span class="keyword">new</span> Cat();<span class="comment">//共享一个祖先 Cat</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> T = <span class="keyword">new</span> Tiger();</span><br><span class="line"><span class="keyword">var</span> C = <span class="keyword">new</span> Cheetah();</span><br><span class="line"><span class="keyword">var</span> L = <span class="keyword">new</span> Lion();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(T.color);</span><br><span class="line"><span class="built_in">console</span>.log(C.color);</span><br><span class="line"><span class="built_in">console</span>.log(L.color);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(T.eat);</span><br><span class="line"><span class="built_in">console</span>.log(C.eat);</span><br><span class="line"><span class="built_in">console</span>.log(L.eat);</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><div class="note primary flat"><p>虚函数是类成员中的概念，是只做了一个声明而未实现的方法，具有虚函数的类称之为抽象类。抽象类不能被实例化因为其中的虚函数并不是一个完整的函数，不能被调用。<br>在js中实现抽象类就是在父类中调用一个未定义的方法，但这个方法在子类中必须被实现。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AbstractClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象类不能直接被调用&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">AbstractClass.prototype.detect = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">AbstractClass.prototype.stop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;stop&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">AbstractClass.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NormalClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  NormalClass.prototype = <span class="built_in">Object</span>.create(AbstractClass.prototype);</span><br><span class="line">  NormalClass.prototype.constructor = NormalClass;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> NormalClass();</span><br><span class="line"><span class="built_in">console</span>.log(n)</span><br><span class="line">n.detect();</span><br><span class="line">n.init();</span><br></pre></td></tr></table></figure><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><ol><li>面向对象的三个基本特征</li><li>手写一下函数的公有和私有方法以及调用的形式<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;jojo&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">    sayName.call(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h1><div class="note primary flat"><p>Iterator是一种接口，也可以说是一种规范，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。即依次处理该数据结构的所有成员</p></div><p>语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note primary flat"><p><code>[Symbol.iterator]</code>属性名是固定的写法，只要拥有了该属性的对象，就能用迭代器的方式进行遍历。</p></div></p><ul><li>迭代器的遍历方法是首先获得一个迭代器的指针。初始时该指针指向第一条数据之前，接着通过调用next方法，改变指针的指向，让他调用下一条数据。</li><li>每次的next都会返回一个对象 有两个属性<ul><li>value： 表示你想获取的数据</li><li>done：布尔值 代表遍历是否结束 true则结束<h2 id="iterator的作用"><a href="#iterator的作用" class="headerlink" title="iterator的作用"></a>iterator的作用</h2>三个作用</li></ul></li><li>创建一个指针对象指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的next方法 指针指向第二个成元</li><li>不断调用next 直到结束位置(假如有三个数据 需要next四次 最后一次的结果是<code>&#123; value: undefined, done: true &#125;</code>)<br>案例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123;<span class="attr">nums</span>:<span class="number">1</span>&#125;,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="built_in">Symbol</span>.iterator]();<span class="comment">//获取数组的迭代器</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: Object &#123; num: 1 &#125;, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h2 id="具有iterator接口的数据结构"><a href="#具有iterator接口的数据结构" class="headerlink" title="具有iterator接口的数据结构"></a>具有iterator接口的数据结构</h2><div class="note primary flat"><p>一个数据结构只要有iterator接口就能被认为是可以遍历的。可以用forof。</p></div>具有iterator接口的数据结构的有四种：</li></ul><ol><li>数组</li><li>类数组</li><li>Set</li><li>Map<h2 id="为什么对象没有iterator接口"><a href="#为什么对象没有iterator接口" class="headerlink" title="为什么对象没有iterator接口"></a>为什么对象没有iterator接口</h2></li></ol><ul><li>对象只能用forin和<code>Object.keys、values</code>遍历</li><li>因为一个对象的哪个属性先遍历和后便利是不确定的，需要开发者手动指定。</li><li>对对象部署iterator接口没有必要 因为map弥补了他的缺陷而且map有iterator接口<br>对对象部署iterator<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    <span class="attr">hobbie</span>: <span class="string">&#x27;睡觉&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keyArr = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> index&lt;keyArr.length?&#123;</span><br><span class="line">        <span class="attr">value</span>:&#123;</span><br><span class="line">          <span class="attr">key</span>:keyArr[index],</span><br><span class="line">          <span class="attr">val</span>:obj[keyArr[index++]]</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;:&#123;</span><br><span class="line">        <span class="attr">done</span>:<span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><div class="note primary flat"><p>四种方案：commonjs，AMD，CMD，ES6</p></div><ul><li><p>CommonJS，node的，通过require来引入模块，通过<code>module.exports</code>定义输出接口。是以同步的方式引入模块的。</p></li><li><p>AMD是采用异步的方式加载模块，模块的加载不影响后面语句的执行 所有依赖这个模块的语句都定义在一个回调函数里面，等加载完再执行回调函数。requirejs实现了AMD规范</p></li><li>CMD方案，也是解决异步加载的委托。代表有seajs。和requirejs的区别在于模块定义的时候堆依赖的处理不同和对依赖模块的执行时机处理不同。</li><li>最后是es6的，通过import和export进行导入导出。默认暴露统一暴露分别暴露。<ul><li>默认暴露：<code>export default</code></li><li>分别暴露：<code>export xxx1;exportxxx2</code>，引入<code>import &#123;xxx1,xxx2&#125; from &#39;xxx&#39;</code></li><li>统一暴露：<code>export &#123;aa1,aa1&#125;</code>，引入<code>import &#123;aa1,aa2&#125; from &#39;xxx&#39;</code></li></ul></li></ul><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><ul><li>写法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.a;<span class="comment">//1</span></span><br></pre></td></tr></table></figure></li><li>注意浏览器中使用的话用<code>browserify</code><div class="note primary flat"><p>和es6的区别如下：</p></div></li><li>前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案,前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。</li><li>而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li><li>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。</li><li>但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li><li>后者会编译成 require/exports 来执行的</li></ul><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><div class="note primary flat"><p>和CMD的区别：</p></div><ul><li>对依赖的处理不一样。AMD是依赖前置。定义模块的时候就要声明依赖的模块，CMD就近依赖，用到哪个才去require</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>); <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐</span></span><br><span class="line">define([<span class="string">&quot;./a&quot;</span>, <span class="string">&quot;./b&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>对于依赖模块的执行实际处理不同。AMD和CMD异步加载，但是AMD在模块加载完就立刻执行依赖模块，依赖模块的执行顺序和我们写的顺序不一定一致。而CMD在依赖模块加载完成后并不执行，只是下载。等全部的依赖模块都加载好后，再去执行，和我们的书写顺序一致。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的JavaScript⑤--垃圾回收与内存泄漏</title>
    <link href="https://zlinni.github.io/posts/9f52b30fe4c5/"/>
    <id>https://zlinni.github.io/posts/9f52b30fe4c5/</id>
    <published>2022-04-20T07:02:04.000Z</published>
    <updated>2022-04-20T07:39:05.210Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><div class="note simple"><p>垃圾回收、内存泄漏</p></div><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><ul><li>对于在js中的字符串，对象，数组是没有固定大小的，只有当对它们进行动态分配存储的时候，解释器才会分配内存来处理这些数据。当js的解释器消耗完系统中所有可用的内存的时候，就会造成系统崩溃。</li><li>内存泄漏，在某些情况下，不再使用到的变量所占用内存没有及时释放，导致程序运行中，内存占用越来越大，极端情况导致系统崩溃，服务器宕机。</li><li>js有自己的一套辣鸡回收机制，js 的解释器可以检测到什么时候程序不再使用这个对象（数据），就会把它所占用的内存释放掉。</li><li>针对js的来及回收机制有下面两种方法（常用）：标记清除，引用计数。</li><li>标记清除。<div class="note primary flat"><p>v8的辣鸡回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另外一个是不死的对象会活得更久。基于这个假说，v8引擎将内存分为了新生代和老生代。</p></div></li><li>新创建的对象或者只经过一次的辣鸡回收的对象被称为新生代，经历过多次垃圾回收的对象被称为老生代。</li><li>新生代被分为from和to两个空间，to一般是闲置的。当from空间满了之后会执行Scavenge算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后继续执行。</li></ul><h2 id="Scavenge"><a href="#Scavenge" class="headerlink" title="Scavenge"></a>Scavenge</h2><div class="note primary flat"><p>这个算法分三步：</p></div><ul><li>首先检查from空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代，如果不满足条件则移动to空间。</li><li>如果对象不存活，则释放对象的空间。</li><li>最后将From空间和to空间进行角色交换</li></ul><h2 id="新生代-gt-老生代"><a href="#新生代-gt-老生代" class="headerlink" title="新生代=&gt;老生代"></a>新生代=&gt;老生代</h2><div class="note primary flat"><p>条件有两个：</p></div><ul><li>第一个是判断对象是否经过一次Scavenge回收，如果经过则将对象从From空间复制到老生代中。若没有经历，则复制到to空间。</li><li>第二个是to空间的内存使用占比是否超过限制。当对象从from空间复制到to空间的时候，若to空间的使用超过25%，则将对象直接晋升到老生代。设置25%的原因是因为算法结束之后，两个空间结束后会交换位置，如果to空间的内存太小，会影响后续的内存分配。<div class="note primary flat"><p>老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉没有标记的对象，由于标记清除后会造成很多内存碎片，不便于后面的内存分配，所以了解内存碎片的问题引入了标记压缩法。</p></div>由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。为了解决这个问题v8引入了增量标记法，将一次停顿进行的过程分为多部，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</li></ul><h2 id="什么时候回收？"><a href="#什么时候回收？" class="headerlink" title="什么时候回收？"></a>什么时候回收？</h2><div class="note primary flat"><p>v8引擎帮我们实现了自动的垃圾回收管理。利用浏览器的渲染的空闲时间进行垃圾回收</p></div><h2 id="具体的回收机制？"><a href="#具体的回收机制？" class="headerlink" title="具体的回收机制？"></a>具体的回收机制？</h2><div class="note primary flat"><p>栈内存的回收：栈内存调用栈上下文切换后就被回收，比较简单。<br>堆内存的回收：v8的堆内存分为新生代内存和老生代内存，新生代内存是临时分配的内存，存在时间短，老生代存在时间长。<br>新生代的回收机制：新生代内存容量小，64位系统下只有32m。新生代内存分为from和to两个部分。在进行扫描的时候，先扫描from，将非存活对象回收，将存活对象顺序复制到to中，之后调换fromto进行下一次回收<br>老生代的回收机制：</p><ul><li>晋升：如果新生代的变量经过多次回收依然存在，那么就会被放入老内存中。</li><li>标记清除：老生代内存会先遍历所有对象并打上标记，然后对正在使用或被强引用的对象取消标记，回收标记的对象。</li><li>整理内存碎片：把对象挪到内存的一端。</li></ul></div><h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><ul><li>意外的全局变量：无法被回收</li><li>定时器：未被正确关闭，导致所引用的外部变量无法被释放。</li><li>事件监听：没有正确销毁（低版本浏览器可能出现）</li><li>闭包<ul><li>第一种情况是我们使用未声明的变量，而意外的创建了一个全局变量，而使得这个变量一直留在内存中无法被回收</li><li>第二种情况是我们设置了setInterval定时器，而忘记取消他，如果循环函数对外部变量有引用的话，那么这个变量会被一直留在内存中，无法被回收。</li><li>第三种情况是我们获取一个DOM元素的引用。而后面的元素被删除。由于我们一直保留了对这个元素的引用，所以他也无法被回收。</li><li>第四种情况是不合理的使用闭包，从而导致某些变量一直被流在内存当中。</li></ul></li><li>dom引用：dom元素被删除时，内存中的引用未被正确清空。</li><li>控制台<code>console.log</code>打印的东西</li></ul><div class="note primary flat"><p>可以用chrome中的timeline进行内存标记，可视化查看内存的变化情况，找出异常点。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的JavaScript④--异步任务与事件</title>
    <link href="https://zlinni.github.io/posts/4a3d108576f2/"/>
    <id>https://zlinni.github.io/posts/4a3d108576f2/</id>
    <published>2022-04-20T07:01:52.000Z</published>
    <updated>2022-04-20T07:38:06.200Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><div class="note simple"><p>事件机制、Promise、Generator、async/await、事件循环</p></div><h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><div class="note primary flat"><p>事件的触发过程？事件代理？</p></div><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><div class="note primary flat"><p>事件流是一个事件沿着特定数据结构传播的过程。冒泡和捕获是事件流在DOM中的两种不同的传播方式。</p></div><h2 id="事件流的三个阶段"><a href="#事件流的三个阶段" class="headerlink" title="事件流的三个阶段"></a>事件流的三个阶段</h2><ul><li>事件捕获阶段</li><li>目标阶段</li><li>事件冒泡阶段</li></ul><h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><div class="note primary flat"><p>事件捕获通俗的理解就是鼠标点击或者触发dom事件的时候，浏览器从根节点开始由外到内的进行事件传播，即点击了子元素。如果父元素通过捕获方式注册了对应的事件的话，会先触发父元素绑定的事件</p></div><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><div class="note primary flat"><p>事件冒泡和事件捕获相反，顺序是由内到外直到根节点</p></div><p>无论是事件捕获还是冒泡，都有一个共同的特征就是事件传播<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220404101558.png" alt=""></p><h2 id="事件流阻止"><a href="#事件流阻止" class="headerlink" title="事件流阻止"></a>事件流阻止</h2><div class="note primary flat"><p>在一些情况下要阻止事件流的传播，阻止默认动作的发生</p></div><ul><li><code>event.preventDefault()</code>取消事件对象的默认动作以及继续传播</li><li><code>event.stopPropagation()/event.cancelBubble = true</code>阻止事件冒泡<h3 id="在不同浏览器的处理"><a href="#在不同浏览器的处理" class="headerlink" title="在不同浏览器的处理"></a>在不同浏览器的处理</h3></li><li>在IE下使用 <code>event.returnValue= false</code>，</li><li>在非IE下则使用 <code>event.preventDefault()</code>进行阻止<h3 id="preventDefault与stopPropagation的区别"><a href="#preventDefault与stopPropagation的区别" class="headerlink" title="preventDefault与stopPropagation的区别"></a><code>preventDefault</code>与<code>stopPropagation</code>的区别</h3></li><li><code>preventDefault</code>告诉浏览器不用执行与事件相关联的默认动作（如表单提交）</li><li><code>stopPropagation</code>是停止事件继续冒泡，但是对IE9以下的浏览器无效<h2 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h2></li><li>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 <code>false</code>。useCapture 决定了注册的事件是捕获事件还是冒泡事件</li><li>一般来说，我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件<div class="note warning flat"><p>注意<code>addEventListener</code>需要销毁，<code>onClick</code>则不需要因为每次都替换</p></div><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2></li><li>优化性能，当子节点过多的时候给父元素绑定事件通过冒泡只执行一次事件节省内存并且不需要给子节点注销事件。<h2 id="事件的兼容写法"><a href="#事件的兼容写法" class="headerlink" title="事件的兼容写法"></a>事件的兼容写法</h2><div class="note primary flat"><p>ie的event和非ie的event不太一样，也不能一起用</p></div></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gete</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//兼容ie的事件</span></span><br><span class="line">  e = e || <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="comment">//兼容ie的target</span></span><br><span class="line">  <span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><div class="note primary flat"><p>谈到promise的时候，除了将他解决的痛点以及常用的api之外，最好进行拓展吧eventloop带进来好好讲一下。微任务，任务的指向顺序，如果看过promise源码，最好可以谈一谈原生promise是如何实现的，还有就是promise的链式调用</p></div><ul><li>promise是es6新增的语法，解决了回调地狱的问题</li><li>promise可以被看成是一个状态机，初始是<code>pending</code>可以通过函数<code>resolve</code>和<code>reject</code>将状态转变为<code>resolved</code>or<code>rejected</code>状态。状态一旦发生改变就不能再次变化。</li><li>then函数会返回一个promise实例，并且该返回值是一个新的实例而不是之前的实例。因为promise规范规定除了pending状态，其他状态是不能改变的。如果返回的是一个相同实例的话，多个then调用就失去了意义。对于then来说，本质上可以看成是flatMap</li></ul><h2 id="promise的基本情况"><a href="#promise的基本情况" class="headerlink" title="promise的基本情况"></a>promise的基本情况</h2><div class="note primary flat"><p>简单来说他是一个容器，里面保存着某个未来才会结束的事件，通常是异步操作的结果。从语法上面来说，promise是一个对象，从他可以获取异步操作的消息。</p></div><p>一般 Promise 在执行过程中，必然会处于以下几种状态之一。</p><ul><li>待定（pending）：初始状态，既没有被完成，也没有被拒绝。</li><li>已完成（fulfilled）：操作成功完成。</li><li>已拒绝（rejected）：操作失败。<div class="note primary flat"><p>待定状态的promise对象指向的话，最后要么会通过一个值完成，要么会通过一个原因被拒绝。当其中一种情况发生的时候，我们用promise的then方法排列起来的相关处理程序就会被调用。因为最后<code>Promise.prototype.then</code> 和 <code>Promise.prototype.catch</code>方法返回的是一个<code>Promise</code>所以它们可以继续被链式调用。</p></div>关于 Promise 的状态流转情况，有一点值得注意的是，内部状态改变之后不可逆，你需要在编程过程中加以注意。文字描述比较晦涩，我们直接通过一张图就能很清晰地看出 Promise 内部状态流转的情况<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220405105526.png" alt=""><h2 id="then-catch"><a href="#then-catch" class="headerlink" title="then catch"></a>then catch</h2></li><li>thencatch都会返回一个新的promise</li><li>catch不管放在哪里都能捕获上层未捕获的错误</li><li>不写默认返回<code>return Promise.resolve(undefined)</code>也是成功回调</li><li>直接return 一个error对象不会抛出错误 所以不会被catch捕获</li><li>返回的值不能是promise本身 否则死循环</li><li>then可以接收两个参数的，在某些时候你可以认为catch是then第二个参数的简便写法。<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2></li><li>不管最后的状态如何都会执行</li><li>不接受任何参数 所以在finally中是没办法知道最终的状态的</li><li>默认返回上一次的promise对象值，如果抛出的是一个异常则返回异常的promise对象</li></ul><h2 id="new-Promise（大坑）"><a href="#new-Promise（大坑）" class="headerlink" title="new Promise（大坑）"></a><code>new Promise</code>（大坑）</h2><p>先看一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    reject()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;失败的状态&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><br>正确答案是1243<br>这是为什么呢？因为我们会忽略一个问题，就是在<code>new Promise</code>的时候，构造器的方法就已经开始执行了，虽然我们一般提倡用函数封装之后<code>return</code>出去这个promise对象。所以就是先执行<code>new Promise</code>里面的代码 输出12然后状态到<code>resolved</code>然后执行同步的4 最后因为成功的回调到3</p><h2 id="promise的静态方法"><a href="#promise的静态方法" class="headerlink" title="promise的静态方法"></a>promise的静态方法</h2><h3 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h3><ul><li>语法:<code>Promise.all(iterable)</code></li><li>参数：一个可迭代对象，例如Array（括号里面放数组）</li><li>描述：此方法对于汇总多个promise的结果很有用，在es6中可以将多个<code>Promise.all</code>异步请求并发操作，返回的结果一般有下面两种情况。<ol><li>当所有结果成功返回按照请求顺序返回成功结果</li><li>当其中一个方法失败就进入失败方法。</li></ol></li><li>业务场景 </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个页面中需要加载获取轮播列表、获取店铺列表、获取分类列表这三个操作，页面需要同时发出请求进行页面渲染，这样用 `Promise.all` 来实现，看起来更清晰、一目了然。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获取轮播数据列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBannerList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;轮播数据&#x27;</span>)</span><br><span class="line">      &#125;,<span class="number">300</span>) </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.获取店铺列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStoreList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">&#x27;店铺数据&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">500</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.获取分类列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCategoryList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">&#x27;分类数据&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">700</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initLoad</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">Promise</span>.all([getBannerList(),getStoreList(),getCategoryList()])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) </span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; </span><br><span class="line">initLoad()</span><br></pre></td></tr></table></figure><h4 id="all如果有一个抛出了异常会如何处理。"><a href="#all如果有一个抛出了异常会如何处理。" class="headerlink" title="all如果有一个抛出了异常会如何处理。"></a>all如果有一个抛出了异常会如何处理。</h4><div class="note primary flat"><p>all和race传入的数组中如果会有抛出异常的异步任务，那么只有最先抛出的错误会被捕获。并且是被then的第二个参数或者后面的catch捕获，但并不影响数组中其他的异步任务的执行。</p></div><h4 id="all是并发的还是串行的"><a href="#all是并发的还是串行的" class="headerlink" title="all是并发的还是串行的"></a>all是并发的还是串行的</h4><div class="note primary flat"><p>并发的。不过<code>promise.all().then()</code>结果中数组的顺序和<code>Promise.all()</code>接收到的数组顺序一致</p></div><h4 id="all的并发限制"><a href="#all的并发限制" class="headerlink" title="all的并发限制"></a>all的并发限制</h4><div class="note primary flat"><p>Promise.all可以保证，promises数组中所有promise对象都达到resolve状态，才执行then回调。</p><p>这时候考虑一个场景：如果你的promises数组中每个对象都是http请求，或者说每个对象包含了复杂的调用处理。而这样的对象有几十万个。</p><p>那么会出现的情况是，你在瞬间发出几十万http请求（tcp连接数不足可能造成等待），或者堆积了无数调用栈导致内存溢出。</p><p>这时候，我们就需要考虑对Promise.all做并发限制。</p><p>Promise.all并发限制指的是，每个时刻并发执行的promise数量是固定的，最终的执行结果还是保持与原来的Promise.all一致。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncPool</span>(<span class="params">poolLimit, array, iteratorFn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line">    <span class="keyword">const</span> executing = [];</span><br><span class="line">    <span class="keyword">const</span> enqueue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 边界处理，array为空数组</span></span><br><span class="line">        <span class="keyword">if</span> (i === array.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每调一次enqueue，初始化一个promise</span></span><br><span class="line">        <span class="keyword">const</span> item = array[i++];</span><br><span class="line">        <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> iteratorFn(item, array));</span><br><span class="line">        <span class="comment">// 放入promises数组</span></span><br><span class="line">        ret.push(p);</span><br><span class="line">        <span class="comment">// promise执行完毕，从executing数组中删除</span></span><br><span class="line">        <span class="keyword">const</span> e = p.then(<span class="function">() =&gt;</span> executing.splice(executing.indexOf(e), <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 插入executing数字，表示正在执行的promise</span></span><br><span class="line">        executing.push(e);</span><br><span class="line">        <span class="comment">// 使用Promise.rece，每当executing数组中promise数量低于poolLimit，就实例化新的promise并执行</span></span><br><span class="line">        <span class="keyword">let</span> r = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">        <span class="keyword">if</span> (executing.length &gt;= poolLimit) &#123;</span><br><span class="line">            r = <span class="built_in">Promise</span>.race(executing);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归，直到遍历完array</span></span><br><span class="line">        <span class="keyword">return</span> r.then(<span class="function">() =&gt;</span> enqueue());</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> enqueue().then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.all(ret));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allSettled方法"><a href="#allSettled方法" class="headerlink" title="allSettled方法"></a><code>allSettled</code>方法</h3><ul><li><code>Promise.allSettled</code>的语法及参数跟<code>Promise.all</code>类似.不同在于它执行完之后不会失败，会按顺序返回每个promise的状态</li><li>案例</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="built_in">Promise</span>.allSettled([resolved, rejected]);</span><br><span class="line">allSettledPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回结果：</span></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 2 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><h3 id="any方法-还在草案不能使用"><a href="#any方法-还在草案不能使用" class="headerlink" title="any方法(还在草案不能使用)"></a>any方法(还在草案不能使用)</h3><ul><li>语法：<code>Promise.any（iterable）</code></li><li>参数： iterable 可迭代的对象，例如 Array。</li><li>描述：any返回一个promise 只要参数promise实例中有一个变成fulfilled状态，最后any返回的实例就返回fulfilled状态，如果全部都是rejected，就返回rejected状态<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> anyPromise = <span class="built_in">Promise</span>.any([resolved, rejected]);</span><br><span class="line">anyPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回结果：</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="race方法"><a href="#race方法" class="headerlink" title="race方法"></a>race方法</h3><ul><li>语法：<code>Promise.race（iterable）</code></li><li>参数： iterable 可迭代的对象，例如 Array。</li><li>描述： race方法返回一个promise，只要参数的promise之中有一个实例率先改变状态，那么race方法的返回状态就跟着改变。那个率先改变的promise实例的返回值就传递给race方法的回调函数。</li><li>业务场景：图片加载 超时判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求某个图片资源</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestImg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; resolve(img); &#125;</span><br><span class="line">    img.src = <span class="string">&#x27;http://www.baidu.com/img/flexible/logo/pc/result.png&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//延时函数，用于给请求计时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; reject(<span class="string">&#x27;图片请求超时&#x27;</span>); &#125;, <span class="number">5000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([requestImg(), timeout()])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面的代码中可以看出，采用 Promise 的方式来判断图片是否加载成功，也是针对 Promise.race 方法的一个比较好的业务场</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220405111554.png" alt=""></p><h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><div class="note primary flat"><p>generator是es6新增的语法，和promise一样可以用来异步编程，最大的特点是它可以利用yield和next分段执行。</p></div><ul><li><code>function *foo(x)</code>使用<em>号来声明该函数是一个生成器函数，`</em>`的位置比较随意。</li><li><code>yield</code>关键字用来实现分段执行，它的意思是产出，当生成器函数遇到yield的时候会暂停并把他后面的表达式抛出去。（注意yield可以不写在生成器中）</li><li><code>next</code>表示将代码的控制权还给生成器函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = foo(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(it.next())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>过程：</p><ul><li>首先执行第一个next的时候传参会被忽略 因为赋值的时候已经传了参 所以参数就是5 且到第一个yield停止。返回后面的结果 就是6 此时x为5</li><li>来到第二个next 传入的参数覆盖上一次yield的结果 所以此时y为<code>12*2=24</code> 那么返回的结果就是8</li><li>第三个next 传入的参数覆盖上一次yield的结果 所以此时z为13 那么总体就是<code>5+24+13=42</code></li></ul><h2 id="简单实现generator"><a href="#简单实现generator" class="headerlink" title="简单实现generator"></a>简单实现generator</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cb 也就是编译过的 test 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generator</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> object = &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">stop</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = cb(object);</span><br><span class="line">        <span class="keyword">if</span> (ret === <span class="literal">undefined</span>) <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: ret,</span><br><span class="line">          <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果你使用 babel 编译后可以发现 test 函数变成了这样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="keyword">return</span> generator(<span class="function"><span class="keyword">function</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> ((_context.prev = _context.next)) &#123;</span><br><span class="line">        <span class="comment">// 可以发现通过 yield 将代码分割成几块</span></span><br><span class="line">        <span class="comment">// 每次执行 next 函数就执行一块代码</span></span><br><span class="line">        <span class="comment">// 并且表明下次需要执行哪块代码</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">          _context.next = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">          _context.next = <span class="number">6</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 执行完毕</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">          <span class="keyword">return</span> _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a><code>async/await</code></h1><div class="note primary flat"><p>Generator的语法糖，有更好的语义性和适用性，返回的是promise</p></div><ul><li>await和promise一样更多是笔试题</li><li>await相比直接使用promise来说 优势在于处理then的调用链，能够更清晰的写出代码。缺点在于await可能导致性能问题。因为await会阻塞代码。也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性，此时更应该使用<code>Promise.all</code></li><li>一个函数如果加上了async 那么就会返回一个promise<div class="note primary flat"><p><code>async =&gt; *</code> <code>await =&gt; yield</code></p></div>案例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + <span class="keyword">await</span> <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>, a) <span class="comment">// -&gt; &#x27;2&#x27; 10</span></span><br><span class="line">  a = (<span class="keyword">await</span> <span class="number">10</span>) + a</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>, a) <span class="comment">// -&gt; &#x27;3&#x27; 20</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>, a) <span class="comment">// -&gt; &#x27;1&#x27; 1</span></span><br></pre></td></tr></table></figure></li><li>首先函数b执行 但是遇到了<code>await</code>暂时返还了代码的控制权，所以到外面去执行了a++并输出a为1。</li><li>又因为await内部实现了generators，且它会保留堆栈中的东西，所以在返还之前的a=0被保留了下来。输出10 然后是20</li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><div class="note primary flat"><p>async/await的优势在于处理 then 的调用链，能够更清晰准确的写出代码，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。</p></div><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><div class="note primary flat"><p>首先js的任务分为同步任务和异步任务，异步中又分为宏任务和微任务，我们常见的settimeout，setinterval系列就是宏任务，promise，muationobserver系列就是微任务，微任务插队宏任务。</p></div><ul><li>默认代码从上到下执行，执行环境通过<code>script</code>来执行</li><li>代码执行过程中，先执行同步任务，再执行异步任务。</li><li>给异步任务划分队列，分别存在微任务（立即存放）和宏任务（时间到了或者事情发生了在存放）到队列中</li><li>script执行后清空所有微任务。</li><li>微任务执行完毕后渲染页面（不是每次都调用—）</li><li>再去宏任务队列中看看也没有到达时间的，拿出来其中一个执行。</li><li>执行完毕后按上述的步骤不停循环。<br>例子(UI渲染是宏任务)<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406095138.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406095150.png" alt=""><div class="note primary flat"><p>自动执行的情况 会输出 listener1 listener2 task1 task2</p></div><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406095222.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406100602.png" alt=""><div class="note primary flat"><p>如果手动点击click 会一个宏任务取出来一个个执行，先执行click的宏任务，取出微任务去执行。会输出 listener1 task1 listener2 task2</p></div></li></ul><p>案例1<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="comment">// await xx ==&gt; promise.resolve(()=&gt;&#123;console.log(3)&#125;).then()</span></span><br><span class="line">  <span class="comment">// console.log(3) 放到promise.resolve或立即执行</span></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="number">3</span>) </span><br><span class="line">  <span class="comment">// 相当于把console.log(4)放到了then promise.resolve(()=&gt;&#123;console.log(3)&#125;).then(()=&gt;&#123;</span></span><br><span class="line">  <span class="comment">//   console.log(4)</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line">  <span class="comment">// 微任务谁先注册谁先执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">  resolve(<span class="number">7</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">d</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(d)&#125;)</span><br><span class="line"></span><br><span class="line">asyncFunc()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 1 6 2 3 8 7 4 5</span></span><br></pre></td></tr></table></figure><br>案例2<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406101017.png" alt=""></p><h2 id="JS为什么是单线程？"><a href="#JS为什么是单线程？" class="headerlink" title="JS为什么是单线程？"></a>JS为什么是单线程？</h2><div class="note primary flat"><p>js的单线程和它的用途有关，作为浏览器脚本语言，JavaScript主要用途是与用户互动以及操作DOM。这决定了他只能是单线程，否则会带来很复杂的同步问题。比如假定js同时有两个线程，一个线程在某dom节点上添加内容，另外一个线程删除了节点。这个时候浏览器应该以哪个线程为准？所以为了避免复杂性，从一诞生，js就是单线程，这已经成为了这门语言的核心特征以后也不会改变。</p></div><h2 id="浏览器事件循环"><a href="#浏览器事件循环" class="headerlink" title="浏览器事件循环"></a>浏览器事件循环</h2><div class="note primary flat"><p>涉及面试题：异步代码的执行顺序？解释一下什么是Event Loop</p></div><ul><li>首先js是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来确保代码的有序进行。</li><li>在执行同步代码的时候，如果遇到了异步事件，js引擎并不会一致等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。</li><li>当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行</li><li>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行</li><li>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。<h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a><code>process.nextTick</code></h2><div class="note primary flat"><p><code>process.nextTick</code>指定的异步任务总是发生于所有异步任务之前。</p></div></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;);</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 2 5 4 3 1</span></span><br></pre></td></tr></table></figure><h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><ul><li><code>process.nextTick</code></li><li><code>promise</code></li><li><code>Object.observe</code></li><li><code>MutationObserver</code><h2 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h2></li><li><code>script</code></li><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code></li><li><code>I/O</code> 网络请求完成、文件读写完成事件</li><li><code>UI rendering</code></li><li>用户交互事件（比如鼠标点击、滚动页面、放大缩小等）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的JavaScript③--原型及周边</title>
    <link href="https://zlinni.github.io/posts/73e8e77b5cac/"/>
    <id>https://zlinni.github.io/posts/73e8e77b5cac/</id>
    <published>2022-04-20T07:01:39.000Z</published>
    <updated>2022-04-20T07:36:33.142Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><div class="note simple"><p>原型、原型链、继承</p></div><h1 id="原型、原型链"><a href="#原型、原型链" class="headerlink" title="原型、原型链"></a>原型、原型链</h1><p><code>__proto__</code>和prototype的关系：<code>__proto__</code>和<code>constructor</code>是对象独有的，<code>prototype</code>是函数独有的。</p><div class="note primary flat"><p>在js中我们使用构造函数来新建一个对象，每一个构造函数的内部都有一个prototype属性，这个属性是一个对象，这个对象包含了可以由该构造函数的所有实例共享的方法和属性。当我们使用构造函数新建一个对象之后，在这个对象的内部将包含一个指针，这个指针指向构造函数的prototype属性对应的值，在es5中这个指针被称为对象的原型。一般来说不能获取到这个值，但是浏览器下载都实现了<code>proto</code>属性让我们来访问，但是最好是不要使用这个属性，因为他不是规范的，最好使用<code>Object.getPrototypeOf()</code>来获取对象的原型</p></div><p>当我们访问一个对象的属性的时候，如果这个对象内部不存在这个属性，那么他就会去他的原型对象里面找这个属性，这个原型对象又会有自己的原型，于是就一直找下去，也就是原型链的概念。原型链的尽头一般来说是<code>Object.prototype</code>所以这就是我们新建的对象为什么能够使用<code>toString</code>等方法的原因</p><div class="note primary flat"><p>特点：js的对象都是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型的时候，与之相关的对象也会继承这一改变。</p></div><ul><li>原型，一个简单的对象，用于实现对象的属性继承。</li><li>构造函数 可以通过new来创建对象的一个函数</li><li>实例 通过构造函数和new创建出来的对象。通过<code>__proto__</code>指向原型，通过<code>constructor</code>指向构造函数。</li></ul><div class="note primary flat"><p>以<code>Object</code>为例，他是一个构造函数，因此可以用它创建实例</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>则此时， 实例为instance, 构造函数为Object，我们知道，构造函数拥有一个prototype的属性指向原型，因此原型为:</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型</span></span><br><span class="line"><span class="keyword">const</span> prototype = <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure><p>三者关系：</p><ul><li><code>实例.__proto__ === 原型</code></li><li><code>原型.constructor === 构造函数</code></li><li><code>构造函数.prototype = 原型</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402093146.png" alt=""></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><div class="note primary flat"><p>原型链是由原型对象组成，每个对象都有<code>__proto__</code>属性，指向了创建该对象的构造函数的原型。<code>__proto__</code>将对象连接起来组成了原型链，是一个用来实现继承和共享属性的有限的对象链。</p></div><ul><li>属性查找机制：当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象<code>Object.prototype</code>，如还是没找到，则输出<code>undefined</code>；</li><li>属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: <code>b.prototype.x = 2</code>；但是这样会造成所有继承于该对象的实例的属性发生改变。</li></ul><h2 id="js获取原型的方法"><a href="#js获取原型的方法" class="headerlink" title="js获取原型的方法"></a>js获取原型的方法</h2><ul><li><code>p.__proto__</code></li><li><code>p.constructor.prototype</code></li><li><code>Object.getPrototypeOf(p)</code></li></ul><p>另外：</p><ul><li>每个函数都有<code>prototype</code>属性，除了<code>Function.prototype.bind()</code> 该属性指向原型。</li><li>每个对象都有<code>__proto__</code>属性，指向了创建该对象的构造函数的原型</li><li>对象可以通过<code>__proto__</code>来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了原型链。</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402094159.png" alt=""><br><div class="note primary flat"><p>涉及面试题：原型如何实现继承？class如何实现继承？class本质</p></div><br>首先讲一下class，其实在js中不存在类，class只是语法糖，本质还是函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line">Person <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><div class="note primary flat"><p>组合继承是最常用的继承方式</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = value;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//通过call的方式来继承父类的属性(调用构造x1)</span></span><br><span class="line">    Parent.call(<span class="built_in">this</span>,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过改变子类的原型来继承父类的函数（x2 此时继承了构造函数，多了不必要的属性）</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> children = <span class="keyword">new</span> Child(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">children.getValue()</span><br><span class="line"><span class="built_in">console</span>.log(children <span class="keyword">instanceof</span> Parent)<span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>通过call来继承父类的属性，然后改变子类的原型来继承父类的函数。</li><li>优点：构造函数可以传参，不会和父类引用属性共享，可以复用父类的函数。</li><li>缺点：继承父类的时候调用了两次父类的构造函数，把父类不必要的属性也给继承了。内存上面浪费</li></ul><h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><div class="note primary flat"><p>这种方法对组合继承进行了优化，组合继承的缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点即可。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.val = value</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>,value);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype,&#123;</span><br><span class="line">  <span class="attr">constructor</span>:&#123;</span><br><span class="line">    <span class="attr">value</span>:Child,</span><br><span class="line">    <span class="attr">enumerable</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line">child.getValue();</span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Parent)</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>以上继承将父类的原型赋值给了子类，并且将构造函数设置成了子类，这样解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p></div><h2 id="Class继承"><a href="#Class继承" class="headerlink" title="Class继承"></a>Class继承</h2><div class="note primary flat"><p>以上两种方式都是通过原型去解决的，在es6中我们可以通过class去实现继承，并且实现起来很简单</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(value)</span><br><span class="line">    <span class="built_in">this</span>.val = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line">child.getValue();</span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Parent)</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>class实现继承的核心在于使用extends表明继承自哪个父类，并且在子类构造函数中必须调用super<br>super可以看作<code>Parent.call(this,value)</code></p></div><div class="note warning flat"><p>其实这样做还是有缺陷的，比如父类的静态方法还是不能继承。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寄生组合继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = value</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.val)</span><br><span class="line">&#125;</span><br><span class="line">Parent.staticMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是静态&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, value);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: Child,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line">child.getValue();</span><br><span class="line"><span class="comment">//Child.staticMethod()//报错</span></span><br><span class="line">Parent.staticMethod()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而class继承则可以<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">caseA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我是静态&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(value)</span><br><span class="line">    <span class="built_in">this</span>.val = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line">child.getValue();</span><br><span class="line">Child.caseA()</span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Parent)</span><br></pre></td></tr></table></figure></p><h2 id="其他继承"><a href="#其他继承" class="headerlink" title="其他继承"></a>其他继承</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的JavaScript②--this及周边</title>
    <link href="https://zlinni.github.io/posts/0c4c7b52a0ab/"/>
    <id>https://zlinni.github.io/posts/0c4c7b52a0ab/</id>
    <published>2022-04-20T07:01:23.000Z</published>
    <updated>2022-04-21T00:21:18.403Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><div class="note simple"><p>this关键字、apply/call/bind 原理、变量提升、执行上下文、作用域、闭包、new关键字</p></div><h1 id="This"><a href="#This" class="headerlink" title="This"></a><code>This</code></h1><div class="note primary flat"><p>this指向调用其的对象。顺带一提，es6中的箭头函数没有<code>this</code>,<code>argument</code>,<code>super</code>等。这些只依赖包含箭头函数最接近的函数。</p></div><div class="note primary flat"><p>先来看适用场景</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">foo()<span class="comment">//指向window window没有a 输出undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo() <span class="comment">//指向obj 输出2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> foo() <span class="comment">//指向c new绑定了c c没有a 输出undefined</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p>箭头函数中的this</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a()()())</span><br><span class="line"><span class="comment">//箭头函数的this指向第一个包含他的普通函数的this这里是window</span></span><br></pre></td></tr></table></figure><ul><li>另外对箭头函数使用bind这类函数是没有用的</li><li>那么说到bind 有没有考虑过一个函数多次bind的结果是什么？</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>) &#125;</span><br><span class="line">fn.bind().bind(a)() <span class="comment">// =&gt; window</span></span><br><span class="line"><span class="comment">//可以发现给函数bind几次 fn中的this永远由第一次bind决定</span></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="comment">// fn.bind().bind(a) 等于</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply()</span><br><span class="line">  &#125;.apply(a)</span><br><span class="line">&#125;</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>this的绑定优先级如下：<br><code>new</code>最高，然后是<code>bind</code>，之后是<code>obj.foo()</code> 最后是<code>foo()</code> 同时<code>this</code>一旦被绑定，就不会被任何方式改变。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220331091103.png" alt=""></p><p>因为满足不了业务需求 所以产生了三种方式让我们手动改变this的指向<code>call apply bind</code></p><h1 id="apply-call-bind-原理"><a href="#apply-call-bind-原理" class="headerlink" title="apply/call/bind 原理"></a>apply/call/bind 原理</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220331091536.png" alt=""></p><div class="note primary flat"><p>这三个方法都是挂载在Function对象上的三个方法，调用这三个方法的必须是一个函数。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func.call(thisArg, param1, param2, ...)</span><br><span class="line">func.apply(thisArg, [param1,param2,...])</span><br><span class="line">func.bind(thisArg, param1, param2, ...)</span><br></pre></td></tr></table></figure><ul><li>在浏览器中，全局范围内的this指向window对象</li><li>在函数中，this永远指向最后调用它的那个对象</li><li>构造函数中，this指向被new出来的新对象</li><li><code>call apply bind</code>中的this被强绑定在指定的那个对象上</li><li>箭头函数中的this比较特殊。箭头函数this作为父作用域的this，不是调用时的this，要知道前四种方式都是调用时确定，也就是动态的，然而箭头函数的this是静态的，声明的时候就确定了下来。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220331092027.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value)</span><br><span class="line">&#125;</span><br><span class="line">getValue.call(a, <span class="string">&#x27;poe&#x27;</span>, <span class="string">&#x27;24&#x27;</span>)</span><br><span class="line">getValue.apply(a, [<span class="string">&#x27;poe&#x27;</span>, <span class="string">&#x27;24&#x27;</span>])</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化</p></div><h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><div class="note primary flat"><p>用<code>Object.prototype.toStirng</code>来判断类型是最合适的，借用它我们几乎可以判断所有类型的数据。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="keyword">typeof</span> obj;</span><br><span class="line">  <span class="keyword">if</span>(type!==<span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).replace(<span class="regexp">/^$/</span>,<span class="string">&#x27;$1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类数组借用方法"><a href="#类数组借用方法" class="headerlink" title="类数组借用方法"></a>类数组借用方法</h2><div class="note primary flat"><p>var arrayLike = {<br>  0: ‘java’,<br>  1: ‘script’,<br>  length: 2<br>}<br>Array.prototype.push.call(arrayLike, ‘jack’, ‘lily’);<br>console.log(typeof arrayLike); // ‘object’<br>console.log(arrayLike);<br>// {0: “java”, 1: “script”, 2: “jack”, 3: “lily”, length: 4}</p></div><div class="note primary flat"><p>用call方法来借用Array原型链上面的push方法 实现一个类数组的push方法，给arrayLike添加元素</p></div><h2 id="获取数组最大值-最小值"><a href="#获取数组最大值-最小值" class="headerlink" title="获取数组最大值/最小值"></a>获取数组最大值/最小值</h2><div class="note primary flat"><p>我们可以用apply来实现数组中判断最大最小值，apply直接传递数组作为调用方法的参数。也可以减少一步展开数组，直接使用Math的方法来获取最大最小。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">13</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>];</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, arr); </span><br><span class="line"><span class="keyword">const</span> min = <span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, arr);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(max);  <span class="comment">// 16</span></span><br><span class="line"><span class="built_in">console</span>.log(min);  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h2 id="实现一个bind函数"><a href="#实现一个bind函数" class="headerlink" title="实现一个bind函数"></a>实现一个bind函数</h2><p>对于实现以下几个函数，可以从几个方面思考。</p><ul><li>不传入第一个参数，那么默认为window</li><li>改变了this指向，让新的对象可以执行该函数，那么思路是否可以变成给新的对象添加一个函数 最后执行完再删除。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否是new 是的话变成指向function 否则指向context</span></span><br><span class="line">        <span class="keyword">var</span> _this = <span class="built_in">this</span> <span class="keyword">instanceof</span> self ? <span class="built_in">this</span> : context;</span><br><span class="line">        <span class="comment">//改变f的原型链</span></span><br><span class="line">        F.prototype = self.prototype;</span><br><span class="line">        <span class="keyword">return</span> self.apply(_this, args.concat(...arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个call函数"><a href="#实现一个call函数" class="headerlink" title="实现一个call函数"></a>实现一个call函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(args)</span><br><span class="line">  <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个apply函数"><a href="#实现一个apply函数" class="headerlink" title="实现一个apply函数"></a>实现一个apply函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myapply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">Symbol</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line">    context[key] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> result = context[key](...args);</span><br><span class="line">    <span class="keyword">delete</span> context[key];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h1><div class="note primary flat"><p>当执行js代码的时候，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数的代码会产生函数执行环境，只此两种执行环境。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b() <span class="comment">// call b</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;Hello world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;call b&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>上面的输出是因为变量提升。通常的解释是声明的代码移动到顶部。但更准确的解释是，在生成执行环境时，会有两个阶段，一个是创建阶段:js解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为undefined，所以在第二个阶段，也就是代码执行阶段，我们可以提前使用。</p></div><ul><li>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b() <span class="comment">// call b second</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;call b fist&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;call b second&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;Hello world&#x27;</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p><code>var</code>会产生很多错误，所以在es6中引入了<code>let</code>，它不能在声明前使用，但并不是说它没有提升，他有提升，且也在声明的时候开辟了内存，但因为它的这个特性导致它不能在声明前使用。</p></div><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><div class="note primary flat"><p>当执行js代码的时候，会产生三种执行上下文</p></div><ul><li>全局执行上下文</li><li>函数执行上下文</li><li><code>eval</code>执行上下文</li></ul><div class="note primary flat"><p>每个执行上下文都有三种重要属性</p></div><ul><li>变量对象（VO),包含变量，函数声明和函数的形参，该属性只能在全局上下文中访问。</li><li>作用域链，js采用词法作用域链，也就是说变量的作用域是在定义的时候决定了。</li><li><code>this</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>对于上述代码代码中，执行栈中有两个上下文：全局上下文和函数foo上下文</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack = [</span><br><span class="line">    globalContext,</span><br><span class="line">    fooContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>对于全局上下文来说，VO大概是这样的</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">globalContext.VO === globe</span><br><span class="line">globalContext.VO = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="literal">undefined</span>,</span><br><span class="line"><span class="attr">foo</span>: &lt;<span class="built_in">Function</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>对于函数foo来说，VO不能访问，只能访问到活动对象AO</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fooContext.VO === foo.AO</span><br><span class="line">fooContext.AO &#123;</span><br><span class="line">    <span class="attr">i</span>: <span class="literal">undefined</span>,</span><br><span class="line"><span class="attr">b</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">arguments</span>: <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// arguments 是函数独有的对象(箭头函数没有)</span></span><br><span class="line"><span class="xml">// 该对象是一个伪数组，有 `length` 属性且可以通过下标访问元素</span></span><br><span class="line"><span class="xml">// 该对象中的 `callee` 属性代表函数本身</span></span><br><span class="line"><span class="xml">// `caller` 属性代表函数的调用者</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p>IIFE注意事项</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo = <span class="number">10</span></span><br><span class="line">    <span class="built_in">console</span>.log(foo)</span><br><span class="line">&#125;()) <span class="comment">// -&gt; ƒ foo() &#123; foo = 10 ; console.log(foo) &#125;</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p>js解释器在遇到IIFE的时候，会创建一个辅助的特定对象，然后将函数的名称（这里是foo）作为这个特定对象的属性。因此函数内部才可以访问到foo，但这个值是只读的，所以我们并不能修改 也不能像这样对他赋值改变，所以最后打印的还是这个函数，并且外部的值也没有改变</p></div><p>总结<br><div class="note primary flat"><p>执行上下文可以简单理解为一个对象</p></div></p><p>它包含三个部分</p><ul><li>变量对象VO</li><li>作用域链 词法作用域</li><li>this指向</li></ul><p>它的类型</p><ul><li>全局执行上下文</li><li>函数执行上下文</li><li><code>eval</code>执行上下文</li></ul><p>代码执行的过程</p><ul><li>创建全局执行上下文 （global EC）</li><li>全局执行上下文(caller)逐行 自上而下执行。遇到函数的时候，函数执行上下文(callee)被push到执行栈顶层</li><li>函数执行上下文被激活后，成为<code>active EC</code> 开始执行函数中的代码，<code>caller</code>被挂起</li><li>函数执行完后，<code>callee</code>被pop出执行栈，控制权还给全局上下文(caller)继续执行</li></ul><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><ul><li>作用域：作用域就是定义变量的区域，他有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找</li><li>作用域链：作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数</li></ul><div class="note primary flat"><p>作用域链本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象</p></div><ul><li>当我们查找一个变量的时候，如果在当前执行环境中没有找到，我们可以沿着作用域链向后查找</li><li>作用域链的创建过程和执行上下文的建立有关。</li></ul><div class="note primary flat"><p>作用域可以理解为变量的可访问性 总共分为三种类型 分别为：</p></div><ul><li>全局作用域</li><li>函数作用域</li><li>块级作用域</li></ul><h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><div class="note primary flat"><p>全局变量是挂载在window对象下的变量，所以在网页中的任何位置都可以使用并且访问到这个全局变量。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalName = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(globalName) <span class="comment">// global</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;inner&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(name) <span class="comment">// inner</span></span><br><span class="line">&#125; </span><br><span class="line">getName();</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// </span></span><br><span class="line"><span class="built_in">console</span>.log(globalName); <span class="comment">//global</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  vName = <span class="string">&#x27;setName&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">setName();</span><br><span class="line"><span class="built_in">console</span>.log(vName); <span class="comment">// setName</span></span><br></pre></td></tr></table></figure><ul><li>全局变量在什么地方可以被访问到</li><li>但是可能会引起命名冲突的问题，所以定义变量的时候注意作用域</li></ul><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><div class="note primary flat"><p>函数中定义的变量叫做函数变量，这个时候只有在函数内部才能访问到它，所以它的作用域也就是函数的内部称为函数作用域</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;inner&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">//inner</span></span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>除了这个函数内部，其他地方都是不能访问到它的，同时当这个函数被执行完之后，这个局部变量也会相应被销毁，所以外面访问不到这个局部变量</p></div><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><div class="note primary flat"><p>es6新增了块级作用域，直接的表现就是let关键字。使用它定义的变量只能在块级作用域中被访问。有暂时性死区的特点。也就是说这个变量在定义之前是不能被使用的。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//a is not defined</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&#x27;123&#x27;</span>；</span><br><span class="line">  <span class="built_in">console</span>.log(a)； <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//a is not defined</span></span><br><span class="line"><span class="comment">//如果这里是var 那么结果就是三个123</span></span><br></pre></td></tr></table></figure><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><div class="note primary flat"><p>闭包其实就是一个可以访问其他函数内部变量的函数。创建闭包的常见方式是在一个函数内创建另外一个函数，创建的函数可以访问到当前函数的局部变量。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br><span class="line"><span class="keyword">var</span> result = fun1();</span><br><span class="line">result();  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合闭包的概念，我们把这段代码放到控制台执行一下，就可以发现最后输出的结果是 1（即 a 变量的值）。那么可以很清楚地发现，a 变量作为一个 fun1 函数的内部变量，正常情况下作为函数内的局部变量，是无法被外部访问到的。但是通过闭包，我们最后还是可以拿到 a 变量的值</span></span><br></pre></td></tr></table></figure><h2 id="闭包的两个常用的用途"><a href="#闭包的两个常用的用途" class="headerlink" title="闭包的两个常用的用途"></a>闭包的两个常用的用途</h2><ul><li>闭包的第一个用途是使我们在函数外部能够访问到内部的变量。</li><li>另外一个用途是使得已经允许结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象 的引用，所以这个变量对象不会被回收。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// fn 是闭包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="comment">// 这里也是闭包</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn2 = fn1()</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure><h2 id="闭包产生的原因"><a href="#闭包产生的原因" class="headerlink" title="闭包产生的原因"></a>闭包产生的原因</h2><div class="note primary flat"><p>闭包产生的本质是：当前环境中存在指向父级作用域的引用。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">//2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fun2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = fun1();</span><br><span class="line">result();</span><br></pre></td></tr></table></figure><ul><li>在上面这段代码中，我们知道，result会拿到父级作用域的变量输出2。因为在当前的环境中，含有对fun2函数的引用，而fun2中又引用了window和fun1，fun2，那么此时fun2可以访问到fun1中的2 那么就输出2</li><li>那是不是只有返回函数才算是产生了闭包？其实不是，回到闭包的本质。我们只需要让父级作用域的引用存在即可。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun3;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  fun3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br><span class="line">fun3();</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>可以看出其中输出的结果还是2 因为在给fun3赋值的时候，fun3就可以访问到window fun1和本身的作用域，然后由下往上查找 找到了fun1中的2 输出2</p></div><p>结论：<br>不能通过最后有没有返回函数来判断闭包。</p><h2 id="闭包的表现形式"><a href="#闭包的表现形式" class="headerlink" title="闭包的表现形式"></a>闭包的表现形式</h2><ol><li>返回一个函数</li><li>在定时器，事件监听，ajax请求，webworkers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时器</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;，<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">$(<span class="string">&#x27;#app&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Event Listener&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>作为函数参数传递的形式<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(baz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 这就是闭包</span></span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 输出2，而不是1</span></span><br></pre></td></tr></table></figure></li><li>IIFE创建了闭包 保存了全局作用域window和当前函数的作用域。因此可以输出全局作用域的变量。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">// 输出2</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li></ol><div class="note primary flat"><p>IIFE 这个函数会稍微有些特殊，算是一种自执行匿名函数，这个匿名函数拥有独立的作用域。这不仅可以避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域，我们经常能在高级的 JavaScript 编程中看见此类函数。</p></div><h2 id="如何解决循环输出问题？"><a href="#如何解决循环输出问题？" class="headerlink" title="如何解决循环输出问题？"></a>如何解决循环输出问题？</h2><div class="note primary flat"><p>code如下</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现 最后的结果是五个6 那么为什么是五个6？如何实现输出12345？</p><ul><li>首先是事件循环机制 同步任务执行完之后再去执行任务栈中的宏任务微任务，settimeout是宏任务，因此循环结束后它的回调才依次执行。</li><li>因为settimeout是一种闭包，往上查找它的父级作用域是window，而变量i是var声明，是window对象上面的全局变量，所以开始执行settimeout的时候i已经是6了 所以最后连续输出的都是6</li></ul><div class="note primary flat"><p>那么如何依次输出12345呢？</p></div><ol><li>利用IIFE <div class="note primary flat"><p>可以利用IIFE 每次for循环的时候把此时的变量传递到定时器里面，然后执行。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>利用es6的let<div class="note primary flat"><p>let有块级作用域，代码以块级执行 相当于任务每次都是等待块级执行完再执行下一个块级</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>利用定时器传入第三个参数<div class="note primary flat"><p>定时器的第三个参数是传入的值，可以是一个function</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j)</span><br><span class="line">  &#125;, <span class="number">0</span>,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="New的原理"><a href="#New的原理" class="headerlink" title="New的原理"></a>New的原理</h1><h2 id="常见考点"><a href="#常见考点" class="headerlink" title="常见考点"></a>常见考点</h2><ul><li>new做了什么事情？</li><li>new返回不同的类型时有声明表现？</li><li>手写new的实现过程<div class="note primary flat"><p>new关键字的主要作用就是执行一个构造函数，返回一个实例对象，在new的过程中，根据构造函数的情况，来确定是否可以接收参数的传递。下面见例子。</p></div></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.log(p.name)  <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure><p>p是通过person这个构造函数生成的一个实例对象。</p><div class="note primary flat"><p>new可以帮助我们构建出一个实例，并且绑定上this，执行的步骤为以下：</p></div><ol><li>创建一个新的对象</li><li>将对象连接到构造函数原型上，并绑定this this指向新对象</li><li>执行构造函数的代码（为这个新对象添加属性）</li><li>返回新对象</li></ol><p>在第四步返回新对象的时候会有一个情况例外：<br><div class="note primary flat"><p>如果不用new关键字会怎么样？</p></div></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = Person();</span><br><span class="line"><span class="built_in">console</span>.log(p) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// &#x27;name&#x27; of undefined</span></span><br></pre></td></tr></table></figure><ul><li>从上面的代码可以看出，不用new 结果是undefined。因为默认情况下this指向window 所以name是Jack </li><li>那么如果构造函数中return一个对象，结果会是怎么样呢？</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&#x27;Jack&#x27;</span>; </span><br><span class="line">   <span class="keyword">return</span> &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.log(p)  <span class="comment">// &#123;age: 18&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p.age) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p>通过这段代码可以看出，当构造函数最后return出来的是一个和this无关的对象的时候，new会直接返回这个对象，而不是通过new执行步骤生成的this对象</p></div><p>但如果这里构造函数返回的不是一个对象 还是会按照new的原则返回新生成的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&#x27;Jack&#x27;</span>; </span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;tom&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.log(p)  <span class="comment">// &#123;name: &#x27;Jack&#x27;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure><div class="note primary flat"><p>总结：new关键字执行之后返回一个对象，要么是实例对象，要不是return语句指定的对象</p></div><h2 id="手写new的实现过程"><a href="#手写new的实现过程" class="headerlink" title="手写new的实现过程"></a>手写new的实现过程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">fn,...args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> fn != <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//我们知道obj.__proto__ = fn.prototype的</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">  <span class="keyword">var</span> res = fn.apply(obj,args);</span><br><span class="line">  <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用<code>Object.create</code>创建一个空对象并将obj的proto指定为构造函数原型</li><li>使用apply方法 将构造函数内的this指向为obj</li><li>在create返回的时候使用三目运算符决定返回结果</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>CSRF跨站点请求伪造</title>
    <link href="https://zlinni.github.io/posts/49adaa848c45/"/>
    <id>https://zlinni.github.io/posts/49adaa848c45/</id>
    <published>2022-04-20T06:53:53.000Z</published>
    <updated>2022-04-20T12:29:38.298Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>Web安全一直是老生常谈的一个问题，下面就讲解关于CSRF的内容<br>关键词：CSRF的由来、CSRF攻击流程、CSRF类型、CSRF特点、CSRF和XSS的区别、CSRF防御手段。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220420202734.png" alt=""></p><h1 id="CSRF是什么？"><a href="#CSRF是什么？" class="headerlink" title="CSRF是什么？"></a>CSRF是什么？</h1><p>跨站请求伪造（Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。如:攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><h1 id="CSRF攻击流程"><a href="#CSRF攻击流程" class="headerlink" title="CSRF攻击流程"></a>CSRF攻击流程</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220420160348.png" alt=""></p><p>综上所述，要想完成一次CSRF攻击，就要进行以下两个步骤：</p><ol><li>登陆受信任的网站A并在本地生成cookie</li><li>在没有登出a的情况下访问了b网站</li></ol><p>看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：</p><ol><li>你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。</li><li>你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）</li><li>上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</li></ol><h1 id="CSRF类型"><a href="#CSRF类型" class="headerlink" title="CSRF类型"></a>CSRF类型</h1><h2 id="GET类型"><a href="#GET类型" class="headerlink" title="GET类型"></a>GET类型</h2><p>只需要一个get请求<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;http://bank.example/withdraw?amount=10000&amp;for=hacker&quot;</span> &gt; </span><br></pre></td></tr></table></figure></p><p>受害者访问到这个页面的该img的时候就会向该链接发出一次HTTP请求。bankexample就会收到包含受害者登陆信息的一次跨域请求。</p><h2 id="POST类型"><a href="#POST类型" class="headerlink" title="POST类型"></a>POST类型</h2><p>这种类型的CSRF利用起来通常是一个自动提交的表单例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;form action=<span class="string">&quot;http://bank.example/withdraw&quot;</span> method=POST&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xiaoming&quot;</span> /&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;for&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="built_in">document</span>.forms[<span class="number">0</span>].submit(); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> </span><br></pre></td></tr></table></figure></p><p>访问该页面之后，表单会自动提交，相当于模拟用户完成了一次post操作。</p><p>post类型的攻击通常比get要求更严格一点，但是不复杂。任何个人网站，博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许post上面。</p><h2 id="链接类型的CSRF"><a href="#链接类型的CSRF" class="headerlink" title="链接类型的CSRF"></a>链接类型的CSRF</h2><p>链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况下，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常以比较夸张的词语诱骗用户点击eg<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker&quot;</span> taget=<span class="string">&quot;_blank&quot;</span>&gt;</span><br><span class="line">重磅消息！！</span><br><span class="line">&lt;a/&gt;</span><br></pre></td></tr></table></figure></p><h1 id="CSRF的特点"><a href="#CSRF的特点" class="headerlink" title="CSRF的特点"></a>CSRF的特点</h1><ul><li>攻击发生在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击利用受害在被攻击网站的登陆凭证，冒充受害者提交操作而不是直接窃取数据。</li><li>这个过程不能获取登陆凭证而是冒用</li><li>跨站请求可用各种方式：图片URL，超链接，CORS，form表单提交等等。部分请求可以直接嵌入在第三方论坛，文章中，难以进行跟踪。</li></ul><p>CSRF攻击通常是跨域的，因为外域更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下面进行，而且这种攻击更加危险。</p><h1 id="CSRF和XSS的区别"><a href="#CSRF和XSS的区别" class="headerlink" title="CSRF和XSS的区别"></a>CSRF和XSS的区别</h1><ul><li>通常来说CSRF是由XSS实现的，CSRF也时常被称为XSRF</li><li>本质上讲，XSS是代码问题，CSRF是HTTP问题。XSS是内容没有过滤导致浏览器将攻击者的输入当代码执行。CSRF则是因为，浏览器在发送请求的时候自动带上了cookie，而一般网站的session都存在cookie里面（token验证可以避免）</li></ul><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><ul><li>验证码：强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制csrf但用户体验不好。</li><li>Referer check：请求来源限制，此种方法成本最低，但并不能保证100%有效，因为服务器并不是什么时候都能取到referer，而且低版本的浏览器野村在伪造referer的风险</li><li>token；token验证的CSRF机制是公认最合适的方案。若网站存在XSS漏洞，这个方法也没有用。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="网络安全" scheme="https://zlinni.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>XSS跨站脚本攻击</title>
    <link href="https://zlinni.github.io/posts/7236227d0d1e/"/>
    <id>https://zlinni.github.io/posts/7236227d0d1e/</id>
    <published>2022-04-20T02:33:01.000Z</published>
    <updated>2022-04-20T08:00:47.168Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>Web安全一直是老生常谈的一个问题，下面就讲解关于XSS的内容<br>关键词：XSS的由来、XSS类型、XSS预防手段、XSS检测。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220420122304.png" alt=""></p><h1 id="XSS是什么？"><a href="#XSS是什么？" class="headerlink" title="XSS是什么？"></a>XSS是什么？</h1><p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击，攻击者通过在目标网站上面注入恶意的脚本，让其在用户的浏览器上面运行。利用这些脚本就能轻易获取到用户的cookie，sessionID等，产生进一步安全威胁。</p><p>在命名上为了和css区分，改为了xss</p><p>在处理输入的时候，以下内容不可信：</p><ul><li>来自用户的 UGC 信息</li><li>来自第三方的链接</li><li>URL 参数</li><li>POST 参数</li><li>Referer （可能来自不可信的来源）</li><li>Cookie （可能来自其他子域注入）</li></ul><h1 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h1><p>根据攻击来源，可以分为存储型，反射型和DOM型</p><h2 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h2><p>攻击流程：</p><ol><li>攻击者将恶意代码提交到网站的数据库中</li><li>用户响应服务端的恶意代码</li><li>恶意代码窃取用户敏感信息发送到攻击者网站，或冒充用户行为执行操作。</li></ol><p>常见场景：<br>论坛发帖，商品评论，用户私信</p><h2 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h2><p>攻击流程：</p><ol><li>攻击者构造出特殊的URL里面包含恶意代码</li><li>用户被诱导点击特殊URL，执行恶意操作。</li></ol><p>反射型和存储型的区别在于，一个是存在URL里面，一个是存在数据库里面。</p><p>常见场景：<br>网站搜索，跳转。</p><p>需要用户主动去点击，所以攻击者常有多种手段诱导用户点击。</p><p>另外注意POST也可以诱发反射型XSS，不过需要构建表单提交界面所以少见。</p><h2 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h2><p>攻击流程：</p><ol><li>攻击者构造出特殊的URL里面包含恶意代码</li><li>用户打开带有恶意代码的URL</li><li>浏览器执行恶意代码</li></ol><p>DOM型和前两种的区别在于，DOM型的攻击是由浏览器端完成的，属于js自身的漏洞，其他两种都是服务器端的安全漏洞</p><h1 id="XSS攻击预防"><a href="#XSS攻击预防" class="headerlink" title="XSS攻击预防"></a>XSS攻击预防</h1><p>上述了解到，XSS攻击有两种要素</p><ol><li>攻击者提交恶意代码</li><li>浏览器执行恶意代码</li></ol><p>针对第一个要素，有以下的防范措施</p><h2 id="输入过滤"><a href="#输入过滤" class="headerlink" title="输入过滤"></a>输入过滤</h2><p>前端过滤—&gt;后端？<br>不可行 绕过过滤，直接构造请求就可以提交了</p><p>数据库输入过滤—&gt;前端？<br>不一定可行。<br>eg 输入<code>5&lt;7</code> 在写入数据库前被转义成<code>5 &amp;lt; 7</code><br>问题是我们在提交阶段不清楚内容要输出到哪里。也就是意味着我们的内容</p><ol><li>用户提交到前端和客户端，经过了<code>escapeHTML()</code>转义，客户端就乱码了</li><li>前端不同地方需要的编码也不一样<ul><li>当 <code>5 &amp;lt; 7</code> 作为 HTML 拼接页面时，可以正常显示：</li><li>当作为AJAX返回的时候，这个内容要经过处理才可以显示。</li></ul></li></ol><p>所以在输入侧是可以解决这个问题但是有乱码和不确定性的问题，导致工程量加大。</p><p>输入侧不行就要通过浏览器来防范</p><ol><li>防止HTML注入</li><li>防止JS执行的时候执行恶意代码</li></ol><h2 id="预防存储型和反射型"><a href="#预防存储型和反射型" class="headerlink" title="预防存储型和反射型"></a>预防存储型和反射型</h2><p>存储型和反射型都是在服务端取出恶意代码后插入到HTML里，攻击者将数据内嵌到代码中，被浏览器执行</p><p>解决方法</p><ol><li>纯前端渲染，数据和代码隔离</li><li>对HTML做充分转义</li></ol><h3 id="纯前端渲染"><a href="#纯前端渲染" class="headerlink" title="纯前端渲染"></a>纯前端渲染</h3><p>过程：</p><ol><li>加载静态HTML，没有任何业务数据</li><li>浏览器执行HTML中的js代码</li><li>数据通过AJAX加载</li></ol><p>关键在于，我们要告诉浏览器下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。</p><div class="note warning flat"><p>注意避免DOM型XSS 比如onload事件和herf中的<code>javascript:xxx</code></p></div><p>在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。</p><h3 id="转义HTML"><a href="#转义HTML" class="headerlink" title="转义HTML"></a>转义HTML</h3><p>利用转义库来进行防护</p><h3 id="预防DOM型XSS"><a href="#预防DOM型XSS" class="headerlink" title="预防DOM型XSS"></a>预防DOM型XSS</h3><p>不要用<code>innerHTML</code>，<code>document.write</code>系列代码<br>用<code>textContent</code>,<code>setAttribute</code>系列代码</p><p>在vue/react中且不使用<code>v-html/dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML、outerHTML</code> 的 XSS 隐患。</p><p>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等<br>都能进行xss攻击，注意防范字符串拼接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 内联事件监听器中包含恶意代码 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onclick</span>=<span class="string">&quot;UNTRUSTED&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;UNTRUSTED&quot;</span> <span class="attr">src</span>=<span class="string">&quot;data:image/png,&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 链接内包含恶意代码 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;UNTRUSTED&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// setTimeout()/setInterval() 中调用恶意代码</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">setTimeout</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">setInterval</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// location 调用恶意代码</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">location.href = <span class="string">&#x27;UNTRUSTED&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// eval() 中调用恶意代码</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">eval</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="其他防范"><a href="#其他防范" class="headerlink" title="其他防范"></a>其他防范</h2><div class="note primary flat"><p>以下是一些通用方案</p></div><h3 id="Content-Security-Policy"><a href="#Content-Security-Policy" class="headerlink" title="Content Security Policy"></a>Content Security Policy</h3><p>严格的 CSP 在 XSS 的防范中可以起到以下的作用：</p><ul><li>禁止加载外域代码，防止复杂的攻击逻辑。</li><li>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。</li><li>禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。</li><li>禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。</li><li>合理使用上报可以及时发现 XSS，利于尽快修复问题。</li></ul><p>关于 CSP 的详情，请关注前端安全系列后续的文章。</p><h3 id="输入内容长度控制"><a href="#输入内容长度控制" class="headerlink" title="输入内容长度控制"></a>输入内容长度控制</h3><p>对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。</p><h3 id="其他安全措施"><a href="#其他安全措施" class="headerlink" title="其他安全措施"></a>其他安全措施</h3><ul><li>HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。</li><li>验证码：防止脚本冒充用户提交危险操作。</li></ul><h1 id="XSS检测"><a href="#XSS检测" class="headerlink" title="XSS检测"></a>XSS检测</h1><ol><li>使用通用 XSS 攻击字符串手动检测 XSS 漏洞。</li><li>使用扫描工具自动检测 XSS 漏洞。</li></ol><p>在<a href="https://github.com/0xsobky/HackVault/wiki/Unleashing-an-Ultimate-XSS-Polyglot">Unleashing an Ultimate XSS</a> Polyglot一文中，小明发现了这么一个字符串：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/0xsobky/HackVault/wiki/Unleashing-an-Ultimate-XSS-Polyglot</span></span><br></pre></td></tr></table></figure></p><p>它能够检测到存在于 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等多种上下文中的 XSS 漏洞，也能检测 <code>eval()、setTimeout()、setInterval()、Function()、innerHTML、document.write()</code> 等 DOM 型 XSS 漏洞，并且能绕过一些 XSS 过滤器。</p><p>小明只要在网站的各输入框中提交这个字符串，或者把它拼接到 URL 参数上，就可以进行检测了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//xxx/search?keyword=jaVasCript%3A%2F*-%2F*%60%2F*%60%2F*%27%2F*%22%2F**%2F(%2F*%20*%2FoNcliCk%3Dalert()%20)%2F%2F%250D%250A%250d%250a%2F%2F%3C%2FstYle%2F%3C%2FtitLe%2F%3C%2FteXtarEa%2F%3C%2FscRipt%2F--!%3E%3CsVg%2F%3CsVg%2FoNloAd%3Dalert()%2F%2F%3E%3E</span></span><br></pre></td></tr></table></figure><p>除了手动检测之外，还可以使用自动扫描工具寻找 XSS 漏洞，例如 <code>Arachni、Mozilla HTTP Observatory、w3af</code> 等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们回到最开始提出的问题，相信同学们已经有了答案：<br><div class="note primary flat"><p>XSS 防范是后端 RD 的责任，后端 RD 应该在所有用户提交数据的接口，对敏感字符进行转义，才能进行下一步操作。</p></div></p><p>不正确。因为：</p><p>防范存储型和反射型 XSS 是后端 RD 的责任。而 DOM 型 XSS 攻击不发生在后端，是前端 RD 的责任。防范 XSS 是需要后端 RD 和前端 RD 共同参与的系统工程。<br>转义应该在输出 HTML 时进行，而不是在提交用户输入时。</p><div class="note primary flat"><p>所有要插入到页面上的数据，都要通过一个敏感字符过滤函数的转义，过滤掉通用的敏感字符后，就可以插入到页面中。</p></div><p>不正确。<br>不同的上下文，如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等，所需要的转义规则不一致。<br>业务 RD 需要选取合适的转义库，并针对不同的上下文调用不同的转义规则。</p><p>整体的 XSS 防范是非常复杂和繁琐的，我们不仅需要在全部需要转义的位置，对数据进行对应的转义。而且要防止多余和错误的转义，避免正常的用户输入出现乱码。<br>虽然很难通过技术手段完全避免 XSS，但我们可以总结以下原则减少漏洞的产生：</p><ul><li>利用模板引擎<br>开启模板引擎自带的 HTML 转义功能。例如：<br>在 ejs 中，尽量使用 <code>&lt;%= data %&gt;</code>而不是 <code>&lt;%- data %&gt;</code>；<br>在 doT.js 中，尽量使用 <code>&#123;&#123;! data &#125;` 而不是` &#123;&#123;= data &#125;`；在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 `freemarker.core.OutputFormat`。* 避免内联事件尽量不要使用` onLoad="onload('&#123;&#123;data&#125;&#125;&#39;)&quot;</code>、<code>onClick=&quot;go(&#39;&#123;&#123;action&#125;&#125;&#39;)&quot;</code> 这种拼接内联事件的写法。在 JavaScript 中通过 <code>.addEventlistener()</code> 事件绑定会更安全。</li><li>避免拼接 HTML<br>前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 <code>createElement、setAttribute</code> 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。</li><li>时刻保持警惕<br>在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。</li><li>增加攻击难度，降低攻击后果<br>通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。</li><li>主动检测和发现<br>可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="网络安全" scheme="https://zlinni.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>春招落幕，暑期已至---日常篇①</title>
    <link href="https://zlinni.github.io/posts/9a9b91333798/"/>
    <id>https://zlinni.github.io/posts/9a9b91333798/</id>
    <published>2022-04-19T14:31:19.000Z</published>
    <updated>2022-04-19T15:16:14.166Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>emm,最近都在忙活八股算法,没什么时间去梳理一下最近发生的事情,以此来做个记录吧.</p></div><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>时至四月,春招可以说是完完全全的走掉了,这个春招里我就拿到过一个小厂的offer,由于自己自信后面能够拿到更好的就拒掉了(事实证明并没有),所以这段时间是没有好好把握住的,有点可惜.不过实际上八股文加算法总共的学习时间也就从3月份开始的一个半月,这一个半月的知识浓度比之前大特别多.每天都在消化吸收,挑战自己不熟练的,没有见过的一些新事物,比如算法,比如计网.这两个东西应该是很多人不想面对的吧.好在我坚持了下来,这段时间陆陆续续的刷了一百多道中等加简单难度的leetcode,感悟非常的深,其实部分算法题也不见得特别困难,可能是我做的难度原因.甚至有些题目能让我回想起以前OJ刷题时候的记忆,除开比较用智商的题目,大多数的题都有专门的方法去解决,也算是比较套路化.截到目前为止,我能罗列出来的算法有滑动窗口,动态规划,dfs,bfs,贪心,回溯以及部分排序,虽然不能说完全熟悉他的做题方法,但是碰到类似的题目也知道该用什么方法去解决了.算是这段时间的一点小进步.数据结构方面大概就是一些简单题显露出来的,常考的二叉树,链表,栈.这些题好像也会出现在面经中,但是基本不会出现在笔试中,经过前一段时间的笔试(腾讯+字节),深刻的明白了,动态规划和贪心才是笔试的重点,所以后面要多刷这方面的题目.</p><p>然后说一件比较痛苦的事情,就是字节的笔试用的是acm模式,导致数据没办法读出来,然后就寄掉了…</p><p>这段时间八股文方面写了JS的知识点总结,HTTP灵魂之问,Vue灵魂之问,手撕Javascript合集,其中特别有意思的是,在HTTP灵魂之问中,讲到数字证书和数字签名的这个部分,我居然和女朋友争辩了半个晚上才明白具体的原理,虽然大部分是我的问题,不过也算是一种收获了.写完了这些之后,特别是Vue的部分,因为没有手写源码的关系吧,其实对于他的面试题还是有点虚的,得多找些面经再补一补,最后感觉还是得根据一些点,细致的写一篇文章来理解.比如之后想写的关于Object的方法详解,数组api的方法详解,map和weakmap..等.但不知道排期到什么时候,毕竟人的消化吸收能力是有限的,目前我想先找到一份实习,空余之下再去补充这些知识点.</p><p>前不久还想着看webpack,但是冗长的网络视频让我失去了学习的兴趣,大致看了个开头到css抽离压缩的部分就没看下去了.虽然我也知道面试的时候会问相关的问题,只能说亡羊补牢吧,或者说面向面经学习.</p><p>现在的形式真是一言难尽啊,互联网大厂裁员,hc少,今年还是当初研究生扩招最大的一年,大家都抢着一个饭碗,导致旱的旱死涝的涝死,投出去的简历一封封也都石沉大海.远没有想到19年的疫情对我们而言影响这么大.</p><p>在牛客上面看到一个评论:”今年或许是往年来最差的一年,也有可能是今后最好的一年了”,大环境差表示我们要付出更多的努力才能换到成果了,加油吧打工人!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="日常" scheme="https://zlinni.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>手撕万物Javascript篇</title>
    <link href="https://zlinni.github.io/posts/139818545f14/"/>
    <id>https://zlinni.github.io/posts/139818545f14/</id>
    <published>2022-04-15T06:27:16.000Z</published>
    <updated>2022-04-22T08:29:17.552Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>本篇关于尽可能手撕一切可以实现的代码，先从js开始下手</p></div><h1 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h1><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,timer</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> t = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> firstClick = !t;</span><br><span class="line">    <span class="keyword">if</span>(firstClick)&#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    t = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      t = <span class="literal">null</span>;</span><br><span class="line">    &#125;, timer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> begin = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cur = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span>(cur-begin&gt;=delay)&#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">      begin = cur;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">oldObj,newObj=&#123;&#125;</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> oldObj) &#123;</span><br><span class="line">    newObj[item] = oldObj[item];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><h2 id="api版本"><a href="#api版本" class="headerlink" title="api版本"></a>api版本</h2><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringfy(oldObj));</span><br></pre></td></tr></table></figure></p><p>缺陷：</p><ul><li>无法实现对函数，正则等特殊对象的克隆</li><li>会抛弃对象的constructor,所有的构造函数会指向Object</li><li>对象有循环引用会报错</li></ul><h2 id="1-0版本"><a href="#1-0版本" class="headerlink" title="1.0版本"></a>1.0版本</h2><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断是否是引用类型或者null 否则返回源对象进行浅拷贝</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>||obj===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是数组，初始化地址。</span></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        result = [];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归调用 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            result[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p><h2 id="2-0版本-解决循环引用"><a href="#2-0版本-解决循环引用" class="headerlink" title="2.0版本 解决循环引用"></a>2.0版本 解决循环引用</h2><p>循环引用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">b</span>:<span class="number">122</span>&#125;;</span><br><span class="line">a.target = a;</span><br><span class="line">deepClone(obj);<span class="comment">//报错: RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure><br>先方法判断复杂类型<br>然后用map存储对象 如果已经存在则直接返回<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> judObj = (<span class="function">(<span class="params">target</span>)=&gt;</span>(<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>||<span class="keyword">typeof</span> target === <span class="string">&#x27;function&#x27;</span>)&amp;&amp; target!==<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">const</span> deepClone2 = (<span class="function">(<span class="params">target,map=<span class="keyword">new</span> <span class="built_in">Map</span>()</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(map.get(target))<span class="keyword">return</span> target;</span><br><span class="line">  <span class="keyword">if</span>(judObj(target))&#123;</span><br><span class="line">    map.set(target,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Array</span>.isArray(target)?[]:&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> target)&#123;</span><br><span class="line">      <span class="keyword">if</span>(target.hasOwnProperty(key))&#123;</span><br><span class="line">        res[key] = deepClone2(target[key],map);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//测试数据</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">val</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a.target = a;</span><br><span class="line"><span class="keyword">let</span> newA = deepClone2(a);</span><br><span class="line"><span class="built_in">console</span>.log(newA)<span class="comment">//&#123; val: 2, target: &#123; val: 2, target: [Circular] &#125; &#125;</span></span><br></pre></td></tr></table></figure></p><p>but存在一个潜在的问题，就是map上的key和map构成了强引用关系，是很危险的。<br>科普强引用和弱引用的关系<br><div class="note primary flat"><p>被弱引用的对象在什么时候都可以被回收，但强引用的不行，上面的代码在程序结束之前都不会释放a的空间</p></div></p><p>所以需要用到weekMap构成弱引用，把Map改成weekMap即可</p><h2 id="拷贝特殊对象"><a href="#拷贝特殊对象" class="headerlink" title="拷贝特殊对象"></a>拷贝特殊对象</h2><p>特殊对象<br>可遍历的特殊对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;object Map&quot;</span>]</span><br><span class="line">[<span class="string">&quot;object Set&quot;</span>]</span><br><span class="line">[<span class="string">&quot;object Array&quot;</span>]</span><br><span class="line">[<span class="string">&quot;object Object&quot;</span>]</span><br><span class="line">[<span class="string">&quot;object Arguments&quot;</span>]</span><br></pre></td></tr></table></figure><br>不可遍历的特殊对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> boolTag = <span class="string">&#x27;[object Boolean]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">&#x27;[object Number]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">&#x27;[object String]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">&#x27;[object Date]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">&#x27;[object Error]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">&#x27;[object RegExp]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">&#x27;[object Function]&#x27;</span>;</span><br></pre></td></tr></table></figure><br>用最准确的那个方法判断<br>然后对于不能遍历的对象直接返回<br>对于能遍历的对象分类<br>如果是map的话 foreach 他的item和index赋值<br>如果是set foreach 他的item<br>其他的数组和对象 就直接用之前的方法遍历递归<br>注意要保留对象的原型<br>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> judObj = (<span class="function">(<span class="params">target</span>)=&gt;</span>(<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>||<span class="keyword">typeof</span> target === <span class="string">&#x27;function&#x27;</span>)&amp;&amp; target!==<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getObj = (<span class="function">(<span class="params">target</span>)=&gt;</span><span class="built_in">Object</span>.prototype.toString.call(target));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canTranverse = &#123;</span><br><span class="line">    <span class="string">&#x27;[object Map]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Set]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Array]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Object]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Arguments]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone3 = (<span class="function">(<span class="params">target,map=<span class="keyword">new</span> <span class="built_in">Map</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!judObj)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> type = getObj(target);</span><br><span class="line">    <span class="keyword">let</span> cloneTarget;</span><br><span class="line">    <span class="keyword">if</span>(!canTranverse[type])&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> ctor = target.prototype;</span><br><span class="line">        cloneTarget = <span class="keyword">new</span> ctor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(map.get(cloneTarget))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        map.set(cloneTarget,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(type === <span class="string">&#x27;[object Map]&#x27;</span>)&#123;</span><br><span class="line">        target.forEach(<span class="function">(<span class="params">item,index</span>) =&gt;</span> &#123;</span><br><span class="line">            cloneTarget.set(deepClone3(item),deepClone3(index));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">&#x27;[object Set]&#x27;</span>)&#123;</span><br><span class="line">        target.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">            cloneTarget.add(deepClone3(item));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">                cloneTarget[key] = deepClone3(target[key],map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="3-0-final"><a href="#3-0-final" class="headerlink" title="3.0 final"></a>3.0 final</h2><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getType = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isObject = <span class="function">(<span class="params">target</span>) =&gt;</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> target === <span class="string">&#x27;function&#x27;</span>) &amp;&amp; target !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canTraverse = &#123;</span><br><span class="line">  <span class="string">&#x27;[object Map]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;[object Set]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;[object Array]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;[object Object]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;[object Arguments]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> mapTag = <span class="string">&#x27;[object Map]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">&#x27;[object Set]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">&#x27;[object Boolean]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">&#x27;[object Number]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">&#x27;[object String]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">&#x27;[object Symbol]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">&#x27;[object Date]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">&#x27;[object Error]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">&#x27;[object RegExp]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">&#x27;[object Function]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleRegExp = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; source, flags &#125; = target;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> target.constructor(source, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleFunc = <span class="function">(<span class="params">func</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 箭头函数直接返回自身</span></span><br><span class="line">  <span class="keyword">if</span>(!func.prototype) <span class="keyword">return</span> func;</span><br><span class="line">  <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>;</span><br><span class="line">  <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span>;</span><br><span class="line">  <span class="keyword">const</span> funcString = func.toString();</span><br><span class="line">  <span class="comment">// 分别匹配 函数参数 和 函数体</span></span><br><span class="line">  <span class="keyword">const</span> param = paramReg.exec(funcString);</span><br><span class="line">  <span class="keyword">const</span> body = bodyReg.exec(funcString);</span><br><span class="line">  <span class="keyword">if</span>(!body) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (param) &#123;</span><br><span class="line">    <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(...paramArr, body[<span class="number">0</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(body[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleNotTraverse = <span class="function">(<span class="params">target, tag</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> Ctor = target.constructor;</span><br><span class="line">  <span class="keyword">switch</span>(tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> boolTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Boolean</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> numberTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Number</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> stringTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">String</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> symbolTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> errorTag: </span><br><span class="line">    <span class="keyword">case</span> dateTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">    <span class="keyword">case</span> regexpTag:</span><br><span class="line">      <span class="keyword">return</span> handleRegExp(target);</span><br><span class="line">    <span class="keyword">case</span> funcTag:</span><br><span class="line">      <span class="keyword">return</span> handleFunc(target);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!isObject(target)) </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  <span class="keyword">let</span> type = getType(target);</span><br><span class="line">  <span class="keyword">let</span> cloneTarget;</span><br><span class="line">  <span class="keyword">if</span>(!canTraverse[type]) &#123;</span><br><span class="line">    <span class="comment">// 处理不能遍历的对象</span></span><br><span class="line">    <span class="keyword">return</span> handleNotTraverse(target, type);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这波操作相当关键，可以保证对象的原型不丢失！</span></span><br><span class="line">    <span class="keyword">let</span> ctor = target.constructor;</span><br><span class="line">    cloneTarget = <span class="keyword">new</span> ctor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(map.get(target)) </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  map.set(target, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(type === mapTag) &#123;</span><br><span class="line">    <span class="comment">//处理Map</span></span><br><span class="line">    target.forEach(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.set(deepClone(key, map), deepClone(item, map));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(type === setTag) &#123;</span><br><span class="line">    <span class="comment">//处理Set</span></span><br><span class="line">    target.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.add(deepClone(item, map));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理数组和对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">        cloneTarget[prop] = deepClone(target[prop], map);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="实现发布订阅EventEmitter"><a href="#实现发布订阅EventEmitter" class="headerlink" title="实现发布订阅EventEmitter"></a>实现发布订阅EventEmitter</h1><p>订阅 取消 只能订阅一次 触发<br>代码如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.event = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">type,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.event)<span class="built_in">this</span>.event = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.event[type])&#123;</span><br><span class="line">      <span class="built_in">this</span>.event[type]=[callback]</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.event[type].push(callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">type,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.event)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">this</span>.event[type] = <span class="built_in">this</span>.event[type].find(<span class="function"><span class="params">item</span>=&gt;</span>item!==callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">once</span>(<span class="params">type,callback</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      callback();</span><br><span class="line">      <span class="built_in">this</span>.off(type,fn); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.on(type,fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">type,...args</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.event[type]&amp;&amp;<span class="built_in">this</span>.event[type].forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn.apply(<span class="built_in">this</span>,args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p>原理 找到实例对象的原型然后不断往上查找,如果和类实例的原型相同则为真,如果是null则为假<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myinstanceof</span>(<span class="params">example,classFunc</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(example);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(proto===<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span>(proto===classFunc.prototype)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      proto = <span class="built_in">Object</span>.getPrototypeOf(proto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><p>模拟new就要知道new操作符做了什么事情</p><ul><li>将对象的隐式原型指向构造函数的原型prototype</li><li>执行构造函数，使用call/apply改变this指向</li><li>返回值为object类型则作为new方法的返回值返回，否则返回上述全新对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mynew</span>(<span class="params">fn,...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">    <span class="keyword">let</span> res = fn.apply(instance,args);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span>?res:instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="call"><a href="#call" class="headerlink" title="call"></a>call</h1><p>call不传入参数则默认绑定的window<br>新建函数将函数设置当前this<br>然后删除该函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用法：f.call(obj,arg1)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">f.myCall(obj, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">//否则this指向window</span></span><br></pre></td></tr></table></figure></p><h1 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h1><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myapply = <span class="function"><span class="keyword">function</span>(<span class="params">context,args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">Symbol</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line">    context[key] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> res = context[key](...args);</span><br><span class="line">    <span class="keyword">delete</span> context[key];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否是new 是的话变成指向function 否则指向context</span></span><br><span class="line">        <span class="keyword">var</span> _this = <span class="built_in">this</span> <span class="keyword">instanceof</span> self ? <span class="built_in">this</span> : context;</span><br><span class="line">        <span class="comment">//改变f的原型链</span></span><br><span class="line">        F.prototype = self.prototype;</span><br><span class="line">        <span class="keyword">return</span> self.apply(_this, args.concat(...arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">proto</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    F.prototype = proto;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><h1 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a><code>Promise.resolve</code></h1><ol><li>值是promise对象则直接返回</li><li>返回一个new promise且如果他是then调用，则返回then方法</li><li>其他情况，返回成功状态的promise<br>code<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. promise return</span></span><br><span class="line"><span class="comment">// =&gt; new promise</span></span><br><span class="line"><span class="comment">// 2. param.then === &#x27;fun&#x27;</span></span><br><span class="line"><span class="comment">// =&gt; param.then(res,rej)</span></span><br><span class="line"><span class="comment">// 3. return resolve(param) </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve = (<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (param <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) <span class="keyword">return</span> param;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (param &amp;&amp; param.then &amp;&amp; <span class="keyword">typeof</span> param.then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> param.then(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> resolve(param)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h1 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a><code>Promise.reject</code></h1><p>reject传入的参数会作为一个reason原封不动的往下传<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a><code>Promise.prototype.finally</code></h1><p>不管状态如何都会执行并且往下传值.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve((cb()).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;,<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve((cb()).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a><code>Promise.all</code></h1><p>code如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.myall = <span class="function"><span class="keyword">function</span>(<span class="params">iterable</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">//传入的是可迭代对象</span></span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">//这里不一定是数组,不一定有length,所以要变量计算.</span></span><br><span class="line">      <span class="keyword">let</span> elementCount = <span class="number">0</span>; <span class="comment">//解决的promise数量</span></span><br><span class="line">      <span class="keyword">let</span> anErrorOccurred = <span class="literal">false</span>;<span class="comment">//判断是否错误</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> promise <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">            <span class="keyword">const</span> curIndex = index; <span class="comment">//封闭index的作用域</span></span><br><span class="line">            promise.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(anErrorOccurred)<span class="keyword">return</span>;</span><br><span class="line">                result[curIndex] = value;</span><br><span class="line">                elementCount++;</span><br><span class="line">                <span class="keyword">if</span>(elementCount === result.length)&#123;</span><br><span class="line">                    resolve(result)<span class="comment">//如果全部任务都成功,返回数组</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(anErrorOccurred)<span class="keyword">return</span>;</span><br><span class="line">                anErrorOccurred=<span class="literal">true</span>;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;)</span><br><span class="line">            index++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(index === <span class="number">0</span>)&#123;</span><br><span class="line">          resolve([]);<span class="comment">//长度是0 返回空数组</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(index);<span class="comment">//要在最后写result 因为index是在循环后才计算出来.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a><code>Promise.race</code></h1><p>race方法只要有一个率先改变了状态,后面就直接resolve<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.myrace = <span class="function"><span class="keyword">function</span> (<span class="params">iterable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> settlementOccurred = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> promise <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (settlementOccurred) <span class="keyword">return</span>;</span><br><span class="line">      settlementOccurred = <span class="literal">true</span>;</span><br><span class="line">      resolve(value);<span class="comment">//直接resolve</span></span><br><span class="line">    &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (settlementOccurred) <span class="keyword">return</span>;</span><br><span class="line">      settlementOccurred = <span class="literal">true</span>;</span><br><span class="line">      reject(err);<span class="comment">//直接reject</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a><code>Promise.allSettled</code></h1><p>执行完后不会失败,按顺序返回每个promise状态<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="built_in">Promise</span>.allSettled([resolved, rejected]);</span><br><span class="line">allSettledPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回结果：</span></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 2 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure></p><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.allSettled = <span class="function"><span class="keyword">function</span> (<span class="params">promiseArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!promiseArgs.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve([]);</span><br><span class="line">  <span class="comment">// 包装不是promise的项</span></span><br><span class="line">  <span class="keyword">const</span> promises = promiseArgs.map(<span class="function"><span class="params">p</span> =&gt;</span> p <span class="keyword">instanceof</span> <span class="built_in">Promise</span> ? p : <span class="built_in">Promise</span>.resolve(p));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> unSettledCount = promises.length;</span><br><span class="line">    promises.forEach(<span class="function">(<span class="params">p, index</span>) =&gt;</span> &#123;</span><br><span class="line">      p.then(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        res[index] = &#123;</span><br><span class="line">          <span class="attr">status</span>: <span class="string">&quot;resolve&quot;</span>,</span><br><span class="line">          reason</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        res[index] = &#123;</span><br><span class="line">          <span class="attr">status</span>: <span class="string">&quot;reject&quot;</span>,</span><br><span class="line">          reason</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        --unSettledCount;</span><br><span class="line">        <span class="keyword">if</span> (!unSettledCount) <span class="keyword">return</span> resolve(res);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Promise-retry超时请求"><a href="#Promise-retry超时请求" class="headerlink" title="Promise.retry超时请求"></a>Promise.retry超时请求</h1><p>简易版<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.retrySimple = <span class="function"><span class="keyword">function</span> (<span class="params">fn, maxRetry, timeout</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Expected a function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  maxRetry = maxRetry || <span class="number">3</span>;</span><br><span class="line">  timeout = timeout || <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> retryCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn().then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">      &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retryCount &gt;= maxRetry) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">setTimeout</span>(run,timeout);</span><br><span class="line">        retryCount++;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    run();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有缓存版<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整版 - 有缓存</span></span><br><span class="line"><span class="built_in">Promise</span>.retry = <span class="function"><span class="keyword">function</span> (<span class="params">fn, options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 参数检查</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Expected a function&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    options = options || &#123;&#125;;</span><br><span class="line">    <span class="comment">// 默认参数</span></span><br><span class="line">    options = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">        <span class="attr">maxRetry</span>: <span class="number">3</span>, <span class="comment">// 默认重试次数</span></span><br><span class="line">        <span class="attr">retryDelay</span>: <span class="number">1000</span>, <span class="comment">// 默认重试时间间隔</span></span><br><span class="line">        <span class="attr">cache</span>: <span class="literal">false</span>, <span class="comment">// 是否缓存结果</span></span><br><span class="line">        <span class="attr">cacheKey</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 缓存 key</span></span><br><span class="line">        <span class="attr">cacheExpire</span>: <span class="number">0</span>, <span class="comment">// 缓存过期时间，单位：毫秒</span></span><br><span class="line">        <span class="attr">cacheMax</span>: <span class="number">0</span> <span class="comment">// 缓存最大值，超过后清空缓存</span></span><br><span class="line">    &#125;, options);</span><br><span class="line">    <span class="keyword">let</span> retryCount = <span class="number">0</span>; <span class="comment">// 已重试次数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 内部函数，进行一次尝试</span></span><br><span class="line">        <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn().then(</span><br><span class="line">                <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 成功收到响应，如果需要缓存，则缓存结果，同时设置缓存过期时间</span></span><br><span class="line">                    <span class="keyword">if</span> (options.cache) &#123;</span><br><span class="line">                        <span class="built_in">localStorage</span>.setItem(options.cacheKey, <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">                            value,</span><br><span class="line">                            <span class="attr">expire</span>: <span class="built_in">Date</span>.now() + options.cacheExpire</span><br><span class="line">                        &#125;));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 封装的 promise 解决</span></span><br><span class="line">                    resolve(value);</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 超过了最大重试次数，拒绝</span></span><br><span class="line">                    <span class="keyword">if</span> (retryCount &gt;= options.maxRetry) &#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 没有超过重试次数，如果有缓存，则读取缓存</span></span><br><span class="line">                    <span class="keyword">if</span> (options.cache) &#123;</span><br><span class="line">                        <span class="keyword">const</span> cache = <span class="built_in">localStorage</span>.getItem(options.cacheKey);</span><br><span class="line">                        <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">                            <span class="keyword">const</span> cacheObj = <span class="built_in">JSON</span>.parse(cache);</span><br><span class="line">                            <span class="keyword">if</span> (cacheObj.expire &gt; <span class="built_in">Date</span>.now()) &#123;</span><br><span class="line">                                resolve(cacheObj.value);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 重试</span></span><br><span class="line">                    <span class="built_in">setTimeout</span>(run, options.retryDelay);</span><br><span class="line">                    retryCount++;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">        run();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="解析URL-Params对象"><a href="#解析URL-Params对象" class="headerlink" title="解析URL Params对象"></a>解析URL Params对象</h1><h1 id="实现JS函数柯里化"><a href="#实现JS函数柯里化" class="headerlink" title="实现JS函数柯里化"></a>实现JS函数柯里化</h1><div class="note primary flat"><p>柯里化的定义：接收一部分参数，返回一个函数接收剩余参数，接收足够参数后，返回原函数。</p></div><p>思路如下：</p><ol><li>利用length属性获取函数的形参个数</li><li>手动指定需要的形参个数</li></ol><p>ES5版本（涉及到arguments的es5转换法）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mycurry</span>(<span class="params">fn,args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = fn.length;</span><br><span class="line">    <span class="keyword">var</span> args = args || [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//arguments的逐次分割</span></span><br><span class="line">        <span class="keyword">var</span> newArgs = args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="comment">//不满足携带newArgs递归</span></span><br><span class="line">        <span class="keyword">if</span>(newArgs.length&lt;len)&#123;</span><br><span class="line">            <span class="keyword">return</span> mycurry.call(<span class="built_in">this</span>,fn,newArgs);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//满足直接返回</span></span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>,newArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiFn</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b*c</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = mycurry(multiFn);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>,<span class="number">3</span>)(<span class="number">4</span>))</span><br></pre></td></tr></table></figure></p><p>ES6版本<br>es6可以直接用拓展运算符所以会写起来简单一点<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Vuejs灵魂之问</title>
    <link href="https://zlinni.github.io/posts/0941e8fc9dd3/"/>
    <id>https://zlinni.github.io/posts/0941e8fc9dd3/</id>
    <published>2022-04-14T03:04:12.000Z</published>
    <updated>2022-04-15T06:17:07.245Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>本文整理了高频vue面试考点，并将难度分为简单中等困难三个难度。</p></div><h1 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h1><h1 id="MVC和MVVM的区别"><a href="#MVC和MVVM的区别" class="headerlink" title="MVC和MVVM的区别"></a>MVC和MVVM的区别</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC的全称是 Model View Controller 是模型，视图，控制器的缩写，是一种软件设计规范。</p><ul><li>Model模型:是应用程序中用于处理程序数据逻辑的部分。通常模型对象负责从数据库里面存取数据</li><li>View视图:是应用程序中处理数据显示的部分。通常视图是依据模型数据渲染的。</li><li>Controller:是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414153548.png" alt=""></p><p>MVC的思想:一句话就是Controller负责将Model的数据取出来用View显示出来，换句话说就是在Controller里面把Model的值赋给View</p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM新增了VM类<br>ViewModel层:做了两件事情完成了双向绑定。</p><ol><li>将Model模型转化为了View视图。即将后端的数据转化为所看到的页面。使用的方式是数据绑定。</li><li>将View视图转化为了Model模型。即将页面转化为了后端的数据。使用的方式是DOM事件监听。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414154052.png" alt=""></p><p>MVVM和MVC最大的区别就是:他实现了View和Model的自动同步，也就是当Model的属性改变的时候，我们不需要手动去操作DOM元素，来改变View的显示，而是改变了属性之后View中的元素也会随之改变。</p><div class="note warning flat"><p>注意 Vue并没有完全遵循MVVM的思想，因为MVVM的思想是不允许Model和View直接通信 但是Vue提供了<code>$refs</code>这个属性让我们可以通信操作dom</p></div><h1 id="为什么data是一个函数"><a href="#为什么data是一个函数" class="headerlink" title="为什么data是一个函数"></a>为什么data是一个函数</h1><p>数据以函数返回值的形式定义，每复用一次组件就返回一份全新的data，类似给组件的实例创建一个私有的数据空间，这样实例之间互不影响。如果直接写成对象的形式，实例之间就共享了同一份data数据。</p><h1 id="Vue组件通讯有那些方式？"><a href="#Vue组件通讯有那些方式？" class="headerlink" title="Vue组件通讯有那些方式？"></a>Vue组件通讯有那些方式？</h1><ol><li>props和<code>$emit</code>父子间向子组件传递通过props，子向父传递通过emit触发事件。</li><li><code>$parent</code>,<code>$children</code>获取当前的父组件和子组件。</li><li>全局事件总线。</li><li>localStorage</li><li><code>$refs</code></li><li>Vuex</li></ol><h1 id="Vue的生命周期方法有那些？在那一步发送请求"><a href="#Vue的生命周期方法有那些？在那一步发送请求" class="headerlink" title="Vue的生命周期方法有那些？在那一步发送请求"></a>Vue的生命周期方法有那些？在那一步发送请求</h1><ul><li>beforeCreate 在实例初始化之前，数据观测data Observer和event/wacter事件配置之前被调用。在当前阶段data，methods，computed以及watch上的数据和方法都不能访问。</li><li>created 实例已经创建完成后被调用，在该阶段已经完了数据观测data observer，属性和方法的运算，watch/event的事件回调，这里没有<code>$el</code>，如果想要和DOM进行交互，指南通过<code>vm.$nextTick</code>来访问DOM</li><li>beforeMount 在挂载开始之前被调用，相关的render函数首次被调用。</li><li>mouted 在挂载完成后发生，在当前阶段，真实的DOM挂载完毕，数据完成双向绑定，可以访问到DOM节点。</li><li>beforeUpdate 数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。可以在这个钩子中进一步的更改状态，这不会触发附加的重渲染过程。</li><li>updated 发生在更新完成之后，当前阶段DOM已经完成更新，要注意的是避免在此阶段修改数据，因为可能会导致无限循环的更新，该钩子在服务器渲染期间不被调用。</li><li>beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在该阶段进行善后收尾工作，比如清除定时器。</li><li>destroyed Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑，所有的事件监听器都会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</li><li>activated keep-alive专属，组件被激活的时候调用。</li><li>deactivated keep-alive专属，组件被销毁的时候调用。</li></ul><div class="note primary flat"><p>异步请求在哪一步发起？</p></div><p>可以在created，beforeMount，mounted中进行，因为在这三个钩子中data已经创建，可以将服务器返回的数据进行赋值。</p><ul><li>对DOM有需求的话一般是放在mouted中，此时DOM已经加载完毕</li><li>对DOM没有需求可以放created，但是只是在created发出了请求，真正的数据还是在mouted阶段才获取。</li></ul><h1 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a>v-if和v-show的区别</h1><p>v-if是真正的条件渲染，在编译过程中会转化成三元表达式，条件不满足不渲染此节点。<br>v-show会被编译成指令，如果条件不满足对应的节点隐藏，相当于<code>display:none</code></p><p>使用场景<br>v-if适用于运行的时候很少改变条件，不需要频繁切换的场景。因为会很影响性能。<br>v-show适用于频繁切换的场景。</p><p>拓展<br><div class="note primary flat"><p><code>display:none</code>,<code>opacity:0</code>,<code>visibility:hidden</code>之间的区别？</p></div></p><p>三者都是隐藏。</p><ol><li>是否占据空间<br>关键在于display隐藏后不占据位置。visibility和opacity还是占据元素位置。</li><li>子元素是否继承。<br>display的父元素都不存在了，自然子元素不会被继承。<br>visibility会被子元素继承，可以使用visible来显示子元素<br>opacity会被子元素继承，但不可以设置1来重新显示子元素。</li><li>事件绑定<br>display的元素不存在了，自然无法使用他绑定的元素<br>visibility不会触发他上面绑定的事件<br>opacity会触发。</li><li>过度动画<br>想要使一个元素慢慢消失，只能用opacity。</li></ol><h1 id="说说Vue的内置指令。"><a href="#说说Vue的内置指令。" class="headerlink" title="说说Vue的内置指令。"></a>说说Vue的内置指令。</h1><p>v-once 定义它的元素只渲染一次包括它的所有子节点，首次渲染完之后将视为静态内容。<br>v-clock 该指令保存在元素上直到关联实例结束编译，解决初始化慢导致页面闪动的最佳实践。<br>v-bind 绑定属性，动态更改HTML元素上的属性可以简写成:<br>v-on 监听dom事件 可以简写成@<br>v-html 和<code>innerHTML</code>一样 注意防止xss攻击<br>v-text 更新元素的textContent<br>v-model 变为value和input的语法糖<br>v-if/v-else/v-else-if 配合template使用。<br>v-show 使用指令来实现隐藏和显示<br>v-for </p><ul><li>循环显示渲染列表</li><li>优先级比v-if高，最好不要一起使用—用computed</li><li>注意增加唯一的key—不要使用index作为key<br>v-pre 跳过这个元素以及它的子元素的编译，加快编译速度。</li></ul><h1 id="怎么理解Vue的单向数据流"><a href="#怎么理解Vue的单向数据流" class="headerlink" title="怎么理解Vue的单向数据流"></a>怎么理解Vue的单向数据流</h1><p>数据总是从父组件流到子组件，子组件理应没有权限修改父组件的数据，因为这样会导致数据流错乱。<br>当然如果需要修改父组件props穿过来的数据。最好定义一个data接收这个值再改变。</p><h1 id="computed和watch的区别和运用的场景"><a href="#computed和watch的区别和运用的场景" class="headerlink" title="computed和watch的区别和运用的场景"></a>computed和watch的区别和运用的场景</h1><p>computed和watch都是对属性的变化做出改变的一个函数了。区别在于computed是计算属性，更偏向于计算的结果这个状态，而watch是监视属性，可以看属性的old和new值，偏向于知道这个过程中发生了什么。<br>场景：<br>computed用在模板渲染比较多，某个值有依赖其他的响应式对象甚至是计算属性计算而来。<br>watch用在观测某个值的变化完成复杂的逻辑功能。</p><h1 id="v-if和v-for为什么不建议一起使用。"><a href="#v-if和v-for为什么不建议一起使用。" class="headerlink" title="v-if和v-for为什么不建议一起使用。"></a>v-if和v-for为什么不建议一起使用。</h1><p>首先是v-for的优先级高于v-if 会先解析v-for在去解析v-if 所以每次判断都会遍历整个渲染的数据再去找里面不需要的内容。改进的方法是使用computed 不用if。</p><h1 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h1><h1 id="Vue响应式数据的原理"><a href="#Vue响应式数据的原理" class="headerlink" title="Vue响应式数据的原理"></a>Vue响应式数据的原理</h1><p>整体思路是数据劫持+观测者模式</p><p>在对象内部使用<code>Object.defineProperty</code>将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应的属性的时候，每个属性都有自己的dep属性，存放她所依赖的watcher，当属性变化后会通知watcher派发更新。</p><p>手写</p><h1 id="Vue如何检测数组变化"><a href="#Vue如何检测数组变化" class="headerlink" title="Vue如何检测数组变化"></a>Vue如何检测数组变化</h1><p>数组考虑性能原因没有使用defineProperty对数组每一项进行拦截，而是选择对7种数组方法进行重写(push,shift,pop,splice,unshift,sort,reverse)</p><p>所以在vue种修改数组的索引和长度是无法检测到的。需要通过以上七种变异方法触发数组对应的watcher才能更新。</p><p>换言之，如果使用了其他方法操作vue中的数组，都是不安全的。</p><h1 id="vue3-0用过吗-了解多少"><a href="#vue3-0用过吗-了解多少" class="headerlink" title="vue3.0用过吗 了解多少"></a>vue3.0用过吗 了解多少</h1><ul><li>响应式原理的改变。使用了Proxy替代了<code>Object.defineProperty</code></li><li>使用了Composition API，组件的入口变成了setup</li><li>生命周期函数的变化 setup的集成。</li><li>性能上面的提升</li></ul><h1 id="Vue3和2的响应式原理区别"><a href="#Vue3和2的响应式原理区别" class="headerlink" title="Vue3和2的响应式原理区别"></a>Vue3和2的响应式原理区别</h1><p>我们知道vue2种的响应式不能很好的解决数组的问题，修改数组索引和长度无法检测，且对象删除和增加的操作也无法检测到。</p><p>vue3就利用了Proxy针对这几项进行了改变。可以直接监听对象和数组的变化。并且有多达13种拦截方法。</p><h1 id="Vue的父子组件生命周期钩子执行顺序"><a href="#Vue的父子组件生命周期钩子执行顺序" class="headerlink" title="Vue的父子组件生命周期钩子执行顺序"></a>Vue的父子组件生命周期钩子执行顺序</h1><ul><li><p>加载过程 很容易理解 因为父组件需要先有雏形才能放子组件，可以理解为进行到beforeMount才能放子组件<br>父beforeCreate<br>父created<br>父beforeMount<br>子beforeCreate<br>子created<br>子beforeMount<br>子mounted<br>父mounted<br>注意在这个过程中是子先mounted</p></li><li><p>子组件更新过程<br>父beforeUpdate<br>子beforeUpdate<br>子updated<br>父updated</p></li><li><p>父组件更新过程<br>父beforeUpdate<br>父updated</p></li><li><p>销毁过程<br>父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p></li></ul><h1 id="虚拟DOM是什么-有什么优缺点"><a href="#虚拟DOM是什么-有什么优缺点" class="headerlink" title="虚拟DOM是什么 有什么优缺点"></a>虚拟DOM是什么 有什么优缺点</h1><p>我们知道，在浏览器中一直操作真实DOM是很浪费性能的，这就是虚拟DOM产生的原因。vue2的virtual DOM本质就是用一个原生的js对象去描述一个DOM节点，是对真实DOM的一层抽象。</p><p>优点：</p><ul><li>保护性能下限，框架的虚拟DOM需要适配任何上层API可能的操作，他的一些DOM操作必须是能够有配合的，所以他的性能并不是最优的。但是比起我们粗暴的操作DOM性能要好很多。因此框架的虚拟DOM至少能够保证在你不需要性能优化的前提下依然还可以提供不错的性能。</li><li>无需手动操作DOM，我们不需要手动操作DOM，只需要写好viewmodel的逻辑，框架就会根据虚拟DOM和数据进行双向绑定，帮助我们更新视图提高我们的开发效率。</li><li>跨平台：虚拟dom本质上是js对象，而DOM和平台强相关，相比之下，虚拟dom可以更方便的进行跨平台操作，比如服务器渲染，weex开发等。</li></ul><p>缺点：</p><ul><li>刚刚也说了，虚拟DOM只能保证我们的性能下限，因此对于性能要求高的引用来说，虚拟DOM无法针对性的进行性能优化；</li><li>当首次渲染大量DOM的时候，由于多了一层虚拟DOM的计算，所以会比innerHTML插入慢。</li></ul><h1 id="v-model的原理"><a href="#v-model的原理" class="headerlink" title="v-model的原理"></a>v-model的原理</h1><p>v-model本质上只是一个语法糖，处理value和input</p><p>他在内部为不同的输入元素使用不同的property并抛出不同的事件。</p><ul><li>text和textarea元素使用value property和input事件</li><li>checkbox和radio使用checked property和change事件</li><li>select字段将value作为prop并将change作为事件。</li></ul><div class="note primary flat"><p>注意对于需要使用输入法的语言，你会发现v-model并不会在输入法组合文字的过程中得到更新。</p></div><p>在普通标签上<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;sth&quot;</span> /&gt;  <span class="comment">//这一行等于下一行</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;sth&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;sth = $event.target.value&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>在组件上<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;currency-input v-model=<span class="string">&quot;price&quot;</span>&gt;&lt;/currentcy-input&gt;</span><br><span class="line">&lt;!--上行代码是下行的语法糖</span><br><span class="line"> &lt;currency-input :value=<span class="string">&quot;price&quot;</span> @input=<span class="string">&quot;price = arguments[0]&quot;</span>&gt;&lt;/currency-input&gt;</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 子组件定义 --&gt;</span><br><span class="line">Vue.component(<span class="string">&#x27;currency-input&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;span&gt;</span></span><br><span class="line"><span class="string">   &lt;input</span></span><br><span class="line"><span class="string">    ref=&quot;input&quot;</span></span><br><span class="line"><span class="string">    :value=&quot;value&quot;</span></span><br><span class="line"><span class="string">    @input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span><br><span class="line"><span class="string">   &gt;</span></span><br><span class="line"><span class="string">  &lt;/span&gt;</span></span><br><span class="line"><span class="string"> `</span>,</span><br><span class="line"> <span class="attr">props</span>: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="v-for为什么要加key"><a href="#v-for为什么要加key" class="headerlink" title="v-for为什么要加key"></a>v-for为什么要加key</h1><p>如果不使用key，vue会使用一种最大限度减少动态元素并且尝试就地修改复用相同类型元素的算法。key是为Vue中的vnode的唯一标记，通过这个标记，我们的diff操作可以更准确，更迅速。</p><p>更准确：因为带key就不是就地复用了，在sameNode函数a的key和b的key对比中可以避免就地复用的情况。所以会更加准确。</p><p>更快速：利用key的唯一性生成map对象来获取对应节点，比遍历方法更快。</p><h1 id="vue事件绑定原理"><a href="#vue事件绑定原理" class="headerlink" title="vue事件绑定原理"></a>vue事件绑定原理</h1><p>原生事件绑定是通过<code>addEventListener</code>绑定给真实元素的，组件事件绑定是通过Vue自定义的$on来实现的。如果要在组件上使用原生事件，需要加<code>.native</code>修饰符，这样就相当于在父组件中把子组件当作普通的HTML标签，然后加上原生事件。</p><p><code>$on</code>,<code>$emit</code>是基于发布订阅模式的，维护一个事件中心，on的时候将事件按名称存在事件中心中，称之为订阅者，然后emit将对应的事件进行发布，去执行事件中心里对应的的监听器。</p><p>手写发布订阅</p><h1 id="vue-router路由钩子函数是什么-执行顺序是什么"><a href="#vue-router路由钩子函数是什么-执行顺序是什么" class="headerlink" title="vue-router路由钩子函数是什么 执行顺序是什么"></a>vue-router路由钩子函数是什么 执行顺序是什么</h1><p>钩子函数种类有全局守卫，路由守卫，组件守卫</p><p>全局守卫3个：<br>1.router.beforeEach 全局前置守卫<br>2.router.beforeResolve 全局解析守卫 在beforeRouteEnter调用后调用。<br>3.router.afterEach 全局后置钩子 进入路由后</p><p>路由独享守卫1个：<br>beforeEnter</p><p>组件守卫3个：<br>1.beforeRouteEnter 进入路由前 不能访问this<br>2.beforeRouteUpdate 路由复用同一个组件时<br>3.beforeRouteLeave 离开当前路由时。我们用它来禁止用户离开，比如还未保存草稿，或者在用户离开前，将setInterval销毁，防止离开之后，定时器还在调用。</p><p>完整的导航解析过程：</p><ol><li>导航被触发</li><li>在失活的组件里调用beforeRouteLeave守卫<br>3，调用全局的beforeEach守卫</li><li>在重用的组件里调用beforeRouteUpdate守卫<br>5，在路由配置里调用beforeEnter</li><li>解析异步路由组件</li><li>在被激活的组件里调用beforeRouteEnter</li><li>调用全局的beforeResolve守卫</li><li>导航被确认</li><li>调用全局的afterEach守卫</li><li>触发DOM更新</li><li>调用beforeRouteEnter守卫中传给next的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220415100347.png" alt=""></p><h1 id="vue-router-动态路由是什么？有什么问题"><a href="#vue-router-动态路由是什么？有什么问题" class="headerlink" title="vue-router 动态路由是什么？有什么问题"></a>vue-router 动态路由是什么？有什么问题</h1><p>我们经常需要把某种模式匹配到的路由全部映射到同个组件。例如我们有一个User组件，对于所有ID各不相同的用户，都需要用这个组件来渲染。那么我们可以在vue-router的路由路径中使用动态路由参数来达到这个效果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&#x27;user.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>:[</span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">&quot;/user/:id&quot;</span>,<span class="attr">component</span>:User&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><div class="note primary flat"><p>vue-router组件复用导致路由参数失效怎么办？</p></div><ol><li>通过watch监听路由参数再发请求。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">  <span class="string">&quot;$route&quot;</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.getData(<span class="built_in">this</span>.$route.params.xxx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>用key来防止复用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view :key=<span class="string">&quot;$router.fullPath&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Vuex的理解"><a href="#Vuex的理解" class="headerlink" title="Vuex的理解"></a>Vuex的理解</h1><p>vuex是专门为vue设计的全局状态管理工具，用于多个组件中数据共享。数据缓存等。但无法持久化，内部的核心原理是创造一个全局实例new vue<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220415101158.png" alt=""></p><p>主要包括以下几个模块：</p><ul><li>State 定义了应用状态的数据结构，可以在这里设置默认的初始状态</li><li>Getter 允许组件从Store中获取数据，mapGetters辅助函数仅仅是将store中的getter映射到局部计算属性</li><li>Mutation 是唯一更改store中状态的方法，且必须是同步函数</li><li>Action 用于提交mutation 而不是直接变更状态，可以包含任意异步操作。</li><li>Module 允许将单一的Store拆分为多个store且同时保存在单一的状态树中。</li></ul><h1 id="Vuex页面刷新数据丢失怎么解决"><a href="#Vuex页面刷新数据丢失怎么解决" class="headerlink" title="Vuex页面刷新数据丢失怎么解决"></a>Vuex页面刷新数据丢失怎么解决</h1><p>数据持久化使用本地存储或者第三方插件vuex-persist</p><h1 id="Vuex为什么要分模块而且加命名空间"><a href="#Vuex为什么要分模块而且加命名空间" class="headerlink" title="Vuex为什么要分模块而且加命名空间"></a>Vuex为什么要分模块而且加命名空间</h1><p>模块：由于使用单一的状态树，应用的所有状态会集中到一个比较大的对象。当应用变得复杂的时候，store对象就有可能变得相当臃肿。为了解决以上的问题，Vuex允许我们将store分割成模块module。每个模块拥有自己的state，mutation，action和getter</p><p>命名空间：默认情况下，模块内部的action，mutation，getter是注册在全局命名空间的—-这样能够使得多个模块能够对同一个mutation或者action做出相应。如果想要模块有更高的封装度和复用性，建议添加namespaced:true的方式使得他成为命名空间。当模块被注册的时候，他的所有getter，action以及mutation都会更具模块注册的路径调整名字。</p><h1 id="使用过Vue-SSR吗？说一说SSR"><a href="#使用过Vue-SSR吗？说一说SSR" class="headerlink" title="使用过Vue SSR吗？说一说SSR"></a>使用过Vue SSR吗？说一说SSR</h1><p>SSR也就是服务端渲染，也就是将vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。</p><p>优点：<br>SSR有更好的SEO，并且是因为按需分配，首屏的加载速度更快</p><p>缺点：<br>开发条件受到限制。服务端渲染只支持beforeCreate和created两个钩子。当我们需要一些外部拓展库的时候需要进行特殊处理，服务端渲染应用程序也需要处于nodejs的运行环境。</p><p>且服务端会有更大的负载需求。</p><h1 id="Vue使用了哪些设计者模式"><a href="#Vue使用了哪些设计者模式" class="headerlink" title="Vue使用了哪些设计者模式"></a>Vue使用了哪些设计者模式</h1><ol><li>工厂模式-传入参数即可创建实例。<br>虚拟dom根据参数的不同返回基础标签的vnode和组件vnode</li><li>单例模式-整个程序有且仅有一个实例<br>vue和vue-router的插件注册方法install判断如果系统存在实例就直接返回掉</li><li>发布-订阅模式（vue事件机制）<br>4，观察者模式-响应式数据原理</li><li>装饰模式-@装饰器用法</li><li>策略模式-策略模式指对象有某个行为，但在不同的场景下，该行为有不同的实现方案，比如选项的合并策略。</li></ol><h1 id="你做过哪些vue的性能优化"><a href="#你做过哪些vue的性能优化" class="headerlink" title="你做过哪些vue的性能优化"></a>你做过哪些vue的性能优化</h1><div class="note primary flat"><p>以下针对vue</p></div><ul><li>对象层级不要太深，否则性能就会差。</li><li>不需要响应式的数据不要放在data中，可以使用<code>Object.freeze</code>冻结数据</li><li>v-if和v-show区别使用</li><li>computed和watch区别使用场景。</li><li>v-for遍历必须加key key最好是id 且避免使用v-if</li><li>大数据列表和表格性能优化-虚拟列表/虚拟表格</li><li>防止内部泄漏，组件销毁后把全局变量和事件销毁。</li><li>图片懒加载</li><li>路由懒加载</li><li>第三方插件按需引入</li><li>适当采用keep-alive缓存组件</li><li>防抖节流避免反复请求</li><li>服务端渲染SSR or 预渲染</li></ul><h1 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h1><h1 id="Vue-mixin的使用场景和原理"><a href="#Vue-mixin的使用场景和原理" class="headerlink" title="Vue.mixin的使用场景和原理"></a>Vue.mixin的使用场景和原理</h1><p>在日常的开发中，我们经常会遇到在不同的组件中会需要用到一些相同或者类似的代码，这些代码的功能相对独立，可以通过vue的mixin抽离公共的业务逻辑，原理类似于原型链的继承，当组件初始化的时候会调用mergeOptions方法进行合并，采用策略模式针对不同的属性进行和并。当组件和混入对象拥有同名的选项的时候，这些选项将以恰当的方式“合并”</p><p>手撕mixin</p><h1 id="nextTick的使用场景和原理"><a href="#nextTick的使用场景和原理" class="headerlink" title="nextTick的使用场景和原理"></a>nextTick的使用场景和原理</h1><p>nextTick中的回调是在下次DOM循环更新结束之后执行的回调。在修改数据之后立刻使用这个方法，获取更新后的DOM。主要的思路是采用微任务优先的方式调用异步方法去执行nextTick包装的方法。</p><p>手撕nextTick</p><h1 id="keep-alive使用场景"><a href="#keep-alive使用场景" class="headerlink" title="keep-alive使用场景"></a>keep-alive使用场景</h1><p>keep-alive是vue内置的一个组件，可以实现组件缓存，当组件切换的时候不会对当前组件进行卸载。</p><ul><li>常用的两个属性include和exclude 允许组件有条件的进行缓存</li><li>生命周期两个 activated 和 deactivated。用来知道组件是否处于激活状态</li><li>keep-alive中话运用了LRU算法，选择最近最久未使用的组件进行淘汰</li></ul><p>手撕keep-alive</p><div class="note primary flat"><p>拓展 LRU算法是什么？</p></div><p>LRU 的核心思想是如果数据最近被访问过，那么将来被访问的几率也更高，所以我们将命中缓存的组件 key 重新插入到 this.keys 的尾部，这样一来，this.keys 中越往头部的数据即将来被访问几率越低，所以当缓存数量达到最大值时，我们就删除将来被访问几率最低的数据，即 this.keys 中第一个缓存的组件。</p><h1 id="Vue-set方法原理"><a href="#Vue-set方法原理" class="headerlink" title="Vue.set方法原理"></a>Vue.set方法原理</h1><p>了解了vue响应式原理的同学都知道在两种情况下修改数据vue是不会触发视图更新的。</p><p>1是给实例添加新的属性<br>2是直接更改数组的下标来修改数组的值</p><p>而set的原理就是我们给数组和对象本身都增加了<em>ob</em>属性，代表的是observer实例。当给对象新增不存在的属性，首先会把新的属性进行响应式的跟踪，然后触发对象ob的dep收集到的watcher去更新，当修改数组索引的时候我们调用数组本身的splice方法去更新数组。</p><p>手撕vueset</p><h1 id="Vue-extend原理"><a href="#Vue-extend原理" class="headerlink" title="Vue.extend原理"></a>Vue.extend原理</h1><p>他的原理是使用基础vue构造器，创建一个子类，参数是一个包含组件选项的对象。</p><p>其实就是一个子类构造器，是vue组件的核心api</p><p>实现的思路是使用原型继承的方法返回了vue的子类，并且利用mergeOption把传入组件的options和父类的options进行了合并</p><p>手撕vueextend</p><h1 id="写过自定义指令吗-原理是啥"><a href="#写过自定义指令吗-原理是啥" class="headerlink" title="写过自定义指令吗 原理是啥"></a>写过自定义指令吗 原理是啥</h1><p>指令本质上是装饰器，是vue对html元素的拓展，给html元素增加自定义功能。vue编译dom的时候，会找到指令对象，执行指令相关的方法。</p><p>自定义指令有五个生命周期，分别是bind，inserted，update，componentUpdated，unbind<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> bind 只调用一次，指令第一次绑定到元素的时候调用，在这里可以进行一次性的初始化设置。</span><br><span class="line"><span class="number">2.</span> inserted 被绑定的元素插入父节点的时候调用，只保证父节点存在，但不一定已被插入文档中</span><br><span class="line"><span class="number">3.</span> update 被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的更新。</span><br><span class="line"><span class="number">4.</span> componentUpdated 被绑定元素所在模板完成一次更新的时候调用。</span><br><span class="line"><span class="number">5.</span> unbind：只调用一次，指令与元素解绑的时候调用。</span><br></pre></td></tr></table></figure></p><p>原理</p><ol><li>在生成ast语法树时，遇到指令会给当前元素添加directives属性</li><li>通过genDirectives生成指令代码</li><li>在patch前将指令的钩子提取到cbs中，在patch过程中调用对应的钩子</li><li>当执行指令对应的钩子函数的时候，调用对应指令定义的方法。</li></ol><h1 id="Vue修饰符有哪些"><a href="#Vue修饰符有哪些" class="headerlink" title="Vue修饰符有哪些"></a>Vue修饰符有哪些</h1><p>事件修饰符<br>为了方便 下面的指令都省略.</p><ul><li>stop阻止事件继续传播</li><li>prevent 阻止标签默认行为</li><li>capture 使用事件捕获模式，即元素自身触发的事件先在此处理，然后交由内部元素进行处理</li><li>self 只当在<code>event.target</code>是当前元素的时候才触发处理函数</li><li>once 事件只会触发一次</li><li>passive 告诉浏览器不要阻止事件的默认行为。</li></ul><p>v-model修饰符</p><ul><li>lazy 通过这个修饰符，转变为在change事件再同步</li><li>number 自动将用户输入的值转换为数值类型</li><li>trim 自动过滤用户输入的首位空格</li></ul><p>键盘事件的修饰符</p><ul><li>enter</li><li>tab</li><li>delete（捕获删除 和 退格键）</li><li>esc</li><li>space</li><li>up down left right</li></ul><p>系统修饰符</p><ul><li>ctrl </li><li>alt</li><li>shift</li><li>meta</li></ul><p>鼠标按键修饰符</p><ul><li>left right middle</li></ul><h1 id="Vue模板编译原理"><a href="#Vue模板编译原理" class="headerlink" title="Vue模板编译原理"></a>Vue模板编译原理</h1><p>vue的编译过程就是将template转化为render函数的过程，分为以下几步：<br>第一步 模板字符串 转化为elements ASTs—解析器<br>第二步 对AST进行静态节点标记，主要用来做虚拟DOM的渲染优化—优化器<br>第三步 使用elements ASTs 生成render函数代码字符串—代码生成器</p><p>手撕模板编译</p><h1 id="生命周期钩子是如何实现的"><a href="#生命周期钩子是如何实现的" class="headerlink" title="生命周期钩子是如何实现的"></a>生命周期钩子是如何实现的</h1><p>vue生命周期钩子的核心是利用发布订阅模式先把用户传入的生命周期钩子订阅好，内部采用数组的方式存储，然后在创建组件实例的过程中会一次执行对应的钩子方法—发布</p><p>手撕生命周期钩子实现</p><h1 id="函数式组件使用场景和原理"><a href="#函数式组件使用场景和原理" class="headerlink" title="函数式组件使用场景和原理"></a>函数式组件使用场景和原理</h1><p>函数式组件与普通组件的区别</p><ol><li>函数式组件需要在声明组件的时候指定<code>functional:true</code></li><li>不需要实例化，所以没有this，他的this通过render函数的第二个参数context来代替</li><li>没有生命周期钩子函数，不能使用computed和watch</li><li>不能通过emit对外暴露事件，调用事件只能通过<code>context.listeners.click</code>的方式调用外部传入的事件.</li><li>因为函数式组件是没有实例化的，所以在外部通过ref去引用组件的时候，实际引用的是HTMLElement</li><li>函数式组件的props可以不用显示声明，所以在没有props里面声明的属性都会被隐式的解析为prop。</li></ol><p>优点</p><ol><li>由于函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件</li><li>函数式组件的结构比较简单，代码结构清晰</li></ol><p>使用场景：<br>一个简单的展示组件，作为容器组件的使用，比如router-view就是一个函数式组件</p><p>高阶组件—用于接收一个组件作为参数，返回一个被包装的组件</p><p>相关代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isTrue(Ctor.options.functional)) &#123;</span><br><span class="line">  <span class="comment">// 带有functional的属性的就是函数式组件</span></span><br><span class="line">  <span class="keyword">return</span> createFunctionalComponent(Ctor, propsData, data, context, children);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> listeners = data.on;</span><br><span class="line">data.on = data.nativeOn;</span><br><span class="line">installComponentHooks(data); <span class="comment">// 安装组件相关钩子 （函数式组件没有调用此方法，从而性能高于普通组件）</span></span><br></pre></td></tr></table></figure></p><h1 id="能说下vue-router中常用的路由模式实现原理吗"><a href="#能说下vue-router中常用的路由模式实现原理吗" class="headerlink" title="能说下vue-router中常用的路由模式实现原理吗"></a>能说下vue-router中常用的路由模式实现原理吗</h1><p>hash模式</p><ol><li>location.hash的值实际就是URL后面#的东西，他的特点在于hash虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，所以改变hash不会重新加载页面</li><li>可以为hash的改变添加监听事件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;hashchange&quot;</span>, funcRef, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>3.每改变一次hash都会在浏览器的访问历史中增加一个记录利用hash的以上特点，就可以实现前端路由更新视图但不请求页面的功能了。</li></ol><div class="note primary flat"><p>特点：兼容性好但是不美观</p></div><p>history模式<br>利用了HTML5 History Interface 中新增的pushState和replaceState方法</p><p>这两个方法应用于浏览器的历史记录站，在当前已有的back，forward，go的基础上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用它们修改的浏览器历史记录栈后，虽然当前的URL改变了，但是浏览器不会刷新页面，这就为单页应用前端路由更新视图但不重新请求页面提供了基础。<br><div class="note primary flat"><p>特点，虽然美观，但是刷新后出现404需要后端配置</p></div></p><h1 id="diff算法了解吗"><a href="#diff算法了解吗" class="headerlink" title="diff算法了解吗"></a>diff算法了解吗</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220415135701.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络不完全指南</title>
    <link href="https://zlinni.github.io/posts/62a0bd444c41/"/>
    <id>https://zlinni.github.io/posts/62a0bd444c41/</id>
    <published>2022-04-14T00:20:38.000Z</published>
    <updated>2022-04-23T06:23:03.331Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>本文通过OSI七层模型阐述前端常考的计网知识点</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414082617.png" alt=""></p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><div class="tip cogs"><p>参见HTTP灵魂之问</p></div><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><div class="note primary flat"><p>DNS的作用就是通过域名查询到IP</p></div><p>因为IP存在数字和英文的组合IPv6，很不利于人类记忆，所以出现了域名。你可以把域名看成某个IP的别名，DNS就是去查询这个别名真正的名称是什么</p><div class="note primary flat"><p>在TCP握手之前就已经进行了DNS查询，这个查询是操作系统自己完成的，当在浏览器中想访问<code>www.google.com</code>会进行以下操作。</p></div><ul><li>本地客户端向服务器发起请求查询 IP 地址</li><li>查看浏览器有没有该域名的 IP 缓存</li><li>查看操作系统有没有该域名的 IP 缓存</li><li>查看 Host 文件有没有该域名的解析配置</li><li>如果这时候还没得话，会通过直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器</li><li>然后去该服务器查询 google.com 这个二级域名</li><li>接下来查询 www.google.com 这个三级域名的地址</li><li>返回给 DNS 客户端并缓存起来</li></ul><div class="note primary flat"><p>以上介绍的是DNS迭代查询，还有一种是递归查询，区别是前者是由客户端去请求，后者是由系统配置的DNS去请求，得到结果之后将数据返回给客户端。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414083618.png" alt=""></p><h3 id="DNS解析优化"><a href="#DNS解析优化" class="headerlink" title="DNS解析优化"></a>DNS解析优化</h3><p>主要分为两个方案</p><ul><li>DNS预解析</li><li>减少DNS请求</li></ul><h3 id="DNS预解析"><a href="#DNS预解析" class="headerlink" title="DNS预解析"></a>DNS预解析</h3><div class="note primary flat"><p>DNS解析也需要时间的，可以通过预解析的方式来预先获取域名所对应的IP</p></div><p>link方式：手动解析<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//blog.poetries.top&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>meta方式：https自动解析<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;x-dns-prefetch-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;on&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>设置响应头：自动解析<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.set(<span class="string">&#x27;X-DNS-Prefetch-Control&#x27;</span>, <span class="string">&#x27;on&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h1 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h1><h2 id="URL的加密和解密"><a href="#URL的加密和解密" class="headerlink" title="URL的加密和解密"></a>URL的加密和解密</h2><h2 id="图片编码和解码"><a href="#图片编码和解码" class="headerlink" title="图片编码和解码"></a>图片编码和解码</h2><h1 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h1><h2 id="验证登陆"><a href="#验证登陆" class="headerlink" title="验证登陆"></a>验证登陆</h2><ul><li>cookie session</li><li>token </li><li>sso 单点登陆</li><li>OAuth第三方登陆</li></ul><h3 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie session"></a>cookie session</h3><p>登陆流程：首次登陆<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414092439.png" alt=""></p><ol><li>用户访问<code>a.com/pageA</code>并输入密码登陆</li><li>服务器验证密码无误后，会创建Session ID并将其保存起来</li><li>服务端响应这个请求，并通过Set-Cookie将Session ID写入Cookie中</li></ol><p>再次登陆：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414092643.png" alt=""></p><ol><li>用户访问<code>a.com/pageB</code>自动带上第一次登陆写入的Cookie</li><li>服务端对比Cookie中的SessionID和保存在服务端的SessionID是否一致</li><li>一致则成功</li></ol><h3 id="cookie-session存在的问题"><a href="#cookie-session存在的问题" class="headerlink" title="cookie session存在的问题"></a>cookie session存在的问题</h3><ul><li>服务器需要对接大量的客户端，导致服务器压力大。</li><li>如果服务器是一个集群，为了同步登陆态，就需要将SessionID同步到每一台机器上，无形中增加了服务器的维护成本。</li><li>由于SessionID存放在Cookie中所以无法避免CSRF攻击</li></ul><h3 id="token登陆"><a href="#token登陆" class="headerlink" title="token登陆"></a>token登陆</h3><p>为了解决cookie+session暴露出来的问题，我们可以使用token的登陆方式<br><div class="note primary flat"><p>token是服务端生成的一串字符串，以作为客户端请求的一个令牌。当第一次登陆完成后，服务器会生成一个token并返回给客户端，客户端后续访问只要带上这个token就可以完成身份验证。</p></div></p><h4 id="token机制实现流程"><a href="#token机制实现流程" class="headerlink" title="token机制实现流程"></a>token机制实现流程</h4><p>首次登陆：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414102745.png" alt=""></p><ol><li>用户输入账号密码，并点击登录。</li><li>服务器端验证账号密码无误，创建 Token。</li><li>服务器端将 Token 返回给客户端，由客户端自由保存。</li></ol><p>后续页面访问时：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414102830.png" alt=""></p><ol><li>用户访问 a.com/pageB 时，带上第一次登录时获取的 Token。</li><li>服务器端验证 Token ，有效则身份验证成功。</li></ol><h4 id="Token-机制的特点"><a href="#Token-机制的特点" class="headerlink" title="Token 机制的特点"></a>Token 机制的特点</h4><p>根据上面的案例，我们可以分析出Token的优缺点：</p><ul><li>服务器端不需要存放token，所以不会对服务器造成压力，即使服务器集群，也不需要增加维护成本。</li><li>Token可以存放在前端的任何地方，可以不用保存在Cookie中，提升了页面的安全性。</li><li>Token下发之后，只要在生效时间内，就一直有效，如果服务器想收回此token的权限，并不容易。</li></ul><h4 id="Token的生成方式"><a href="#Token的生成方式" class="headerlink" title="Token的生成方式"></a>Token的生成方式</h4><p>最常见的Token生成方式是使用JWT，他是一种简洁的，自包含的方法用于通信双方之间以JSON对象的形式安全的传递信息。</p><p>上文中我们说到，使用Token后，服务器端并不会存储Token，那怎么判断客户端的token是否合法有效？</p><p>答案其实就在Token字符串中，其实Token并不是一串杂乱无章的字符串，而是通过多种算法拼接组合而成的字符串。如下：</p><p>JWT算法主要分成了三个部分 </p><ul><li>header 头信息</li><li>payload 消息体</li><li>signature 签名</li></ul><p>header部分指定了JWT使用的签名算法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header = <span class="string">&#x27;&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;&#x27;</span>   <span class="comment">// `HS256` 表示使用了 HMAC-SHA256 来生成签名。</span></span><br></pre></td></tr></table></figure></p><p>payload部分指明了JWT的使用意图<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;&#123;&quot;loggedInAs&quot;:&quot;admin&quot;,&quot;iat&quot;:1422779638&#125;&#x27;</span>     <span class="comment">//iat 表示令牌生成的时间</span></span><br></pre></td></tr></table></figure></p><p>signature部分为JWT的签名 主要为了让JWT不能随意更改，签名的方法分为两个步骤</p><ol><li>输入base64url编码的header部分，base64url编码的payload部分，输出unsignedToken</li><li>输入服务器端私钥，unsignedToken,输出signature签名</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base64Header = encodeBase64(header)</span><br><span class="line"><span class="keyword">const</span> base64Payload = encodeBase64(payload)</span><br><span class="line"><span class="keyword">const</span> unsignedToken = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;服务器私钥&#x27;</span></span><br><span class="line"></span><br><span class="line">signature = HMAC(key, unsignedToken)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后Token计算如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base64Header = encodeBase64(header)</span><br><span class="line"><span class="keyword">const</span> base64Payload = encodeBase64(payload)</span><br><span class="line"><span class="keyword">const</span> base64Signature = encodeBase64(signature)</span><br><span class="line"></span><br><span class="line">token = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>.<span class="subst">$&#123;base64Signature&#125;</span>`</span></span><br></pre></td></tr></table></figure></p><p>服务器在判断token的时候<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [base64Header, base64Payload, base64Signature] = token.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> signature1 = decodeBase64(base64Signature)</span><br><span class="line"><span class="keyword">const</span> unsignedToken = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> signature2 = HMAC(<span class="string">&#x27;服务器私钥&#x27;</span>, unsignedToken)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(signature1 === signature2) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;签名验证成功，token 没有被篡改&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> payload =  decodeBase64(base64Payload)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Date</span>() - payload.iat &lt; <span class="string">&#x27;token 有效期&#x27;</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;token 有效&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有了 Token 之后，登录方式已经变得非常高效，接下来我们介绍另外两种登录方式。</p><h3 id="SSO单点登陆"><a href="#SSO单点登陆" class="headerlink" title="SSO单点登陆"></a>SSO单点登陆</h3><div class="note primary flat"><p>单点登陆指的是在公司内部搭建一个公共的认证中心，公司下的所有产品的登陆都可以在认证中心中完成，一个产品在认证中心登陆后，再去访问另外一个产品，可以不用再次登陆，即可获取登陆状态。</p></div><h4 id="SSO机制实现流程"><a href="#SSO机制实现流程" class="headerlink" title="SSO机制实现流程"></a>SSO机制实现流程</h4><p>用户首次访问需要在认证中心登陆</p><h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h2><p><a href="https://juejin.cn/post/6844904046436843527">https://juejin.cn/post/6844904046436843527</a></p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h2><div class="note primary flat"><ol><li>tcp是面向链接的 udp是无连接的即发送数据前不需要建立连接</li><li>tcp提供可靠的服务，也就是说通过tcp连接发送的数据，无差错，不丢失，不重复，且按序到达，udp尽最大的努力交付，即不保证可靠交付。并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换</li><li>tcp是面向字节流，udp面向报文，并且网络出现拥塞不会使得发送速率降低（因此会产生丢包，对实时的应用比如ip电话和视频会议等）</li><li>tcp只能是一对一的，udp支持1对1 1对多</li><li>tcp的首部较大为20字节 udp只有8字节</li><li>tcp是面向连接的可靠性传输，udp是不可靠的 </li></ol></div><h3 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h3><p>UDP：</p><ul><li>直播</li><li>游戏</li></ul><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><div class="note primary flat"><p>建立连接前，客户端和服务端需要通过握手来确认对方</p></div><ul><li>客户端发送SYN同步序列编号请求，进入SYN_SEND状态，等待确认</li><li>服务端接收并确认SYN包之后发送SYN+ACK包，进入SYN_RECV状态</li><li>客户端接收SYN+ACK包之后，发送ACK包，双方进入ESTABLISHED状态</li></ul><h4 id="为什么采用三次握手？"><a href="#为什么采用三次握手？" class="headerlink" title="为什么采用三次握手？"></a>为什么采用三次握手？</h4><p>举例：已失效的连接请求报文段</p><ul><li>如果客户端发送请求报文但由于网络问题导致报文失效，服务端接收到请求后就会发送确认报文表示同意连接。此时如果是两次握手，那么此时服务端已经建立了新的连接，但由于这个请求是失效的，客户端并没有建立连接，服务端就会浪费很多资源。如果是三次握手，那么此时服务端收不到确认连接的信息，就知道客户端没有建立连接。这就是三次握手的作用。<div class="note primary flat"><p>TCP有六种标识SYN建立连接，ACK确认，PSH传送，FIN结束，RST重置，URG紧急</p></div></li></ul><h4 id="三次握手过程中可以携带数据吗？"><a href="#三次握手过程中可以携带数据吗？" class="headerlink" title="三次握手过程中可以携带数据吗？"></a>三次握手过程中可以携带数据吗？</h4><ul><li>第一次第二次握手不能携带数据，因为第一次握手和第二次握手服务端还没有建立连接，此时发送数据会让服务器受到攻击。</li><li>第三次握手服务器已经处于ESTABLISHED状态，对于客户端来说已经建立了连接，并且也知道服务器的接收发送能力是正常的了，所以能携带数据。</li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><div class="note primary flat"><p>为了确保数据能完成传输</p></div><ul><li>客户端—FIN—&gt;服务端，FIN——WAIT</li><li>服务端—ACK—&gt;客户端，CLOSE——WAIT</li><li>服务端—ACK，FIN—&gt;客户端，LAST——ACK</li><li>客户端—ACK—&gt;服务端，CLOSED</li></ul><h4 id="为什么连接的时候是三次握手，关闭的时候是四次挥手？"><a href="#为什么连接的时候是三次握手，关闭的时候是四次挥手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候是四次挥手？"></a>为什么连接的时候是三次握手，关闭的时候是四次挥手？</h4><ul><li>服务端接收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。</li><li>但是在关闭连接的时候，当服务端收到FIN报文的时候 ，很可能并不会立刻关闭连接，所以只能先回复一个ACK报文，告诉客户端，你发的FIN报文收到了，只有等服务器所有的报文发送完了才能发送FIN报文，因此不能一起发送，故需要四次挥手。 </li></ul><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><div class="note primary flat"><p>网络拥塞（congestion）是指在分组交换网络中传送分组的数目太多时，由于存储转发节点的资源有限而造成网络传输性能下降的情况。当网络发生拥塞时，一般会出现数据丢失，时延增加，吞吐量下降，严重时甚至会导致“拥塞崩溃”（congestion collapse）。通常情况下，当网络中负载过度增加致使网络性能下降时，就会发生网络拥塞。下图则描述了在有无拥塞控制的干预下，网络吞吐量随输入负载的增加的变化情况。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423112204.png" alt=""><br>通过以上的描述，我们大概可以得到以下信息：</p><ul><li>网络拥塞往往是由于对资源的请求超出了存储转发节点的能力而导致的。</li><li>网络拥塞可能会导致数据丢失，时延增加，吞吐量下降等问题。</li><li>若出现拥塞而不进行控制，有可能会使整个网络情况恶化，甚至网络吞吐降为0。</li><li>网络的拥塞状况与当前网络负载是密切相关的。</li></ul><h4 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h4><ol><li>慢启动</li><li>拥塞避免</li><li>快重传</li><li>快恢复</li></ol><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>如果发送方的数据发送过快，接收者来不及接收，就有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。</p><p>流量控制的根本目的是防止分组丢失，它是构成TCP可靠性的一方面</p><h4 id="实现流量控制"><a href="#实现流量控制" class="headerlink" title="实现流量控制"></a>实现流量控制</h4><p>滑动窗口协议（连续ARQ协议）实现。它保证了分组无差错，有序接收，也实现了流量控制。</p><p>主要的方式是 接收方返回的ack包会包含自己接收窗口的大小，并且利用大小来控制发送方的数据发送</p><h4 id="流量控制引发的死锁？怎么避免死锁发生？-没看明白"><a href="#流量控制引发的死锁？怎么避免死锁发生？-没看明白" class="headerlink" title="流量控制引发的死锁？怎么避免死锁发生？(没看明白)"></a>流量控制引发的死锁？怎么避免死锁发生？(没看明白)</h4><p>当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。</p><h4 id="拥塞控制和流量控制的区别"><a href="#拥塞控制和流量控制的区别" class="headerlink" title="拥塞控制和流量控制的区别"></a>拥塞控制和流量控制的区别</h4><p>拥塞控制就是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的方法是：慢开始，拥塞避免，快重传，快恢复。</p><p>流量控制就是作用于接收者的，它是控制发送者的发送速度从而使得接收者来得及接收，防止分组丢失</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="计算机网络" scheme="https://zlinni.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP灵魂之问</title>
    <link href="https://zlinni.github.io/posts/18a3127ce1f3/"/>
    <id>https://zlinni.github.io/posts/18a3127ce1f3/</id>
    <published>2022-04-10T01:42:40.000Z</published>
    <updated>2022-04-18T01:57:07.108Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>记录HTTP前端常考考点，关联计算机网络。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414082510.png" alt=""></p><h1 id="1-0-1-x-2-0"><a href="#1-0-1-x-2-0" class="headerlink" title="1.0 1.x 2.0"></a>1.0 1.x 2.0</h1><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h2><p>任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。</p><p>除了GET命令，还引入了POST命令和HEAD命令。</p><p>http请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p><p>只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。</p><p>不支持断点续传，也就是说，每次都会传送全部的页面和数据。</p><p>通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）</p><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h2><p>http1.1是目前最为主流的http协议版本，从1999年发布至今，仍是主流的http协议版本。</p><p>引入了持久连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 keep-alive 来设置</p><p>引入了管道机制（ pipelining），即在同一个TCP连接里，客户端可以同时发送多个 请求，进一步改进了HTTP协议的效率。</p><p>HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。</p><p>支持断点续传，通过使用请求头中的 Range 来实现。</p><p>使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</p><p>新增方法：PUT、 PATCH、 OPTIONS、 DELETE。</p><h2 id="http1-x版本问题"><a href="#http1-x版本问题" class="headerlink" title="http1.x版本问题"></a>http1.x版本问题</h2><p>在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。</p><p>HTTP/1.1 版本默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞。</p><p>http/1.x 版本支持Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。</p><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><p>二进制分帧 这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”：头信息帧和数据帧。</p><p>头部压缩 HTTP 1.1版本会出现 User-Agent、Cookie、Accept、Server、Range 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 HPACK 算法进行压缩。</p><p>多路复用 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。</p><p>服务器推送 允许服务器未经请求，主动向客户端发送资源，即服务器推送。</p><p>请求优先级 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</p><h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>在HTTP1.1之前的时代，请求体一般有响应的压缩编码过程，通过Content-Encoding头部字段来指定，但你有没有想过头部字段本身的压缩呢？当请求字段非常复杂的时候，尤其对于GET请求，请求报文几乎全是请求头，这个时候还是存在非常大的优化空间的。HTTP2针对头部字段采用了压缩算法HPACK对请求头进行压缩。</p><p>HPACK算法是专门为HTTP2.0设计的，它的主要亮点有两个：</p><ul><li>首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的过程中对于之前出现过的值，只需要把索引传给对方即可，对方拿到索引表查即可。这种传索引的方式，可以让请求头的字段得到极大程度的精简和复用。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413183603.png" alt=""></li></ul><p>HTTP2当中废除了起始行的概念，将起始行中的请求方法，URI，状态码转换成了头字段，不过这些字段都有个：前缀，用来和其他请求区分开来。</p><ul><li>其次是对于整数和字符串进行哈夫曼编码，哈夫曼编码的原理是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的索引序列，可以达到非常高的压缩效率。</li></ul><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。</p><h4 id="HTTP队头阻塞"><a href="#HTTP队头阻塞" class="headerlink" title="HTTP队头阻塞"></a>HTTP队头阻塞</h4><p>我们之前讨论了HTTP队头阻塞的问题，其根本原因在于HTTP基于请求响应模型，在同一个TCP长连接中，前面的请求没有得到响应，后面的请求就会被阻塞。</p><p>后面我们又讨论到并发连接和域名分片的方式解决队头阻塞的问题，但实际上治标不治本，因为只是单纯的增加了TCP连接，分摊风险而已。而且这么做也有弊端，多条TCP连接会竞争有限的带宽，让真正优先级高的请求不能优先处理。</p><p>而HTTP2便从HTTP协议本身解决了这个问题。注意，这里并不是TCP阻塞，而是HTTP队头阻塞，两者并不是一回事。TCP的队头阻塞是在数据包层面，单位是数据包，前一个报文没有收到便不会将后面的报文上传给HTTP，而HTTP的队头阻塞是在HTTP请求响应的层面，前一个请求没有处理完，后一个请求就会被阻塞住。两者所在的层次不一样。</p><h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p>首先HTTP2认为明文传输对机器而言太麻烦了，不方便计算机的解析，因为对于文本而言会有多义性的字符，比如回车换行到底是内容还是分隔符，在内部需要用到状态机去识别，效率比较低。于是HTTP2干脆把报文全部换成二进制，全部传输01串，方便机器解析。</p><p>原来Headers+Body的报文格式如今被拆分成一个个二进制的帧，用Headers帧存放头部字段，用Data帧存放请求体数据。分帧之后，服务器看到的不再是一个个完整的HTTP请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了HTTP队头阻塞问题。</p><p>通信双方都可以给对方发送二进制帧，这种二进制的双向传输的序列，也叫做流Stream。HTTP2用流来在一个TCP连接上来进行多个数据帧的通信，这就是多路复用的概念。</p><p>可能你会有一个疑问，既然是乱序收发，那么如何来处理这些乱序的数据帧呢？</p><p>首先要声明的是，所谓的乱序指的是不同ID的Stream是乱序的，但同一个Stream ID的数据帧一定是按顺序传输的。二进制到达后对方会将Stream ID相同的二进制帧组装成完整的请求报文和响应报文。当然，在二进制帧中还有一些其他字段，实现了优先级和流量控制。下一节再介绍。</p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>另外值得一说的是HTTP2的服务器推送Server Push。在HTTP2中，服务器已经不再是被动的接收请求，响应请求，他也能新建Stream来给客户端发送信息，当TCP连接建立之后，比如浏览器请求一个HTML文件，服务器就可以在返回HTML的基础上，将HTML中引用到的一些其他资源文件一起返回给客户端，减少客户端等待。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当然，HTTP/2 新增那么多的特性，是不是 HTTP 的语法要重新学呢？不需要，HTTP/2 完全兼容之前 HTTP 的语法和语义，如请求头、URI、状态码、头部字段都没有改变，完全不用担心。同时，在安全方面，HTTP 也支持 TLS，并且现在主流的浏览器都公开只支持加密的 HTTP/2, 因此你现在能看到的 HTTP/2 也基本上都是跑在 TLS 上面的了。最后放一张分层图给大家参考:<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413190733.png" alt=""></p><h3 id="HTTP2缺点"><a href="#HTTP2缺点" class="headerlink" title="HTTP2缺点"></a>HTTP2缺点</h3><ul><li>TCP 以及 TCP+TLS建立连接的延时,HTTP/2使用TCP协议来传输的，而如果使用HTTPS的话，还需要使用TLS协议进行安全传输，而使用TLS也需要一个握手过程,在传输数据之前，导致我们需要花掉 3～4 个 RTT。</li><li>TCP的队头阻塞并没有彻底解决。在HTTP/2中，多个请求是跑在一个TCP管道中的。但当HTTP/2出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该TCP连接中的所有请求。</li></ul><h3 id="HTTP-2-中的二进制帧是如何设计的？"><a href="#HTTP-2-中的二进制帧是如何设计的？" class="headerlink" title="HTTP/2 中的二进制帧是如何设计的？"></a>HTTP/2 中的二进制帧是如何设计的？</h3><p>帧结构<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413190800.png" alt=""><br>每个帧分为帧头和帧体。先是三个字节的帧长度，这个长度表示是帧体的长度。</p><p>然后是帧类型，分为数据帧和控制帧。数据帧用来存放HTTP报文，控制帧用来管理流的传输。</p><p>接下来的一个字节是帧标志，里面一共有8个标志位，常用的有END_HEADERS表示头数据结束，END_STREAM表示单方向数据发送结束。</p><p>后四个字节是Stream ID，也就是流标识符，有了他就能从乱序的二进制帧中选出ID相同的帧，按顺序组装成请求响应报文。</p><h3 id="流的状态变化"><a href="#流的状态变化" class="headerlink" title="流的状态变化"></a>流的状态变化</h3><p>从前面可以知道，在HTTP2中，所谓的流，其实就是二进制的双向传输的序列，那么在HTTP2请求和响应的过程中，流的状态是如何改变的呢？</p><p>HTTP2其实也是借鉴了TCP状态变化的思想，根据帧的标志位来实现具体的状态改变，这里我们以一个普通的请求响应过程为例子来说明。</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413214916.png" alt=""></p><p>最开始两者都是空闲状态，当客户端发送Header帧后，开始分配Stream ID，此时客户端的流打开，服务端接收之后服务端的流也打开，两端的流打开后，就可以互相传递数据帧和控制帧了。</p><p>当客户端要关闭的时候，向服务端发送END_STREAM帧，进入半关闭状态，这个时候客户端只能接收数据，而不能发送数据。</p><p>服务端接收到这个END_STREAM帧之后，也进入半关闭状态，不过此时服务端只能发送不能接收。随后服务端也向客户端发送END_STREAM帧，表示数据发送完毕，双方进入关闭状态。</p><p>如果下次要开启新的流，流ID需要自增，直到上限为止，到达上限之后开一个新的TCP连接重头开始计数。由于流ID字段字节长度为4个子节，最高位又被保留，因此范围是0~2的31次方，大约21亿个。</p><h3 id="流的特性"><a href="#流的特性" class="headerlink" title="流的特性"></a>流的特性</h3><p>刚刚讲到了流的状态变化的过程，这里顺便来总结一下流传输的特性。</p><ul><li>并发性。一个HTTP2连接上可以同时发送多个帧，这一点和HTTP1不一样。这是实现多路复用的基础。</li><li>自增性。流ID是不可重用的，而会按顺序递增，达到上限后新开TCP连接从头开始。</li><li>双向性。客户端和服务端都可以创建流，互不干扰，双方都可以作为发送方和接收方。</li><li>可设置优先级。可以设置数据帧的优先级，让服务器优先处理重要资源，优化用户体验。</li></ul><h2 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h2><div class="note primary flat"><p>Google 在推SPDY的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 UDP 协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。主要特性如下：</p></div><ul><li>实现了类似TCP的流量控制、传输可靠性的功能。虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性</li><li>实现了快速握手功能。由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据。</li><li>集成了TLS加密功能。目前QUIC使用的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。</li><li>多路复用，彻底解决TCP中队头阻塞的问题。</li></ul><h1 id="http报文的组成部分"><a href="#http报文的组成部分" class="headerlink" title="http报文的组成部分"></a>http报文的组成部分</h1><p>请求报文</p><ul><li>请求行(http方法+页面地址+http协议+版本)</li><li>请求头(key+value值)</li><li>空行(服务端通过空行来判断下一部分不再是请求头，而当作请求体来解析)</li><li>请求体(数据部分)<br>响应报文</li><li>状态行+响应头+空行+响应体</li></ul><h2 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h2><p>对于请求报文来说 起始行类似下面这样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /home HTTP/<span class="number">1.1</span></span><br></pre></td></tr></table></figure><br>也就是方法加路径加版本<br>对于响应报文来说，起始行类似于下面这样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br></pre></td></tr></table></figure><br>响应报文的起始行也叫状态行 由http版本 状态码和原因三部分组成<br>值得注意的是 在起始行中，每两个部分之间用空格隔开，最后一个部分后面应该接个换行，严格遵循<code>ABNF</code>语法规范</p><h2 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h2><p>展示一下请求头和响应头在报文中的位置：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220411184426.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220411184443.png" alt=""><br><div class="note primary flat"><p>不管是请求头还是响应头，其中的字段是相当多的，而且牵扯到http非常多的特性，这里就不一一列举的，重点看看这些头部字段的格式：</p></div></p><ul><li>字段名不区分大小写</li><li>字段名不允许出现空格</li><li>字段名后面必须紧跟着<code>:</code></li></ul><h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><div class="note primary flat"><p>用来区分头部和实体</p></div><p>问：如果在头部的中间故意加一个空行会怎么样？<br>后面的全部被当成实体。</p><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><p>具体的数据，也就是body部分，请求报文对应请求体，响应报文对应响应体</p><h1 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h1><p><code>http/1.1</code>规定了以下方法</p><ul><li>GET: 通常用来获取资源</li><li>HEAD: 获取资源的元信息</li><li>POST: 提交数据，即上传数据</li><li>PUT: 修改数据</li><li>DELETE: 删除资源(几乎用不到)</li><li>CONNECT: 建立连接隧道，用于代理服务器</li><li>OPTIONS: 列出可对资源实行的请求方法，用来跨域请求</li><li>TRACE: 追踪请求-响应的传输路径</li></ul><h2 id="GET-POST-区别"><a href="#GET-POST-区别" class="headerlink" title="GET/POST 区别"></a>GET/POST 区别</h2><div class="note primary flat"><p>首先从直观上是语义的区别，而后又有些具体的差异：</p></div><ul><li>从缓存的角度，GET请求会被浏览器主动缓存下来，留下历史记录，而POST默认不会</li><li>从编码的角度，GET请求只能进行url编码，只能接收ASCII符，而POST没有限制。</li><li>从参数的角度，GET一般在URL，因此不安全，POST放在请求体中，更适合传输敏感信息。</li><li>从幂等性的角度，GET是幂等的，而POST不是。（幂等表示执行同样的操作，结果也是相同的）</li><li>从TCP的角度，GET请求会一次性把请求报文发出去，而POST会分为两个TCP数据包，首先发送header部分，如果服务器响应100，然后发body部分。（火狐除外，它的浏览器只发送一个TCP包）</li></ul><h1 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h1><div class="note primary flat"><p>URI, 全称为(Uniform Resource Identifier), 也就是统一资源标识符，它的作用很简单，就是区分互联网上不同的资源。</p></div><p>但是，她并不是我们常说的网址，网址指的是URL，实际上URI包含了URN和URI两个部分，由于URL过于普及，就默认将URI视为URL了。</p><h2 id="URI的结构"><a href="#URI的结构" class="headerlink" title="URI的结构"></a>URI的结构</h2><p>如下：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220411221333.png" alt=""></p><ul><li><code>scheme</code>表示协议名，比如http、https、file等，特点是后面都要跟<code>://</code></li><li><code>user:passwd@</code> 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。</li><li><code>host:port</code>表示主机名和端口。</li><li><code>path</code>表示请求路径，标记资源所在位置。</li><li><code>query</code>表示查询参数，为<code>key=val</code>这种形式，多个键值对之间用&amp;隔开。</li><li><code>fragment</code>表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置。</li></ul><p>eg<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//www.baidu.com/s?wd=HTTP&amp;rsv_spt=1</span></span><br></pre></td></tr></table></figure><br>这个 URI 中，<code>https</code>即<code>scheme</code>部分，<code>www.baidu.com</code>为<code>host:port</code>部分（注意，<code>http</code> 和 <code>https</code> 的默认端口分别为80、443），<code>/s</code>为path部分，而<code>wd=HTTP&amp;rsv_spt=1</code>就是<code>query</code>部分。</p><h2 id="URI编码"><a href="#URI编码" class="headerlink" title="URI编码"></a>URI编码</h2><p>URI 只能使用ASCII, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。<br>因此，URI 引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个<code>%</code>。<br>如，空格被转义成了<code>%20</code>，三元被转义成了<code>%E4%B8%89%E5%85%83</code>。</p><h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><div class="note primary flat"><p>RFC规定HTTP的状态码为三位数，被分为五类：</p></div><ul><li>1xx：表示目前是协议处理的中间状态，还需要后续操作。</li><li>2xx：表示成功状态。</li><li>3xx：重定向状态，资源位置发生变动，需要重新请求。</li><li>4xx：请求报文有误</li><li>5xx：服务器端发生错误。<br>接下来就一一分析状态码：</li></ul><h2 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h2><p>101 Switching Protocols 在http升级为websocket的时候，如果服务器同意变更，就会发送状态码101</p><h2 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h2><p>200 OK 是见的最多的成功状态码，通常在响应体中放有数据。<br>204 No Content 含义与200相同，但响应头后没有body数据。<br>206 Partial Content顾名思义，表示部分内容，他的使用场景是为HTTP分块下载和断点续传，</p><h2 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h2><p>301 Moved Permanently永久重定向，对应302 Found 即临时重定向<br><div class="note primary flat"><p>比如你的网站升级到httos了，以前的站点不用了，应当返回301，这时候浏览器默认做缓存优化，在第二次访问的时候自动访问重定向的地址。<br>而如果只是暂时不用，那么直接返回302即可，和301不同的是，浏览器不会做缓存优化</p></div><br>304 Not Modified 当协商缓存命中时会返回这个状态码</p><h2 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h2><p>400 Bad Request 开发者看到经常一头雾水，只是笼统的提示了一下错误，并不知道哪里出错了。<br>403 Forbidden 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止，信息敏感…<br>404 Not Found 资源未找到，表示服务器上面没有这个资源。<br>405 Method Not Allow 该请求方法服务器不允许<br>406 Not Acceptable 资源无法满足客户端条件。<br>408 Request Timeout 服务器等待太久<br>409 Conflict 多个请求发生了冲突<br>413 Request Entity Too Large: 请求体的数据过大。<br>414 Request-URI Too Long: 请求行里的 URI 太大。<br>429 Too Many Request: 客户端发送的请求过多。<br>431 Request Header Fields Too Large请求头的字段内容太大。</p><h2 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h2><p>500 Internal Server Error: 仅仅告诉你服务器出错了，出了啥错咱也不知道。<br>501 Not Implemented: 表示客户端请求的功能还不支持。<br>502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。<br>503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><div class="note primary flat"><p>HTTP的特点概括如下：</p></div><ul><li>灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</li><li>可靠传输。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。</li><li>请求-应答。也就是一发一收、有来有回， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。</li><li>无状态。这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。</li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><h2 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h2><p>对需要长连接的场景来说，需要保存大量的上下文信息，以免传输大量的重复信息，这时候无状态就是缺点<br>但对于一些应用仅仅只需要获取一些数据来说，不需要保存上下文信息，无状态反而减小了网络开销</p><h2 id="明文传输"><a href="#明文传输" class="headerlink" title="明文传输"></a>明文传输</h2><p>即协议里面的报文不使用二进制数据，而是使用明文<br>对于调试来说是一种便利，但是同时也把HTTP报文信息传输给了外界，给攻击者提供了便利。WIFI陷阱就是利用HTTP明文传输的特点，诱导你连上热点，然后疯狂抓取你的流量，从而拿到你的敏感信息。</p><h2 id="队头阻塞问题"><a href="#队头阻塞问题" class="headerlink" title="队头阻塞问题"></a>队头阻塞问题</h2><p>当http开启长连接的时候，共用一个TCP连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其他的请求只能处于阻塞状态，也就是著名的队头阻塞问题，下面会有一小节讨论他。</p><h1 id="Accept系列字段"><a href="#Accept系列字段" class="headerlink" title="Accept系列字段"></a>Accept系列字段</h1><div class="note primary flat"><p>对于Accept系列字段分为四个部分，数据格式，压缩方式，支持语言和字符集</p></div><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><div class="note primary flat"><p>HTTP支持非常多的数据格式，那么这么多格式的数据一下子到客户端，客户端怎么知道他的格式呢？</p></div><p>介绍一个标准：MIME(Multipurpose Internet Mail Extensions, 多用途互联网邮件扩展)<br>他首用在电子邮件系统中，让邮件可以发送任意类型的数据，这对于HTTP来说也是通用的。<br>因此 HTTP从MIME type取了一部分来标记报文的body数据类型，这些类型体现在<code>Content-type</code>这个字段，当然这是针对于发送端而言的。接收端想要接收指定类型的数据，也可以用<code>Accept</code>字段<br>具体而言，这两个字段的取值可以分为下面几类:</p><ul><li>text： text/html, text/plain, text/css 等</li><li>image: image/gif, image/jpeg, image/png 等</li><li>audio/video: audio/mpeg, video/mp4 等</li><li>application: application/json, application/javascript, application/pdf, application/octet-stream</li></ul><h2 id="压缩方式"><a href="#压缩方式" class="headerlink" title="压缩方式"></a>压缩方式</h2><p>当然这些数据都是会进行压缩的，采用什么压缩方式在于发送方的<code>Content-Encoding</code>字段上，同样的，接收什么样的压缩方式体现在接收方的<code>Accept-Encoding</code>上，取值如下：</p><ul><li>gzip 当今最流行的压缩格式</li><li>deflate 另外一种著名的压缩格式</li><li>br 一种专门为HTTP发明的压缩算法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line">Content-Encoding: gzip</span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line">Accept-Encoding: gzip</span><br></pre></td></tr></table></figure><h2 id="支持语言"><a href="#支持语言" class="headerlink" title="支持语言"></a>支持语言</h2><p>对于发送方而言，还有一个<code>Content-Language</code>字段，在需要实现国际化的方案当中，可以用来指定支持的语言，在接受方对应的字段为<code>Accept-Language</code>。如:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line">Content-Language: zh-CN, zh, en</span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line">Accept-Language: zh-CN, zh, en</span><br></pre></td></tr></table></figure></p><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>最后是一个比较特殊的字段, 在接收端对应为<code>Accept-Charset</code>，指定可以接受的字符集，而在发送端并没有对应的<code>Content-Charset</code>, 而是直接放在了<code>Content-Type</code>中，以<code>charset</code>属性指定。如:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line">Accept-Charset: charset=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure></p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220412104403.png" alt=""></p><h1 id="对于定长和不定长的数据，HTTP-是怎么传输的？"><a href="#对于定长和不定长的数据，HTTP-是怎么传输的？" class="headerlink" title="对于定长和不定长的数据，HTTP 是怎么传输的？"></a>对于定长和不定长的数据，HTTP 是怎么传输的？</h1><h2 id="定长包体"><a href="#定长包体" class="headerlink" title="定长包体"></a>定长包体</h2><p>对于定长包体而言，发送端在传输的时候一般会带上 <code>Content-Length</code>, 来指明包体的长度。</p><p>我们用一个nodejs服务器来模拟一下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(req.url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    res.setHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>);</span><br><span class="line">    res.setHeader(<span class="string">&#x27;Content-Length&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">    res.write(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8081</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功启动&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>启动后访问: localhost:8081。</p><p>浏览器中显示如下:<br>//helloworld<br>这是长度正确的情况，那不正确的情况是如何处理的呢？</p><p>我们试着把这个长度设置的小一些:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&#x27;Content-Length&#x27;</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure><br>重启服务，再次访问，现在浏览器中内容如下:<br>//hellowor<br>那后面的ld哪里去了呢？实际上在 http 的响应体中直接被截去了。</p><p>然后我们试着将这个长度设置得大一些:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&#x27;Content-Length&#x27;</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure><br>直接无法显示了。可以看到<code>Content-Length</code>对于 http 传输过程起到了十分关键的作用，如果设置不当可以直接导致传输失败。</p><h2 id="不定长包体"><a href="#不定长包体" class="headerlink" title="不定长包体"></a>不定长包体</h2><div class="note primary flat"><p>上述是针对于定长包体，那么对于不定长包体而言是如何传输的呢？</p></div><p>这里就必须介绍另外一个 http 头部字段了:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><br>表示分块传输数据，设置这个字段后会自动产生两个效果:</p><ol><li><code>Content-Length</code> 字段会被忽略</li><li>基于长连接持续推送动态内容<br>我们依然以一个实际的例子来模拟分块传输，nodejs 程序如下:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(req.url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    res.setHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf8&#x27;</span>);</span><br><span class="line">    res.setHeader(<span class="string">&#x27;Content-Length&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">    res.setHeader(<span class="string">&#x27;Transfer-Encoding&#x27;</span>, <span class="string">&#x27;chunked&#x27;</span>);</span><br><span class="line">    res.write(<span class="string">&quot;&lt;p&gt;来啦&lt;/p&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      res.write(<span class="string">&quot;第一次传输&lt;br/&gt;&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      res.write(<span class="string">&quot;第二次传输&quot;</span>);</span><br><span class="line">      res.end()</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8009</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功启动&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220412110217.png" alt=""><br>用 telnet 抓到的响应如下:<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220412110235.png" alt=""><br>注意，Connection: keep-alive及之前的为响应行和响应头，后面的内容为响应体，这两部分用换行符隔开。</li></ol><p>响应体的结构比较有意思，如下所示:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chunk长度(<span class="number">16</span>进制的数)</span><br><span class="line">第一个chunk的内容</span><br><span class="line">chunk长度(<span class="number">16</span>进制的数)</span><br><span class="line">第二个chunk的内容</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><br>最后是留有有一个空行的，这一点请大家注意。</p><p>以上便是 http 对于定长数据和不定长数据的传输方式。</p><h1 id="HTTP-如何处理大文件的传输？"><a href="#HTTP-如何处理大文件的传输？" class="headerlink" title="HTTP 如何处理大文件的传输？"></a>HTTP 如何处理大文件的传输？</h1><div class="note primary flat"><p>对于几百 M 甚至上 G 的大文件来说，如果要一口气全部传输过来显然是不现实的，会有大量的等待时间，严重影响用户体验。因此，HTTP 针对这一场景，采取了范围请求的解决方案，允许客户端仅仅请求一个资源的一部分。</p></div><h2 id="如何支持"><a href="#如何支持" class="headerlink" title="如何支持"></a>如何支持</h2><div class="note primary flat"><p>当然，前提是服务器要支持范围请求，要支持这个功能，就必须加上这样一个响应头:</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: none</span><br></pre></td></tr></table></figure><h2 id="Range-字段拆解"><a href="#Range-字段拆解" class="headerlink" title="Range 字段拆解"></a>Range 字段拆解</h2><div class="note primary flat"><p>而对于客户端而言，它需要指定请求哪一部分，通过<code>Range</code>这个请求头字段确定，格式为<code>bytes=x-y</code>。接下来就来讨论一下这个 Range 的书写格式:</p></div><ul><li>0-499表示从开始到第 499 个字节。</li><li>500- 表示从第 500 字节到文件终点。</li><li>-100表示文件的最后100个字节。<br>服务器收到请求之后，首先验证范围是否合法，如果越界了那么返回416错误码，否则读取相应片段，返回206状态码。<br>同时，服务器需要添加<code>Content-Range</code>字段，这个字段的格式根据请求头中Range字段的不同而有所差异。<br>具体来说，请求单段数据和请求多段数据，响应头是不一样的。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单段数据</span></span><br><span class="line"><span class="attr">Range</span>: bytes=<span class="number">0</span>-<span class="number">9</span></span><br><span class="line"><span class="comment">// 多段数据</span></span><br><span class="line"><span class="attr">Range</span>: bytes=<span class="number">0</span>-<span class="number">9</span>, <span class="number">30</span>-<span class="number">39</span></span><br></pre></td></tr></table></figure>接下来我们就分别来讨论着两种情况。</li></ul><h2 id="单段数据"><a href="#单段数据" class="headerlink" title="单段数据"></a>单段数据</h2><p>对于单段数据的请求，返回的响应如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">206</span> Partial Content</span><br><span class="line">Content-Length: <span class="number">10</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Range: bytes <span class="number">0</span>-<span class="number">9</span>/<span class="number">100</span></span><br><span class="line"></span><br><span class="line">i am xxxxx</span><br></pre></td></tr></table></figure><br>值得注意的是<code>Content-Range</code>字段，0-9表示请求的返回，100表示资源的总大小，很好理解。</p><h2 id="多段数据"><a href="#多段数据" class="headerlink" title="多段数据"></a>多段数据</h2><p>接下来我们看看多段请求的情况。得到的响应会是下面这个形式:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">206</span> Partial Content</span><br><span class="line">Content-Type: multipart/byteranges; boundary=<span class="number">00000010101</span></span><br><span class="line">Content-Length: <span class="number">189</span></span><br><span class="line"><span class="attr">Connection</span>: keep-alive</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--<span class="number">00000010101</span></span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes <span class="number">0</span>-<span class="number">9</span>/<span class="number">96</span></span><br><span class="line"></span><br><span class="line">i am xxxxx</span><br><span class="line">--<span class="number">00000010101</span></span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes <span class="number">20</span>-<span class="number">29</span>/<span class="number">96</span></span><br><span class="line"></span><br><span class="line">eex jspy e</span><br><span class="line">--<span class="number">00000010101</span>--</span><br></pre></td></tr></table></figure><br>这个时候出现了一个非常关键的字段<code>Content-Type: multipart/byteranges;boundary=00000010101</code>，它代表了信息量是这样的:</p><ul><li>请求一定是多段数据请求</li><li>响应体中的分隔符是 00000010101<br>因此，在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上<code>--</code>表示结束。</li></ul><p>以上就是 http 针对大文件传输所采用的手段。</p><h1 id="HTTP-中如何处理表单数据的提交？"><a href="#HTTP-中如何处理表单数据的提交？" class="headerlink" title="HTTP 中如何处理表单数据的提交？"></a>HTTP 中如何处理表单数据的提交？</h1><p>在 http 中，有两种主要的表单提交的方式，体现在两种不同的<code>Content-Type</code>取值:</p><ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data<br>由于表单提交一般是POST请求，很少考虑GET，因此这里我们将默认提交的数据放在请求体中。</li></ul><h2 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a><code>application/x-www-form-urlencoded</code></h2><p>特点:</p><ul><li>数据会被编码为&amp;分割的键值对</li><li>字符以URL形式编码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换过程: &#123;a: 1, b: 2&#125; -&gt; a=1&amp;b=2 -&gt; 如下(最终形式)</span></span><br><span class="line"><span class="string">&quot;a%3D1%26b%3D2&quot;</span></span><br></pre></td></tr></table></figure><h2 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a><code>multipart/form-data</code></h2><ul><li>请求头中的<code>Content-Type</code>字段会包含<code>boundary</code>，且<code>boundary</code>的值有浏览器默认指定。例: <code>Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe</code>。<br>8 数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如<code>Content-Type</code>，在最后的分隔符会加上<code>--</code>表示结束。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data;name=<span class="string">&quot;data1&quot;</span>;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">data1</span><br><span class="line">----WebkitFormBoundaryRRJKeWfHPGrS4LKe</span><br><span class="line">Content-Disposition: form-data;name=<span class="string">&quot;data2&quot;</span>;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">data2</span><br><span class="line">----WebkitFormBoundaryRRJKeWfHPGrS4LKe--</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><div class="note primary flat"><p>值得一提的是，multipart/form-data 格式最大的特点在于:每一个表单元素都是独立的资源表述。另外，你可能在写业务的过程中，并没有注意到其中还有boundary的存在，如果你打开抓包工具，确实可以看到不同的表单元素被拆分开了，之所以在平时感觉不到，是以为浏览器和 HTTP 给你封装了这一系列操作。<br>而且，在实际的场景中，对于图片等文件的上传，基本采用<code>multipart/form-data</code>而不用<code>application/x-www-form-urlencoded</code>，因为没有必要做 <code>URL</code> 编码，带来巨大耗时的同时也占用了更多的空间。</p></div><h1 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h1><p>什么是队头阻塞？<br>HTTP的传输是请求应答模式的，即报文必须一发一收，但值得注意的是里面的任务被放到一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理，这就是队头阻塞问题。</p><h2 id="并发连接"><a href="#并发连接" class="headerlink" title="并发连接"></a>并发连接</h2><p>对于同一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个任务阻塞了其他所有任务。在RFC2616规定过客户端最多并发两个连接，不过事实现在的浏览器标准中，上限要高很多，比如Chrome是6个<br>但其实，即使提高了并发连接，还是不能满足人们对性能的要求。</p><h2 id="域名分片"><a href="#域名分片" class="headerlink" title="域名分片"></a>域名分片</h2><p>一个域名不是可以并发六个长连接吗？那就多分几个域名<br>比如content1.sanyuan.com 、content2.sanyuan.com。<br>这样一个<code>sanyuan.com</code>域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>简介<br>我们知道HTTP是无状态的协议，每次HTTP请求都是独立，无关的，默认不需要保留任何信息，但有时候要保存一些状态。所以就诞生了Cookie<br>本质是浏览器里存储的一个很小的文本文件，内部以键值对的方式来存储。想同一个域名发送请求，都会携带相同的Cookie，服务器拿到Cookie进行解析，便能拿到客户端的状态，而服务端就可以通过响应头中的<code>Set-Cookie</code>字段来给客户端写入Cookie。<br>eg<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求头</span></span><br><span class="line"><span class="attr">Cookie</span>: a=xxx;b=xxx</span><br><span class="line"><span class="comment">// 响应头</span></span><br><span class="line"><span class="built_in">Set</span>-Cookie: a=xxx</span><br><span class="line">set-Cookie: b=xxx</span><br></pre></td></tr></table></figure></p><h2 id="Cookie属性"><a href="#Cookie属性" class="headerlink" title="Cookie属性"></a>Cookie属性</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>设置有效期用以下两个属性</p><ul><li>Expires过期时间</li><li>Max-Age用的是一段时间间隔，单位是s，从浏览器收到报文开始计算。<br>若Cookie过期，则Cookie会被删除并不会发送给服务端。</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>两个属性</p><ul><li>Domain域名</li><li>Path路径<br>在发送请求之前，发现域名和路径两者不匹配，则不会带上Cookie。值得注意的是，对于路径来说，<code>/</code>表示域名下的任意路径都允许使用Cookie</li></ul><h3 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h3><p>如果带上Secure。说明只能通过HTTPS传输Cookie<br>如果带上HttpOnly，说明只能通过HTTP协议传输，不能通过JS访问，这也是预防XSS攻击的重要手段。<br>对应的，对于CSRF攻击的预防，也有SameSite属性。<br>三个值 <code>Strict</code>,<code>Lax</code>,<code>None</code></p><ul><li>在strict模式下，浏览器完全禁止第三方请求携带Cookie，比如请求<code>aaa.com</code>的网站只能在<code>aaa.com</code>的域名当中请求才能携带Cookie，在其他网站请求都不行。</li><li>在lax模式下，就宽松一点，但是只能在GET方法提交表单或者a标签发送get请求的情况下可以携带Cookie，其他情况都不能。</li><li>在None，也就是默认模式下，请求会自动携带上Cookie</li></ul><h2 id="Cookie的缺点"><a href="#Cookie的缺点" class="headerlink" title="Cookie的缺点"></a>Cookie的缺点</h2><ol><li>容量缺陷 4kb</li><li>性能缺陷，cookie紧跟域名，不管域名下面某个地址需不需要这个cookie，都会携带上完整的cookie，这样随着请求的增多，会造成巨大的性能浪费，但是可以通过domain和path来指定作用域解决。</li><li>安全缺陷，cookie是以纯文本的形式存储在浏览器中的，很容易被用户非法获取，然后进行一系列的篡改，在cookie有效期内发给服务器，这是很危险的。另外，在httponly为false的情况下，cookie信息能直接通过js脚本获取。</li></ol><h1 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h1><p>我们知道在HTTP是基于请求响应模型的协议，一般由客户端请求，服务器来进行响应。<br>当然也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应。而对于源服务器，表现为客户端发起请求，具有双重身份，那代理服务器是用来做什么的呢？</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>负载均衡。客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP都是多少，客户端是不知道的。因此这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各个源服务器的负载尽量平均。当然这样的算法有很多，包括随机算法，轮询，一致性，hash，LRU等等，不过这些算法并不是重点。</li><li>保障安全。利用心跳机制监控后台的服务器，一旦发现故障就将其踢出集群。并且对于上下行的数据进行过滤，对非法IP限流，这些都是代理服务器的工作。</li><li>缓存代理。将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里，下一节详细拆解。</li></ol><h2 id="相关头部字段"><a href="#相关头部字段" class="headerlink" title="相关头部字段"></a>相关头部字段</h2><h3 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h3><p>代理服务器需要表明自己的身份，在HTTP传输中留下自己的痕迹，怎么办？<br>通过Via字段来记录，举个例子，现在中间有两台代理服务器，在客户端发送请求后会经历这样一个过程：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 -&gt; 代理<span class="number">1</span> -&gt; 代理<span class="number">2</span> -&gt; 源服务器</span><br></pre></td></tr></table></figure><br>在源服务器收到请求之后，会在请求头拿到这个字段<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Via: proxy_server1, proxy_server2</span><br></pre></td></tr></table></figure><br>可以看到Via的代理顺序即为在HTTP传输中报文传达的顺序。</p><h3 id="X-Forwarded-For"><a href="#X-Forwarded-For" class="headerlink" title="X-Forwarded-For"></a>X-Forwarded-For</h3><p>字面意思就是为谁转发，它记录的是请求方的IP地址，注意和Via区分开，它记录的是请求方的。</p><h3 id="X-Real-IP"><a href="#X-Real-IP" class="headerlink" title="X-Real-IP"></a>X-Real-IP</h3><p>是一种获取用户真实IP的字段，不管中间经过多少代理，这个字段始终记录最初客户端的IP。<br>相应的，还有<code>X-Forwarded-Host</code>和<code>X-Forwarded-Proto</code>，分别记录着客户端的域名和协议名</p><h3 id="X-Forwarded-For产生的问题"><a href="#X-Forwarded-For产生的问题" class="headerlink" title="X-Forwarded-For产生的问题"></a>X-Forwarded-For产生的问题</h3><p>这个字段记录的是请求方的IP，所以说每次经过代理它都会发生改变。<br>所以产生了一下两个问题</p><ol><li>意味着代理必须解析HTTP请求头，然后修改，比直接转发数据性能下降。</li><li>在HTTPS通信加密的过程中，原始报文是不允许被修改的。<br>由此产生了代理协议，一般使用明文版本，只需要在HTTP请求行上加上这样格式的文本即可。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口</span></span><br><span class="line">PROXY TCP4 <span class="number">0.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.2</span> <span class="number">1111</span> <span class="number">2222</span></span><br><span class="line">GET / HTTP/<span class="number">1.1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>就可以解决<code>X-Forwarded-For</code>带来的问题了。</li></ol><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><div class="note primary flat"><p>浏览器缓存分为强缓存和协商缓存，当客户端请求某个资源的时候，获取缓存的流程如下：</p></div><ul><li>先根据这个资源的一些<code>http header</code>判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发送请求到服务器。</li><li>当强缓存没有命中的时候，客户端会发送请求到服务器，服务器通过一些<code>request header</code>验证这个资源是否命中协商缓存，称为<code>http</code>再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源。</li><li>强缓存和协商缓存的共同之处在于，如果命中缓存，服务器都不会返回资源；区别是，强缓存不会发送请求到服务器，协商缓存会。</li><li>当协商缓存也没有命中的时候，服务器将资源发送到客户端。</li><li>当<code>ctrl+f5</code>强制刷新网页的时候，直接从服务器加载，则跳过强缓存和协商缓存。</li><li>当F5刷新网页的时候，跳过强缓存，但是会检查协商缓存。</li></ul><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><div class="note primary flat"><p>强缓存的两种方式如下：</p></div><ul><li><code>Expires</code>(该字段是http1.0时的规范，值为一个绝对是件绝对时间的GMT格式的时间字符串，代表缓存资源的过期时间)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, <span class="number">22</span> Oct <span class="number">2018</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure><ul><li><code>Cache-Control:max-age</code>该字段是http1.1的规范，强缓存利用其<code>max-age</code>值来判断缓存资源的最大声明周期，它的值单位为秒。</li><li><code>private</code>：客户端可以缓存</li><li><code>public</code>：客户端和代理服务器都可以缓存</li><li><code>max-age=t</code>：缓存内容将在t秒后失效</li><li><code>no-cache</code>：需要使用协商缓存来验证缓存数据</li><li><code>no-store</code>：所有内容都不会缓存<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-control: max-age=<span class="number">30</span></span><br></pre></td></tr></table></figure></li></ul><div class="note warning flat"><p>强缓存表示在缓存存在的期间不需要请求，会返回状态码200<br><code>Expires</code>受限于本地时间，如果修改了本地时间，可能导致缓存失效。<br><code>Cache-Control:max-age</code>优先级高于<code>Expires</code></p></div><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><div class="note primary flat"><p>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回304<br>协商缓存也有两种方式：<code>Last-Modified</code>,<code>If-Modified-Since</code></p></div><ul><li><code>Last-Modified</code>值为资源最后更新时间。</li><li><code>If-Modified-Since</code>会将<code>Last-Modified</code>的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就把新的资源发送过来，否则命中协商缓存。<div class="note warning flat"><p>但是如果在本地打开缓存文件，就会造成<code>Last-Modified</code>被修改，所以http1.1出现了<code>ETag</code>和<code>If-None-Match</code></p></div></li><li><code>ETag</code>类似于文件指纹，表示资源的唯一性。</li><li><code>If-None-Match</code>会将当前的<code>Etag</code>发送给服务器，询问服务器该资源的<code>Etag</code>是否有变动，如果有变动则发送新的资源回来，如果没有修改则命中协商缓存。且注意<code>Etag</code>的优先级大于<code>Last-Modified</code></li></ul><h2 id="选择合适的缓存策略"><a href="#选择合适的缓存策略" class="headerlink" title="选择合适的缓存策略"></a>选择合适的缓存策略</h2><div class="note primary flat"><p>对于大部分场景可以使用强缓存配合协商缓存解决问题。但在一些特殊的情况下选择特殊的缓存策略更为重要。</p></div><ul><li>对于某些不需要缓存的资源，可以使用<code>Cache-control:no-store</code>表示该资源不需要缓存。</li><li>对于频繁变动的资源，可以使用<code>Cache-Control:no-cache</code>配合<code>Etag</code>使用，表示该资源已被缓存，但是每次都会发送请求询问该资源是否更新。</li><li>对于代码文件来说，通常使用<code>Cache-Control:max-age=31536000</code>并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会下载新的文件。</li></ul><h2 id="缓存新鲜度"><a href="#缓存新鲜度" class="headerlink" title="缓存新鲜度"></a>缓存新鲜度</h2><div class="note primary flat"><p>缓存新鲜度 = <code>max-age || (expires - date)</code></p></div><ul><li>date表示创建报文的时间，可以理解为服务器返回新资源的时间。</li><li>过期时间-创建时间就能计算缓存时间。默认转为秒</li></ul><h2 id="启发式缓存"><a href="#启发式缓存" class="headerlink" title="启发式缓存"></a>启发式缓存</h2><p>我们上述已经知道强缓存的新鲜度公式了，那么如果此时没有<code>max-age</code>,<code>expires</code>这两个关键字的时候，新鲜度怎么计算呢？<br>此时没有了强缓存的必要字段，但服务器还是会走强缓存<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date: Thu, 02 Sep 2021 13:28:56 GMT</span><br><span class="line">age: 10467792</span><br><span class="line">cache-control: public</span><br><span class="line">last-modified: Mon, 26 Apr 2021 09:56:06 GMT</span><br></pre></td></tr></table></figure><br>浏览器会触发启发式缓存，公式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缓存新鲜度 = max(<span class="number">0</span>,（date - last-modified)) * <span class="number">10</span>%</span><br></pre></td></tr></table></figure><br>根据响应报头中 date 与 last-modified 值之差与 0 取最大值后取其值的百分之十作为缓存时间。</p><h2 id="Last-Modified弊端"><a href="#Last-Modified弊端" class="headerlink" title="Last-Modified弊端"></a><code>Last-Modified</code>弊端</h2><div class="note primary flat"><p>它是一个时间，最小单位是秒，但如果资源修改得非常快，快到毫秒级别，那么服务器就无法识别，导致浏览器资源没有即使更新。<br>二 当服务器资源被修改了 但实质上的东西并没有改变 此时也会发送最新的<code>Last-Modified</code>，但我们不希望它这样做。<br>于是就产生了<code>Etag</code></p></div><h1 id="HTTP-缓存及缓存代理？"><a href="#HTTP-缓存及缓存代理？" class="headerlink" title="HTTP 缓存及缓存代理？"></a>HTTP 缓存及缓存代理？</h1><p>强缓存和协商缓存<br>首先通过 <code>Cache-Control</code> 验证强缓存是否可用<br>如果强缓存可用，直接使用<br>否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的<code>If-Modified-Since</code>或者<code>If-None-Matc</code>h这些条件请求字段检查资源是否更新<br>若资源更新，返回资源和200状态码<br>否则，返回304，告诉浏览器直接从缓存获取资源<br>这一节我们主要来说说另外一种缓存方式: 代理缓存。</p><h2 id="为什么产生代理缓存"><a href="#为什么产生代理缓存" class="headerlink" title="为什么产生代理缓存"></a>为什么产生代理缓存</h2><p>对于源服务器来说，他也是有缓存的，比如Redis，Memcache，但对于HTTP缓存来说，如果每次客户端缓存失效都要到源服务器获取，那么源服务器的压力是非常大的。<br>由此引入了缓存代理机制，让代理服务器承担一部分HTTP缓存，客户端缓存过期之后就到就近的代理服务器上面获取，代理缓存过期了才请求源服务器，这样流量巨大的时候才能明显降低源服务器的压力。<br>那缓存代理是如何做到的呢？<br>总的来说，代理缓存分为两个部分，一部分是源服务器端的控制，一部分是客户端的控制。</p><h2 id="源服务器的缓存控制"><a href="#源服务器的缓存控制" class="headerlink" title="源服务器的缓存控制"></a>源服务器的缓存控制</h2><h3 id="private和public"><a href="#private和public" class="headerlink" title="private和public"></a>private和public</h3><p>在源服务器的响应头中，在<code>Cache-Control</code>这个字段中可以加入private或者public是否允许代理服务器进行缓存，前者禁止，后者允许。<br>比如一些比较敏感的数据，就不要缓存到代理服务器了，这样别人访问代理服务器就能获取了，这部分就private设置。</p><h3 id="proxy-revalidate"><a href="#proxy-revalidate" class="headerlink" title="proxy-revalidate"></a>proxy-revalidate</h3><p><code>must-revalidate</code>的意思是客户端缓存过期就直接到源服务器获取，<code>proxy-revalidate</code>表示客户端缓存过期到代理服务器获取。</p><h3 id="s-maxage"><a href="#s-maxage" class="headerlink" title="s-maxage"></a>s-maxage</h3><p>s是share的意思，限制了缓存在代理服务器中可以存放多久，和限制客户端缓存时间的max-age并不冲突<br>eg<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public, max-age=<span class="number">1000</span>, s-maxage=<span class="number">2000</span></span><br></pre></td></tr></table></figure><br>这个响应是允许代理服务器缓存的，在本地缓存的时间是1000s，在代理服务器的缓存时间是2000s</p><h2 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h2><h3 id="max-stale和min-fresh"><a href="#max-stale和min-fresh" class="headerlink" title="max-stale和min-fresh"></a>max-stale和min-fresh</h3><p>在客户端的请求头中，可以加入这两个字段，来对代理服务器上的缓存进行宽容和限制操作。<br>比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max-stale = <span class="number">5</span></span><br></pre></td></tr></table></figure><br>表示客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也没关系，只要在过期的五秒内还是可以从代理缓存中获取的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min-fresh = <span class="number">5</span></span><br></pre></td></tr></table></figure><br>表示代理缓存需要一定的新鲜度，不要等缓存刚好过期才去拿，一定要在到期的前5s内拿，否则拿不到。</p><h3 id="only-if-cached"><a href="#only-if-cached" class="headerlink" title="only-if-cached"></a>only-if-cached</h3><p>这个字段加上后表示客户端只会接收代理缓存，而不会接收源服务器的缓存。如果代理缓存无效直接返回504（Gateway Timeout）</p><h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>回顾一下url的组成<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220412195102.png" alt=""><br>违背同源策略（协议scheme，主机host，端口port三者一致）即为跨域<br>非同源有以下限制：</p><ul><li>不能读取和修改对方的DOM</li><li>不能访问对方的Cookie，indexDB和LocalStorage</li><li>限制XMLHttpRequest请求。<br>当浏览器向目标URI发送AJAX请求的时候，如果当前URL和目标URL不同源，则产生跨域，这就是跨域请求。</li></ul><p>跨域请求的响应一般会被浏览器拦截，注意：是被浏览器拦截，响应其实是已经发送到客户端了，那么这个拦截是如何发生的呢？</p><p>首先要知道浏览器是多进程的，以Chrome为例子，进程组成如下：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220412195516.png" alt=""><br>以下内容是CV<br>WebKit 渲染引擎和V8 引擎都在渲染进程当中。<br>当<code>xhr.send</code>被调用，即<code>Ajax</code>请求准备发送的时候，其实还只是在渲染进程的处理。为了防止黑客通过脚本触碰到系统资源，浏览器将每一个渲染进程装进了沙箱，并且为了防止 CPU 芯片一直存在的Spectre 和 Meltdown漏洞，采取了站点隔离的手段，给每一个不同的站点(一级域名不同)分配了沙箱，互不干扰。具体见YouTube上Chromium安全团队的演讲视频。<br>在沙箱当中的渲染进程是没有办法发送网络请求的，那怎么办？只能通过网络进程来发送。那这样就涉及到进程间通信(IPC，Inter Process Communication)了。接下来我们看看 chromium 当中进程间通信是如何完成的，在 chromium 源码中调用顺序如下:<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220412195744.png" alt=""><br>可能看了你会比较懵，如果想深入了解可以去看看 <code>chromiu</code> 最新的源代码，<code>IPC</code>源码地址及<code>Chromium IPC</code>源码解析文章。<br>总的来说就是利用<code>Unix Domain Socket</code>套接字，配合事件驱动的高性能网络并发库<code>libevent</code>完成进程的 IPC 过程。<br>好，现在数据传递给了浏览器主进程，主进程接收到后，才真正地发出相应的网络请求。<br>在服务端处理完数据后，将响应返回，主进程检查到跨域，且没有cors(后面会详细说)响应头，将响应体全部丢掉，并不会发送给渲染进程。这就达到了拦截数据的目的。<br>接下来我们来说一说解决跨域问题的几种方案。</p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS是W3C规定的一个标准，全称是跨域资源共享，他需要浏览器和服务器的共同支持，具体来说，非 IE 和 IE10 以上支持CORS，服务器需要附加特定的响应头，后面具体拆解。不过在弄清楚 CORS 的原理之前，我们需要清楚两个概念: 简单请求和非简单请求。</p><p>浏览器根据请求方法和请求头的特定字段，将请求做了个分类，具体来说规则是这样的，凡是满足以下条件的为简单请求：</p><ul><li>请求方法为GET POST 或者HEAD</li><li>请求头的取值范围为：Accept，Accept-Language，Content-Language，Content-Type（仅限三个值：<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>）<br>除此之外的就是非简单请求.<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><div class="note primary flat"><p>请求发出去之前，浏览器在做什么？</p></div>他会自动在请求头中，添加一个Origin字段，用来说明请求来自哪个源。服务器拿到请求之后，在回应时对应的添加<code>Access-Control-Allow-Origin</code>字段，如果Origin不在这个字段的范围内，浏览器就会将响应拦截。<br>因此<code>Access-Control-Allow-Origin</code>字段是服务器用来决定浏览器是否拦截这个响应，这是必须的字段。与此同时，其他一些可选的功能性字段，用来描述如果不会被拦截，这些字段将发挥各自的作用。</li></ul><p><code>Access-Control-Allow-Credentials</code>这个字段是一个布尔值，表示是否允许发送Cookie，对于跨域请求，浏览器对这个字段的默认值设为false，而如果需要拿到浏览器的Cookie，需要添加这个响应头并且设置为true，并且前端也需要设置<code>withCredentials</code>属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><br><code>Access-Control-Expose-Headers</code>这个字段是给XMLHttpRequest对象赋能，让它不仅能拿到基本的六个响应头字段，包括<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>和<code>Pragma</code>）, 还能拿到这个字段声明的响应头字段。比如这样设置:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Expose-Headers: aaa</span><br></pre></td></tr></table></figure><br>那么前端就能通过<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest.getResponseHeader(<span class="string">&#x27;aaa&#x27;</span>) </span><br></pre></td></tr></table></figure><br>拿到该字段的值。</p><h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>非简单请求相对而言会有些不同，体现在两个方面，预检请求和响应字段。<br>以PUT方法为例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://xxx.com&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;PUT&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;X-Custom-Header&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><br>当这段代码执行的时候会发送预检请求，这个预检请求的请求行和请求体如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS / HTTP/<span class="number">1.1</span></span><br><span class="line"><span class="attr">Origin</span>: 当前地址</span><br><span class="line"><span class="attr">Host</span>: xxx.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br></pre></td></tr></table></figure><br>预检请求的方法是OPTIONS，同时会加上Origin源地址和Host目标地址，这很简单。同时也会加上两个关键的字段:</p><ul><li>Access-Control-Request-Method, 列出 CORS 请求用到哪个HTTP方法</li><li><p>Access-Control-Request-Headers，指定 CORS 请求将要加上什么请求头<br>这是预检请求。接下来是响应字段，响应字段也分为两部分，一部分是对于预检请求的响应，一部分是对于 CORS 请求的响应。<br>预检请求的响应。如下面的格式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Max-Age: <span class="number">1728000</span></span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>其中有这样几个关键的响应头字段:</p></li><li><p>Access-Control-Allow-Origin: 表示可以允许请求的源，可以填具体的源名，也可以填*表示允许任意源请求。</p></li><li>Access-Control-Allow-Methods: 表示允许的请求方法列表。</li><li>Access-Control-Allow-Credentials: 简单请求中已经介绍。</li><li>Access-Control-Allow-Headers: 表示允许发送的请求头字段</li><li>Access-Control-Max-Age: 预检请求的有效期，在此期间，不用发出另外一条预检请求。</li></ul><p>在预检请求的响应返回后，如果请求不满足响应头的条件，则触发XMLHttpRequest的onerror方法，当然后面真正的CORS请求也不会发出去了。<br>CORS 请求的响应。绕了这么一大转，到了真正的 CORS 请求就容易多了，现在它和简单请求的情况是一样的。浏览器自动加上Origin字段，服务端响应头返回Access-Control-Allow-Origin。可以参考以上简单请求部分的内容。</p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>虽然XMLHttpRequest对象遵循同源政策，但是script标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。这也就是 JSONP 的原理，接下来我们就来封装一个 JSONP:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsonp = <span class="function">(<span class="params">&#123; url, params, callbackName &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> generateURL = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dataStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      dataStr += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>&amp;`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dataStr += <span class="string">`callback=<span class="subst">$&#123;callbackName&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;dataStr&#125;</span>`</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化回调函数名称</span></span><br><span class="line">    callbackName = callbackName || <span class="built_in">Math</span>.random().toString.replace(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;&#x27;</span>); </span><br><span class="line">    <span class="comment">// 创建 script 元素并加入到当前文档中</span></span><br><span class="line">    <span class="keyword">let</span> scriptEle = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    scriptEle.src = generateURL();</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(scriptEle);</span><br><span class="line">    <span class="comment">// 绑定到 window 上，为了后面调用</span></span><br><span class="line">    <span class="built_in">window</span>[callbackName] = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(data);</span><br><span class="line">      <span class="comment">// script 执行完了，成为无用元素，需要清除</span></span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(scriptEle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当然在服务端也会有响应的操作, 以 express 为例:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; a, b, callback &#125; = req.query</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line">  <span class="comment">// 注意哦，返回给script标签，浏览器直接把这部分字符串执行</span></span><br><span class="line">  res.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;数据包&#x27;)`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><br>前端这样简单地调用一下就好了:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jsonp(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123; </span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 拿到数据进行处理</span></span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// 数据包</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>和CORS相比，JSONP 最大的优势在于兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。</p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx是一种高效的反向代理服务器，可以用来轻松解决跨域问题。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220412223038.png" alt=""><br>下面关于正向代理和反向代理的区别<br>正向代理：帮助客户端访问自己访问不到的服务器，然后将结果返回给客户端。<br>反向代理：拿到客户端的请求，将请求转发给其他服务器，主要的场景是维持服务器集群的负载均衡，换句话说，反向代理帮其他服务器拿到请求，然后选择一个合适的服务器转发给他。<br>因此两者的区别就很明显了，正向代理是帮客户端做事情，反向代理是帮其他服务器做事情。<br>那么Nginx是如何解决跨域的呢？<br>比如说现在客户端的域名为<code>client.com</code>，服务器的域名为<code>server.com</code>，客户端向服务器发送 Ajax 请求，当然会跨域了，那这个时候让 Nginx 登场了，通过下面这个配置:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen  <span class="number">80</span>;</span><br><span class="line">  server_name  client.com;</span><br><span class="line">  location /api &#123;</span><br><span class="line">    proxy_pass server.com;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Nginx 相当于起了一个跳板机，这个跳板机的域名也是<code>client.com</code>，让客户端首先访问 <code>client.com/api</code>，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给<code>server.com</code>，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。<br>其实还有一些不太常用的方式，大家了解即可，比如<code>postMessage</code>，当然<code>WebSocket</code>也是一种方式，但是已经不属于 HTTP 的范畴，另外一些奇技淫巧就不建议大家去死记硬背了，一方面从来不用，名字都难得记住，另一方面临时背下来，面试官也不会对你印象加分，因为看得出来是背的。当然没有背并不代表减分，把跨域原理和前面三种主要的跨域方式理解清楚，经得起更深一步的推敲，反而会让别人觉得你是一个靠谱的人。</p><h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><h2 id="和http的区别："><a href="#和http的区别：" class="headerlink" title="和http的区别："></a>和http的区别：</h2><div class="note primary flat"><ol><li>https协议需要ca证书 费用比较高</li><li>http的信息是明文传输，https是经过ssl协议加密传输的</li><li>端口不同 一般来讲http是80端口 https是443端口</li></ol></div><h2 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h2><div class="note primary flat"><p>通信不容易收到拦截，ssl是tls的前身，现在绝大部分的浏览器不支持ssl而是支持tls，但是ssl的名气很大，所以人们经常会说ssl。</p></div><p>SSL安全套接层(Secure Socket Layer),在OSI七层模型中处于会话层(第五层)。之前SSL出过三个大版本，当他发展到第三个大版本的时候才被标准化，成为TLS(传输层安全，Transport Layer Security)并被当作TLS1.0版本，准确的说TLS1.0 = SSL3.1</p><p>现在的主流版本是TLS/1.2,之前的TLS1.0，1.1都被认为是不安全的，在不久的将来会被完全淘汰，因此我们下面要讨论的是TLS/1.2</p><h3 id="传统RSA握手"><a href="#传统RSA握手" class="headerlink" title="传统RSA握手"></a>传统RSA握手</h3><h3 id="TLS1-2握手"><a href="#TLS1-2握手" class="headerlink" title="TLS1.2握手"></a>TLS1.2握手</h3><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413091420.png" alt=""></p><h4 id="step1：Client-Hello"><a href="#step1：Client-Hello" class="headerlink" title="step1：Client Hello"></a>step1：Client Hello</h4><p>首先浏览器发送client_random,TLS版本，加密套件列表。</p><p>client_random是什么？用来形成最终secret的一个参数</p><p>加密套件列表是什么？eg<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TLS_ECDHE_WITH_AES_128_GCM_SHA256</span><br></pre></td></tr></table></figure></p><p>意思是在TLS握手的过程中，使用ECDHE算法pre_random,128位的AES算法进行对称加密，在对称加密的过程中使用主流的GCM分组模式，因为对称加密中很重要的一个问题就是如何分组，最后一个是采用哈希摘要算法，采用SHA256算法。</p><p>其中值得解释的是这个哈希摘要算法，试想一下这个场景，服务端现在给客户端发信息来了，而客户端不知道此时的消息是服务端的还是中间人的，现在引入这个哈希摘要算法，将服务端的证书信息通过这个算法生成一个摘要，用来标识这个服务器的身份，然后用CA私钥加密后把加密后的标识和CA公钥发给客户端。客户端拿到这个CA公钥来解密，生成另外一份摘要。两个摘要进行对比，如果相同则能确认服务器的身份。这也就是所谓数字签名的原理。其中除了哈希摘要算法，最重要的是私钥加密，公钥解密。</p><h4 id="step2-Server-Hello"><a href="#step2-Server-Hello" class="headerlink" title="step2 Server Hello"></a>step2 Server Hello</h4><p>server_random发送这个随机数，确认TLS版本，需要使用的加密套件和自己的证书，那么这个server_params是做什么的呢？</p><h4 id="step3-Client验证证书，生成secret"><a href="#step3-Client验证证书，生成secret" class="headerlink" title="step3 Client验证证书，生成secret"></a>step3 Client验证证书，生成secret</h4><p>客户端验证服务器传过来的证书和签名是否通过，如果验证通过，则将client_params传递给服务器。</p><p>接着客户端通过ECDHE算法计算出了pre_random,其中传入两个参数：server_params和client_params。现在你应该清楚这两个参数的作用了吧，由于ECDHE算法是基于椭圆曲线离散对数，这两个参数也称作椭圆曲线的公钥。</p><p>客户端现在拥有了client_random,server_random和pre_random,接下来这三个数通过一个伪随机数函数计算出最终的secret</p><h4 id="step4-Server生成secret"><a href="#step4-Server生成secret" class="headerlink" title="step4 Server生成secret"></a>step4 Server生成secret</h4><p>客户端传了client_params过来了，服务端开始用ECDHE算法生成pre_random,接着用和客户端同样的伪随机函数生成最后的secret</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><div class="note primary flat"><p>TLS握手实际上是一个双向认证的过程，从step1可以看出客户端有能力验证服务器的身份（数字签名），那么服务器能不能验证客户端的身份呢？</p></div><p>当然是可以的。具体来说，在step3中，客户端发送client_params,实际上是给服务器一个验证消息，让服务器走相同的流程（哈希摘要，私钥加密，公钥解密），确认客户端的身份</p><div class="note primary flat"><p>在客户端生成secret后，会给服务器发送一个收尾的信息，告诉服务器之后都要用对称加密，对称加密的算法就是用第一次约定的，服务器生成完secret后也会向客户端发送一个收尾信息，告诉客户端以后用对称加密来通信。</p></div><p>这个收尾信息包括两个部分，一部分是<code>Change Cipher Spec</code>,意味着后面加密传输了，另外一个是Finished消息，这个消息是对之前发送的所有数据做的摘要，对摘要进行加密，让对方验证一下。</p><p>当双方都验证通过之后，握手才正式结束，后面的HTTP正式开始传输加密报文。</p><h4 id="RSA和ECDHE有什么区别？"><a href="#RSA和ECDHE有什么区别？" class="headerlink" title="RSA和ECDHE有什么区别？"></a>RSA和ECDHE有什么区别？</h4><ol><li>ECDHE握手，也就是主流的TLS1.2握手，使用ECHDE算法实现pre_random的加密解密，没有用到RSA</li><li>使用ECDHE还有一个特点，就是客户端发送完收尾信息后可以提前抢跑，直接发送HTTP报文，节省一个RTT，不必等到收尾信息到到服务器，然后等服务器返回收尾信息告诉自己，直接开始发送请求，这也叫TLS False Start<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3>数字签名是公钥加一些个人信息用哈希算法生成摘要之后，再用私钥加密生成的东西。<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3>数字证书应用了数字签名的技术，将个人信息和公钥用哈希算法生成摘要之后，再用CA的私钥加密，这整个就是数字证书。<h3 id="TLS1-3做了什么改进？"><a href="#TLS1-3做了什么改进？" class="headerlink" title="TLS1.3做了什么改进？"></a>TLS1.3做了什么改进？</h3>TLS 1.2 虽然存在了 10 多年，经历了无数的考验，但历史的车轮总是不断向前的，为了获得更强的安全、更优秀的性能，在2018年就推出了 TLS1.3，对于TLS1.2做了一系列的改进，主要分为这几个部分:强化安全、提高性能。</li></ol><h4 id="强化安全"><a href="#强化安全" class="headerlink" title="强化安全"></a>强化安全</h4><p>TLS1.3废除了很多加密算法，最后只保留了五个加密套件。</p><ul><li>TLS_AES_128_GCM_SHA256</li><li>TLS_AES_256_GCM_SHA384</li><li>TLS_CHACHA20_POLY1305_SHA256</li><li>TLS_AES_128_GCM_SHA256</li><li>TLS_AES_128_GCM_8_SHA256</li></ul><p>可以看到，最后剩下的对称加密算法是AES和CHACHA20，之前主流的也会这两种。分组模式也只剩GCM和POLY1305，哈希摘要算法只剩下SHA256和SHA384了</p><p>那你可能会问了，之前RSA这么重要的非对称加密算法怎么不在了？</p><p>两方面原因：</p><ol><li>2015年发现了FREAK攻击，就是说有人发现了RSA漏洞，能够进行破解了。</li><li>一旦私钥泄漏，那么中间人可以通过私钥计算出之前所有的报文secret，破解之前所有的密文。</li></ol><p>为什么？回到RSA握手的过程中，客户端拿到服务器的证书后，提取出服务器的公钥，然后生成pre_random并用公钥加密传送给服务器，服务器通过私钥解密，从而拿到真实的pre_random。当中间人拿到了服务器的私钥，并且截获之前的所有报文的时候， 那么就能拿到pre_random,server_random和client_random并根据对应的随机数函数生成secret，也就是拿到了TLS的最终会话密钥，每一个历史报文都能通过这样的方式破解。</p><p>但ECDHE在每次握手的时候都生成临时性的密钥对，即使私钥被破解，之前的历史信息也不会收到影响。这种一次性破解并不影响历史信息的性质也叫前向安全性</p><p>RSA算法不具备前向安全性，所以被ECDHE取代了。</p><h4 id="提升性能"><a href="#提升性能" class="headerlink" title="提升性能"></a>提升性能</h4><h5 id="握手改进"><a href="#握手改进" class="headerlink" title="握手改进"></a>握手改进</h5><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413095834.png" alt=""><br>大体上看和TLS1.2差不多，不过和TLS1.2相比少了一个RTT，服务器不需要在等待对方证书验证完毕之后再拿到client_params,而是直接在第一次握手的时候就能拿到，拿到之后立刻计算出secret，节省了之前不必要的等待时间。同时也意味着第一次握手的时候客户端需要传送更多的消息，一口气传完。</p><p>这种TLS1.3的握手方式也被称为1-RTT握手，但其实这种握手方式还是有一定的优化空间的，接下里介绍这种优化方式。</p><h5 id="会话复用"><a href="#会话复用" class="headerlink" title="会话复用"></a>会话复用</h5><div class="note primary flat"><p>会话复用有两种方式：Session ID和Session Ticket</p></div><p>先说说最早出现的Session ID，具体做法是客户端和服务端连接的时候会保存各自的会话ID，并存储会话密钥，当再次连接的时候，客户端发送ID过来，服务器查找这个ID是否存在，如果找到了就直接复用之前的会话状态，会话密钥就不用重新生成，直接用原来的那个部分。</p><p>但这个方式也存在一定的弊端，就是当客户端数量庞大的时候，对服务端的存储压力非常大。</p><p>因此出现了第二种方式—Session Ticket，服务端压力大那就给客户端保存呗。具体来说，双方连接成功后，服务器加密会话信息，用Session Ticket消息发送给客户端，让客户端保存下来。下次重连的时候，就把这个ticket进行解密，验证它有没有过期，如果没过期就恢复之前的会话状态。</p><p>这种方式虽然减小了服务器的压力，但是带来了安全问题，即每次用一个固定的密钥来解密ticket数据，一旦黑客拿到这个密钥，之前所有的历史记录也会被破解了。因此为了避免这样的问题，密钥需要定期更换。</p><p>总的来说，这些会话复用的技术在保证1-RTT的时候，也节省了生成会话密钥这些算法所消耗的时间，是一笔客观的性能提升。</p><h5 id="PSK"><a href="#PSK" class="headerlink" title="PSK"></a>PSK</h5><p>刚刚说的是1-RTT的情况，能不能优化到0-RTT呢？</p><p>答案是可以的，方法也很简单，在发送Session Ticket的同时带上数据，不用等服务器确认，这种方式被称为<code>Pre-Shared Key</code>即PSK。</p><p>这种方法虽然方便，但是也带来了安全问题，中间人截获PSK数据，不断向服务器重复发，类似于TCP第一次握手携带数据，增加了服务器被攻击的风险。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>TLS1.3在1.2的基础上废除了大量的算法，提升了安全性，同时利用会话复用节省了重新生成密钥的时间，利用PSK做到了0-RTT连接。</p><h2 id="客户端是如何对比数字签名？"><a href="#客户端是如何对比数字签名？" class="headerlink" title="客户端是如何对比数字签名？"></a>客户端是如何对比数字签名？</h2><ul><li>浏览器会安装一些比较权威的第三方认证机构的公钥，比如VeriSign、Symantec以及GlobalSign等等</li><li>验证数字签名的时候，直接从本地拿到第三方公钥，对私钥加密后的数字签名进行解密得到真正的签名。</li><li>然后客户端利用签名生成规则进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。</li></ul><h2 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h2><div class="note primary flat"><p>https就是利用上面的对称加密和非对称加密进行一个混合加密。兼顾了对称加密传输快和非对称消耗资源大的问题。</p></div><h2 id="如何把http请求换成https"><a href="#如何把http请求换成https" class="headerlink" title="如何把http请求换成https"></a>如何把http请求换成https</h2><div class="note primary flat"><p>用axios进行封装的时候域名最好也定义一个baseURL 方便在后面将它改为https的的请求<br>or<br>使用meta标签 </p></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span> =<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;upgrade-insecure-requests&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="为什么说HTTPS比HTTP安全呢"><a href="#为什么说HTTPS比HTTP安全呢" class="headerlink" title="为什么说HTTPS比HTTP安全呢"></a>为什么说HTTPS比HTTP安全呢</h2><ul><li>通过混合加密保证传输的数据不被窃听</li><li>通过数字签名的方式保证数据不会被篡改</li><li>通过数字证书保证服务器身份的真实性</li></ul><h2 id="什么是中间人攻击？"><a href="#什么是中间人攻击？" class="headerlink" title="什么是中间人攻击？"></a>什么是中间人攻击？</h2><p>中间人攻击(Man-in-the-MiddleAttack，简称“MITM攻击”)是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方 直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻 击中，攻击者可以拦截通讯双方的通话并插入新的内容。中间人攻击是一个(缺乏)相互认证的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，SSL协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信 任的数字证书认证机构颁发，并且能执行双向身份认证。<br>中间人攻击过程 1客户端发送请求到服务端，请求被中间人截获。<br>2)服务器向客户端发送公钥。<br>3)中间人截获公钥，保留在自己手上。然后自己生成一个【伪 造的】公钥，发给客户端。<br>4)客户端收到伪造的公钥后，生成加密hash值发给服务器。<br>5)中间人获得加密hash值，用自己的私钥解密获得真秘钥。同时生成假的加密hash值，发给服务器。<br>6 ) 服务器用私钥解密获得假密钥。然后加密数据传输给客户端。</p><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="计算机网络" scheme="https://zlinni.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP" scheme="https://zlinni.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>FooTok项目杂谈</title>
    <link href="https://zlinni.github.io/posts/92dd6276498c/"/>
    <id>https://zlinni.github.io/posts/92dd6276498c/</id>
    <published>2022-03-24T14:33:23.000Z</published>
    <updated>2022-03-28T11:40:07.365Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip cogs"><p>老项目新谈，用vue3重构ing</p></div><h1 id="主题演示"><a href="#主题演示" class="headerlink" title="主题演示"></a>主题演示</h1><p>待填充…</p><h1 id="构建工具-技术栈"><a href="#构建工具-技术栈" class="headerlink" title="构建工具+技术栈"></a>构建工具+技术栈</h1><p>编译软件：vscode<br>开发框架: vue3<br>打包工具：vite<br>UI：element-plus<br>icon：阿里巴巴<br>其他：pinia， vue-router，git<br>插件：pubsub，nanoid，less-loader<br>后端： nodejs，mysql</p><h1 id="part0-路由-amp-pinia"><a href="#part0-路由-amp-pinia" class="headerlink" title="part0 路由&amp;pinia"></a>part0 路由&amp;pinia</h1><p>定义路由，以及重定向。<br>当时在router里面把路径写错了导致页面跳转问题出现。！！！<br>vue3的路由写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    createRouter,</span><br><span class="line">    createWebHashHistory</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"><span class="keyword">const</span> routes = [&#123;</span><br><span class="line">xxxx</span><br><span class="line">&#125;]</span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">    <span class="attr">history</span>: createWebHashHistory(),</span><br><span class="line">    routes,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><br>pinia写法</p><h1 id="part1-mainFrame"><a href="#part1-mainFrame" class="headerlink" title="part1 mainFrame"></a>part1 mainFrame</h1><div class="tip "><p>这个部分是关于整个页面框架的</p></div><h2 id="element-plus"><a href="#element-plus" class="headerlink" title="element-plus"></a>element-plus</h2><p>全局引入和按需引入，没什么好说的。注意的是官网的例子部分是ts，不太友好。</p><h2 id="农历的类"><a href="#农历的类" class="headerlink" title="农历的类"></a>农历的类</h2><p>使用到了一个可以返回农历值的方法，将他封装了起来，放进了plugins。最后暴露方法出来。</p><h2 id="css变量"><a href="#css变量" class="headerlink" title="css变量"></a>css变量</h2><p>这次使用了css变量来定义全部的颜色变量，方便后期修改<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220324225112.png" alt=""><br>注意使用css变量的框架不要设置<code>style:scoped</code>否则后面的读不出来数据。</p><h1 id="part2-login"><a href="#part2-login" class="headerlink" title="part2 login"></a>part2 login</h1><div class="tip "><p>这个部分是关于login页面的</p></div><p>还待解决的问题：分辨率不同footok的标题向下位置不同<br>注意router的引入<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRoute, useRouter &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br></pre></td></tr></table></figure></p><h2 id="注册的判断"><a href="#注册的判断" class="headerlink" title="注册的判断"></a>注册的判断</h2><p>关于id的正则表达式：<code>/^[a-zA-Z0-9_-]&#123;4,16&#125;$/</code>（只支持字母，数字，下划线，减号）<br>关于密码的正则：<code>/^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z]).*$/</code>（最少六位加大小写），并且注意不能空密码空账号<br>注意watch方法中，reactive的变量检测使用<code>()=&gt;obj.xxx</code><br>例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">watch(</span><br><span class="line">  <span class="function">() =&gt;</span> userData.password,</span><br><span class="line">  <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> patt = <span class="regexp">/^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z]).*$/</span>;</span><br><span class="line">    <span class="keyword">if</span> (!patt.test(newValue)) &#123;</span><br><span class="line">      passwordTips.value = <span class="string">&quot;您的密码强度不够&quot;</span>;</span><br><span class="line">      isSuccess.passWordSuccess = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      passwordTips.value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      isSuccess.passWordSuccess = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h2 id="登陆和注册以及axios"><a href="#登陆和注册以及axios" class="headerlink" title="登陆和注册以及axios"></a>登陆和注册以及axios</h2><p>发送：注意发送的时候不要发响应式的对象，因为后端不需要你的响应式对象，它需要一个普通对象，所以可以使用toRaw将你的数据变成普通对象之后发送。<br>接收：axios的问题是要知道code和数据来自哪里。这里发现后端发来的数据中，code来自data</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">  .post(<span class="string">&quot;http://localhost:3000/api/register&quot;</span>, rawData)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.data.code === <span class="number">200</span>) &#123;</span><br><span class="line">      sessionStorage.setItem(<span class="string">&quot;sid&quot;</span>, res.data.data.user.id);</span><br><span class="line">      router.push(&#123; <span class="attr">name</span>: <span class="string">&quot;index&quot;</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    userNameTips.value = <span class="string">&quot;用户名已存在&quot;</span>;</span><br><span class="line">    isSuccess.userNameSuccess = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>注册逻辑：200则注册成功，在session里面放sid，这样router里面就能放行，并且跳转。如果异常则是用户名已存在。（网络异常的判断？）<br>登陆逻辑：200登陆成功，否则用户名存在。<br>（登陆的优化？安全？token？jwt？）</p><h1 id="part3-indexAside"><a href="#part3-indexAside" class="headerlink" title="part3 indexAside"></a>part3 indexAside</h1><div class="tip "><p>这个部分是关于两侧aside页面的</p></div><p>用到了视口单位进行了响应式。</p><h1 id="part4-foodSwiper"><a href="#part4-foodSwiper" class="headerlink" title="part4 foodSwiper"></a>part4 foodSwiper</h1><div class="tip "><p>这个部分是关于轮播图页面的</p></div><p>三个需求</p><ol><li>展示轮播图片 五个一循环 点击换一些 再切换五个<br>目前还没解决的问题是 根据用户请求 </li><li>点赞功能</li><li>收藏功能</li></ol><h2 id="轮播图片"><a href="#轮播图片" class="headerlink" title="轮播图片"></a>轮播图片</h2><p>采用的element的走马灯并进行了魔改。具体魔改的是下方的指示灯<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220325200931.png" alt=""><br>遇到的问题：</p><ol><li>axios请求图片之后需要滑动走马灯才显示的问题<br>原因：没有设置渲染条件，走马灯没读到数据。<br>解决方法：<code>v-if</code>数据的长度，有数据就显示</li><li>点击换一些过一会屏幕空白<br>原因：没有初始化数据数组长度<br>解决方法：先初始化再赋值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getfood = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  foodMsgObj.foodMsg = [];</span><br><span class="line">  axiosFoodMsg()</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      foodMsgObj.foodMsg = res;</span><br><span class="line">    &#125;) <span class="comment">//初始化走马灯文字</span></span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;el-carousel__button&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; btn.length; i++) &#123;</span><br><span class="line">        btn[i].innerText = wordObj[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>魔改的指示灯不显示<br>原因：赋值完dom还没有渲染完，所以魔改的灯没有值。<br>解决方法：如上，使用异步。</li><li>魔改的指示灯背景色 这个是css问题 已经解决。<br>亮点：封装了axios方法到hook，方便后面请求使用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">let</span> idObj =&#123;</span><br><span class="line">        <span class="attr">id</span>:<span class="built_in">parseInt</span>(sessionStorage.getItem(<span class="string">&#x27;sid&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> axios.post(<span class="string">&quot;/api/swiper&quot;</span>,idObj).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// if(res.status ===200)&#123;</span></span><br><span class="line">        <span class="comment">//     arr = res.data;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (res.data.code === <span class="number">200</span>) &#123;</span><br><span class="line">            arr = res.data.data.records;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(arr);</span><br><span class="line">    &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>axios注意事项：</p></div></li><li>注意res的data和data里面的data问题。</li><li>注意return，它返回的是一个<code>promise</code>对象，解析<code>promise</code>对象需要使用then方法<h2 id="点赞功能"><a href="#点赞功能" class="headerlink" title="点赞功能"></a>点赞功能</h2><div class="note primary flat"><p>性能优化：防抖后确认和第一次的状态不一致才发送请求改变状态</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> updateLikeTime = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> likeInit;</span><br><span class="line"><span class="keyword">var</span> zan = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = foodMsgObj.foodMsg.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.id === id;</span><br><span class="line">  &#125;)[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">//如果是第一次 那么记录初始点赞状态</span></span><br><span class="line">  <span class="keyword">if</span> (!arr.zanfirstClick) &#123;</span><br><span class="line">    likeInit = arr.islike;</span><br><span class="line">    arr.zanfirstClick = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//点赞和取消点赞</span></span><br><span class="line">  <span class="keyword">if</span> (!arr.islike) &#123;</span><br><span class="line">    arr.likenum++;</span><br><span class="line">    arr.islike = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(updateLikeTime);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    arr.likenum--;</span><br><span class="line">    arr.islike = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(updateLikeTime);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果最后一次操作和初始状态不一样 才设置定时器发送请求</span></span><br><span class="line">  <span class="keyword">if</span> (likeInit !== arr.islike) &#123;</span><br><span class="line">    updateLikeTime = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> updateData = &#123;</span><br><span class="line">        <span class="attr">userid</span>: sessionStorage.getItem(<span class="string">&quot;sid&quot;</span>),</span><br><span class="line">        <span class="attr">id</span>: id,</span><br><span class="line">        <span class="attr">islike</span>: arr.islike,</span><br><span class="line">      &#125;;</span><br><span class="line">      axios.post(<span class="string">&quot;/api/updatelike&quot;</span>, updateData).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">        <span class="keyword">if</span> (res.status === <span class="number">200</span>) &#123;</span><br><span class="line">          arr.zanfirstClick = <span class="literal">false</span>;</span><br><span class="line">          <span class="built_in">console</span>.log(id,<span class="string">&quot;点赞转换成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="收藏功能"><a href="#收藏功能" class="headerlink" title="收藏功能"></a>收藏功能</h2>同上 逻辑类似不赘述<h1 id="part5-foodMap"><a href="#part5-foodMap" class="headerlink" title="part5 foodMap"></a>part5 foodMap</h1><div class="tip "><p>这个部分是关于美食地图的</p></div>需求如下：</li><li>热点地图 点击切换区域</li><li>axios请求后显示相应的收录数，收录排行前二的数据</li><li>点击数据 跳转对应的详情页（产生通用接口传id查sql跳转）</li><li>查看所有直接跳转美食目录<h2 id="热点地图"><a href="#热点地图" class="headerlink" title="热点地图"></a>热点地图</h2>这个玩意当时纠结了很久，怎么点击一个地图的热点区域并高亮该区域<br>目前知道的方法就是map标签，里面添加area标签以及poly属性处理多边形。前提还要和图片进行一个绑定。原理是通过点击热点区域动态改变图片src<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//代码太长删掉了一部分 值得一提的是usemap和map中的id绑定，但此时只有写name即可视为绑定。</span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;mainMap&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">usemap</span>=<span class="string">&quot;#map&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mainmap&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">area</span></span></span><br><span class="line"><span class="tag">          <span class="attr">shape</span>=<span class="string">&quot;poly&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:coords</span>=<span class="string">&quot;huanan1&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;huanan&quot;</span></span></span><br><span class="line"><span class="tag">          @<span class="attr">click.native</span>=<span class="string">&quot;changeMap&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">area</span></span></span><br><span class="line"><span class="tag">          <span class="attr">shape</span>=<span class="string">&quot;poly&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:coords</span>=<span class="string">&quot;huanan2&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;huanan&quot;</span></span></span><br><span class="line"><span class="tag">          @<span class="attr">click.native</span>=<span class="string">&quot;changeMap&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure>写到这你以为很简单？看到上面的coords属性了吗，这个是坐标的区域，也就意味着每个多边形的坐标都需要知道，以至于…<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220326144056.png" alt=""><br>这只是一部分，后面的坐标还有很多。是通过ps的方式找坐标的，也就意味着要一个一个点打…</li></ol><h2 id="交互部分"><a href="#交互部分" class="headerlink" title="交互部分"></a>交互部分</h2><p>剩下的功能倒不是很难实现，也没什么值得一提的地方，除了后端这个数据<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220326144306.png" alt=""><br>前端就只能慢慢的解构赋值了</p><h2 id="热点地图自适应（已解决）"><a href="#热点地图自适应（已解决）" class="headerlink" title="热点地图自适应（已解决）"></a>热点地图自适应（已解决）</h2><p>原先问题：没有办法解决当缩放的时候，失去热点区域的问题，因为图片被缩放了，但是热点区域没有发生改变，原来的坐标还是在屏幕对应的位置 所以会出错。<br>解决方法：先记录图片初始化的大小，x坐标乘现在宽/初始宽的比例，y坐标乘现在高/初始高的比例，得到缩放后的比例。<br>过程中遇到的问题和注意事项：</p><ol><li>坐标是字符串 转数组才能操作 操作完要转回字符串。</li><li>需要暴露两个obj 一个是初始坐标obj，另外一个暴露的obj会变成响应式后面使用。如果只暴露一个，那么响应式的就算暂存了地址中的数据也会发生变化。</li><li>替换坐标的时候，不能采用<code>obj = function返回的obj</code>这样的形式，会丢失响应式。建议直接<code>obj.xx = xxfunction(xx)...</code>这样的形式保证不会出错。</li><li>缩放设置定时器避免重复计算。<br>上代码<br>hook里面的<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> coordsObj = &#123;</span><br><span class="line">    <span class="attr">huanan1</span>: huanan1,</span><br><span class="line">    <span class="attr">huanan2</span>: huanan2,</span><br><span class="line">    <span class="attr">huanan3</span>: huanan3,</span><br><span class="line">    <span class="attr">huabei</span>: huabei,</span><br><span class="line">    <span class="attr">huazhong</span>: huazhong,</span><br><span class="line">    <span class="attr">huadong</span>: huadong,</span><br><span class="line">    <span class="attr">xibu</span>: xibu</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> initCoords = &#123;</span><br><span class="line">    <span class="attr">huanan1</span>: huanan1,</span><br><span class="line">    <span class="attr">huanan2</span>: huanan2,</span><br><span class="line">    <span class="attr">huanan3</span>: huanan3,</span><br><span class="line">    <span class="attr">huabei</span>: huabei,</span><br><span class="line">    <span class="attr">huazhong</span>: huazhong,</span><br><span class="line">    <span class="attr">huadong</span>: huadong,</span><br><span class="line">    <span class="attr">xibu</span>: xibu</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCoords</span>(<span class="params">arr, w, h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> img = <span class="built_in">document</span>.getElementById(<span class="string">&quot;mainmap&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> newWidth = img.width;</span><br><span class="line">    <span class="keyword">let</span> newHeight = img.height;</span><br><span class="line">    <span class="keyword">let</span> widthpercent = newWidth / w;</span><br><span class="line">    <span class="keyword">let</span> heightpercent = newHeight / h;</span><br><span class="line">    arr = arr.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// x坐标</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">            arr[i] = <span class="built_in">Math</span>.round(<span class="built_in">parseInt</span>(arr[i]) * widthpercent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//y</span></span><br><span class="line">            arr[i] = <span class="built_in">Math</span>.round(<span class="built_in">parseInt</span>(arr[i]) * heightpercent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> newPosition = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        newPosition += arr[j];</span><br><span class="line">        <span class="keyword">if</span> (j &lt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">            newPosition += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newPosition;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    coordsObj,</span><br><span class="line">    initCoords,</span><br><span class="line">    setCoords,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>vue里面的<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mycoordsObj = reactive(coordsObj);</span><br><span class="line"><span class="comment">//热点区域自适应</span></span><br><span class="line"><span class="comment">//初始化热点</span></span><br><span class="line"><span class="keyword">let</span> time = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initCoord</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">clearTimeout</span>(time);</span><br><span class="line">  time = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    mycoordsObj.huanan1 = setCoords(initCoords.huanan1, <span class="number">767</span>, <span class="number">586</span>);</span><br><span class="line">    mycoordsObj.huanan2 = setCoords(initCoords.huanan2, <span class="number">767</span>, <span class="number">586</span>);</span><br><span class="line">    mycoordsObj.huanan3 = setCoords(initCoords.huanan3, <span class="number">767</span>, <span class="number">586</span>);</span><br><span class="line">    mycoordsObj.huabei = setCoords(initCoords.huabei, <span class="number">767</span>, <span class="number">586</span>);</span><br><span class="line">    mycoordsObj.huazhong = setCoords(initCoords.huazhong, <span class="number">767</span>, <span class="number">586</span>);</span><br><span class="line">    mycoordsObj.huadong = setCoords(initCoords.huadong, <span class="number">767</span>, <span class="number">586</span>);</span><br><span class="line">    mycoordsObj.xibu = setCoords(initCoords.xibu, <span class="number">767</span>, <span class="number">586</span>);</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;</span><br><span class="line">initCoord(<span class="number">200</span>);</span><br><span class="line"><span class="comment">//当缩放的时候 自适应 且设置定时器避免多次计算</span></span><br><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  initCoord(<span class="number">1500</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2></li><li>png转webp，从400k变100k直升四倍，注意格式工厂的webp转换底色会变绿</li><li>依旧是定时器，避免重复计算。</li></ol><h1 id="part6-foodCatalog"><a href="#part6-foodCatalog" class="headerlink" title="part6 foodCatalog"></a>part6 foodCatalog</h1><div class="tip "><p>这个部分是关于美食目录的</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220328194001.png" alt=""><br>需求如下：</p><ol><li>分页显示图片，内容，点击图片跳转详情页</li><li>根据不同标签显示不同种类图片<h2 id="骨架屏的使用"><a href="#骨架屏的使用" class="headerlink" title="骨架屏的使用"></a>骨架屏的使用</h2>第一次使用element的骨架屏，用法也比较简单，需要在<code>el-skeleton</code>标签内放两个template，一个用于骨架显示，一个用于实际显示。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-skeleton</span> <span class="attr">:loading</span>=<span class="string">&quot;loading&quot;</span> <span class="attr">animated</span> <span class="attr">:throttle</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 骨架显示 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-skeleton-item</span></span></span><br><span class="line"><span class="tag">      <span class="attr">variant</span>=<span class="string">&quot;image&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        width: 24%;</span></span></span><br><span class="line"><span class="string"><span class="tag">        height: 32%;</span></span></span><br><span class="line"><span class="string"><span class="tag">        margin-bottom: 5px;</span></span></span><br><span class="line"><span class="string"><span class="tag">        margin-right: 5px;</span></span></span><br><span class="line"><span class="string"><span class="tag">      &quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">&quot;item in 12&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 实际图片显示 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;foodBox&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-card</span> <span class="attr">:body-style</span>=<span class="string">&quot;&#123; padding: &#x27;0px&#x27; &#125;&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;item in foodData&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span></span></span><br><span class="line"><span class="tag">        &gt;</span><span class="tag">&lt;<span class="name">el-image</span> <span class="attr">:src</span>=<span class="string">&quot;item.foodbigimg&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; item.foodname &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-card</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-skeleton</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-pagination</span></span></span><br><span class="line"><span class="tag">  <span class="attr">background</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;pagin&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">layout</span>=<span class="string">&quot;prev, pager, next&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">current-change</span>=<span class="string">&quot;handleCurrentChange&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:currentPage</span>=<span class="string">&quot;currentPage&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:total</span>=<span class="string">&quot;pageSize&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>遇到的问题：<br>项目中一页显示12个，骨架屏里面也有十二个内容，想着切换的条件应该是图片loading完毕就显示。所以给<code>el-image</code>的load事件绑定了loading，但是实际上并没有用。猜想可能是图片不是同时渲染，所以给出的boolean值也随时间变化，不是固定值，所以骨架屏整个的切换无法进行。<br>解决方法：<br>不等图片渲染完再取消了，直接收到请求之后取消。<h2 id="分页器"><a href="#分页器" class="headerlink" title="分页器"></a>分页器</h2>element的分页器也是第一次使用，当时遇到的问题就是不知道怎么响应当前页数，就是点到第几页显示对应的数字。后面从文档中了解到使用<code>@current-change=&quot;handleCurrentChange&quot;</code>绑定当前页，默认传入的是当前页的值val 这样就可以传参到后端了。</li></ol><h2 id="性能优化-1"><a href="#性能优化-1" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li>骨架屏：请求回来之前使用骨架屏，响应之后渲染图片，增加用户体验</li><li>css的loading，这个和骨架屏的原理其实差不多，选了骨架屏</li><li>依旧是png转webp，可以到达更小的size其实，只需要缩略图</li></ol><h1 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h1><h2 id="链接hash问题"><a href="#链接hash问题" class="headerlink" title="链接hash问题"></a>链接hash问题</h2><p>vite会自动把链接变成哈希值，所以是不能直接引入某某链接的，需要使用一个方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getAssetsImages.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">fileName,imgName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> URL(<span class="string">`/src/assets/img/<span class="subst">$&#123;fileName&#125;</span>/<span class="subst">$&#123;imgName&#125;</span>`</span>,</span><br><span class="line">        <span class="keyword">import</span>.meta.url).href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个js由于使用的场景太多 直接封装之后放入了hook使用。后面考虑全局使用。</p><h2 id="vite配置项的问题"><a href="#vite配置项的问题" class="headerlink" title="vite配置项的问题"></a>vite配置项的问题</h2><p>vite的配置项和之前vuecli不太一样，而且确保能完全使用它的功能，还需要将vite的版本升到最新。所以当时配置的时候删库重新init了vite项目，这个问题需要非常注意。<br>检验的方法是：init之后康康有没有<code>vite.config.js</code></p><h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><p>代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    defineConfig</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">    <span class="attr">plugins</span>: [vue()],</span><br><span class="line">    <span class="attr">base</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">    <span class="attr">build</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;modules&#x27;</span>,</span><br><span class="line">        <span class="attr">outDir</span>: <span class="string">&#x27;dist&#x27;</span>, <span class="comment">//指定输出路径</span></span><br><span class="line">        <span class="attr">assetsDir</span>: <span class="string">&#x27;assets&#x27;</span>, <span class="comment">// 指定生成静态资源的存放路径</span></span><br><span class="line">        <span class="attr">minify</span>: <span class="string">&#x27;terser&#x27;</span> <span class="comment">// 混淆器，terser构建后文件体积更小</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">server</span>: &#123;</span><br><span class="line">        <span class="attr">cors</span>: <span class="literal">true</span>, <span class="comment">// 默认启用并允许任何源</span></span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">// 在服务器启动时自动在浏览器中打开应用程序</span></span><br><span class="line">        <span class="comment">//反向代理配置，注意rewrite写法，开始没看文档在这里踩了坑</span></span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="comment">//     &#x27;/api&#x27;: &#123;</span></span><br><span class="line">            <span class="comment">//         target:&#x27;http://isinpc.natappfree.cc&#x27;,</span></span><br><span class="line">            <span class="comment">//         changeOrigin: true,</span></span><br><span class="line">            <span class="comment">//         rewrite: (path) =&gt; path.replace(/^\/api/, &#x27;&#x27;)</span></span><br><span class="line">            <span class="comment">//   &#125;</span></span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&#x27;http://localhost:8081&#x27;</span>,</span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">rewrite</span>: <span class="function">(<span class="params">path</span>) =&gt;</span> path.replace(<span class="regexp">/^\/api/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>这里的proxy是配置转发，前端使用ajax或者axios的时候，就会将<code>localhost:3000</code>自动转换成对应的值。这里方便合作还使用到了内网穿透的api，来换切换使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
</feed>
