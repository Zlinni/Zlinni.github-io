<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鱼与前端🐟</title>
  
  <subtitle>摸鱼和工作不可得兼~</subtitle>
  <link href="https://zlinni.github.io/atom.xml" rel="self"/>
  
  <link href="https://zlinni.github.io/"/>
  <updated>2022-05-05T10:42:30.454Z</updated>
  <id>https://zlinni.github.io/</id>
  
  <author>
    <name>Zlinni</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Binary Tree二叉树⑥--特性篇</title>
    <link href="https://zlinni.github.io/posts/2732070170/"/>
    <id>https://zlinni.github.io/posts/2732070170/</id>
    <published>2022-05-05T08:38:38.000Z</published>
    <updated>2022-05-05T10:42:30.454Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在前面的文章我们学习了寻找一颗二叉树的重复子树，这个问题结合了第四章节的序列化内容加第三章节的构造内容，接下来我们学习二叉搜索树的知识，读完本文你对以下的题目有更深刻的了解：</p></div><p>Leetcode<br>230.二叉树中的第k小元素<br>538.把二叉搜索树转为累加树<br>1038.把二叉搜索树转为累加树</p><h1 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h1><div class="note primary flat"><p>全称二叉搜索树，简写BST，特性如下：</p></div><ol><li>BST的每个节点，左子树节点的值都比他小，右子树节点的值都比他大。</li><li>对于BST的每一个节点，他的左侧子树和右侧子树都是BST</li></ol><div class="note primary flat"><p>labuladong原话：二叉搜索树并不算复杂，但我觉得它可以算是数据结构领域的半壁江山，直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。</p></div><p>从算法题的角度来讲，中序遍历一个BST，是升序的，因为他先构造了左子树再构造右子树，所以如果是以一个数组的形式显示，就是从小到大的。</p><h1 id="寻找第-K-小的元素"><a href="#寻找第-K-小的元素" class="headerlink" title="寻找第 K 小的元素"></a>寻找第 K 小的元素</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505183122.png" alt=""><br>按照上面的思路，我们只要中序遍历这个二叉树然后找第k个就行了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kthSmallest = <span class="function"><span class="keyword">function</span>(<span class="params">root, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res;</span><br><span class="line">    <span class="keyword">const</span> inorder = <span class="function"><span class="params">root</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span>(k===<span class="number">0</span>)res = root.val;</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree二叉树笔记--合集（更新中）</title>
    <link href="https://zlinni.github.io/posts/3500150157/"/>
    <id>https://zlinni.github.io/posts/3500150157/</id>
    <published>2022-05-05T07:06:00.000Z</published>
    <updated>2022-05-05T08:53:20.736Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>根据这五篇的二叉树学习，你将从一个只会根左右，左根右和左右根的算法小白中领略二叉树的核心算法。</p><h1 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h1><p><a href="https://zlinni.github.io/posts/1410341477">手把手二叉树笔记①—纲领篇</a><br><a href="https://zlinni.github.io/posts/1410341478">手把手二叉树笔记②—思路篇</a><br><a href="https://zlinni.github.io/posts/686027467">手把手二叉树笔记③—构造篇</a><br><a href="https://zlinni.github.io/posts/3440987103">手把手二叉树笔记④—序列化篇</a><br><a href="https://zlinni.github.io/posts/3318597918">手把手二叉树笔记⑤—后序篇</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree二叉树笔记⑤--后序篇</title>
    <link href="https://zlinni.github.io/posts/732690854/"/>
    <id>https://zlinni.github.io/posts/732690854/</id>
    <published>2022-05-05T07:05:40.000Z</published>
    <updated>2022-05-05T08:53:32.398Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在上一篇我们学习了用js解决二叉树的序列化和反序列化的问题，其实序列化的过程就是考察二叉树遍历的过程，反序列化的过程就是考察了二叉树的构造过程，结合了前几章的知识。本篇文章深入学习二叉树后序的妙用，带你了解以下题目：</p></div><p>Leetcode<br>652.寻找重复的子树</p><h1 id="寻找重复的子树"><a href="#寻找重复的子树" class="headerlink" title="寻找重复的子树"></a>寻找重复的子树</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505151327.png" alt=""></p><p>这道题实际上就是找子树的问题，看下图<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505151425.png" alt=""></p><p>首先节点4可以作为一颗子树，二叉树中有多个节点4<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505151457.png" alt=""></p><p>类似的还存在两颗以2为根的重复子树<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505151521.png" alt=""></p><p>那么我们返回的list就应该有两个treenode，2和4 </p><p>具体这道题要怎么做呢？先思考对于一个节点他应该做什么？</p><p>我们拿这个2节点作为例子，他是不是重复的子树，是不是就要先知道自己是一颗怎么样的子树，再去找别的子树进行对比？<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505152207.png" alt=""></p><p>那么我们解题的关键就来了：</p><ol><li>先知道自己长什么样</li><li>去看看别人有没有和自己一样的</li></ol><p>那么对于第一个问题，根据本文你可以知道我们要用后序遍历的操作去做，其实前序中序都可以，只不过后序在这个阶段看的东西更明显，怎么知道自己是谁呢？其实就是自身加左右子树<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postoreder = <span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> left = postoreder(n.left);</span><br><span class="line">  <span class="keyword">let</span> right = postoreder(n.right);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;left&#125;</span>,<span class="subst">$&#123;right&#125;</span>,<span class="subst">$&#123;n.val&#125;</span>`</span>;</span><br><span class="line">  <span class="comment">//n 就是一颗树了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样不就能知道自己是谁了吗？一看这个问题，你就会发现，和之前的序列化二叉树及其相似，其实知道自己是谁的这个过程，就是经历了一次序列化。</p><p>那么现在怎么解决找同伴的问题呢？其实很简单，我们运用js的set或者map，考量这两个api用哪个的时候，我们先看我们需要什么？我们需要记录出现次数超过一次的子树，也就是记录子树+子树出现次数，所以用map更好。完整代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findDuplicateSubtrees = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//定义map集合和存放的数组</span></span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(),res = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> tranverse = <span class="function"><span class="params">root</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">const</span> left = tranverse(root.left);</span><br><span class="line">        <span class="keyword">const</span> right = tranverse(root.right);</span><br><span class="line">        <span class="keyword">const</span> str = <span class="string">`<span class="subst">$&#123;left&#125;</span>,<span class="subst">$&#123;right&#125;</span>,<span class="subst">$&#123;root.val&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">const</span> count = map.get(str);</span><br><span class="line">        <span class="keyword">if</span>(count===<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//等于1就存放子树</span></span><br><span class="line">            res.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(str,(count||<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tranverse(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree二叉树笔记④--序列化篇</title>
    <link href="https://zlinni.github.io/posts/3440987103/"/>
    <id>https://zlinni.github.io/posts/3440987103/</id>
    <published>2022-05-04T11:44:11.000Z</published>
    <updated>2022-05-05T08:53:29.574Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在上一期我们对二叉树的构造进行了深入的了解，重点掌握了构造的核心原理以及一些细节上面的问题。下面来学习二叉树的序列化，通过本篇文章你可以学会以下的题目</p></div><p>Leetcode<br>297.二叉树的序列化与反序列化</p><h1 id="二叉树的序列化与反序列化"><a href="#二叉树的序列化与反序列化" class="headerlink" title="二叉树的序列化与反序列化"></a>二叉树的序列化与反序列化</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505111425.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505145026.png" alt=""></p><p>该题目本质上，就是把二叉树转换为字符串，再从字符串转为二叉树的过程。</p><p>至于我们序列化的过程，使用什么符号定义并不重要，只要最后能够反序列化出来即可。</p><p>eg<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505145259.png" alt=""></p><p>对于一颗这样的树，我们可以将他序列化成<code>2,1,#,6,3,#,#</code>其实他考察的就是如何对二叉树进行遍历。</p><p>二叉树的递归遍历有三种，前序中序后序，迭代遍历有层序，那么就从层序开始，看如何解题</p><h1 id="前序遍历解法"><a href="#前序遍历解法" class="headerlink" title="前序遍历解法"></a>前序遍历解法</h1><p>我们知道，前序遍历的代码就是在递归之前写的，那么就有以下的逻辑<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">traverse(root.left);</span><br><span class="line">traverse(root.right);</span><br></pre></td></tr></table></figure></p><p>那么我们就很容易得出序列化的过程了，就是字符串的连接<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serialize = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;root&#125;</span>,<span class="subst">$&#123;root.left&#125;</span>,<span class="subst">$&#123;root.right&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>那么其实反序列化，就是把序列化的这一串字符串转换为treenode。</p><p>对于一个字符串来说，js提供了split方法帮我们进行分割，也就是说以下的逻辑，会分割出一个数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nodeArr = data.split(<span class="string">&quot;,&quot;</span>);</span><br></pre></td></tr></table></figure></p><p>我们拿到了这个数组，因为他是前序的序列化而来的，那么我们根据前序的特性可以得到以下条件<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505145931.png" alt=""></p><p>第一个值是根，这就是我们的递归关键，回想一下前序构造二叉树，我们可以得到如下的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> build = <span class="function">(<span class="params">preorder</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> val = preorder.shift();</span><br><span class="line">  <span class="keyword">if</span>(val === <span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">  root.left = build(preorder);</span><br><span class="line">  root.right = build(preorder);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么我们的反序列化就能写出来了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deserialize = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nodearr = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!nodearr.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> build = <span class="function">(<span class="params">nodearr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> val = nodearr.shift();</span><br><span class="line">        <span class="keyword">if</span> (val === <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root.left = build(nodearr);</span><br><span class="line">        root.right = build(nodearr);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(nodearr);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree二叉树笔记③--构造篇</title>
    <link href="https://zlinni.github.io/posts/686027467/"/>
    <id>https://zlinni.github.io/posts/686027467/</id>
    <published>2022-05-04T11:43:28.000Z</published>
    <updated>2022-05-05T08:53:26.276Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在上一篇笔记里面，我们深入了解了前序和后序遍历的本质，学会了翻转二叉树，将二叉树转为链表和填充二叉树右侧指针三道问题。接下来进一步学习，在本篇能理解并运用以下题目：</p></div><p>Leetcode<br>654.最大二叉树<br>105.从前序遍历和中序遍历构造二叉树<br>106.从中序和后序遍历构造二叉树<br>889.根据前序和后序遍历构造二叉树</p><h1 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220504201032.png" alt=""></p><p>我们细分这道题，其实他在做这样的事情<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constructMaximumBinaryTree = <span class="function"><span class="keyword">function</span> (<span class="params">[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">5</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 找到数组的最大值</span></span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(<span class="number">6</span>)</span><br><span class="line">    <span class="comment">// 递归调用构造左右子树</span></span><br><span class="line">    root.left = constructMaximumBinaryTree([<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]);</span><br><span class="line">    root.right = constructMaximumBinaryTree([<span class="number">0</span>,<span class="number">5</span>]);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再详细一点就是如下的思路：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constructMaximumBinaryTree = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> build = <span class="function">(<span class="params">nums,start,end</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//查找最大值和他的下标</span></span><br><span class="line">        <span class="keyword">let</span> max = -<span class="literal">Infinity</span>,index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;max)&#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构造二叉树</span></span><br><span class="line">        <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(max);</span><br><span class="line">        root.left = build(nums,start,index-<span class="number">1</span>);</span><br><span class="line">        root.right = build(nums,index+<span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(nums,<span class="number">0</span>,len);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 或者可以这样</span></span><br><span class="line"><span class="keyword">var</span> constructMaximumBinaryTree = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//查找最大值和他的下标</span></span><br><span class="line">    <span class="keyword">if</span>(!nums.length)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> max = -<span class="literal">Infinity</span>, index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; max) &#123;</span><br><span class="line">            max = nums[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造二叉树</span></span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(max);</span><br><span class="line">    root.left = constructMaximumBinaryTree(nums.slice(<span class="number">0</span>, index));</span><br><span class="line">    root.right = constructMaximumBinaryTree(nums.slice(index + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>至此第一道构造二叉树的题目就做完了，接下看看另外两道题目</p><h1 id="通过前序和中序遍历结果构造二叉树"><a href="#通过前序和中序遍历结果构造二叉树" class="headerlink" title="通过前序和中序遍历结果构造二叉树"></a>通过前序和中序遍历结果构造二叉树</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220504201525.png" alt=""></p><p>我们知道前序遍历的第一个节点就是整个树的根，那么中序遍历的根节点前面就是左子树，后面就是右子树，利用这个特性，自然而然的会想出以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> build = <span class="function">(<span class="params">preorder, inorder</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//找到根节点</span></span><br><span class="line">    <span class="keyword">const</span> root = preorder.shift();</span><br><span class="line">    <span class="comment">// 中序找到该节点的下标</span></span><br><span class="line">    <span class="keyword">const</span> rootIndex = inorder.indexOf(root);</span><br><span class="line">    <span class="keyword">const</span> tree = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">    <span class="comment">//递归调用构造左右子树</span></span><br><span class="line">    tree.left = fun(...);</span><br><span class="line">    tree.right = fun(...);</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，我们这里要创建一个什么样的函数去递归呢？<br>其实我们只要利用我们的中序数组就可以了，因为能依靠他查找，就能依靠他构造</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> build = <span class="function">(<span class="params">inorder</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inorder||!inorder.length)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> root = preorder.shift();</span><br><span class="line">        <span class="keyword">const</span> rootIndex = inorder.indexOf(root);</span><br><span class="line">        <span class="keyword">const</span> tree = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">        tree.left = build(inorder.slice(<span class="number">0</span>,rootIndex));</span><br><span class="line">        tree.right = build(inorder.slice(rootIndex+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(inorder);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者我们可以这样,我们知道了其实前序的左子树终止边界就是中序到根节点的长度+1，那么我们也就可以带入前序递归<br><img src="https://labuladong.github.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/6.jpeg" alt=""><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!preorder.length) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> root = preorder.shift();</span><br><span class="line">    <span class="keyword">const</span> tree = <span class="keyword">new</span> TreeNode(root)</span><br><span class="line">    <span class="keyword">const</span> rootIndex = inorder.indexOf(root)</span><br><span class="line">    tree.left = buildTree(preorder.slice(<span class="number">0</span>, rootIndex), inorder.slice(<span class="number">0</span>,rootIndex))</span><br><span class="line">    tree.right = buildTree(preorder.slice(rootIndex), inorder.slice(rootIndex+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="通过后序和中序遍历结果构造二叉树"><a href="#通过后序和中序遍历结果构造二叉树" class="headerlink" title="通过后序和中序遍历结果构造二叉树"></a>通过后序和中序遍历结果构造二叉树</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220504204143.png" alt=""></p><p>后序遍历的最后一个节点是root，那么我们知道了这个道理，其实就把shift的操作变成pop即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">inorder, postorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!postorder.length)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> root = postorder.pop();</span><br><span class="line">    <span class="keyword">const</span> rootIndex = inorder.indexOf(root);</span><br><span class="line">    <span class="keyword">const</span> tree = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">    tree.left = buildTree(inorder.slice(<span class="number">0</span>,rootIndex),postorder.slice(<span class="number">0</span>,rootIndex));</span><br><span class="line">    tree.right = buildTree(inorder.slice(rootIndex+<span class="number">1</span>),postorder.slice(rootIndex));</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="通过前序和后序构造二叉树"><a href="#通过前序和后序构造二叉树" class="headerlink" title="通过前序和后序构造二叉树"></a>通过前序和后序构造二叉树</h1><p>我们知道了结合中序构造的方法，就是从中序中找到对应的index然后分离左右，最后递归。</p><p>那么前序和后序怎么构造呢？</p><p>实际上，拿前序当参照物，第一个就是根节点，第二个就是左子树的根节点，那么我们就可以同样的在后序中找到这个左子树根节点，去分离我们的左右子树。这里注意我们需要用到长度需要注意。<br><img src="https://labuladong.github.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/8.jpeg" alt=""><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constructFromPrePost = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, postorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!preorder.length||!postorder.length)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(preorder.length===<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> root = preorder[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> index = postorder.indexOf(root);</span><br><span class="line">    <span class="keyword">const</span> tree = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> postLeft = postorder.slice(<span class="number">0</span>,index+<span class="number">1</span>),</span><br><span class="line">        postRight = postorder.slice(index+<span class="number">1</span>,postorder.length-<span class="number">1</span>),</span><br><span class="line">        preLeft = preorder.slice(<span class="number">1</span>,postLeft.length+<span class="number">1</span>),</span><br><span class="line">        preRight = preorder.slice(postLeft.length+<span class="number">1</span>);</span><br><span class="line">    tree.left = constructFromPrePost(preLeft,postLeft)</span><br><span class="line">    tree.right = constructFromPrePost(preRight,postRight)</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后总结一下，构造二叉树实际上就是找到根节点+构造左子树+构造右子树。根节点使用indexof和遍历的性质寻找，左右子树的构造使用递归的方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree二叉树笔记②--思路篇</title>
    <link href="https://zlinni.github.io/posts/1410341478/"/>
    <id>https://zlinni.github.io/posts/1410341478/</id>
    <published>2022-05-03T12:34:45.683Z</published>
    <updated>2022-05-05T08:53:23.861Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在上一篇手把手二叉树的笔记中，我们解决了三道问题，二叉树最大深度，二叉树最大直径，和层序遍历。而读完本文，你可以解决以下问题：</p></div><p>Leetcode<br>226.翻转二叉树<br>114.将二叉树展开为链表<br>116.填充二叉树节点的右侧指针</p><h1 id="再谈二叉树的重要性"><a href="#再谈二叉树的重要性" class="headerlink" title="再谈二叉树的重要性"></a>再谈二叉树的重要性</h1><p>对于经典的算法快速排序和归并排序来说，如果你知道二叉树的前序遍历就是快速排序，后序遍历就是归并排序，那么你对二叉树就有比较深入的了解了。</p><p>快速排序的逻辑是先找到一个基准点，根据这个基准点，去对我们左侧的数据划分，使得左侧的数据都小于这个基准点，右侧的数据都大于这个基准点，然后在左侧和右侧进行递归这个过程，最后的数组就是被排序的</p><p>代码逻辑过程：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function">(<span class="params">arr,i,j</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);</span><br><span class="line">    ...</span><br><span class="line">    quickSort(arr,i,p-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr,p+<span class="number">1</span>,j);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先构造分界点，再根据左右子数组去构造分界点，这不就是二叉树的前序遍历吗</p><p>再谈谈归并排序的逻辑，先分割数组，到最小规模后逐步合并子数组，直到完全有序</p><p>代码逻辑过程：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeSort = <span class="function">(<span class="params">arr</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//分割</span></span><br><span class="line">    left = mergeSort(arr.slice(<span class="number">0</span>,mid));</span><br><span class="line">    right = mergeSort(arr.slice(mid,len));</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    arr = mergeArr(left,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是不是发现了他很像后序遍历，先对左右数组排序然后合并。</p><p>所以接下来做几道比较有意思的二叉树算法题</p><h1 id="递归的诀窍"><a href="#递归的诀窍" class="headerlink" title="递归的诀窍"></a>递归的诀窍</h1><div class="note primary flat"><p>写递归算法的诀窍就是明确函数定义的是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要试图跳入递归。</p></div><p>用个具体的例子来解释：求一颗二叉树有多少节点<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + count(n.left) + count(n.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子非常简单，用根节点加左右子树的节点就是总节点。那左右子树的节点怎么计算？就是调用递归的count计算出来的。</p><p>写树相关的算法，简单来说就是搞清楚当前root节点要做什么，然后根据函数定义递归子节点，递归调用会让孩子做相同的事情。</p><h1 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h1><h2 id="题目一：翻转二叉树-226"><a href="#题目一：翻转二叉树-226" class="headerlink" title="题目一：翻转二叉树-226"></a>题目一：翻转二叉树-226</h2><p>eg<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>我们发现只要将二叉树的左右节点都交换就可以完成这个过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> root;</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    [root.left,root.right] = [root.right,root.left];</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//前序</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    [root.left,root.right] = [root.right,root.left];</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这道题你会发现前序和后序都能做，但是中序就不行。因为中序的遍历是一边先结束再另一边，所以做不到反转。边界条件的话，因为前序可能是一开始就无，所以是null，而后序最后是根，所以是root</p><h2 id="题目二：填充二叉树节点的右侧指针-116"><a href="#题目二：填充二叉树节点的右侧指针-116" class="headerlink" title="题目二：填充二叉树节点的右侧指针-116"></a>题目二：填充二叉树节点的右侧指针-116</h2><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220503224625.png" alt=""></p><p>我们仿造上面的思路其实可以这样做<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> connect = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root||!root.left)<span class="keyword">return</span> root;</span><br><span class="line">    root.left.next = root.right;</span><br><span class="line">    connect(root.left);</span><br><span class="line">    connect(root.right);</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过这样其实有很大的问题<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220503224912.png" alt=""></p><p>我们发现跨越父节点的值并没有被连接起来。</p><p>稍微改造一下代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> connect = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> connectTwo = <span class="function">(<span class="params">n1,n2</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//其中一者没有直接返回上一步</span></span><br><span class="line">        <span class="keyword">if</span>(!n1||!n2)<span class="keyword">return</span>;</span><br><span class="line">        n1.next = n2;</span><br><span class="line">        <span class="comment">// 相同父节点的左右连接</span></span><br><span class="line">        connectTwo(n1.left,n1.right);</span><br><span class="line">        connectTwo(n2.left,n2.right);</span><br><span class="line">        <span class="comment">// 跨越父节点的左右连接</span></span><br><span class="line">        connectTwo(n1.right,n2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    connectTwo(root.left,root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样使用connectTwo递归就可以无死角的覆盖整颗二叉树，将所有相邻的节点连接起来了。</p><h2 id="题目三：将二叉树展开为链表-114"><a href="#题目三：将二叉树展开为链表-114" class="headerlink" title="题目三：将二叉树展开为链表-114"></a>题目三：将二叉树展开为链表-114</h2><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220503225946.png" alt=""></p><p>那么我们要怎么做才能拉平这个数组呢？</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220503230236.png" alt=""></p><p>可以看出，我们首先需要将左子树拉平，然后将右子树拉平，然后再把左子树接到右子树上。</p><p>那么就第一步怎么拉平左右子树呢？</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714efce7db2cdff~tplv-t2oaga2asx-watermark.awebp" alt=""></p><p>我们根据后序遍历动画可以知道，只要经过后序遍历，就能拉平左右子树，那么第一步的问题就解决了。</p><p>随后是怎么把左子树接到右子树上面呢？</p><p>首先我们要清楚，这个左子树不是中途就能插入的，我们必须先把左右子树保存，然后删掉左子树，将保存的左子树放到右子树，再将保存的右子树插入到右子树。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flatten = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//拉平</span></span><br><span class="line">    flatten(root.left);</span><br><span class="line">    flatten(root.right);</span><br><span class="line">    <span class="comment">//暂存左右子树</span></span><br><span class="line">    <span class="keyword">let</span> left = root.left;</span><br><span class="line">    <span class="keyword">let</span> right = root.right;</span><br><span class="line">    <span class="comment">//删除原左子树，将暂存的左子树放在原右子树上</span></span><br><span class="line">    root.left = <span class="literal">null</span>;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="comment">//类似于链表 遍历右子树找到他末尾节点 然后插入暂存右子树</span></span><br><span class="line">    <span class="keyword">let</span> p = root;</span><br><span class="line">    <span class="keyword">while</span>(p.right!==<span class="literal">null</span>)&#123;</span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">    p.right = right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>根据labuladong所说，递归的算法真谛就是相信递归的定义，不要去纠里面的细节所在。然后二叉树方面其实很多递归的问题，并且我们还要考虑边界情况，一般来说我们后序遍历不需要root的话，遍历到末尾节点就可以直接返回，或者返回null，一般我们在计算节点深度或者直径的时候，就要返回0。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree二叉树笔记①--纲领篇</title>
    <link href="https://zlinni.github.io/posts/1410341477/"/>
    <id>https://zlinni.github.io/posts/1410341477/</id>
    <published>2022-05-03T10:41:00.167Z</published>
    <updated>2022-05-05T08:52:53.445Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>labuladong的二叉树算法入门第一章，这段时间的算法确实没什么长进，只停留在会做针对性的题目的阶段，如果出现了变体就很难解决了，所以下决心从算法基础再开始修炼算法。由于labuladong的代码大多数是c++，本文便修改为js进行学习。</p></div><p>读完本文，你可以解决以下问题：<br>104.二叉树的最大深度<br>543.二叉树的直径<br>102.二叉树的层序遍历</p><h1 id="二叉树学习的必要性"><a href="#二叉树学习的必要性" class="headerlink" title="二叉树学习的必要性"></a>二叉树学习的必要性</h1><div class="note primary flat"><p>二叉树是所有高级算法的基础，他涉及了递归，回溯，所以算法入门最好就从二叉树开始。</p></div><h1 id="深入理解前中后序"><a href="#深入理解前中后序" class="headerlink" title="深入理解前中后序"></a>深入理解前中后序</h1><div class="note primary flat"><p>根左右，左根右，左右根…可能很多人在学习数据结构的时候，老师教过这样的判断过程。这三句话对应着二叉树的前中后序，但实际上你真的理解这三种遍历顺序吗</p></div><p>从前序开始看，我们知道，有这样的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">console</span>.log(root);</span><br><span class="line">traverse(root.left);</span><br><span class="line">traverse(root.right);</span><br></pre></td></tr></table></figure></p><p>其实这个就是一个一次遍历，和遍历数组链表的方式大同小异，而所谓的前序遍历，只不过进入第一个节点就开始遍历，而后序遍历是离开一个节点的时候才开始遍历,中序遍历是在遍历完左子树，即将遍历右子树的时候才执行。</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220503185141.png" alt=""></p><p>这之中利用到了递归和回溯的这个特性，我们规定了遍历到最后才返回的时机，就能实现后序遍历，</p><h1 id="解题的思路"><a href="#解题的思路" class="headerlink" title="解题的思路"></a>解题的思路</h1><div class="note primary flat"><p>二叉树题目的递归解法可以分为两类，一类是一次遍历实现的结果，第二类是分解问题得到答案，这两类思路分别对应着回溯算法核心框架和动态规划核心框架</p></div><p>在leetcode第104题中，求二叉树的最大深度，这道题很明显，思路就是遍历一次二叉树，记录每个节点的深度，取叶子节点深度的最大值即可，这就是一次遍历完成的结果。</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220503185822.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> deep = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">            max = <span class="built_in">Math</span>.max(max, depth);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">        deep(n.left);</span><br><span class="line">        deep(n.right);</span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line">    deep(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这道题无关遍历的顺序，有关系的只是什么时机去刷新这个max。并且我们知道前序的条件是进入一个节点之前，所以我们使用了depth++，后序是在离开一个节点的时候，所以depth—，这个depth记录了当前递归的节点深度，所以要这样维护他。</p><p>除此之外，我们也很容易知道，二叉树的最大高度可以通过子树的最大高度计算出来，这就是分解问题的关键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> deep = <span class="function">(<span class="params">n,l</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> left = deep(n.left,l+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">let</span> right = deep(n.right,l+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(left,right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep(root,<span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个思路的核心在于，要使用递归先获得子树的最大高度，那么要获得这个最大高度，就需要遍历完这个子树，这个时候，代码逻辑写在后序的部分就显得尤为重要，因为此时一个完整的子树已经被遍历了，我们只需要在这个阶段获取最大高度刷新即可。</p><h1 id="后序的特殊之处"><a href="#后序的特殊之处" class="headerlink" title="后序的特殊之处"></a>后序的特殊之处</h1><p>我们知道前序是刚刚进入节点的时刻，后序是即将离开节点的时刻，前序自顶向下，后序自底向上。那么就意味着，前序的代码只能获取父节点传递过来的数据。后序的代码不仅可以获取数据，还能拿到子树通过函数返回的数据</p><p>举个例子，现有一颗二叉树，处理以下两个问题：</p><ol><li>如果把根节点看成第一层，如何知道每个节点的层数</li><li>如何打印每个节点的左右子树有多少个节点？并返回节点总数</li></ol><p>首先第一个代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> traverse = <span class="function">(<span class="params">root,level</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(root,level);</span><br><span class="line">    traverse(root.left,level+<span class="number">1</span>);</span><br><span class="line">    traverse(root.right,level+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">traverse(root,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>第二个代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> traverse = <span class="function">(<span class="params">root,level</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = traverse(root.left,level+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> right = traverse(root.right,level+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(root,left,right);</span><br><span class="line">    <span class="keyword">return</span> left+right+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此我们发现，只有后序才能够帮助我们获取子树的信息，所以一旦发现题目和子树有关，大概率代码的位置要写在后序的部分。</p><p>那么后序在二叉树刷题中是如何发挥作用的，这里看一道leetcode的543题，二叉树直径，计算出二叉树直径的最大长度。</p><p>所谓的二叉树的直径，就是两个任意节点之间的路径长度。最大路径长度不一定是要穿过根节点，看下图</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220503193254.png" alt=""></p><p>这个图片中，最大的路径长度有两条，1是[4,2,1,3],2是[5,2,1,3]</p><p>这道题的关键在于，每一条二叉树的直径就是一个节点的左右子树最大深度之和，比如说这个节点1 左子树最大深度2，右子树最大深度1 加起来就是3 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> diameterOfBinaryTree = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> deep = <span class="function">(<span class="params">n,l</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//注意深度问题边界是0</span></span><br><span class="line">        <span class="keyword">let</span> left = deep(n.left,l+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">let</span> right = deep(n.right,l+<span class="number">1</span>);</span><br><span class="line">        max = <span class="built_in">Math</span>.max(left+right,max);<span class="comment">//刷新最大深度之和,这步才是重点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(left,right)+<span class="number">1</span>;<span class="comment">//返回最大深度+1；让下一次递归知道长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    deep(root,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h1><p>层序遍历属于迭代遍历，代码框架如下；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> jud = <span class="function">(<span class="params">n, count</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (!map[count]) &#123;</span><br><span class="line">            map[count] = [n.val];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map[count].push(n.val);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        jud(n.left, count);</span><br><span class="line">        jud(n.right, count);</span><br><span class="line">    &#125;</span><br><span class="line">    jud(root, count);</span><br><span class="line">    <span class="keyword">return</span> [...Object.values(map)]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220503203233.png" alt=""></p><p>其实BFS算法就是从二叉树的层序遍历衍生出来的，常用于求无权图的最短路径问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="手把手二叉树" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/%E6%89%8B%E6%8A%8A%E6%89%8B%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>前端必须知道的浏览器性能指标</title>
    <link href="https://zlinni.github.io/posts/2062480448/"/>
    <id>https://zlinni.github.io/posts/2062480448/</id>
    <published>2022-05-01T14:40:21.000Z</published>
    <updated>2022-05-03T10:39:50.366Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>上周一面腾讯云智的时候，面试官问我这么个问题：“你知道浏览器的首屏时间怎么查看吗？”我回答进入页面到最后一个请求回收所用的时间，然后他又问：具体有什么指标来表明呢？于是就有了下文</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/性能指标.png" alt=""></p><h1 id="浏览器性能指标"><a href="#浏览器性能指标" class="headerlink" title="浏览器性能指标"></a>浏览器性能指标</h1><p>为了描述web页面的性能，开发人员提供了很多可量化的指标来进行分析。比如TTFB、FP、FCP等。指标之间也是有联系的，其中还有部分指标专门为了描述用户交互体验，比如FP、FCP、FSP、FCI、TTI等。下面就来从用户核心指标开始讲述内容。</p><h1 id="核心指标"><a href="#核心指标" class="headerlink" title="核心指标"></a>核心指标</h1><div class="note primary flat"><p>当用户打开一个页面，会经历一个这样的视觉过程：白屏-&gt;底图-&gt;出现部分内容-&gt;首屏内容出现，但图片还在加载中-&gt;首屏内容和图片都加载完毕</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220502163126.png" alt=""></p><p>一般在这个首屏的内容大部分被加载的时候，用户才能开始和页面进行交互等操作，所以如果这段响应的时间很长，就会导致用户的体验很差，下面的几个核心指标描述这些过程的关键变化点，通过它们我们可以来了解用户体验。</p><ul><li>LCP 最大内容绘制</li><li>FID 第一次交互的延迟</li><li>CLS 累计位移偏差</li></ul><h1 id="Largest-Contentful-Paint-LCP"><a href="#Largest-Contentful-Paint-LCP" class="headerlink" title="Largest Contentful Paint(LCP)"></a>Largest Contentful Paint(LCP)</h1><div class="note primary flat"><p>最大内容绘制，用于记录视窗内最大元素的绘制时间，这个可能随着页面的渲染发生变化。且在用户第一次交互后停止记录。</p></div><p>LCP会持续更新，因此在页面的骨架屏或者loading动画存在的时候，FCP已经记录完了，而LCP因为这个特性，可以让我们知道后续页面的主要内容是什么时候呈现的</p><p>最优时间在2.5s内</p><h2 id="LCP关注什么元素"><a href="#LCP关注什么元素" class="headerlink" title="LCP关注什么元素"></a>LCP关注什么元素</h2><ol><li><code>&lt;img&gt;</code> 元素</li><li><code>&lt;image&gt;</code>元素内的<code>&lt;svg&gt;</code>元素</li><li><code>&lt;video&gt;</code> 元素</li><li>通过 <code>url()</code> 函数加载背景图片的元素</li><li>包含文本节点或其他内联文本元素子级的块级元素。</li></ol><h2 id="改善LCP"><a href="#改善LCP" class="headerlink" title="改善LCP"></a>改善LCP</h2><div class="note primary flat"><p>改善LCP就要从为什么会造成LCP开始说明</p></div><ul><li>服务器响应时间慢 </li><li>阻断渲染的JS和CSS</li><li>资源加载时间慢</li><li>客户端渲染</li></ul><p>从以上的角度去改善LCP</p><h3 id="服务器优化"><a href="#服务器优化" class="headerlink" title="服务器优化"></a>服务器优化</h3><div class="note primary flat"><p>服务器涉及到TTFB这个指标，可以从以下几个方面来优化</p></div><ul><li>缓存HTML离线页面，缓存页面资源，减小浏览器对资源的请求(不是首次)</li><li>压缩HTML</li><li>使用preconnect尽快与服务器建立连接，使用dns-prefetch尽快进行DNS查找</li><li>使用CDN</li></ul><h3 id="优化阻断渲染的资源"><a href="#优化阻断渲染的资源" class="headerlink" title="优化阻断渲染的资源"></a>优化阻断渲染的资源</h3><div class="note primary flat"><p>JS和CSS阻断页面的渲染是无可避免的，我们只能通过CSS和JS压缩合并级联内联来减少</p></div><h3 id="优化资源加载时间"><a href="#优化资源加载时间" class="headerlink" title="优化资源加载时间"></a>优化资源加载时间</h3><div class="note primary flat"><p>上述我们知道LCP只和几个标签有关，那我们就从标签入手优化</p></div><ul><li>对图片进行优化，转WEBP</li><li>对重要的资源进行预加载，比如为 <code>style</code> 标签添加 <code>rel=&quot;preload&quot;</code> 属性</li><li>gzip压缩</li><li>service worker缓存资源</li></ul><h3 id="转服务端渲染"><a href="#转服务端渲染" class="headerlink" title="转服务端渲染"></a>转服务端渲染</h3><p>SSR</p><h1 id="First-Input-Delay-FID"><a href="#First-Input-Delay-FID" class="headerlink" title="First Input Delay(FID)"></a>First Input Delay(FID)</h1><div class="note primary flat"><p>首次输入延迟，记录了FCP和TTI之间用户首次与页面交互的时候响应的延迟。</p></div><p>这个指标衡量响应的延迟，也是表明长任务的一个指标。</p><h2 id="改善FID"><a href="#改善FID" class="headerlink" title="改善FID"></a>改善FID</h2><h3 id="减少JS执行时间"><a href="#减少JS执行时间" class="headerlink" title="减少JS执行时间"></a>减少JS执行时间</h3><p>同上LCP的方法</p><ul><li>缩小并压缩js</li><li>延迟加载首屏不需要的js</li><li>尽量减少未使用的polyfill</li></ul><h3 id="分解耗时任务"><a href="#分解耗时任务" class="headerlink" title="分解耗时任务"></a>分解耗时任务</h3><p>超过50ms的任务都称之为长任务，所以我们可以通过将长任务拆解称为较小的异步任务。</p><h3 id="使用Web-Worker"><a href="#使用Web-Worker" class="headerlink" title="使用Web Worker"></a>使用Web Worker</h3><p>主线程阻塞是FID的根本原因，所以使用Web Worker帮助你在和主线程分离的后台线程上运行js，从而改善FID</p><h1 id="Cumulative-Layout-Shift-CLS"><a href="#Cumulative-Layout-Shift-CLS" class="headerlink" title="Cumulative Layout Shift(CLS)"></a>Cumulative Layout Shift(CLS)</h1><div class="note primary flat"><p>累计位移偏差。也可以理解为视觉稳定性。这个指标是为了记录有些动态插入的内容影响用户的体验诞生的。计算的方法是：位移影响的面积*位移距离</p></div><p>期望值低于0.1是比较好的，说明页面跳来跳去的情况比较少。如果有广告插入对用户的体验也不是很好</p><h2 id="改善CLS"><a href="#改善CLS" class="headerlink" title="改善CLS"></a>改善CLS</h2><p>位移会造成CLS变大，那么就从这个方面开始改善。</p><h3 id="不使用无尺寸的元素"><a href="#不使用无尺寸的元素" class="headerlink" title="不使用无尺寸的元素"></a>不使用无尺寸的元素</h3><p>这方面的知识可能很多人都不是很清楚，我们除了要设置图片的长宽之外，还可以指定他的长宽比<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">  aspect-ratio: <span class="built_in">attr</span>(width)/ <span class="built_in">attr</span>(height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于响应式的图片，我们可以这样设置<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">img</span> </span><br><span class="line">    <span class="attribute">width</span>=&quot;<span class="number">1000</span>&quot; </span><br><span class="line">    <span class="attribute">height</span>=&quot;<span class="number">1000</span>&quot;</span><br><span class="line">    <span class="attribute">src</span>=&quot;puppy-<span class="number">1000</span><span class="selector-class">.jpg</span>&quot;</span><br><span class="line">    srcset=&quot;puppy-<span class="number">1000</span><span class="selector-class">.jpg</span> <span class="number">1000</span>w,</span><br><span class="line">            puppy-<span class="number">2000</span><span class="selector-class">.jpg</span> <span class="number">2000</span>w,</span><br><span class="line">            puppy-<span class="number">3000</span><span class="selector-class">.jpg</span> <span class="number">3000</span>w&quot;</span><br><span class="line">    alt=&quot;ConardLi&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p><ul><li>不要在现有的内容之上插入内容，除非是响应式的用户交互。</li><li>宁可转换动画，也不要转换触发布局变化的属性的动画</li></ul><h3 id="提前给广告位预留空间"><a href="#提前给广告位预留空间" class="headerlink" title="提前给广告位预留空间"></a>提前给广告位预留空间</h3><p>很多页面的广告都是动态插入的，所以要为广告位预留空间</p><h3 id="字体变化"><a href="#字体变化" class="headerlink" title="字体变化"></a>字体变化</h3><p>字体变化可以采用<code>font-display:swap</code>和<code>preload</code>的方式提前加载，还有转格式并压缩的方式。</p><h1 id="First-Paint-FP"><a href="#First-Paint-FP" class="headerlink" title="First Paint (FP)"></a>First Paint (FP)</h1><div class="note primary flat"><p>从开始加载到浏览器首次绘制像素到屏幕上的时间，也就是页面在屏幕上首次发生视觉变化的时间。但此变化可能是简单的背景色更新或者不引人注意的内容，她并不代表页面的完整性，可能会报告没有任何可见内容被绘制的时间</p></div><h2 id="测量方式"><a href="#测量方式" class="headerlink" title="测量方式"></a>测量方式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstPaint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> firstPaints = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> performance.getEntriesByType === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> performanceEntries = performance.getEntriesByType(<span class="string">&#x27;paint&#x27;</span>) || [];</span><br><span class="line">    performanceEntries.forEach(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry.name === <span class="string">&#x27;first-paint&#x27;</span>) &#123;</span><br><span class="line">        firstPaints.firstPaint = entry.startTime;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.name === <span class="string">&#x27;first-contentful-paint&#x27;</span>) &#123;</span><br><span class="line">        firstPaints.firstContentfulPaint = entry.startTime;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (chrome &amp;&amp; chrome.loadTimes) &#123;</span><br><span class="line">      <span class="keyword">let</span> loadTimes = <span class="built_in">window</span>.chrome.loadTimes();</span><br><span class="line">      <span class="keyword">let</span> &#123;firstPaintTime, startLoadTime&#125; = loadTimes;</span><br><span class="line">      firstPaints.firstPaint = (firstPaintTime - startLoadTime) * <span class="number">1000</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (performance.timing &amp;&amp; <span class="keyword">typeof</span> performance.timing.msFirstPaint === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123;msFirstPaint, navigationStart&#125; = performance.timing;</span><br><span class="line">      firstPaints.firstPaint = msFirstPaint - navigationStart;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> firstPaints;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="First-Contentful-Paint-FCP"><a href="#First-Contentful-Paint-FCP" class="headerlink" title="First Contentful Paint (FCP)"></a>First Contentful Paint (FCP)</h1><div class="note primary flat"><p>这个指标用于记录浏览器首次绘制来自DOM内容的时间，内容必须是文本、图片(包含背景图)、非白色的canvas或SVG、也包含正在加载中的Web字体的文本。</p></div><p>该阶段用户看到的可能是一个header或者导航栏，并不一定是用户值得消费的内容</p><p>且字体对FCP影响比较大，我们可以使用<code>font-display:swap</code>的方式让浏览器一开始就使用系统的字体，等字体更新好再使用自定义的字体</p><p>字体的优化还可以从格式上，比如将：</p><p>FCP的测量方式见FP</p><p>最优时间<br>关于这两个指标，有如下的时间体验<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220502170159.png" alt=""></p><p>我们可以看出在2s以内能完成就算体验优秀，详细的也可以在LightHouse中查看</p><h1 id="Time-to-Interactive-TTI"><a href="#Time-to-Interactive-TTI" class="headerlink" title="Time to Interactive(TTI)"></a>Time to Interactive(TTI)</h1><div class="note primary flat"><p>首次可交互时间，计算比较复杂，需要满足以下几个条件</p></div><ol><li>FCP指标之后开始计算</li><li>持续五秒没有长任务（执行时间超过50ms）且无两个以上正在进行的GET请求<br>3， 往前回溯至5s前的最后一个长任务结束时间。</li></ol><p>50ms是谷歌定义的，推荐的响应时间是100ms以内，如果超过了这个时间，用户会有延迟感。</p><p>这个指标衡量了响应交互。</p><h1 id="Total-Blocking-Time-TBT"><a href="#Total-Blocking-Time-TBT" class="headerlink" title="Total Blocking Time(TBT)"></a>Total Blocking Time(TBT)</h1><div class="note primary flat"><p>阻塞总时间，记录了FCP到TTI之间所有长任务的阻塞时间总和。</p></div><h1 id="Time-to-First-Byte-TTFB"><a href="#Time-to-First-Byte-TTFB" class="headerlink" title="Time to First Byte(TTFB)"></a>Time to First Byte(TTFB)</h1><p>服务器有关<br><div class="note primary flat"><p>浏览器从请求页面开始到接收第一字节的时间，这个时间段内包括 DNS 查找、TCP 连接和 SSL 连接。</p></div></p><h1 id="DomContentLoaded（DCL）"><a href="#DomContentLoaded（DCL）" class="headerlink" title="DomContentLoaded（DCL）"></a>DomContentLoaded（DCL）</h1><div class="note primary flat"><p>DomContentLoaded 事件触发的时间。当 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架加载完成。</p></div><h1 id="Load-L"><a href="#Load-L" class="headerlink" title="Load(L)"></a>Load(L)</h1><div class="note primary flat"><p>onLoad 事件触发的时间。页面所有资源都加载完毕后（比如图片，CSS），onLoad 事件才被触发。</p></div><h1 id="关于核心指标"><a href="#关于核心指标" class="headerlink" title="关于核心指标"></a>关于核心指标</h1><p>LCP代表了页面的速度，且LCP在目前流行loading和骨架屏的情况下，能体现的东西就更多了。他的指标实时更新，数据更精确，且代表着页面最大元素的渲染时间，通常来说最大元素的快速加载能让用户感觉性能还好。</p><p>FID表示页面的交互体验指标，如果他快说明交互的延迟低，会让用户觉得网页流畅。</p><p>CLS代表了页面的稳定性，尤其在手机上更为重要。因为收集屏幕小的原因，偏移差越多导致视觉交互越差，降低用户体验。</p><h1 id="关于指标收集"><a href="#关于指标收集" class="headerlink" title="关于指标收集"></a>关于指标收集</h1><h2 id="Lighthouse"><a href="#Lighthouse" class="headerlink" title="Lighthouse"></a>Lighthouse</h2><p>使用到了Lighthouse，这个是Chrome自带的性能指标获取器，会显示出具体的指标名称和时间，以及分数。</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220502193259.png" alt=""></p><h2 id="web-vitals-extension"><a href="#web-vitals-extension" class="headerlink" title="web-vitals-extension"></a>web-vitals-extension</h2><p>可以用这个插件来获取三大核心指标：LCP、FID、CLS</p><h2 id="web-vitals-库"><a href="#web-vitals-库" class="headerlink" title="web-vitals 库"></a>web-vitals 库</h2><p>使用这个库可以获取CLS、FID、LCP以及FCP、TTFB</p><p>使用方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;getCLS, getFID, getLCP&#125; <span class="keyword">from</span> <span class="string">&#x27;web-vitals&#x27;</span>;</span><br><span class="line"></span><br><span class="line">getCLS(<span class="built_in">console</span>.log);</span><br><span class="line">getFID(<span class="built_in">console</span>.log);</span><br><span class="line">getLCP(<span class="built_in">console</span>.log);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="Chrome-DevTools"><a href="#Chrome-DevTools" class="headerlink" title="Chrome DevTools"></a>Chrome DevTools</h2><p>打开performance就可以获取指标</p><h2 id="代码收集"><a href="#代码收集" class="headerlink" title="代码收集"></a>代码收集</h2><p>使用<code>window.performance</code>或其他第三方的库</p><h1 id="关于测试"><a href="#关于测试" class="headerlink" title="关于测试"></a>关于测试</h1><p>资源加载方面的延迟：使用sleep的方式人为的控制资源的加载时长。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./css/index.css?sleep=3000&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>网络方面的延迟：使用chrome的网速调节，可以方便我们测试占位图，骨架屏的情况。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="浏览器系列" scheme="https://zlinni.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="浏览器" scheme="https://zlinni.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>从0到1TypeScript</title>
    <link href="https://zlinni.github.io/posts/2090815300/"/>
    <id>https://zlinni.github.io/posts/2090815300/</id>
    <published>2022-04-26T14:23:37.000Z</published>
    <updated>2022-05-02T15:24:23.722Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>TS入门教程，从0到1</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/ts.png" alt=""></p><h1 id="TS介绍"><a href="#TS介绍" class="headerlink" title="TS介绍"></a>TS介绍</h1><h2 id="TS是什么？"><a href="#TS是什么？" class="headerlink" title="TS是什么？"></a>TS是什么？</h2><div class="note primary flat"><p>ts是js的超集，超集指的是他包含了es前面所有版本的内容并有自己的拓展。</p></div><h2 id="TS做到了什么？"><a href="#TS做到了什么？" class="headerlink" title="TS做到了什么？"></a>TS做到了什么？</h2><div class="note primary flat"><p>首先js是弱类型，很多错误在运行的时候才能发现。<br>ts使用了他的静态类型检测机制（后面提及）帮助我们提早发现错误。</p></div><h2 id="TS特点"><a href="#TS特点" class="headerlink" title="TS特点"></a>TS特点</h2><ol><li>支持最新的js特性（超集）</li><li>静态代码检查（解决弱类型）</li><li>有其他后端语言的特性（枚举，泛型，类型转化，命名空间，声明文件…)</li></ol><h1 id="静态类型检测"><a href="#静态类型检测" class="headerlink" title="静态类型检测"></a>静态类型检测</h1><p>为什么会产生这个问题？</p><div class="note primary flat"><p>js在运行代码的时候，需要我们人为的知道代码的返回值是什么，才能做出响应的操作（执行函数才能知道）。不能在我们书写的过程就立刻给出编译错误的反馈。<br>ts就能在（编译之前）告诉我们</p></div><h2 id="非异常故障"><a href="#非异常故障" class="headerlink" title="非异常故障"></a>非异常故障</h2><p>ts不仅能告诉我们哪些函数的值错误，还能识别类似于错别字，未调用函数和基本逻辑错误<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;ber&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">user.location</span><br></pre></td></tr></table></figure><br>上面这段代码在js中返回<code>undefined</code>,而在ts中提前告诉你这个变量没有定义不能使用</p><p><code>错别字</code>：告诉你对象上面某个方法拼写错误等</p><p><code>未调用函数</code>：函数没有加括号就使用，会提示未调用错误</p><p><code>逻辑错误</code>：比如只有两种条件的情况下，if一个条件又elseif另外一个条件，就会报错</p><h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><h2 id="安装ts"><a href="#安装ts" class="headerlink" title="安装ts"></a>安装ts</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g typescript</span><br></pre></td></tr></table></figure><h2 id="安装ts-node"><a href="#安装ts-node" class="headerlink" title="安装ts-node"></a>安装ts-node</h2><p>可以直接编译ts文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i -g ts-node</span><br><span class="line">//使用</span><br><span class="line">npx ts-node xxx.ts</span><br></pre></td></tr></table></figure></p><h2 id="创建一个tsconfig-json"><a href="#创建一个tsconfig-json" class="headerlink" title="创建一个tsconfig.json"></a>创建一个<code>tsconfig.json</code></h2><p>解决变量名or函数名相同报错的问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure></p><h2 id="官方playground"><a href="#官方playground" class="headerlink" title="官方playground"></a>官方playground</h2><p>官方提供的ts在线编译云环境—<a href="">playground</a></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>在对应的目录终端运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure></p><p>得到对应的js文件,执行node命令就可以执行js代码</p><h2 id="ts和js的冲突"><a href="#ts和js的冲突" class="headerlink" title="ts和js的冲突"></a>ts和js的冲突</h2><div class="note primary flat"><p>当我们将ts代码修改为一个函数并调用的时候，再次编译运行js文件，会产生冲突</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220430175814.png" alt=""></p><p>原因：函数名or变量名相同，重复定义</p><p>解决方法：</p><ol><li><code>tsc --init</code>生成配置文件</li><li>注释掉<code>&quot;strict&quot;: true,  o9</code></li></ol><h2 id="自动编译"><a href="#自动编译" class="headerlink" title="自动编译"></a>自动编译</h2><p><code>tsc --watch</code></p><h2 id="发出错误"><a href="#发出错误" class="headerlink" title="发出错误"></a>发出错误</h2><div class="note primary flat"><p>我们在ts里面报了错，但是在编译完之后，还是能运行js文件，如果我们要优化这个过程，结果为：ts编译报错就不生成js文件的话，需要如下：</p></div><p><code>tsc -noEmitOnError hello.ts</code></p><p>or</p><p><code>tsc -noEmitOnError --watch</code></p><h2 id="降级编译"><a href="#降级编译" class="headerlink" title="降级编译"></a>降级编译</h2><p>设置json里面的target为<code>es5</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220430195603.png" alt=""></p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><div class="note primary flat"><p>不同的用户希望在ts里面检查的严格程度是不一样的，配置如下</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220430195741.png" alt=""></p><p><code>strict</code>是包含了下面两个类型的模式</p><p><code>noImplicitAny</code>是指不可以忽略any，也就是要定义类型</p><p><code>strictNullChecks</code>意思是<code>null undefined</code>只能赋值给对应的类型</p><h1 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h1><h2 id="显式类型"><a href="#显式类型" class="headerlink" title="显式类型"></a>显式类型</h2><p>ts给我们提供了类型定义的注释，比如说<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">conflit</span>(<span class="params">person:<span class="built_in">string</span>,date:<span class="built_in">Date</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello,<span class="subst">$&#123;person&#125;</span>,<span class="subst">$&#123;date&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">conflit(<span class="string">&#x27;jojo&#x27;</span>,<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br></pre></td></tr></table></figure></p><p>但是在编译成js之后就会删去，可以方便程序员查看。</p><p>根据上面显式类型的说法我们知道了ts可以定义很多数据类型，比如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: string = <span class="string">&quot;jimmy&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> num: number = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">let</span> bool: boolean = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> obj: object = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> big: bigint = <span class="number">100n</span>;</span><br><span class="line"><span class="keyword">let</span> sym: symbol = <span class="built_in">Symbol</span>(<span class="string">&quot;me&quot;</span>); </span><br></pre></td></tr></table></figure></p><h2 id="几个需要留意的数据"><a href="#几个需要留意的数据" class="headerlink" title="几个需要留意的数据"></a>几个需要留意的数据</h2><div class="note primary flat"><p>当我们定义好类型的时候，如果给变量赋值别的类型是会报错提示的，但是有两个类型不一样</p></div><h3 id="null-amp-undefined"><a href="#null-amp-undefined" class="headerlink" title="null&amp;undefined"></a><code>null&amp;undefined</code></h3><p><code>null undefined</code>这两个类型可以作为其他所有类型的子类型,也就是可以把它们赋给别的值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// null和undefined赋值给string</span></span><br><span class="line"><span class="keyword">let</span> str:<span class="built_in">string</span> = <span class="string">&quot;666&quot;</span>;</span><br><span class="line">str = <span class="literal">null</span></span><br><span class="line">str= <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined赋值给number</span></span><br><span class="line"><span class="keyword">let</span> num:<span class="built_in">number</span> = <span class="number">666</span>;</span><br><span class="line">num = <span class="literal">null</span></span><br><span class="line">num= <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined赋值给object</span></span><br><span class="line"><span class="keyword">let</span> obj:<span class="built_in">object</span> =&#123;&#125;;</span><br><span class="line">obj = <span class="literal">null</span></span><br><span class="line">obj= <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined赋值给Symbol</span></span><br><span class="line"><span class="keyword">let</span> sym: symbol = <span class="built_in">Symbol</span>(<span class="string">&quot;me&quot;</span>); </span><br><span class="line">sym = <span class="literal">null</span></span><br><span class="line">sym= <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined赋值给boolean</span></span><br><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">isDone = <span class="literal">null</span></span><br><span class="line">isDone= <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined赋值给bigint</span></span><br><span class="line"><span class="keyword">let</span> big: bigint =  <span class="number">100n</span>;</span><br><span class="line">big = <span class="literal">null</span></span><br><span class="line">big= <span class="literal">undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>但如果在<code>tsconfig.json</code>里面指定了<code>&quot;strictNullChecks&quot;:true</code>那么它们只能被赋值给自己的类型或者void</p></div><h3 id="number-amp-bigint"><a href="#number-amp-bigint" class="headerlink" title="number&amp;bigint"></a><code>number&amp;bigint</code></h3><div class="note primary flat"><p>这两个值互不兼容，也就是说不能相互赋值，会报错</p></div><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><div class="note primary flat"><p>对数组的定义有两种方式</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arr:type[]</span></span><br><span class="line"><span class="keyword">let</span> arr:<span class="built_in">string</span>[] = [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>];</span><br><span class="line"><span class="comment">//arr:Array&lt;type&gt;这是泛型的定义方法</span></span><br><span class="line"><span class="keyword">let</span> arr2:<span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>]</span><br></pre></td></tr></table></figure><p>定义联合类型数组<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arr:(type1|type2)[]</span></span><br><span class="line"><span class="keyword">let</span> arr3:(<span class="built_in">number</span> | <span class="built_in">string</span>)[];</span><br><span class="line">arr3 = [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;sdcas&quot;</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br></pre></td></tr></table></figure></p><p>定义对象类型数组<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Arrobj &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr4:Arrobj[] = [&#123;<span class="attr">name</span>:<span class="string">&#x27;jojo&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;]</span><br></pre></td></tr></table></figure></p><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>定义成any类型的时候表示你不希望某个特定值导致类型错误的产生。</p><div class="note warning flat"><p>注意避免使用any 这样会丢失ts的保护机制</p></div><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>具名函数<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>,y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="note primary flat"><p>这个是告诉我们函数的返回值也可以指定类型，但一般不需要，因为ts会给我们自动判断返回值的类型</p></div><p>匿名函数：会自动根据上下文判断读取的数据类型是什么。</p><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用接口定义函数类型"><a href="#用接口定义函数类型" class="headerlink" title="用接口定义函数类型"></a>用接口定义函数类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc&#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用函数表达式接口定义函数类型的数据的时候，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数，参数类型，返回值类型不变。</p><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>使用<code>变量名?: type</code>的形式<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">number</span>,y?: <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y)&#123;</span><br><span class="line">      <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myFun(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(myFun(<span class="number">33</span>))</span><br></pre></td></tr></table></figure></p><div class="note warning flat"><p>注意可选参数后面不能再跟必需参数</p></div><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><p>在type后面加<code>= 默认值</code><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span> = <span class="number">22</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myFun(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(myFun(<span class="number">33</span>))</span><br></pre></td></tr></table></figure></p><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>注意需要用any来指定rest<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;, ...items: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">        arr.push(item);</span><br><span class="line">    &#125;)    </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(myFun(arr,<span class="number">3</span>,<span class="number">4</span>,<span class="number">543414</span>,<span class="number">123</span>))</span><br></pre></td></tr></table></figure></p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>js是动态语言，会根据不同的参数返回不同类型的调用结果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line">add(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>); <span class="comment">//&quot;12&quot;</span></span><br></pre></td></tr></table></figure></p><p>but如果开启了noImplicitAny的话，ts不能用上述代码，因为需要指定类型，所以就诞生了联合类型帮助我们根据不同的情况返回不同的结果</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Combination = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: Combination, y: Combination</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> y === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.toString() + y.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myFun(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(myFun(<span class="number">1</span>,<span class="string">&quot;3&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但其实到这一步，看似没有问题了，实际上新的问题又产生了<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Combination = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: Combination, y: Combination</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> y === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.toString() + y.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = myFun(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line">result.split(<span class="string">&quot; &quot;</span>);<span class="comment">//报错</span></span><br></pre></td></tr></table></figure></p><p>查看提示可以知道number类型上面没有方法split，为什么是number类型呢？因为我们这个参数虽然定义了组合类型，但是我们的ts并不知道返回值是什么类型，所以产生了函数重载</p><div class="note primary flat"><p>函数重载就是使用相同函数名称和不同参数类型或不同参数个数创建方法的一种能力</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Combination = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">number</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: Combination, y: Combination</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> y === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.toString() + y.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = myFun(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="keyword">const</span> res = result.split(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure><p>上述实现了函数的重载</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintCoord</span>(<span class="params">pt:&#123;x: <span class="built_in">number</span>,y: <span class="built_in">number</span>&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pt.x,pt.y);</span><br><span class="line">&#125;</span><br><span class="line">PrintCoord(&#123;<span class="attr">x</span>:<span class="number">333</span>,<span class="attr">y</span>:<span class="number">44</span>&#125;)</span><br></pre></td></tr></table></figure><p>配合可选参数+可选链的例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintCoord</span>(<span class="params">pt:&#123;x: <span class="built_in">number</span>,y?: <span class="built_in">string</span>&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pt.y?.toUpperCase())</span><br><span class="line">&#125;</span><br><span class="line">PrintCoord(&#123;<span class="attr">x</span>:<span class="number">333</span>,<span class="attr">y</span>:<span class="string">&#x27;jojo&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>我们定义接口可以用于类型的后续拓展，看基础应用如下<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">pt:Point</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pt.x+pt.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myFun(&#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>&#125;))</span><br></pre></td></tr></table></figure></p><p>拓展接口如下：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Bear <span class="keyword">extends</span> Animal&#123;</span><br><span class="line">    <span class="attr">honey</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bear: Bear = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;jobear&#x27;</span>,</span><br><span class="line">    <span class="attr">honey</span>:<span class="string">&#x27;蜂蜜&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bear)</span><br></pre></td></tr></table></figure></p><p>type的拓展 通过&amp;符号<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bear = Animal &amp;&#123;</span><br><span class="line">    <span class="attr">honey</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bear: Bear = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;jobear&#x27;</span>,</span><br><span class="line">    <span class="attr">honey</span>:<span class="string">&#x27;蜂蜜&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bear)</span><br></pre></td></tr></table></figure></p><p>向现有的类型添加字段(重复定义接口名字添加)<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> jojo &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> jojo &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> j: jojo = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;jojo&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(j)</span><br></pre></td></tr></table></figure></p><p>类型创建后不能更改<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> jojo = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> jojo = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//报错</span></span><br></pre></td></tr></table></figure></p><h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>void表示没有任何类型，一般的用处是函数没有返回值的时候定义为void<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>): <span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is a void function&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">myFunc()</span><br></pre></td></tr></table></figure></p><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p>never表示永不存在值的类型</p><p>比方说当函数遇到异常的时候，那么这个函数永远都不会有返回值，因为抛出异常直接中断了程序运行，不会到最后一步。</p><p>或者说代码中遇到无限循环的时候，程序永远到不了执行函数返回值的那一步，永不存在返回</p><p>使用的场景是：<br>针对于我们的代码来说，如果我们定义的联合类型被修改了，那么会因为我们事先在条件判断中写了never从而报错，因此在代码的安全性来讲never是比较可靠的使用。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">controlFlowAnalysisWithNever</span>(<span class="params">foo: Foo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里 foo 被收窄为 string 类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里 foo 被收窄为 number 类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// foo 在这里是 never</span></span><br><span class="line">    <span class="keyword">const</span> check: <span class="built_in">never</span> = foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果有人修改了type的类型 将报错</span></span><br></pre></td></tr></table></figure></p><h2 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h2><p>unknown定义的类型和any一样可以赋全部值</p><h2 id="不要弄混原始类型和对象类型"><a href="#不要弄混原始类型和对象类型" class="headerlink" title="不要弄混原始类型和对象类型"></a>不要弄混原始类型和对象类型</h2><div class="note primary flat"><p>我们在初学ts的时候，很容易把number，boolean这一类和<code>Number Boolean</code>搞混，实际上前者属于原始类型，后者属于原始类型的包装对象，在使用上面，前者可以赋值给后者，后者不能赋值给前者</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> Num: <span class="built_in">Number</span>;</span><br><span class="line">Num = num; <span class="comment">// ok</span></span><br><span class="line">num = Num; <span class="comment">// ts(2322)报错</span></span><br></pre></td></tr></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><div class="note primary flat"><p>元组用来限制数组元素的个数和类型，是ts独有的机制，适合用于多值返回</p></div><p>元组定义的数据必须类型和个数都要匹配<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>]; </span><br><span class="line"><span class="comment">// 类型必须匹配且个数必须为2</span></span><br><span class="line"></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]; <span class="comment">// OK </span></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>,<span class="number">10</span>]; <span class="comment">// Error </span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure></p><h3 id="元组的解构赋值"><a href="#元组的解构赋值" class="headerlink" title="元组的解构赋值"></a>元组的解构赋值</h3><div class="note primary flat"><p>元组也是支持解构赋值的</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> employee: [<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">1</span>, <span class="string">&quot;Semlinker&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> [id, username] = employee;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`id: <span class="subst">$&#123;id&#125;</span>`</span>);<span class="comment">//id 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`username: <span class="subst">$&#123;username&#125;</span>`</span>);<span class="comment">// username Semlinker</span></span><br></pre></td></tr></table></figure><h3 id="元组类型的可选元素"><a href="#元组类型的可选元素" class="headerlink" title="元组类型的可选元素"></a>元组类型的可选元素</h3><p>见例子知用法<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point = [<span class="built_in">number</span>, <span class="built_in">number</span>?, <span class="built_in">number</span>?];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x: Point = [<span class="number">10</span>]; <span class="comment">// 一维坐标点</span></span><br><span class="line"><span class="keyword">const</span> xy: Point = [<span class="number">10</span>, <span class="number">20</span>]; <span class="comment">// 二维坐标点</span></span><br><span class="line"><span class="keyword">const</span> xyz: Point = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">10</span>]; <span class="comment">// 三维坐标点</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x.length); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(xy.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(xyz.length); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><h3 id="元组的剩余元素"><a href="#元组的剩余元素" class="headerlink" title="元组的剩余元素"></a>元组的剩余元素</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RestTupleType = [<span class="built_in">number</span>, ...string[]];</span><br><span class="line"><span class="keyword">let</span> restTuple: RestTupleType = [<span class="number">666</span>, <span class="string">&quot;Semlinker&quot;</span>, <span class="string">&quot;Kakuqo&quot;</span>, <span class="string">&quot;Lolo&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(restTuple[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(restTuple[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h3 id="元组的只读类型"><a href="#元组的只读类型" class="headerlink" title="元组的只读类型"></a>元组的只读类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point: <span class="keyword">readonly</span> [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cannot assign to &#x27;0&#x27; because it is a read-only property.</span></span><br><span class="line">point[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// Property &#x27;push&#x27; does not exist on type &#x27;readonly [number, number]&#x27;.</span></span><br><span class="line">point.push(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// Property &#x27;pop&#x27; does not exist on type &#x27;readonly [number, number]&#x27;.</span></span><br><span class="line">point.pop();</span><br><span class="line"><span class="comment">// Property &#x27;splice&#x27; does not exist on type &#x27;readonly [number, number]&#x27;.</span></span><br><span class="line">point.splice(<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h1 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h1><p>ts提供了as xxx进行类型的断言，这样子我们在自身清楚实际的类型的情况下，让编译器不要干扰你的类型值，就好比any，但是使用了any就完全指定不了了，下面是一个例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayNumber: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> greaterThan2: <span class="built_in">number</span> = arrayNumber.find(<span class="function"><span class="params">num</span> =&gt;</span> num &gt; <span class="number">2</span>) <span class="keyword">as</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="built_in">console</span>.log(greaterThan2)</span><br></pre></td></tr></table></figure></p><p>告诉编译器我要编译出来的结果是什么类型</p><p>语法如下：两种类型<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尖括号 语法</span></span><br><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// as 语法</span></span><br><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure></p><p>尖括号语法会和react中的JSX冲突，所以更推荐使用as</p><h2 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h2><div class="note primary flat"><p>在上下文中ts的类型检查器无法判断类型的时候，使用<code>!</code>就可以用于断言操作对象是非null和非undefined类型<br>举例，x!将从x的值域排除null和undefined</p></div><p>eg<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumGenerator = <span class="function">() =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">numGenerator: NumGenerator | <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Object is possibly &#x27;undefined&#x27;.(2532)</span></span><br><span class="line">  <span class="comment">// Cannot invoke an object which is possibly &#x27;undefined&#x27;.(2722)</span></span><br><span class="line">  <span class="keyword">const</span> num1 = numGenerator(); <span class="comment">// Error</span></span><br><span class="line">  <span class="keyword">const</span> num2 = numGenerator!(); <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="确定赋值断言"><a href="#确定赋值断言" class="headerlink" title="确定赋值断言"></a>确定赋值断言</h2><div class="note primary flat"><p>在变量声明后面使用<code>!</code>这个断言,告诉ts这个变量会被明确的赋值</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x!: <span class="built_in">number</span>;</span><br><span class="line">initialize();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> * x); <span class="comment">// Ok</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不写该断言，则会报错为该数在赋值前被使用了。</p><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><div class="note primary flat"><p>ts独有的定义方式，js中没有，通过enum来进行定义</p></div><p>枚举会自动帮我们递增<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direaction&#123;</span><br><span class="line">    UP=<span class="number">1</span>,</span><br><span class="line">    DOWN,</span><br><span class="line">    LEFT,</span><br><span class="line">    RIGHT</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Direaction.UP);</span><br><span class="line"><span class="built_in">console</span>.log(Direaction.RIGHT);</span><br><span class="line"><span class="built_in">console</span>.log(Direaction.DOWN);</span><br><span class="line"><span class="built_in">console</span>.log(Direaction.LEFT);</span><br><span class="line"><span class="comment">//1 4 2 3</span></span><br></pre></td></tr></table></figure></p><h1 id="类型拓宽"><a href="#类型拓宽" class="headerlink" title="类型拓宽"></a>类型拓宽</h1><div class="note primary flat"><p>通过ts推断出来的类型就是字面量拓宽</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;this is string&#x27;</span>; <span class="comment">// 类型是 string</span></span><br><span class="line"><span class="keyword">let</span> strFun = <span class="function">(<span class="params">str = <span class="string">&#x27;this is string&#x27;</span></span>) =&gt;</span> str; <span class="comment">// 类型是 (str?: string) =&gt; string;</span></span><br><span class="line"><span class="keyword">const</span> specifiedStr = <span class="string">&#x27;this is string&#x27;</span>; <span class="comment">// 类型是 &#x27;this is string&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = specifiedStr; <span class="comment">// 类型是 &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">let</span> strFun2 = <span class="function">(<span class="params">str = specifiedStr</span>) =&gt;</span> str; <span class="comment">// 类型是 (str?: string) =&gt; string;</span></span><br></pre></td></tr></table></figure><h1 id="类型缩小"><a href="#类型缩小" class="headerlink" title="类型缩小"></a>类型缩小</h1><div class="note primary flat"><p>将类型声明细化为更具体的类型的过程我们称之为类型缩小</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span>, input: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>) + input;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> padding + input</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="真值缩小"><a href="#真值缩小" class="headerlink" title="真值缩小"></a>真值缩小</h2><div class="note primary flat"><p>使用条件、<code>&amp;&amp;、||</code>、if语句，布尔否定<code>!</code>进行缩小的方式称为真值缩小，常见如下：</p></div><ol><li>强制类型转换</li><li>使用Boolean</li><li>使用<code>!!</code>，第一个叹号将文字转换为布尔类型，再通过另外一个叹号转成真正的true或者false</li></ol><h2 id="等值缩小"><a href="#等值缩小" class="headerlink" title="等值缩小"></a>等值缩小</h2><div class="note primary flat"><p>ts可以通过真值判断类型，如下</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">x: <span class="built_in">number</span>|<span class="built_in">string</span>, y:<span class="built_in">boolean</span>|<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x===y)&#123;</span><br><span class="line">        x.toUpperCase;</span><br><span class="line">        y.toUpperCase;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="in缩小"><a href="#in缩小" class="headerlink" title="in缩小"></a>in缩小</h2><div class="note primary flat"><p>js的in操作符用于确定某个对象是否拥有该名称的属性</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220501210341.png" alt=""></p><h2 id="instanceof缩小"><a href="#instanceof缩小" class="headerlink" title="instanceof缩小"></a>instanceof缩小</h2><p>略</p><h2 id="分配缩小"><a href="#分配缩小" class="headerlink" title="分配缩小"></a>分配缩小</h2><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220501210631.png" alt=""></p><h2 id="类型谓词"><a href="#类型谓词" class="headerlink" title="类型谓词"></a>类型谓词</h2><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220501210749.png" alt=""></p><h1 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h1><div class="note primary flat"><p>ts支持三种字面量类型：字符串字面量、数字字面量、布尔字面量</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> specifiedStr: <span class="string">&#x27;this is string&#x27;</span> = <span class="string">&#x27;this is string&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> specifiedNum: <span class="number">1</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> specifiedBoolean: <span class="literal">true</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h1><div class="note primary flat"><p>使用|符号 </p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">&#x27;seven&#x27;</span>; <span class="comment">// OK</span></span><br><span class="line">myFavoriteNumber = <span class="number">7</span>; <span class="comment">// OK</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h1><div class="note primary flat"><p>和联合类型差不多，不过这里的符号用的是&amp;，可以理解为是所有类型都要有,类似于求并集</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntersectionType = &#123; <span class="attr">id</span>: <span class="built_in">number</span>; name: <span class="built_in">string</span>; &#125; &amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> mixed: IntersectionType = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>这里引申出一个问题，如果合并的是同名的属性类型会怎么样呢？</p></div><p>情况1 两个同名key 但是类型不同<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntersectionTypeConfict = &#123; <span class="attr">id</span>: <span class="built_in">number</span>; name: <span class="built_in">string</span>; &#125; </span><br><span class="line">&amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span>; name: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">const</span> mixedConflict: IntersectionTypeConfict = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="number">2</span>, <span class="comment">// ts(2322) 错误，&#x27;number&#x27; 类型不能赋给 &#x27;never&#x27; 类型</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这种情况下直接pass</p><p>情况2 两个同名key 类型相同， 但其中一个是另一个是子类型<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntersectionTypeConfict = &#123; <span class="attr">id</span>: <span class="built_in">number</span>; name: <span class="number">2</span>; &#125; </span><br><span class="line">&amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span>; name: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mixedConflict: IntersectionTypeConfict = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="number">2</span>, <span class="comment">// ok</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">mixedConflict = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="number">22</span>, <span class="comment">// &#x27;22&#x27; 类型不能赋给 &#x27;2&#x27; 类型</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>这种情况以子类型为主</p><p>情况3 两个同名key 类型不是基本类型<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>:&#123;<span class="attr">d</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  <span class="attr">x</span>:&#123;<span class="attr">e</span>:<span class="built_in">string</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> C &#123;</span><br><span class="line">  <span class="attr">x</span>:&#123;<span class="attr">f</span>:<span class="built_in">number</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ABC = A &amp; B &amp; C</span><br><span class="line"><span class="keyword">let</span> abc:ABC = &#123;</span><br><span class="line">  <span class="attr">x</span>:&#123;</span><br><span class="line">    <span class="attr">d</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">e</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">f</span>:<span class="number">666</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果是可以合并</p><h1 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h1><div class="note primary flat"><p>泛型可以帮助我们关联参数的值和返回值之间的关系，见下面的例子。</p></div><p>需求：如果我们要实现一个函数 identity，函数的参数可以是任何值，返回值就是将参数原样返回，并且其只能接受一个参数，你会怎么做？</p><p>由于其可以接受任意值，也就是说你的函数的入参和返回值都应该可以是任意类型。 现在让我们给代码增加类型声明：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> idBoolean = <span class="function">(<span class="params">arg: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">type</span> idNumber = <span class="function">(<span class="params">arg: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> idString = <span class="function">(<span class="params">arg: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>这样下来你每次都要写无穷无尽的代码，很明显是不太合理的，所以引出了泛型这个概念，下面看看泛型的用法：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中T是一个抽象类型type，只有在调用它的时候才确定它的值。</p><p>除了T以外，还有其他的泛型代表：</p><ol><li>K key 表示对象中的键类型</li><li>V value 表示对象中的值类型</li><li>E element 表示元素类型</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220501211814.png" alt=""></p><p>其实并不是只能定义一个类型变量，我们可以引入自定义的类型变量如下<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span> &lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">value: T, message: U</span>) : <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(identity&lt;<span class="built_in">Number</span>, <span class="built_in">string</span>&gt;(<span class="number">68</span>, <span class="string">&quot;Semlinker&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>也可以简略的调用,编译器会帮我们自动识别。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(identity(<span class="number">68</span>, <span class="string">&quot;Semlinker&quot;</span>));</span><br></pre></td></tr></table></figure></p><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><div class="note primary flat"><p>如果想打印出参数的size，直接使用是不行的，因为T只是类型，并不是所有方法的集合</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trace</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.size); <span class="comment">// Error: Property &#x27;size doesn&#x27;t exist on type &#x27;T&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何操作使得他能拥有这个size类型呢？其实很简单，只要你自己定义一个接口，让T去继承即可<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Sizeable&#123;</span><br><span class="line">    <span class="attr">size</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trace</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Sizeable</span>&gt;(<span class="params">args:T</span>): <span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(args.size);</span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="泛型工具类型"><a href="#泛型工具类型" class="headerlink" title="泛型工具类型"></a>泛型工具类型</h2><div class="note primary flat"><p>为了方便开发者，ts设置了一些工具类比如Partial、Required、Readonly等。但我们需要知道一些基础知识方便我们后续用这些工具类</p></div><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><div class="note primary flat"><p>关于typeof我们知道是用于判断类型的，但你可能不会做下面这样的事情</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> jojo: Person = &#123;<span class="attr">name</span>:<span class="string">&#x27;jojo&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">type</span> JOJO = <span class="keyword">typeof</span> jojo;<span class="comment">//type JOJO = Person</span></span><br></pre></td></tr></table></figure><p>在上述代码用了typeof获取了变量的类型并赋给了JOJO，后面我们就可以用到JOJO类型</p><p>除此之外，typeof还可以用来获取函数的类型、对象的结构类型<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Message = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;jimmy&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">      <span class="attr">province</span>: <span class="string">&#x27;四川&#x27;</span>,</span><br><span class="line">      <span class="attr">city</span>: <span class="string">&#x27;成都&#x27;</span>   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> message = <span class="keyword">typeof</span> Message;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> type message = &#123;</span></span><br><span class="line"><span class="comment">    name: string;</span></span><br><span class="line"><span class="comment">    age: number;</span></span><br><span class="line"><span class="comment">    address: &#123;</span></span><br><span class="line"><span class="comment">        province: string;</span></span><br><span class="line"><span class="comment">        city: string;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">Array</span>&lt;<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Func = <span class="keyword">typeof</span> toArray; <span class="comment">// -&gt; (x: number) =&gt; number[]</span></span><br></pre></td></tr></table></figure></p><h3 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h3><div class="note primary flat"><p>该方法返回类型的所有键，返回值是联合类型</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> K1 = keyof Person; <span class="comment">// &quot;name&quot; | &quot;age&quot;</span></span><br><span class="line"><span class="keyword">type</span> K2 = keyof Person[]; <span class="comment">// &quot;length&quot; | &quot;toString&quot; | &quot;pop&quot; | &quot;push&quot; | &quot;concat&quot; | &quot;join&quot; </span></span><br><span class="line"><span class="keyword">type</span> K3 = keyof &#123; [x: <span class="built_in">string</span>]: Person &#125;;  <span class="comment">// string | number</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>keyof的作用<br><div class="note primary flat"><p>js是一门高度动态的语言，所以有些时候在我们的ts里面想要捕获到某些操作可能很麻烦，比如</p></div></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prop</span>(<span class="params">obj:<span class="built_in">object</span>,key:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Element implicitly has an &#x27;any&#x27; type because expression of type &#x27;string&#x27; can&#x27;t be used to index type &#x27;&#123;&#125;&#x27;.</span></span><br></pre></td></tr></table></figure><p>元素隐式的拥有any类型，所以string类型不能用于索引{}类型，因此我们需要利用到keyof和泛型来帮助我们解决这个问题</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prop</span>&lt;<span class="title">T</span> <span class="title">extend</span> <span class="title">object</span>,<span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T,key: K</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述的代码中，T约束了object，K约束了T的所有键，所以非常的合理，此时访问不存在的属性的时候，也会提示错误了。</p><h3 id="in-具体场景？"><a href="#in-具体场景？" class="headerlink" title="in(具体场景？)"></a>in(具体场景？)</h3><div class="note primary flat"><p>in用来遍历枚举类型</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Keys = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Obj =  &#123;</span><br><span class="line">  [p <span class="keyword">in</span> Keys]: <span class="built_in">any</span></span><br><span class="line">&#125; <span class="comment">// -&gt; &#123; a: any, b: any, c: any &#125;</span></span><br></pre></td></tr></table></figure><h3 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h3><div class="note primary flat"><p>infer就是取到函数值的返回类型，方便后续使用</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...args: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><div class="note primary flat"><p>添加约束，上面已经讲到了用法和场景，略</p></div><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><div class="note primary flat"><p>在实际开发中，我们经常需要在对象中获取一些值然后建立对应的集合</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;musion&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">35</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValues</span>(<span class="params">person: <span class="built_in">any</span>, keys: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keys.map(<span class="function"><span class="params">key</span> =&gt;</span> person[key])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getValues(person, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])) <span class="comment">// [&#x27;musion&#x27;, 35]</span></span><br><span class="line"><span class="built_in">console</span>.log(getValues(person, [<span class="string">&#x27;gender&#x27;</span>])) <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure><p>但此时ts并没有对不存在的值进行报错，通过这里我们想到了keyof+extends,结合我们的索引类型操作符[]</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValues</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">person: T, keys: K[]</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> keys.map(<span class="function"><span class="params">key</span> =&gt;</span> person[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;musion&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">35</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getValues(person, [<span class="string">&#x27;name&#x27;</span>]) <span class="comment">// [&#x27;musion&#x27;]</span></span><br><span class="line">getValues(person, [<span class="string">&#x27;gender&#x27;</span>]) <span class="comment">// 报错：</span></span><br><span class="line"><span class="comment">// Argument of Type &#x27;&quot;gender&quot;[]&#x27; is not assignable to parameter of type &#x27;(&quot;name&quot; | &quot;age&quot;)[]&#x27;.</span></span><br><span class="line"><span class="comment">// Type &quot;gender&quot; is not assignable to type &quot;name&quot; | &quot;age&quot;.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码中，<code>T[K]</code>表示对象T的属性K所表示的类型，那么<code>T[K][]</code>就是对象T的属性K所表示类型的数组。</p><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><div class="note primary flat"><p>根据旧的类型创造出新的类型，称之为映射类型</p></div><p>映射类型的用法非常巧妙，如下例子将接口的所有属性变成可选<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> TestInterface&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//希望将接口的所有属性变成可选</span></span><br><span class="line"><span class="comment">//在ts中可以通过+/-添加或者删除</span></span><br><span class="line"><span class="keyword">type</span> OptionTestInterface&lt;T&gt; = &#123;</span><br><span class="line">    [p <span class="keyword">in</span> keyof T]+?:T[p]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> newTestInterface = OptionTestInterface&lt;TestInterface&gt;</span><br><span class="line"><span class="comment">// type newTestInterface = &#123;</span></span><br><span class="line"><span class="comment">//    name?:string,</span></span><br><span class="line"><span class="comment">//    age?:number</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>将接口的所有属性变成只读<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> OptionalTestInterface&lt;T&gt; = &#123;</span><br><span class="line"> +<span class="keyword">readonly</span> [p <span class="keyword">in</span> keyof T]+?:T[p]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> newTestInterface = OptionalTestInterface&lt;TestInterface&gt;</span><br><span class="line"><span class="comment">// type newTestInterface = &#123;</span></span><br><span class="line"><span class="comment">//   readonly name?:string,</span></span><br><span class="line"><span class="comment">//   readonly age?:number</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>由于生成只读和可选属性比较常用，ts已经内置了Readonly和Partial工具类型</p><h3 id="Partial-可选"><a href="#Partial-可选" class="headerlink" title="Partial 可选"></a>Partial 可选</h3><p>我们看例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInfo&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变成可选</span></span><br><span class="line"><span class="keyword">type</span> newUserInfo = Partial&lt;UserInfo&gt;;</span><br><span class="line"><span class="comment">//interface newUserInfo &#123;</span></span><br><span class="line"><span class="comment">//    id?: string;</span></span><br><span class="line"><span class="comment">//    name?: string;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><div class="note warning flat"><p>Partial有局限性，他只负责第一层的数据，如果多层就要自己实现了。</p></div><h3 id="DeepPartial-深度可选"><a href="#DeepPartial-深度可选" class="headerlink" title="DeepPartial 深度可选"></a>DeepPartial 深度可选</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeepPartial&lt;T&gt; = &#123;</span><br><span class="line">    [U <span class="keyword">in</span> keyof T]?: T[U] <span class="keyword">extends</span> <span class="built_in">object</span></span><br><span class="line">    ? DeepPartial&lt;T[U]&gt;</span><br><span class="line">    : T[U]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> PartialedWindow = DeepPartial&lt;T&gt;; </span><br><span class="line"><span class="comment">//所有属性都变成可选了</span></span><br></pre></td></tr></table></figure><h3 id="Required-必选"><a href="#Required-必选" class="headerlink" title="Required 必选"></a>Required 必选</h3><div class="note primary flat"><p>将所有属性变成必选</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123; </span><br><span class="line">    [P <span class="keyword">in</span> keyof T]-?: T[P] </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中<code>-?</code>是为了移除可选</p><h3 id="Readonly-只读"><a href="#Readonly-只读" class="headerlink" title="Readonly 只读"></a>Readonly 只读</h3><div class="note primary flat"><p>只读，不可修改</p></div><p>原理<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line"> <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>eg<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line"> <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo: Readonly&lt;Todo&gt; = &#123;</span><br><span class="line"> <span class="attr">title</span>: <span class="string">&quot;Delete inactive users&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">todo.title = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// Error: cannot reassign a readonly property</span></span><br></pre></td></tr></table></figure></p><h3 id="Pick-挑选属性"><a href="#Pick-挑选属性" class="headerlink" title="Pick 挑选属性"></a>Pick 挑选属性</h3><p>原理<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  description: <span class="built_in">string</span>;</span><br><span class="line">  completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TodoPreview = Pick&lt;Todo, <span class="string">&quot;title&quot;</span> | <span class="string">&quot;completed&quot;</span>&gt;;</span><br><span class="line"><span class="comment">//TodoPreview 只有title和completed了</span></span><br><span class="line"><span class="keyword">const</span> todo: TodoPreview = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Clean room&quot;</span>,</span><br><span class="line">  <span class="attr">completed</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><div class="note primary flat"><p>将K中所有属性值转换为T类型</p></div><p>原理<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PageInfo &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Page = <span class="string">&quot;home&quot;</span> | <span class="string">&quot;about&quot;</span> | <span class="string">&quot;contact&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x: Record&lt;Page, PageInfo&gt; = &#123;</span><br><span class="line">  <span class="attr">about</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;about&quot;</span> &#125;,</span><br><span class="line">  <span class="attr">contact</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;contact&quot;</span> &#125;,</span><br><span class="line">  <span class="attr">home</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;home&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="ReturnType-获取返回类型"><a href="#ReturnType-获取返回类型" class="headerlink" title="ReturnType 获取返回类型"></a>ReturnType 获取返回类型</h3><div class="note primary flat"><p>得到函数的返回值类型</p></div><p>原理<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...args: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Func = <span class="function">(<span class="params">value: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">const</span> foo: ReturnType&lt;Func&gt; = <span class="string">&quot;1&quot;</span>;</span><br></pre></td></tr></table></figure><br><code>ReturnType</code>获取到Func的类型是字符串，所以foo也只能被赋为字符串了</p><h3 id="Exclude-移除"><a href="#Exclude-移除" class="headerlink" title="Exclude 移除"></a>Exclude 移除</h3><div class="note primary flat"><p>将某个类型中属于另外一个的类型移除，类似于类型去重</p></div><p>原理<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T0 = Exclude&lt;<span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>&gt;; <span class="comment">// &quot;b&quot; | &quot;c&quot;</span></span><br><span class="line"><span class="keyword">type</span> T1 = Exclude&lt;<span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span>&gt;; <span class="comment">// &quot;c&quot;</span></span><br><span class="line"><span class="keyword">type</span> T2 = Exclude&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | (<span class="function">() =&gt;</span> <span class="built_in">void</span>), <span class="built_in">Function</span>&gt;; <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure></p><h3 id="Extract-提取"><a href="#Extract-提取" class="headerlink" title="Extract 提取"></a>Extract 提取</h3><div class="note primary flat"><p>从T中提取U,类似于找到唯一值</p></div><p>原理<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Extract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T0 = Extract&lt;<span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span> | <span class="string">&quot;f&quot;</span>&gt;; <span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="keyword">type</span> T1 = Extract&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | (<span class="function">() =&gt;</span> <span class="built_in">void</span>), <span class="built_in">Function</span>&gt;; <span class="comment">// () =&gt;void</span></span><br></pre></td></tr></table></figure></p><h3 id="Omit-排他"><a href="#Omit-排他" class="headerlink" title="Omit 排他"></a>Omit 排他</h3><div class="note primary flat"><p>Omit类似于排他思想 除了自己之外的都能用</p></div><p>原理<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Omit&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  description: <span class="built_in">string</span>;</span><br><span class="line">  completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TodoPreview = Omit&lt;Todo, <span class="string">&quot;description&quot;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo: TodoPreview = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Clean room&quot;</span>,</span><br><span class="line">  <span class="attr">completed</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="NonNullable-排null-amp-undefined"><a href="#NonNullable-排null-amp-undefined" class="headerlink" title="NonNullable 排null&amp;undefined"></a>NonNullable 排null&amp;undefined</h3><div class="note primary flat"><p>NonNullable用于过滤null和undefined</p></div><p>原理<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NonNullable&lt;T&gt; = T extendsnull | <span class="literal">undefined</span> ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T0 = NonNullable&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">undefined</span>&gt;; <span class="comment">// string | number</span></span><br><span class="line"><span class="keyword">type</span> T1 = NonNullable&lt;<span class="built_in">string</span>[] | <span class="literal">null</span> | <span class="literal">undefined</span>&gt;; <span class="comment">// string[]</span></span><br></pre></td></tr></table></figure></p><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><div class="note primary flat"><p>用于获取参数类型组成的元组类型</p></div><p>原理<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Parameters&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: infer P) =&gt; <span class="built_in">any</span></span><br><span class="line">? P : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = Parameters&lt;<span class="function">() =&gt;</span><span class="built_in">void</span>&gt;; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">type</span> B = Parameters&lt;typeofArray.isArray&gt;; <span class="comment">// [any]</span></span><br><span class="line"><span class="keyword">type</span> C = Parameters&lt;typeofparseInt&gt;; <span class="comment">// [string, (number | undefined)?]</span></span><br><span class="line"><span class="keyword">type</span> D = Parameters&lt;typeofMath.max&gt;; <span class="comment">// number[]</span></span><br></pre></td></tr></table></figure></p><h1 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a><code>tsconfig.json</code></h1><div class="note primary flat"><p>他是ts的重要配置文件，相当于<code>vue.config.js</code>，在这里讲几个重要的配置</p></div><p>files -设置要编译的文件名字<br>include -设置需要进行编译的文件，支持路径模式匹配<br>exclude -设置无需编译的文件，支持路径模式匹配<br>compilerOptions -设置与编译流程相关的选项</p><h2 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a>compilerOptions</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 基本选项 */</span></span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>,                       <span class="comment">// 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span></span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span>,                  <span class="comment">// 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span></span><br><span class="line">    <span class="string">&quot;lib&quot;</span>: [],                             <span class="comment">// 指定要包含在编译中的库文件</span></span><br><span class="line">    <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span>,                       <span class="comment">// 允许编译 javascript 文件</span></span><br><span class="line">    <span class="string">&quot;checkJs&quot;</span>: <span class="literal">true</span>,                       <span class="comment">// 报告 javascript 文件中的错误</span></span><br><span class="line">    <span class="string">&quot;jsx&quot;</span>: <span class="string">&quot;preserve&quot;</span>,                     <span class="comment">// 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span></span><br><span class="line">    <span class="string">&quot;declaration&quot;</span>: <span class="literal">true</span>,                   <span class="comment">// 生成相应的 &#x27;.d.ts&#x27; 文件</span></span><br><span class="line">    <span class="string">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,                     <span class="comment">// 生成相应的 &#x27;.map&#x27; 文件</span></span><br><span class="line">    <span class="string">&quot;outFile&quot;</span>: <span class="string">&quot;./&quot;</span>,                       <span class="comment">// 将输出文件合并为一个文件</span></span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;./&quot;</span>,                        <span class="comment">// 指定输出目录</span></span><br><span class="line">    <span class="string">&quot;rootDir&quot;</span>: <span class="string">&quot;./&quot;</span>,                       <span class="comment">// 用来控制输出目录结构 --outDir.</span></span><br><span class="line">    <span class="string">&quot;removeComments&quot;</span>: <span class="literal">true</span>,                <span class="comment">// 删除编译后的所有的注释</span></span><br><span class="line">    <span class="string">&quot;noEmit&quot;</span>: <span class="literal">true</span>,                        <span class="comment">// 不生成输出文件</span></span><br><span class="line">    <span class="string">&quot;importHelpers&quot;</span>: <span class="literal">true</span>,                 <span class="comment">// 从 tslib 导入辅助工具函数</span></span><br><span class="line">    <span class="string">&quot;isolatedModules&quot;</span>: <span class="literal">true</span>,               <span class="comment">// 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 严格的类型检查选项 */</span></span><br><span class="line">    <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span>,                        <span class="comment">// 启用所有严格类型检查选项</span></span><br><span class="line">    <span class="string">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>,                 <span class="comment">// 在表达式和声明上有隐含的 any类型时报错</span></span><br><span class="line">    <span class="string">&quot;strictNullChecks&quot;</span>: <span class="literal">true</span>,              <span class="comment">// 启用严格的 null 检查</span></span><br><span class="line">    <span class="string">&quot;noImplicitThis&quot;</span>: <span class="literal">true</span>,                <span class="comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span></span><br><span class="line">    <span class="string">&quot;alwaysStrict&quot;</span>: <span class="literal">true</span>,                  <span class="comment">// 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 额外的检查 */</span></span><br><span class="line">    <span class="string">&quot;noUnusedLocals&quot;</span>: <span class="literal">true</span>,                <span class="comment">// 有未使用的变量时，抛出错误</span></span><br><span class="line">    <span class="string">&quot;noUnusedParameters&quot;</span>: <span class="literal">true</span>,            <span class="comment">// 有未使用的参数时，抛出错误</span></span><br><span class="line">    <span class="string">&quot;noImplicitReturns&quot;</span>: <span class="literal">true</span>,             <span class="comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span></span><br><span class="line">    <span class="string">&quot;noFallthroughCasesInSwitch&quot;</span>: <span class="literal">true</span>,    <span class="comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 模块解析选项 */</span></span><br><span class="line">    <span class="string">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>,            <span class="comment">// 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span></span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>,                       <span class="comment">// 用于解析非相对模块名称的基目录</span></span><br><span class="line">    <span class="string">&quot;paths&quot;</span>: &#123;&#125;,                           <span class="comment">// 模块名到基于 baseUrl 的路径映射的列表</span></span><br><span class="line">    <span class="string">&quot;rootDirs&quot;</span>: [],                        <span class="comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span></span><br><span class="line">    <span class="string">&quot;typeRoots&quot;</span>: [],                       <span class="comment">// 包含类型声明的文件列表</span></span><br><span class="line">    <span class="string">&quot;types&quot;</span>: [],                           <span class="comment">// 需要包含的类型声明文件名列表</span></span><br><span class="line">    <span class="string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,  <span class="comment">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="string">&quot;sourceRoot&quot;</span>: <span class="string">&quot;./&quot;</span>,                    <span class="comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span></span><br><span class="line">    <span class="string">&quot;mapRoot&quot;</span>: <span class="string">&quot;./&quot;</span>,                       <span class="comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span></span><br><span class="line">    <span class="string">&quot;inlineSourceMap&quot;</span>: <span class="literal">true</span>,               <span class="comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span></span><br><span class="line">    <span class="string">&quot;inlineSources&quot;</span>: <span class="literal">true</span>,                 <span class="comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他选项 */</span></span><br><span class="line">    <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>,        <span class="comment">// 启用装饰器</span></span><br><span class="line">    <span class="string">&quot;emitDecoratorMetadata&quot;</span>: <span class="literal">true</span>          <span class="comment">// 为装饰器提供元数据的支持</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端登陆指南</title>
    <link href="https://zlinni.github.io/posts/3355969119/"/>
    <id>https://zlinni.github.io/posts/3355969119/</id>
    <published>2022-04-24T02:15:14.000Z</published>
    <updated>2022-04-25T02:41:30.129Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>前端登陆的四种方式介绍以及应用</p></div><p>关键词：Cookie/Session、Token、SSO单点登录、OAuth第三方登陆<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220424211445.png" alt=""></p><h1 id="验证登陆"><a href="#验证登陆" class="headerlink" title="验证登陆"></a>验证登陆</h1><ul><li>Cookie/Session</li><li>Token </li><li>SSO 单点登陆</li><li>OAuth第三方登陆</li></ul><h1 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie session"></a>cookie session</h1><p>登陆流程：首次登陆<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414092439.png" alt=""></p><ol><li>用户访问<code>a.com/pageA</code>并输入密码登陆</li><li>服务器验证密码无误后，会创建Session ID并将其保存起来</li><li>服务端响应这个请求，并通过Set-Cookie将Session ID写入Cookie中</li></ol><p>再次登陆：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414092643.png" alt=""></p><ol><li>用户访问<code>a.com/pageB</code>自动带上第一次登陆写入的Cookie</li><li>服务端对比Cookie中的SessionID和保存在服务端的SessionID是否一致</li><li>一致则成功</li></ol><h2 id="cookie-session存在的问题"><a href="#cookie-session存在的问题" class="headerlink" title="cookie session存在的问题"></a>cookie session存在的问题</h2><ul><li>服务器需要对接大量的客户端，导致服务器压力大。</li><li>如果服务器是一个集群，为了同步登陆态，就需要将SessionID同步到每一台机器上，无形中增加了服务器的维护成本。</li><li>由于SessionID存放在Cookie中所以无法避免CSRF攻击</li></ul><h1 id="token登陆"><a href="#token登陆" class="headerlink" title="token登陆"></a>token登陆</h1><p>为了解决cookie+session暴露出来的问题，我们可以使用token的登陆方式<br><div class="note primary flat"><p>token是服务端生成的一串字符串，以作为客户端请求的一个令牌。当第一次登陆完成后，服务器会生成一个token并返回给客户端，客户端后续访问只要带上这个token就可以完成身份验证。</p></div></p><h2 id="token机制实现流程"><a href="#token机制实现流程" class="headerlink" title="token机制实现流程"></a>token机制实现流程</h2><p>首次登陆：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414102745.png" alt=""></p><ol><li>用户输入账号密码，并点击登录。</li><li>服务器端验证账号密码无误，创建 Token。</li><li>服务器端将 Token 返回给客户端，由客户端自由保存。</li></ol><p>后续页面访问时：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414102830.png" alt=""></p><ol><li>用户访问 a.com/pageB 时，带上第一次登录时获取的 Token。</li><li>服务器端验证 Token ，有效则身份验证成功。</li></ol><h2 id="Token-机制的特点"><a href="#Token-机制的特点" class="headerlink" title="Token 机制的特点"></a>Token 机制的特点</h2><p>根据上面的案例，我们可以分析出Token的优缺点：</p><ul><li>服务器端不需要存放token，所以不会对服务器造成压力，即使服务器集群，也不需要增加维护成本。</li><li>Token可以存放在前端的任何地方，可以不用保存在Cookie中，提升了页面的安全性。</li><li>Token下发之后，只要在生效时间内，就一直有效，如果服务器想收回此token的权限，并不容易。</li></ul><h2 id="Token的生成方式"><a href="#Token的生成方式" class="headerlink" title="Token的生成方式"></a>Token的生成方式</h2><p>最常见的Token生成方式是使用JWT，他是一种简洁的，自包含的方法用于通信双方之间以JSON对象的形式安全的传递信息。</p><p>上文中我们说到，使用Token后，服务器端并不会存储Token，那怎么判断客户端的token是否合法有效？</p><p>答案其实就在Token字符串中，其实Token并不是一串杂乱无章的字符串，而是通过多种算法拼接组合而成的字符串。如下：</p><p>JWT算法主要分成了三个部分 </p><ul><li>header 头信息</li><li>payload 消息体</li><li>signature 签名</li></ul><p>header部分指定了JWT使用的签名算法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header = <span class="string">&#x27;&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;&#x27;</span>   <span class="comment">// `HS256` 表示使用了 HMAC-SHA256 来生成签名。</span></span><br></pre></td></tr></table></figure></p><p>payload部分指明了JWT的使用意图<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;&#123;&quot;loggedInAs&quot;:&quot;admin&quot;,&quot;iat&quot;:1422779638&#125;&#x27;</span>     <span class="comment">//iat 表示令牌生成的时间</span></span><br></pre></td></tr></table></figure></p><p>signature部分为JWT的签名 主要为了让JWT不能随意更改，签名的方法分为两个步骤</p><ol><li>输入base64url编码的header部分，base64url编码的payload部分，输出unsignedToken</li><li>输入服务器端私钥，unsignedToken,输出signature签名</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base64Header = encodeBase64(header)</span><br><span class="line"><span class="keyword">const</span> base64Payload = encodeBase64(payload)</span><br><span class="line"><span class="keyword">const</span> unsignedToken = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;服务器私钥&#x27;</span></span><br><span class="line"></span><br><span class="line">signature = HMAC(key, unsignedToken)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后Token计算如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base64Header = encodeBase64(header)</span><br><span class="line"><span class="keyword">const</span> base64Payload = encodeBase64(payload)</span><br><span class="line"><span class="keyword">const</span> base64Signature = encodeBase64(signature)</span><br><span class="line"></span><br><span class="line">token = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>.<span class="subst">$&#123;base64Signature&#125;</span>`</span></span><br></pre></td></tr></table></figure></p><p>服务器在判断token的时候<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [base64Header, base64Payload, base64Signature] = token.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> signature1 = decodeBase64(base64Signature)</span><br><span class="line"><span class="keyword">const</span> unsignedToken = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> signature2 = HMAC(<span class="string">&#x27;服务器私钥&#x27;</span>, unsignedToken)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(signature1 === signature2) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;签名验证成功，token 没有被篡改&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> payload =  decodeBase64(base64Payload)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Date</span>() - payload.iat &lt; <span class="string">&#x27;token 有效期&#x27;</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;token 有效&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有了 Token 之后，登录方式已经变得非常高效，接下来我们介绍另外两种登录方式。</p><h1 id="SSO单点登陆"><a href="#SSO单点登陆" class="headerlink" title="SSO单点登陆"></a>SSO单点登陆</h1><div class="note primary flat"><p>单点登陆指的是在公司内部搭建一个公共的认证中心，公司下的所有产品的登陆都可以在认证中心中完成，一个产品在认证中心登陆后，再去访问另外一个产品，可以不用再次登陆，即可获取登陆状态。</p></div><h2 id="SSO机制实现流程"><a href="#SSO机制实现流程" class="headerlink" title="SSO机制实现流程"></a>SSO机制实现流程</h2><p>分为同域和不同域。</p><h3 id="同域的单点登陆"><a href="#同域的单点登陆" class="headerlink" title="同域的单点登陆"></a>同域的单点登陆</h3><p>比如现在有一个域名叫<code>zlinni.cn</code>,然后我的其他页面分别为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.zlinni.cn</span><br><span class="line">b.zlinni.cn</span><br><span class="line">c.zlinni.cn</span><br><span class="line">login.zlinni.cn<span class="comment">//sso登陆系统</span></span><br></pre></td></tr></table></figure></p><p>那么此时我们只要满足在login中登陆，然后abc三个都登陆就完成了sso</p><p>实现的方式就是利用了cookie的path和domain，我们设置domain为<code>.zlinni.cn</code>，然后path为<code>/</code>就能实现所有的域名都共享login的cookie，就实现了单点登陆。</p><h3 id="不同域的单点登陆"><a href="#不同域的单点登陆" class="headerlink" title="不同域的单点登陆"></a>不同域的单点登陆</h3><p>用户首次访问需要在认证中心登陆：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220424182851.png" alt=""></p><ol><li>用户先访问<code>a.com</code>下面的pageA页面，然后系统发现它未登陆，给它重定向到sso认证中心</li><li>在sso中注册，提交登陆</li><li>sso验证账号密码有效，重定向到<code>a.com</code>并带上授权码ticket，再将sso的登录态写入cookie</li><li>此时a就拿着ticket去sso中验证是否有效。</li><li>在a的服务器中拿着ticket向sso验证确认真实性</li><li>验证成功后，服务器将写入两个信息到cookie，一个是ticket作为a的登录态，一个是sso的token记录sso的登录态</li></ol><p>抛出疑问：为什么要用ticket？这个问题我们后面再讲</p><p>然后登陆完成访问a下面的其他页面<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220424192857.png" alt=""></p><p>此时我们的cookie中携带了ticket，只要到服务端验证是否在有效的时间内即可。</p><p>访问b页面的时候（这个b页面是认证中心下面的不同产品，如果要做例子的话，可以认为a是新浪微博，b是新浪博客）<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220424193220.png" alt=""><br>此时由于我们的b是不同源的页面，所以cookie中是没有ticket的（！！！！非常重要），但是它重定向到sso中，sso中我们的cookie是存在登录态的，所以此时不需要再注册等操作，验证token之后，直接给b下发ticket即可。b再去验证ticket真实性即可完成登陆。</p><h2 id="为什么需要Ticket"><a href="#为什么需要Ticket" class="headerlink" title="为什么需要Ticket"></a>为什么需要Ticket</h2><p>ticket的存在是为了解决不同域携带的cookie不一样的问题</p><p>以上过程就解释了我们要用ticket的理由，因为a和b不是同源页面所以不会携带同样的ticket，但是sso中拥有登录态token所以我们会下发ticket到b中验证。</p><h2 id="SSO单点登陆退出"><a href="#SSO单点登陆退出" class="headerlink" title="SSO单点登陆退出"></a>SSO单点登陆退出</h2><p>单点登陆使得多个产品共享登录态，但是怎么做到在一个产品中退出登陆，其他的产品也退出呢？</p><p>这里其实要做的事情很简单，比如说退出这个bcom的登陆：</p><ol><li>首先我们要清除掉b中的ticket</li><li>认证中心sso中清除对应的cookie</li><li>sso遍历所有对应cookie下发了ticket的产品并删除。</li></ol><h2 id="总结sso"><a href="#总结sso" class="headerlink" title="总结sso"></a>总结sso</h2><p>sso就是类似于<code>Nginx+ticket+token</code>的组合.其中，我们利用它的重定向规则，可以将token存在sso的cookie中，将ticket返回到具体的页面存在cookie中，然后再认证完成登陆</p><h1 id="OAuth第三方登陆"><a href="#OAuth第三方登陆" class="headerlink" title="OAuth第三方登陆"></a>OAuth第三方登陆</h1><p>由于sso实际上还是比较麻烦的，所以我们可以利用大厂提供的第三方登陆系统实现登陆</p><p>我们不关心这个完成授权的过程，但是要知道用户点击到返回登陆的这个过程发生了什么</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220424204420.png" alt=""></p><ol><li>首先用户在acom点击用户登陆，跳转到OAuth，并带上回调地址acom</li><li>用户二维码验证之后，微信返回临时票据code</li><li>a带着code和自己申请的appid、appsecret，向微信的服务器申请token，验证成功微信下发token</li><li>有了token之后，a就可以向微信服务器获取用户的头像和昵称等信息。并将用户的登录态写入cookie以便下一次登陆。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试指南" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>融会贯通八大排序</title>
    <link href="https://zlinni.github.io/posts/3106196216/"/>
    <id>https://zlinni.github.io/posts/3106196216/</id>
    <published>2022-04-23T06:37:29.000Z</published>
    <updated>2022-05-04T11:38:32.153Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>记录常用排序算法的算法思想和实现，力争基础达标，往后深入的点分开补充~</p></div><p>关键词：常用算法、sort排序、冒泡排序、插入排序、选择排序、快速排序、归并排序、桶排序、希尔排序</p><h1 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h1><p>直接使用api就能进行排序，注意的点是：<br>不传参，默认是unicode排序，所以常用来排序字母<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;asbcascacsac&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> sortArr = arr.sort();</span><br><span class="line"><span class="built_in">console</span>.log(sortArr)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">    &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;b&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;c&#x27;, &#x27;s&#x27;, &#x27;s&#x27;, &#x27;s&#x27;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>传参，默认两个参，名字无所谓，这里举例是a和b，看返回值来决定升序降序<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">116516</span>,<span class="number">1213</span>,<span class="number">123</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr))</span><br><span class="line"><span class="keyword">let</span> upArr = arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);</span><br><span class="line"><span class="keyword">let</span> downArr = arr2.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>b-a);</span><br><span class="line"><span class="built_in">console</span>.log(upArr)</span><br><span class="line"><span class="built_in">console</span>.log(downArr)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">     1,      4,   5,</span></span><br><span class="line"><span class="comment">     8,      8, 123,</span></span><br><span class="line"><span class="comment">  1213, 116516</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  116516, 1213, 123,</span></span><br><span class="line"><span class="comment">       8,    8,   5,</span></span><br><span class="line"><span class="comment">       4,    1</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>思想：从第一个元素开始比较相邻的元素大小，大则交换(升序)<br>时间复杂度：O(n²)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">116516</span>,<span class="number">1213</span>,<span class="number">123</span>]</span><br><span class="line"><span class="keyword">const</span> bubblesort = (<span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;len-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j+<span class="number">1</span>]&lt;arr[j])&#123;</span><br><span class="line">                [arr[j],arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>],arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(bubblesort(arr))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">     1,      4,   5,</span></span><br><span class="line"><span class="comment">     8,      8, 123,</span></span><br><span class="line"><span class="comment">  1213, 116516</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>优化：如果原数组已经是排序数组，就不必再排，用flag<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bubblesort = (<span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)<span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(bubblesort(arr))</span><br></pre></td></tr></table></figure></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>思想：每次都找到最小值放在头部，然后缩小范围继续操作 直到完全有序<br>时间复杂度：O(n²)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectsort = (<span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[minIndex]&gt;arr[j])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minIndex!==i)&#123;</span><br><span class="line">            [arr[minIndex],arr[i]] = [arr[i],arr[minIndex]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(selectsort(arr))</span><br></pre></td></tr></table></figure></p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>原理：当每次排序的时候，如果前面的元素大于当前的元素，那么将前面的元素转换成当前元素，继续比较，最后替换回最开始转换的元素<br>时间复杂度：O(n²)<br>eg<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line">经过第一轮（单个元素可以当成有序的数列所以忽略第一个元素） 从index1开始保存变量，也就是temp3和<span class="number">5</span>对比</span><br><span class="line">如果<span class="number">3</span>&lt;<span class="number">5</span>，<span class="number">5</span>就在前面腾出一个位置给<span class="number">3</span><span class="string">&#x27;5 5 2 4 1&#x27;</span> （arr[j-<span class="number">1</span>]=arr[j]）;</span><br><span class="line">最后还原temp就变成</span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line">第二轮 对比<span class="number">5</span>和<span class="number">2</span> 此时<span class="number">5</span>前面需要腾出一个位置给<span class="number">2</span>(<span class="number">2</span>&lt;<span class="number">5</span>)此时变成<span class="string">&#x27;3 5 5 4 1&#x27;</span> 然后又发现<span class="number">2</span>&lt;<span class="number">3</span>(j--) 则继续腾位置<span class="string">&#x27;3 3 5 4 1&#x27;</span>(使用<span class="keyword">while</span>的原因)最后</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> j=i;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (j&gt;<span class="number">0</span>&amp;&amp;arr[j-<span class="number">1</span>]&gt;temp) &#123;</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];<span class="comment">//arr[1]3-&gt;5</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;<span class="comment">//arr[0]5-&gt;3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>原理：采用分治思想，分解每个子问题，整个数组可以对半分割，一直到分割最小的状态，然后开始逐渐合并，从规模1到规模2一直到还原回整个数组。</p><p>时间复杂度：O(nlog(n))</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220504151812.png" alt=""></p><p>例子：<code>[8, 7, 6, 5, 4, 3, 2, 1]</code>;</p><p>首先分割，我们利用递归的方法，注意边界小于等于1直接返回arr<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, | <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">7</span>,| <span class="number">6</span>, <span class="number">5</span>, | <span class="number">4</span>, <span class="number">3</span>, |<span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">8</span>,| <span class="number">7</span>,| <span class="number">6</span>, | <span class="number">5</span>, | <span class="number">4</span>,|  <span class="number">3</span>, |<span class="number">2</span>,|  <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>此时的规模已经到了最小状态，那么开始两两合并,这里利用数组的push<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7</span>,| <span class="number">8</span>,| <span class="number">5</span>, | <span class="number">6</span>, | <span class="number">3</span>,|  <span class="number">4</span>, |<span class="number">1</span>,|  <span class="number">2</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">8</span>,| <span class="number">5</span>, <span class="number">6</span>, | <span class="number">3</span>, <span class="number">4</span>, |<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>,  | <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure></p><p>如果已经有一方的合并完全了，那么直接concat另一边剩下的</p><p>具体代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分解</span></span><br><span class="line"><span class="keyword">const</span> mergeSort = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">2</span>)<span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">const</span> mid = len/<span class="number">2</span>,</span><br><span class="line">        left = mergeSort(arr.slice(<span class="number">0</span>,mid)),</span><br><span class="line">        right = mergeSort(arr.slice(mid));</span><br><span class="line">    <span class="keyword">return</span> mergeArr(left,right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="keyword">const</span> mergeArr = <span class="function">(<span class="params">left,right</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">while</span>(left.length &amp;&amp; right.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left[<span class="number">0</span>]&lt;=right[<span class="number">0</span>])&#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(...left,...right);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(mergeSort([<span class="number">4</span>,<span class="number">54</span>,<span class="number">654</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">45</span>,<span class="number">1</span>,<span class="number">2</span>]))</span><br></pre></td></tr></table></figure></p><h2 id="归并排序是原地排序吗？"><a href="#归并排序是原地排序吗？" class="headerlink" title="归并排序是原地排序吗？"></a>归并排序是原地排序吗？</h2><div class="note primary flat"><p>实际上它在合并的时候，借助了额外的空间，但是合并完成之后额外的空间又被释放了。所以不是原地排序</p></div><h2 id="归并排序稳定吗？"><a href="#归并排序稳定吗？" class="headerlink" title="归并排序稳定吗？"></a>归并排序稳定吗？</h2><div class="note primary flat"><p>merge方法里面的<code>left[0]&lt;=right[0]</code>保证了值相同的元素在合并前后的顺序不变，所以他是一种稳定的排序</p></div><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>从效率上看，归并排序可算是排序算法中的佼佼者。假设数组长度为 n，那么拆分数组共需 logn 步, 又每步都是一个普通的合并子数组的过程，时间复杂度为 O(n)，故其综合时间复杂度为 O(nlogn)。<br>最佳情况：T(n) = O(nlogn)。<br>最差情况：T(n) = O(nlogn)。<br>平均情况：T(n) = O(nlogn)。</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>原理：</p><ol><li>找到一个基准值，一般是数组中间</li><li>创建新的左右空数组，分别存放比基准值小的和比基准值大的数据<br>3，递归上述操作，直到数组长度小于等于1</li></ol><p>特点：</p><ol><li>快速、常用</li></ol><p>缺点：<br>需要新建两个数组浪费空间资源</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">1</span>)<span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//取出基准值</span></span><br><span class="line">    <span class="keyword">const</span> midVal = arr.splice(mid,<span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">const</span> left = [],right = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;midVal)&#123;</span><br><span class="line">            left.push(arr[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat(midVal,right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(quickSort([<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure><h2 id="快速排序是原地排序吗？"><a href="#快速排序是原地排序吗？" class="headerlink" title="快速排序是原地排序吗？"></a>快速排序是原地排序吗？</h2><p>在分区的时候，他不需要很多额外的空间，所以是原地排序操作。</p><h2 id="快速排序稳定吗？"><a href="#快速排序稳定吗？" class="headerlink" title="快速排序稳定吗？"></a>快速排序稳定吗？</h2><p>和选择排序类似，快速排序可能不是相邻的，因此他有可能打破原来相同元素之间的顺序，所以是不稳定的。</p><h2 id="快速排序的时间复杂度"><a href="#快速排序的时间复杂度" class="headerlink" title="快速排序的时间复杂度"></a>快速排序的时间复杂度</h2><p>快速排序的时间复杂度是多少 ？<br>极端的例子：如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n / 2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)。<br>最佳情况：T(n) = O(nlogn)。<br>最差情况：T(n) = O(n2)。<br>平均情况：T(n) = O(nlogn)。</p><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>浅谈TCP与UDP</title>
    <link href="https://zlinni.github.io/posts/2458362678/"/>
    <id>https://zlinni.github.io/posts/2458362678/</id>
    <published>2022-04-23T06:24:50.000Z</published>
    <updated>2022-04-25T02:41:30.113Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>web前端常考TCP与UDP的知识解析，力争基础达标，往后深入的点分开补充~</p></div><p>关键词:TCP/UDP、三次握手、四次挥手、流量控制、拥塞控制、TCP粘包<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423142857.png" alt=""></p><h1 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h1><ol><li>tcp是面向链接的 udp是无连接的即发送数据前不需要建立连接</li><li>tcp提供可靠的服务，也就是说通过tcp连接发送的数据，无差错，不丢失，不重复，且按序到达，udp尽最大的努力交付，即不保证可靠交付。并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换</li><li>tcp是面向字节流，udp面向报文，并且网络出现拥塞不会使得发送速率降低（因此会产生丢包，对实时的应用比如ip电话和视频会议等）</li><li>tcp只能是一对一的，udp支持1对1 1对多</li><li>tcp的首部较大为20字节 udp只有8字节</li><li>tcp是面向连接的可靠性传输，udp是不可靠的 </li></ol><h2 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h2><p>UDP：</p><ul><li>直播</li><li>游戏</li></ul><h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><div class="note primary flat"><p>建立连接前，客户端和服务端需要通过握手来确认对方</p></div><ul><li>客户端发送SYN同步序列编号请求，进入SYN_SEND状态，等待确认</li><li>服务端接收并确认SYN包之后发送SYN+ACK包，进入SYN_RECV状态</li><li>客户端接收SYN+ACK包之后，发送ACK包，双方进入ESTABLISHED状态</li></ul><h2 id="为什么采用三次握手？"><a href="#为什么采用三次握手？" class="headerlink" title="为什么采用三次握手？"></a>为什么采用三次握手？</h2><p>举例：已失效的连接请求报文段</p><ul><li>如果客户端发送请求报文但由于网络问题导致报文失效，服务端接收到请求后就会发送确认报文表示同意连接。此时如果是两次握手，那么此时服务端已经建立了新的连接，但由于这个请求是失效的，客户端并没有建立连接，服务端就会浪费很多资源。如果是三次握手，那么此时服务端收不到确认连接的信息，就知道客户端没有建立连接。这就是三次握手的作用。<div class="note primary flat"><p>TCP有六种标识SYN建立连接，ACK确认，PSH传送，FIN结束，RST重置，URG紧急</p></div></li></ul><h2 id="三次握手过程中可以携带数据吗？"><a href="#三次握手过程中可以携带数据吗？" class="headerlink" title="三次握手过程中可以携带数据吗？"></a>三次握手过程中可以携带数据吗？</h2><ul><li>第一次第二次握手不能携带数据，因为第一次握手和第二次握手服务端还没有建立连接，此时发送数据会让服务器受到攻击。</li><li>第三次握手服务器已经处于ESTABLISHED状态，对于客户端来说已经建立了连接，并且也知道服务器的接收发送能力是正常的了，所以能携带数据。</li></ul><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><div class="note primary flat"><p>为了确保数据能完成传输</p></div><ul><li>客户端—FIN—&gt;服务端，FIN——WAIT</li><li>服务端—ACK—&gt;客户端，CLOSE——WAIT</li><li>服务端—ACK，FIN—&gt;客户端，LAST——ACK</li><li>客户端—ACK—&gt;服务端，CLOSED</li></ul><h2 id="为什么连接的时候是三次握手，关闭的时候是四次挥手？"><a href="#为什么连接的时候是三次握手，关闭的时候是四次挥手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候是四次挥手？"></a>为什么连接的时候是三次握手，关闭的时候是四次挥手？</h2><ul><li>服务端接收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。</li><li>但是在关闭连接的时候，当服务端收到FIN报文的时候 ，很可能并不会立刻关闭连接，所以只能先回复一个ACK报文，告诉客户端，你发的FIN报文收到了，只有等服务器所有的报文发送完了才能发送FIN报文，因此不能一起发送，故需要四次挥手。 </li></ul><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><div class="note primary flat"><p>网络拥塞（congestion）是指在分组交换网络中传送分组的数目太多时，由于存储转发节点的资源有限而造成网络传输性能下降的情况。当网络发生拥塞时，一般会出现数据丢失，时延增加，吞吐量下降，严重时甚至会导致“拥塞崩溃”（congestion collapse）。通常情况下，当网络中负载过度增加致使网络性能下降时，就会发生网络拥塞。下图则描述了在有无拥塞控制的干预下，网络吞吐量随输入负载的增加的变化情况。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423112204.png" alt=""><br>通过以上的描述，我们大概可以得到以下信息：</p><ul><li>网络拥塞往往是由于对资源的请求超出了存储转发节点的能力而导致的。</li><li>网络拥塞可能会导致数据丢失，时延增加，吞吐量下降等问题。</li><li>若出现拥塞而不进行控制，有可能会使整个网络情况恶化，甚至网络吞吐降为0。</li><li>网络的拥塞状况与当前网络负载是密切相关的。</li></ul><h2 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h2><ol><li>慢启动</li><li>拥塞避免</li><li>快重传</li><li>快恢复</li></ol><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>如果发送方的数据发送过快，接收者来不及接收，就有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。</p><p>流量控制的根本目的是防止分组丢失，它是构成TCP可靠性的一方面</p><h2 id="实现流量控制"><a href="#实现流量控制" class="headerlink" title="实现流量控制"></a>实现流量控制</h2><p>滑动窗口协议（连续ARQ协议）实现。它保证了分组无差错，有序接收，也实现了流量控制。</p><p>主要的方式是 接收方返回的ack包会包含自己接收窗口的大小，并且利用大小来控制发送方的数据发送</p><h2 id="流量控制引发的死锁？怎么避免死锁发生？-没看明白"><a href="#流量控制引发的死锁？怎么避免死锁发生？-没看明白" class="headerlink" title="流量控制引发的死锁？怎么避免死锁发生？(没看明白)"></a>流量控制引发的死锁？怎么避免死锁发生？(没看明白)</h2><p>当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。</p><h2 id="拥塞控制和流量控制的区别"><a href="#拥塞控制和流量控制的区别" class="headerlink" title="拥塞控制和流量控制的区别"></a>拥塞控制和流量控制的区别</h2><p>拥塞控制就是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的方法是：慢开始，拥塞避免，快重传，快恢复。</p><p>流量控制就是作用于接收者的，它是控制发送者的发送速度从而使得接收者来得及接收，防止分组丢失</p><h1 id="TCP粘包"><a href="#TCP粘包" class="headerlink" title="TCP粘包"></a>TCP粘包</h1><h1 id="什么是TCP粘包"><a href="#什么是TCP粘包" class="headerlink" title="什么是TCP粘包"></a>什么是TCP粘包</h1><div class="note primary flat"><p>现在假设客户端连续发了两个数据包给服务端，用pack1和pack2来表示，那么就有以下几种情况：</p></div><ol><li>接收端正常收到了两个数据包，没有发生异常<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423102351.png" alt=""></li><li>接收端只收到一个数据包，因为TCP不会丢包所以这个数据包包含了发送端发送的两个数据包，这就是粘包。服务端不知道怎么划分这两个数据包所以很难处理。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423102618.png" alt=""></li><li>接收端收到两个数据包，但它们都不完整。这种情况下可能是pack1丢了一点到pack2，也有可能是pack2丢了一点到pack1，此时发生了粘包拆包<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423103042.png" alt=""></li></ol><h1 id="为什么会发生粘包拆包"><a href="#为什么会发生粘包拆包" class="headerlink" title="为什么会发生粘包拆包"></a>为什么会发生粘包拆包</h1><p>原因如下：</p><ol><li>本身套接字缓冲区大小不足，一次写入的数据多了，就发生了拆包</li><li>本身套接字缓冲区过大，多次写入数据，就发生了粘包</li><li>TCP连接复用，本来单独的连接中双方规定好了数据格式，但是因为复用导致多个进程以及不同的数据格式传输，就造成了粘包</li><li>接收方没及时接收数据，就发生了粘包</li></ol><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决方法就是处理这个边界问题。</p><ol><li>尾部标识法：通过协商的尾部标记，比如<code>\n\t\r</code>等来说明这是边界</li><li>头部标记法：不是不知道长度吗？直接在TCP头部加上标识数据长度</li><li>定长发送法：发送端封装数据包为指定长度发送</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="网络系列" scheme="https://zlinni.github.io/categories/%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="计算机网络" scheme="https://zlinni.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>面试官问我了解TCP粘包吗</title>
    <link href="https://zlinni.github.io/posts/1161612098/"/>
    <id>https://zlinni.github.io/posts/1161612098/</id>
    <published>2022-04-23T02:10:31.000Z</published>
    <updated>2022-04-25T02:41:30.117Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>有一天小明高兴的去面试，突然间面试官抛出一个问题：什么是TCP粘包？这下子好了，小明脑袋搜索了TCP的内容，发现只搜索到TCP和UDP的区别，流量控制，拥塞控制，和三握四挥这几个内容，小明尴尬的说：我不知道。于是回来恶补了TCP粘包的内容</p></div><p>关键词：TCP粘包、拆包<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423111651.png" alt=""></p><h1 id="什么是TCP粘包"><a href="#什么是TCP粘包" class="headerlink" title="什么是TCP粘包"></a>什么是TCP粘包</h1><div class="note primary flat"><p>现在假设客户端连续发了两个数据包给服务端，用pack1和pack2来表示，那么就有以下几种情况：</p></div><ol><li>接收端正常收到了两个数据包，没有发生异常<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423102351.png" alt=""></li><li>接收端只收到一个数据包，因为TCP不会丢包所以这个数据包包含了发送端发送的两个数据包，这就是粘包。服务端不知道怎么划分这两个数据包所以很难处理。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423102618.png" alt=""></li><li>接收端收到两个数据包，但它们都不完整。这种情况下可能是pack1丢了一点到pack2，也有可能是pack2丢了一点到pack1，此时发生了粘包拆包<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220423103042.png" alt=""></li></ol><h1 id="为什么会发生粘包拆包"><a href="#为什么会发生粘包拆包" class="headerlink" title="为什么会发生粘包拆包"></a>为什么会发生粘包拆包</h1><p>原因如下：</p><ol><li>本身套接字缓冲区大小不足，一次写入的数据多了，就发生了拆包</li><li>本身套接字缓冲区过大，多次写入数据，就发生了粘包</li><li>TCP连接复用，本来单独的连接中双方规定好了数据格式，但是因为复用导致多个进程以及不同的数据格式传输，就造成了粘包</li><li>接收方没及时接收数据，就发生了粘包</li></ol><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决方法就是处理这个边界问题。</p><ol><li>尾部标识法：通过协商的尾部标记，比如<code>\n\t\r</code>等来说明这是边界</li><li>头部标记法：不是不知道长度吗？直接在TCP头部加上标识数据长度</li><li>定长发送法：发送端封装数据包为指定长度发送</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="网络系列" scheme="https://zlinni.github.io/categories/%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>三道题，入门async和await</title>
    <link href="https://zlinni.github.io/posts/1222301607/"/>
    <id>https://zlinni.github.io/posts/1222301607/</id>
    <published>2022-04-22T06:32:35.000Z</published>
    <updated>2022-04-25T02:41:30.127Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>各厂很喜欢考的async和await题，一般不了解他的做法都很容易踩坑。下面用三道题来讲解怎么解这类型的题目<br>关键词:async、await、题解</p></div><h1 id="题一"><a href="#题一" class="headerlink" title="题一"></a>题一</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>第一道门槛：<br>大部分人在前面都没问题，到await这里就会卡住，此时对于await的情况是这样的。<br>他会去看自己之后的代码，</p><ol><li>查看其中是否有同步代码，如果有，执行</li><li>如果没有 其中异步的直接放到任务栈</li><li>分析await下面的代码<br>然后跳出代码，继续往下查看</li></ol><p>其中关于await的操作，其实是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(async2());</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//这也就是await后面的代码能看成是微任务的原因</span></span><br></pre></td></tr></table></figure></p><p>它等待async2执行完回调这个输出</p><p>第二道门槛：<br>这里就来到下面看有没有同步代码了 这里就是第二步门槛，如果你认为，他直接输出’script end’，那么你就踩坑了。这里我们看到在此之前new了Promise，关键来了，他会立刻执行它的构造函数，也就是你可以把这个构造函数看成是同步代码，此时就会输出<code>promise1</code>.再到<code>script end</code></p><p>第三道门槛：<br>此时，我们得知道 所有的同步任务都执行完了，开始执行任务栈中的代码了<br>此时的任务栈中有await之后的代码，promise的成功回调，和settimeout，当然为什么是这个顺序呢。我们要知道微任务会插队在宏任务前面，也就是一开始的顺序是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">settimeout</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> code 插队</span><br><span class="line">settimeout</span><br><span class="line"></span><br><span class="line"><span class="comment">//遇到promise 插队在宏任务前面</span></span><br><span class="line"><span class="keyword">await</span> code</span><br><span class="line">promise </span><br><span class="line">settimeout</span><br></pre></td></tr></table></figure><p>所以按顺序执行 结果是<code>async1 end``promise2``setTimeout</code></p><p>最终答案：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220422151115.png" alt=""></p><h1 id="题二"><a href="#题二" class="headerlink" title="题二"></a>题二</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise3&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise4&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>第一道门槛：<br>async2中promise的构造器执行之后，将成功的回调放进任务栈，再去把await下面的code放进任务栈</p><p>任务栈的内容（异步）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line"></span><br><span class="line">promise2(插队)</span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line"></span><br><span class="line">promise2</span><br><span class="line">async1 end(插队)</span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line"></span><br><span class="line">promise2</span><br><span class="line">async1 end</span><br><span class="line">promise4(插队)</span><br><span class="line"><span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure></p><p>最终答案<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">promise1</span><br><span class="line">promise3</span><br><span class="line">script end</span><br><span class="line">promise2</span><br><span class="line">async1 end</span><br><span class="line">promise4</span><br><span class="line"><span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure></p><h1 id="题三"><a href="#题三" class="headerlink" title="题三"></a>题三</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout1&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout2&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout3&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>前面的一样，不过这次进入async2后是宏任务，我们依然把它放进任务栈，再把<br>踩坑点：<br>容易忽视掉setimeout3是第一个宏任务。<br>因此答案为setimeout2 1 3 实际上是3 2 1</p><p>最终答案<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">promise2</span><br><span class="line">setTimeout3</span><br><span class="line">setTimeout2</span><br><span class="line">setTimeout1</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>三道基本的题，掌握了await的基本原理。其实就是promise的回调。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试指南" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>DNS域名系统</title>
    <link href="https://zlinni.github.io/posts/3906343608/"/>
    <id>https://zlinni.github.io/posts/3906343608/</id>
    <published>2022-04-21T07:29:56.000Z</published>
    <updated>2022-04-25T02:41:30.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>web前端你必须了解的DNS，下面讲解DNS的一些过程和由来以及产生的安全问题<br>关键词：DNS是什么、DNS的分布式、层次数据库、本地DNS服务器、DNS递归查询和迭代查询、DNS缓存、DNS劫持</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220422103253.png" alt=""></p><h1 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS"></a>什么是DNS</h1><p>DNS即域名系统，全称是Domain Name System。当我们在浏览器输入一个URL地址的时候，浏览器要向这个URL的主机名对于的服务器发起请求，就得知道服务器的IP。对于浏览器来说，DNS的作用就是将主机名转换为IP地址。</p><div class="note primary flat"><p>DNS是：</p><ol><li>一个由分层的DNS服务器实现的分布式数据库</li><li>一个使得主机能够查阅分布式数据库的应用层协议</li></ol></div><p>也就是 DNS是一个应用层的协议，我们发送一个请求，其中包含我们要查询的主机名，他就会给我们返回这个主机名对应的IP。</p><p>其次，DNS是一个分布式数据库，整个DNS由分散在世界各地的很多台DNS服务器组成，每台DNS服务器上面都保存了一些数据，这些数据可以让我们查到最终主机名对应的IP</p><p>所以DNS的查询过程，本质上就是去向这些DNS服务器访问，直到查到这个IP为止。</p><h1 id="分布式、层次数据库"><a href="#分布式、层次数据库" class="headerlink" title="分布式、层次数据库"></a>分布式、层次数据库</h1><h2 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h2><p>因为所有的主机不可能全部ip都放在一台dns服务器上面，所以就一台一台分出来，每台存储不同的数据，负责不同的映射。</p><h2 id="什么是层次"><a href="#什么是层次" class="headerlink" title="什么是层次"></a>什么是层次</h2><p>DNS服务器有三种类型：根DNS服务器，顶级域DNS服务器和权威NDS服务器，<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421154505.png" alt=""></p><ul><li>根DNS服务器<br>首先我们要明确根域名是什么？比如<code>www.baidu.com</code>其实他的根域名是被隐藏的。真正的根域名是<code>www.baidu.com.root</code>后面的.root</li></ul><p>那么根DNS服务器的作用是什么?就是管理他的下一级，也就是顶级域DNS服务器。通过询问根DNS服务器，我们能查到该主机名对应的顶级域的ip是多少，从而继续向顶级域请求了解他的下一层。</p><ul><li><p>顶级域服务器<br>除了前面提到的com是顶级域名，常见的顶级域名还有cn，org，edu等。然后顶级域管理的是权威DNS</p></li><li><p>权威DNS<br>由各大厂商负责管理的域名，它可以返回最终的一个IP</p></li></ul><p>服务器之间是如何继续交互的，继续往下看：</p><h1 id="本地DNS服务器"><a href="#本地DNS服务器" class="headerlink" title="本地DNS服务器"></a>本地DNS服务器</h1><p>上一层没有讲到本地DNS服务器，是因为他严格意义上不属于DNS的层次结构。</p><p>什么是本地DNS服务器？</p><p>每个ISP都有一台本地DNS服务器，比如小区，大学，机构等。都有一台或多台本地DNS服务器。当主机发出DNS请求的时候，该请求被发往本地DNS服务器，本地DNS服务器代理这些请求，将它们转发到DNS服务器中。好比Nginx</p><h1 id="递归查询-迭代查询"><a href="#递归查询-迭代查询" class="headerlink" title="递归查询 迭代查询"></a>递归查询 迭代查询</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421155733.png" alt=""></p><p>其中com是顶级域名 n是权威域名 </p><p>这个过程中，主机向本地DNS服务器请求就是递归查询<br>本地服务器向根DNS，顶级DNS和权威DNS发出的请求就是迭代查询<br>迭代的特点就是所有的都是由本地DNS发出 所有的接收也是回到本地DNS</p><p>当然不是所有的DNS查询都是这样的模式 DNS查询可以是递归的，也可以是迭代的 如下图就只是递归的<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421160546.png" alt=""></p><h1 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h1><p>为了让我们更快的拿到想要的IP，DNS广泛使用了缓存技术。DNS的缓存原理就是，在一个DNS查询的过程中，某台DNS收到了一个DNS应答的时候，就能将映射缓存到本地，下次查询就能直接用到缓存的内容。</p><p>but 缓存不是永久的，他也会定时删除。</p><p>所以有了缓存，很多时候都绕开了根DNS，所以需要向根DNS发起的查询请求很少。</p><h1 id="DNS解析优化"><a href="#DNS解析优化" class="headerlink" title="DNS解析优化"></a>DNS解析优化</h1><p>主要分为两个方案</p><ul><li>DNS预解析</li><li>减少DNS请求</li></ul><h1 id="DNS预解析"><a href="#DNS预解析" class="headerlink" title="DNS预解析"></a>DNS预解析</h1><div class="note primary flat"><p>DNS解析也需要时间的，可以通过预解析的方式来预先获取域名所对应的IP</p></div><p>link方式：手动解析<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//blog.poetries.top&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>meta方式：https自动解析<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;x-dns-prefetch-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;on&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>设置响应头：自动解析<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.set(<span class="string">&#x27;X-DNS-Prefetch-Control&#x27;</span>, <span class="string">&#x27;on&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h1 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h1><p>域名劫持就是在劫持的范围内拦截解析的请求，分析请求的域名，把审查范围之外的请求放行，否则直接返回假的IP地址或者什么也不做使其失去响应，效果就是特定的网址不能访问或者访问的是假的网址</p><p>域名劫持会影响用户体验，一方面还有可能被诱骗到冒牌网站进行登陆导致隐私泄漏</p><p>DNS可以有本地DNS劫持，路由DNS劫持，攻击DNS服务器</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>加强本地的计算机病毒检查，开启防火墙，防止恶意软件，木马感染计算机等。</li><li>改变路由器默认密码，防止攻击者修改路由器的DNS配置指向恶意的DNS服务器。</li><li>企业可以准备两个or以上的域名，一个挂了用另外一个</li><li>用HTTP DNS 代替Local DNS</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>DNS的内容其实讲深了还是很多的，但是基本的原理和概念还是要清楚，熟悉一下DNS解析的过程以及这个递归和迭代，关于域名这块以后还是会出文章，有购买域名的打算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="网络系列" scheme="https://zlinni.github.io/categories/%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="网络" scheme="https://zlinni.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Flex弹性布局</title>
    <link href="https://zlinni.github.io/posts/1131280526/"/>
    <id>https://zlinni.github.io/posts/1131280526/</id>
    <published>2022-04-21T00:31:57.000Z</published>
    <updated>2022-04-25T02:41:30.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>详细记录flex弹性布局的具体属性和常考题。<br>关键词：flex属性、</p></div><h1 id="flex概念"><a href="#flex概念" class="headerlink" title="flex概念"></a>flex概念</h1><p>弹性盒子是一种按行或者按列布局元素的一种以为布局方法，容器里面的元素可以膨胀填充额外的空间，收缩来适应更小的空间，适用于任何元素。</p><p>元素使用flex布局就会在内部形成BFC，目前flex已经适配所有常规浏览器</p><h2 id="拓展：BFC"><a href="#拓展：BFC" class="headerlink" title="拓展：BFC"></a>拓展：BFC</h2><p>BFC：块级格式化上下文，是一个完全独立的空间，里面的子元素不会影响到外面的布局。</p><p>触发BFC的方式：</p><ul><li><code>overflow:hidden</code></li><li><code>display:inline-block,table-cell,flex</code></li><li><code>position:absolute,fixed</code></li></ul><p>BFC解决的问题：</p><ul><li>高度塌陷</li><li>margin边距重叠</li></ul><h1 id="flex和inline-flex"><a href="#flex和inline-flex" class="headerlink" title="flex和inline-flex"></a>flex和inline-flex</h1><p>display有两种设置方式：flex和inline-flex。</p><p>区别在于：<br>flex元素和宽度是父容器的100%<br>inline-flex是所有元素的宽度和<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421110404.png" alt=""></p><p>那么在元素溢出的情况下是怎么样呢？<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421110450.png" alt=""><br>可见inline-flex会撑大flex容器，造成溢出</p><p>使用inline-flex的时候，注意配合min-width和min-height一起使用。不建议显示设置height和width</p><h2 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h2><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421110628.png" alt=""><br>可以总结为 整个容器的设置flex 不占整个容器的或者容器的部分 设置为inline-flex</p><h1 id="主轴和交叉轴"><a href="#主轴和交叉轴" class="headerlink" title="主轴和交叉轴"></a>主轴和交叉轴</h1><p>flex布局有两个轴的概念：主轴和交叉轴。水平的叫做主轴，垂直的叫做交叉轴。主轴的开始位置叫做start 结束叫做end 交叉轴也是如此。<br>flex布局的元素称为容器container，他的所有子元素都是一个项目item</p><h1 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421085022.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421085431.png" alt=""></p><h2 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h2><ul><li>row:水平左 左对齐</li><li>row-reverse:水平右 右对齐</li><li>column: 垂直上 上对齐</li><li>column-reverse: 垂直下 下对齐</li></ul><p>场景<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421110854.png" alt=""></p><p>由于默认会携带<code>flex-direction:row</code>（代码冗余）所以在非row的时候再设置flex-direction做布局算法优化</p><h2 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h2><p>默认情况下元素不换行nowrap，加了wrap属性之后，会换行</p><ul><li>nowrap 不换</li><li>wrap 换行</li><li>wrap-reverse 换行 第一行在下方<br>eg<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="literal">null</span> <span class="literal">null</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span>    <span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h2><p>是direction和wrap属性的简写 默认为row nowrap<br>只设置一个值的时候 看匹配哪个属性值 来取值<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-flow</span>: row || nowrap</span><br></pre></td></tr></table></figure></p><h2 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h2><p>描述了元素在主轴上面的对齐方式</p><ul><li>flex-start 左对齐</li><li>flex-end 右对齐</li><li>center 居中</li><li>space-around 每个项目两端的间隔相等 意味着第一个和最后一个元素两侧的宽度不等</li><li>space-between 两端对齐 项目之间的间隔相等</li><li>space-evenly: 项目的间隔和容器的间隔相等</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421090432.png" alt=""></p><h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><p>描述元素在交叉轴上面的对齐方式</p><ul><li>flex-start 上对齐</li><li>flex-end 下对齐</li><li>center 居中</li><li>baseline 项目第一行文字的基线对齐</li><li>stretch 默认 如果没设置高度或者auto 则占满整个容器的高度</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421090724.png" alt=""></p><h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2><p>定义了多根轴线的对齐方式 前提设置flex-wrap：wrap 否则不生效</p><ul><li>flex-start 交叉轴起点</li><li>flex-end 交叉轴中终点</li><li>center 中点</li><li>space-between 两端对齐 轴线之间平均分 </li><li>space-around  轴线间间隔相等</li><li>stretch 默认值 占满整个交叉轴</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421091427.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421111124.png" alt=""></p><h2 id="gap"><a href="#gap" class="headerlink" title="gap"></a>gap</h2><p>gap用来控制flex项目之间的间距，但会忽略flex项目与flex容器边缘的间距<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421111332.png" alt=""></p><h1 id="项目的子项属性"><a href="#项目的子项属性" class="headerlink" title="项目的子项属性"></a>项目的子项属性</h1><h2 id="order"><a href="#order" class="headerlink" title="order"></a>order</h2><p>定义项目的排列顺序 数值越小越前 默认0 可以是负数<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421091444.png" alt=""></p><p>场景：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421111454.png" alt=""></p><h2 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h2><p>定义了容器中剩余空间应该有多少分配给项目，最终的宽度为：自身宽度+容器剩余空间分配宽度 该属性的最大值是1 超过1按1来拓展<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421091802.png" alt=""></p><h2 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h2><p>该属性指定了flex元素的收缩规则。只在项目的元素宽度和大于容器的时候才会触发。收缩的大小是依据该属性的值 默认为1</p><p>eg 两个div 第一个div宽度200 第二个div宽度300 容器400<br>容器设置了flex布局 两个div的shrink都设置为1<br>那么此时 两个div500大于400 所以触发收缩</p><p>那么收缩后子项的宽度怎么计算呢？<br>有公式如下</p><ol><li>所有子项宽度和-容器的宽度=<code>500 - 400 = 100</code></li><li>第一个子项的占比 <code>2/5</code> 第二个子项的占比 <code>3/5</code></li><li>第一个子项的宽度为<code>200-2/5*100=160</code>,第二个为:<code>300-3/5*100=240</code></li></ol><h2 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h2><p>指定子项目的在主轴的初始化大小，优先级高于自身宽度width<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-basis</span>: <span class="number">0</span> | <span class="number">100%</span> | auto | &lt;length&gt;</span><br></pre></td></tr></table></figure></p><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>flex是flex-grow flex-shrink 和 flex-basis的简写<br>单值的时候 数值被当作flexgrow 一个有效的宽度值被当作basis<br>双值的时候 一个无单位的数 被当成shrink 一个有效的宽度值被当成basis<br>三值 略</p><p>默认 0 1 auto</p><p>取值，除了自定义的三种外：<br><code>auto</code>根据自身的width和height来确定比例 相当于<code>1 1 auto</code><br><code>initial</code>相当于0 1 auto<br><code>none</code> 0 0 auto</p><h2 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h2><p>允许单个项目有和其他项目不一样的对齐方式，可以覆盖align-items属性，默认auto表示继承align-items 如果没有父元素 则等于stretch<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421092936.png" alt=""></p><p>常见使用场景<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421111420.png" alt=""></p><h1 id="Flex项目上的-margin"><a href="#Flex项目上的-margin" class="headerlink" title="Flex项目上的 margin"></a>Flex项目上的 margin</h1><p>在Flex项目显式设置 margin 的值为 auto 可以灵活的控制单个Flex项目在Flex容器中的位置：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421105904.png" alt=""><br>比如像下图这样的效果，使用 margin-left: auto 就非常的实用：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421105923.png" alt=""></p><h1 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h1><p>等高布局</p><p>左侧宽度固定 右侧宽度自适应布局（常见的tob系统布局，左侧菜单树右侧内容）<br>粘性页脚<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220421105548.png" alt=""><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex__container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;coupon&quot;</span>&gt;</span>卷<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;divider&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;price&quot;</span>&gt;</span><span class="symbol">&amp;yen;</span>1000<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.flex__container &#123;</span><br><span class="line">  display: inline-flex;</span><br><span class="line">  min-width: 200px;</span><br><span class="line">  height: 60px;</span><br><span class="line">  </span><br><span class="line">  border: 1px solid rgba(255, 0, 54, 1);</span><br><span class="line">  background-color: rgba(255, 0, 54, 0.1);</span><br><span class="line">  border-radius: 4px;</span><br><span class="line">  color: #ff0036;</span><br><span class="line">  font-size: 24px;</span><br><span class="line">  font-weight: 400;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.flex__container &gt; span &#123;</span><br><span class="line">  display: inline-flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.divider &#123;</span><br><span class="line">  border-right: 1px dashed currentColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.coupon &#123;</span><br><span class="line">  min-width: 50px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.price &#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">  min-width: 0;</span><br><span class="line">  padding: 0 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="CSS系列" scheme="https://zlinni.github.io/categories/CSS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的JavaScript合集</title>
    <link href="https://zlinni.github.io/posts/3250811507/"/>
    <id>https://zlinni.github.io/posts/3250811507/</id>
    <published>2022-04-20T07:40:52.000Z</published>
    <updated>2022-05-05T08:27:39.444Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>将2w字长文分成了七个模块，方便今后补充内容，详见传送门。</p></div><h1 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h1><p><a href="https://zlinni.github.io/posts/3931945421/">你所不知道的JavaScript①—数据类型及周边</a><br><a href="https://zlinni.github.io/posts/961371178/">你所不知道的JavaScript②—this及周边</a><br><a href="https://zlinni.github.io/posts/1060178397/">你所不知道的JavaScript③—原型及周边</a><br><a href="https://zlinni.github.io/posts/3693633031/">你所不知道的JavaScript④—异步任务与事件</a><br><a href="https://zlinni.github.io/posts/3693633031/">你所不知道的JavaScript⑤—垃圾回收与内存泄漏</a><br><a href="https://zlinni.github.io/posts/3318597918/">你所不知道的JavaScript⑥—面向对象与模块化</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的JavaScript⑥--面向对象与模块化</title>
    <link href="https://zlinni.github.io/posts/3318597918/"/>
    <id>https://zlinni.github.io/posts/3318597918/</id>
    <published>2022-04-20T07:32:49.000Z</published>
    <updated>2022-04-25T02:41:30.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><div class="note simple"><p>面向对象、迭代器、模块化</p></div><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="对象遍历"><a href="#对象遍历" class="headerlink" title="对象遍历"></a>对象遍历</h2><ol><li><code>for in</code></li><li><code>Object.keys(xxx)</code>把key取出来作为一个数组。</li><li><code>Object.values(xxx)</code>遍历对象的值作为一个数组<h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2></li></ol><ul><li>基本思想是使用对象，类，继承，封装等基本概念来进行程序设计</li><li>优点：<ul><li>易维护：采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，维护也只是在局部模块，所以维护起来非常方便，成本较低</li><li>易拓展</li><li>开发工作的重用性，继承性高，降低重复工作量</li><li>缩短了开发周期<div class="note primary flat"><p>一般面向对象包括：继承，封装，多态，抽象</p></div></li></ul></li></ul><h2 id="对象形式的继承"><a href="#对象形式的继承" class="headerlink" title="对象形式的继承"></a>对象形式的继承</h2><div class="note primary flat"><p>讲深浅拷贝之前，我们需要知道，基本数据类型在栈里面，被复制了就算修改也不会改变原来的的值，引用数据类型在堆里面，因为共享内存所以复制后被修改会改变源对象的值，至此引申出深浅拷贝。</p></div><ul><li>浅拷贝<div class="note primary flat"><p>基本的浅拷贝就是对象的赋值，但我们需要注意，实际上我们的需求是复制源对象上面的属性，那么单纯的赋值，会把新对象的值给覆盖掉。参见下面</p></div></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;allin&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">home</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">        <span class="attr">office</span>: <span class="string">&#x27;office&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">sclools</span>: [<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;z&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> programer = &#123;</span><br><span class="line">    <span class="attr">language</span>: <span class="string">&#x27;js&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果不使用该方法 programmer里面的language会被覆盖掉</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">p, c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = c || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> prop <span class="keyword">in</span> p)&#123;</span><br><span class="line">        c[prop] = p[prop];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">extend(Person, programer);</span><br><span class="line"><span class="comment">//or </span></span><br><span class="line"><span class="comment">// programer = Object.assign(programer,Person);</span></span><br><span class="line">programer.name;  <span class="comment">// allin</span></span><br><span class="line">programer.address.home;  <span class="comment">// home</span></span><br><span class="line">programer.address.home = <span class="string">&#x27;house&#x27;</span>;  <span class="comment">//house</span></span><br><span class="line">Person.address.home;  <span class="comment">// house</span></span><br><span class="line"><span class="comment">//programmer依旧保留自己的language</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>注意 浅拷贝不是新对象的地址指向整个旧对象的地址，而是拷贝旧对象的属性的地址。即自己原先的内容不变，拷贝的过程中如果key重复覆盖，否则保留。<br>思路是遍历对象 赋值。</p></div><p>深拷贝<br><div class="note primary flat"><p>深拷贝是开辟一个新的内存地址，将源对象的各个属性复制进去<br>注意的点：对象原型上面的属性不应该去拷贝，使用到<code>Object.hasOwnProperty(key)</code></p></div></p><ol><li>通过<code>JSON.parse(JSON.stringfy())</code>进行深拷贝</li></ol><ul><li>是序列化和反序列化的过程，序列化是存储地址的一个映射，所以反序列化之后，修改并不会影响原先的地址。就可以达成深拷贝。</li><li>缺点：不能拷贝<code>undefined function 正则 Error对象</code></li></ul><ol><li>递归</li></ol><ul><li>通过判断引用类型数据进行初始化之后赋值的操作指向新的地址。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断是否是引用类型或者null 否则返回源对象进行浅拷贝</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>||obj===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是数组，初始化地址。</span></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        result = [];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归调用 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            result[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li>缺点：栈会溢出。</li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul><li>命名空间<ul><li>js是没有命名空间的，因此可以用对象来模拟</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = &#123;&#125;<span class="comment">//命名空间app</span></span><br><span class="line"><span class="comment">//模块1</span></span><br><span class="line">app.module1 = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;allin&#x27;</span>,</span><br><span class="line">  <span class="attr">f</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">app.module1.name;</span><br><span class="line">app.module1.f();</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>对象的属性外界是可读可写的，那么如何达到封装的目的？通过闭包和局部变量</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Girl</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//通过方法访问变量</span></span><br><span class="line">  <span class="keyword">var</span> love = <span class="string">&#x27;jojo&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.name =name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> love;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.movelove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    love = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Girl(<span class="string">&#x27;bb&#x27;</span>,<span class="number">19</span>);</span><br><span class="line">g.say();</span><br><span class="line">g.movelove();</span><br><span class="line">g.say();</span><br></pre></td></tr></table></figure><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><div class="note primary flat"><p>就是在函数外面定义静态方法，静态方法只有该类能够使用。</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员</span></span><br><span class="line">Person.walk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;static&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Person.walk();  <span class="comment">// static</span></span><br></pre></td></tr></table></figure><h2 id="私有与公有"><a href="#私有与公有" class="headerlink" title="私有与公有"></a>私有与公有</h2><div class="note primary flat"><p>对象的方法和属性分为私有和公有，公有的属性需要在实例化的时候传入对应的值去调用，私有的属性和方法只能通过公有的方法暴露出去。注意私有的方法如果返回的是公有的属性，还需要使用call改变this指向</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 私有属性与方法</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;allin&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//公有属性与方法</span></span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;say hello&#x27;</span>);</span><br><span class="line">        work.call(<span class="built_in">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="number">123</span>);</span><br><span class="line">p1.name; <span class="comment">// undefined</span></span><br><span class="line">p1.id;  <span class="comment">// 123</span></span><br><span class="line">p1.say();  <span class="comment">// say hello 123</span></span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><div class="note primary flat"><p>同一个父类继承出来的子类有各自的形态,写的时候注意<code>子类,prototype = new 父类()</code></p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.eat = <span class="string">&#x27;肉&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tiger</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.color = <span class="string">&#x27;黑黄相间&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cheetah</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.color = <span class="string">&#x27;报文&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Lion</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.color = <span class="string">&#x27;土黄色&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tiger.prototype =  Cheetah.prototype = Lion.prototype = <span class="keyword">new</span> Cat();<span class="comment">//共享一个祖先 Cat</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> T = <span class="keyword">new</span> Tiger();</span><br><span class="line"><span class="keyword">var</span> C = <span class="keyword">new</span> Cheetah();</span><br><span class="line"><span class="keyword">var</span> L = <span class="keyword">new</span> Lion();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(T.color);</span><br><span class="line"><span class="built_in">console</span>.log(C.color);</span><br><span class="line"><span class="built_in">console</span>.log(L.color);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(T.eat);</span><br><span class="line"><span class="built_in">console</span>.log(C.eat);</span><br><span class="line"><span class="built_in">console</span>.log(L.eat);</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><div class="note primary flat"><p>虚函数是类成员中的概念，是只做了一个声明而未实现的方法，具有虚函数的类称之为抽象类。抽象类不能被实例化因为其中的虚函数并不是一个完整的函数，不能被调用。<br>在js中实现抽象类就是在父类中调用一个未定义的方法，但这个方法在子类中必须被实现。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AbstractClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象类不能直接被调用&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">AbstractClass.prototype.detect = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">AbstractClass.prototype.stop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;stop&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">AbstractClass.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NormalClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  NormalClass.prototype = <span class="built_in">Object</span>.create(AbstractClass.prototype);</span><br><span class="line">  NormalClass.prototype.constructor = NormalClass;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> NormalClass();</span><br><span class="line"><span class="built_in">console</span>.log(n)</span><br><span class="line">n.detect();</span><br><span class="line">n.init();</span><br></pre></td></tr></table></figure><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><ol><li>面向对象的三个基本特征</li><li>手写一下函数的公有和私有方法以及调用的形式<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;jojo&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">    sayName.call(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h1><div class="note primary flat"><p>Iterator是一种接口，也可以说是一种规范，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。即依次处理该数据结构的所有成员</p></div><p>语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note primary flat"><p><code>[Symbol.iterator]</code>属性名是固定的写法，只要拥有了该属性的对象，就能用迭代器的方式进行遍历。</p></div></p><ul><li>迭代器的遍历方法是首先获得一个迭代器的指针。初始时该指针指向第一条数据之前，接着通过调用next方法，改变指针的指向，让他调用下一条数据。</li><li>每次的next都会返回一个对象 有两个属性<ul><li>value： 表示你想获取的数据</li><li>done：布尔值 代表遍历是否结束 true则结束<h2 id="iterator的作用"><a href="#iterator的作用" class="headerlink" title="iterator的作用"></a>iterator的作用</h2>三个作用</li></ul></li><li>创建一个指针对象指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的next方法 指针指向第二个成元</li><li>不断调用next 直到结束位置(假如有三个数据 需要next四次 最后一次的结果是<code>&#123; value: undefined, done: true &#125;</code>)<br>案例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123;<span class="attr">nums</span>:<span class="number">1</span>&#125;,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="built_in">Symbol</span>.iterator]();<span class="comment">//获取数组的迭代器</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: Object &#123; num: 1 &#125;, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h2 id="具有iterator接口的数据结构"><a href="#具有iterator接口的数据结构" class="headerlink" title="具有iterator接口的数据结构"></a>具有iterator接口的数据结构</h2><div class="note primary flat"><p>一个数据结构只要有iterator接口就能被认为是可以遍历的。可以用forof。</p></div>具有iterator接口的数据结构的有四种：</li></ul><ol><li>数组</li><li>类数组</li><li>Set</li><li>Map<h2 id="为什么对象没有iterator接口"><a href="#为什么对象没有iterator接口" class="headerlink" title="为什么对象没有iterator接口"></a>为什么对象没有iterator接口</h2></li></ol><ul><li>对象只能用forin和<code>Object.keys、values</code>遍历</li><li>因为一个对象的哪个属性先遍历和后便利是不确定的，需要开发者手动指定。</li><li>对对象部署iterator接口没有必要 因为map弥补了他的缺陷而且map有iterator接口<br>对对象部署iterator<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    <span class="attr">hobbie</span>: <span class="string">&#x27;睡觉&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keyArr = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> index&lt;keyArr.length?&#123;</span><br><span class="line">        <span class="attr">value</span>:&#123;</span><br><span class="line">          <span class="attr">key</span>:keyArr[index],</span><br><span class="line">          <span class="attr">val</span>:obj[keyArr[index++]]</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;:&#123;</span><br><span class="line">        <span class="attr">done</span>:<span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><div class="note primary flat"><p>四种方案：commonjs，AMD，CMD，ES6</p></div><ul><li><p>CommonJS，node的，通过require来引入模块，通过<code>module.exports</code>定义输出接口。是以同步的方式引入模块的。</p></li><li><p>AMD是采用异步的方式加载模块，模块的加载不影响后面语句的执行 所有依赖这个模块的语句都定义在一个回调函数里面，等加载完再执行回调函数。requirejs实现了AMD规范</p></li><li>CMD方案，也是解决异步加载的委托。代表有seajs。和requirejs的区别在于模块定义的时候堆依赖的处理不同和对依赖模块的执行时机处理不同。</li><li>最后是es6的，通过import和export进行导入导出。默认暴露统一暴露分别暴露。<ul><li>默认暴露：<code>export default</code></li><li>分别暴露：<code>export xxx1;exportxxx2</code>，引入<code>import &#123;xxx1,xxx2&#125; from &#39;xxx&#39;</code></li><li>统一暴露：<code>export &#123;aa1,aa1&#125;</code>，引入<code>import &#123;aa1,aa2&#125; from &#39;xxx&#39;</code></li></ul></li></ul><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><ul><li>写法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.a;<span class="comment">//1</span></span><br></pre></td></tr></table></figure></li><li>注意浏览器中使用的话用<code>browserify</code><div class="note primary flat"><p>和es6的区别如下：</p></div></li><li>前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案,前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。</li><li>而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li><li>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。</li><li>但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li><li>后者会编译成 require/exports 来执行的</li></ul><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><div class="note primary flat"><p>和CMD的区别：</p></div><ul><li>对依赖的处理不一样。AMD是依赖前置。定义模块的时候就要声明依赖的模块，CMD就近依赖，用到哪个才去require</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>); <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐</span></span><br><span class="line">define([<span class="string">&quot;./a&quot;</span>, <span class="string">&quot;./b&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>对于依赖模块的执行实际处理不同。AMD和CMD异步加载，但是AMD在模块加载完就立刻执行依赖模块，依赖模块的执行顺序和我们写的顺序不一定一致。而CMD在依赖模块加载完成后并不执行，只是下载。等全部的依赖模块都加载好后，再去执行，和我们的书写顺序一致。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的JavaScript⑤--垃圾回收与内存泄漏</title>
    <link href="https://zlinni.github.io/posts/1805418661/"/>
    <id>https://zlinni.github.io/posts/1805418661/</id>
    <published>2022-04-20T07:02:04.000Z</published>
    <updated>2022-04-27T15:07:14.198Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><div class="note simple"><p>垃圾回收、内存泄漏</p></div><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220427230620.png" alt=""></p><h2 id="为什么要垃圾回收？"><a href="#为什么要垃圾回收？" class="headerlink" title="为什么要垃圾回收？"></a>为什么要垃圾回收？</h2><div class="note primary flat"><p>js的变量没有固定大小，是动态分配的，所以需要进行垃圾回收，避免内存占用满了之后造成系统崩溃。</p></div><h2 id="垃圾回收的机制-特点"><a href="#垃圾回收的机制-特点" class="headerlink" title="垃圾回收的机制/特点"></a>垃圾回收的机制/特点</h2><div class="note primary flat"><p>对于栈内存 切换到别的上下文就回收<br>对于堆内存 分为新生代和老生代</p></div><p>含义：新生代指的是只经过一次垃圾回收的对象，老生代指的是经过多次垃圾回收的对象</p><p>具体：新生代被分为from和to两个空间。to一般闲置，在from的空间满了之后执行scavenge算法进行垃圾回收。</p><p>执行垃圾回收的时候应用逻辑将停止，等垃圾回收结束后继续执行</p><h2 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收?"></a>什么时候回收?</h2><div class="note primary flat"><p>利用浏览器的空闲时间</p></div><h2 id="scavenge算法"><a href="#scavenge算法" class="headerlink" title="scavenge算法"></a>scavenge算法</h2><div class="note primary flat"><p>算法分为三步：</p></div><ol><li>检测from空间的存活对象，查看是否满足老生代条件（to是否超过25%/是否经历过一次垃圾回收）?老生代:移动到to空间</li><li>如果对象不存活则释放对象的空间</li><li>最后将from和to空间进行角色交换</li></ol><h2 id="新生代到老生代"><a href="#新生代到老生代" class="headerlink" title="新生代到老生代"></a>新生代到老生代</h2><div class="note primary flat"><p>条件有两个</p></div><ol><li>我们知道新生代的条件是只经过一次垃圾回收，也就意味着它经历了一次Scavenge</li><li>to空间的内容使用占比。因为scavenge算法结束之后会交换fromto的位置，所以to的空间不能太小，影响到后续的内存分配。所以当从from到to的时候，如果to的空间超过25%，直接变成老生代。</li></ol><h2 id="老生代的回收机制"><a href="#老生代的回收机制" class="headerlink" title="老生代的回收机制"></a>老生代的回收机制</h2><div class="note primary flat"><p>老生代采用了标记清除和标记压缩法</p></div><p>标记清除：在回收的过程中标记存活的对象，结束后清除没有标记的对象（释放了空间）</p><p>不利：造成了很多内存碎片，不利于后续内存分配，引入标记压缩法</p><p>标记压缩法：</p><h2 id="其他的方法"><a href="#其他的方法" class="headerlink" title="其他的方法"></a>其他的方法</h2><div class="note primary flat"><p>增量标记法：垃圾回收的过程会暂停应用逻辑，对于新生代来说还好，对于老生代来说时间长，所以引入增量标记分割停顿的过程，执行一段分割就运行一会逻辑，交替。</p></div><h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><ul><li>意外的全局变量：无法被回收</li><li>定时器：未被正确关闭，导致所引用的外部变量无法被释放。</li><li>事件监听：没有正确销毁（低版本浏览器可能出现）</li><li>闭包<ul><li>第一种情况是我们使用未声明的变量，而意外的创建了一个全局变量，而使得这个变量一直留在内存中无法被回收</li><li>第二种情况是我们设置了setInterval定时器，而忘记取消他，如果循环函数对外部变量有引用的话，那么这个变量会被一直留在内存中，无法被回收。</li><li>第三种情况是我们获取一个DOM元素的引用。而后面的元素被删除。由于我们一直保留了对这个元素的引用，所以他也无法被回收。</li><li>第四种情况是不合理的使用闭包，从而导致某些变量一直被流在内存当中。</li></ul></li><li>dom引用：dom元素被删除时，内存中的引用未被正确清空。</li><li>控制台<code>console.log</code>打印的东西</li></ul><div class="note primary flat"><p>可以用chrome中的timeline进行内存标记，可视化查看内存的变化情况，找出异常点。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的JavaScript④--异步任务与事件</title>
    <link href="https://zlinni.github.io/posts/3693633031/"/>
    <id>https://zlinni.github.io/posts/3693633031/</id>
    <published>2022-04-20T07:01:52.000Z</published>
    <updated>2022-04-25T02:41:30.168Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><div class="note simple"><p>事件机制、Promise、Generator、async/await、事件循环</p></div><h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><div class="note primary flat"><p>事件的触发过程？事件代理？</p></div><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><div class="note primary flat"><p>事件流是一个事件沿着特定数据结构传播的过程。冒泡和捕获是事件流在DOM中的两种不同的传播方式。</p></div><h2 id="事件流的三个阶段"><a href="#事件流的三个阶段" class="headerlink" title="事件流的三个阶段"></a>事件流的三个阶段</h2><ul><li>事件捕获阶段</li><li>目标阶段</li><li>事件冒泡阶段</li></ul><h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><div class="note primary flat"><p>事件捕获通俗的理解就是鼠标点击或者触发dom事件的时候，浏览器从根节点开始由外到内的进行事件传播，即点击了子元素。如果父元素通过捕获方式注册了对应的事件的话，会先触发父元素绑定的事件</p></div><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><div class="note primary flat"><p>事件冒泡和事件捕获相反，顺序是由内到外直到根节点</p></div><p>无论是事件捕获还是冒泡，都有一个共同的特征就是事件传播<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220404101558.png" alt=""></p><h2 id="事件流阻止"><a href="#事件流阻止" class="headerlink" title="事件流阻止"></a>事件流阻止</h2><div class="note primary flat"><p>在一些情况下要阻止事件流的传播，阻止默认动作的发生</p></div><ul><li><code>event.preventDefault()</code>取消事件对象的默认动作以及继续传播</li><li><code>event.stopPropagation()/event.cancelBubble = true</code>阻止事件冒泡<h3 id="在不同浏览器的处理"><a href="#在不同浏览器的处理" class="headerlink" title="在不同浏览器的处理"></a>在不同浏览器的处理</h3></li><li>在IE下使用 <code>event.returnValue= false</code>，</li><li>在非IE下则使用 <code>event.preventDefault()</code>进行阻止<h3 id="preventDefault与stopPropagation的区别"><a href="#preventDefault与stopPropagation的区别" class="headerlink" title="preventDefault与stopPropagation的区别"></a><code>preventDefault</code>与<code>stopPropagation</code>的区别</h3></li><li><code>preventDefault</code>告诉浏览器不用执行与事件相关联的默认动作（如表单提交）</li><li><code>stopPropagation</code>是停止事件继续冒泡，但是对IE9以下的浏览器无效<h2 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h2></li><li>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 <code>false</code>。useCapture 决定了注册的事件是捕获事件还是冒泡事件</li><li>一般来说，我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件<div class="note warning flat"><p>注意<code>addEventListener</code>需要销毁，<code>onClick</code>则不需要因为每次都替换</p></div><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2></li><li>优化性能，当子节点过多的时候给父元素绑定事件通过冒泡只执行一次事件节省内存并且不需要给子节点注销事件。<h2 id="事件的兼容写法"><a href="#事件的兼容写法" class="headerlink" title="事件的兼容写法"></a>事件的兼容写法</h2><div class="note primary flat"><p>ie的event和非ie的event不太一样，也不能一起用</p></div></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gete</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//兼容ie的事件</span></span><br><span class="line">  e = e || <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="comment">//兼容ie的target</span></span><br><span class="line">  <span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><div class="note primary flat"><p>谈到promise的时候，除了将他解决的痛点以及常用的api之外，最好进行拓展吧eventloop带进来好好讲一下。微任务，任务的指向顺序，如果看过promise源码，最好可以谈一谈原生promise是如何实现的，还有就是promise的链式调用</p></div><ul><li>promise是es6新增的语法，解决了回调地狱的问题</li><li>promise可以被看成是一个状态机，初始是<code>pending</code>可以通过函数<code>resolve</code>和<code>reject</code>将状态转变为<code>resolved</code>or<code>rejected</code>状态。状态一旦发生改变就不能再次变化。</li><li>then函数会返回一个promise实例，并且该返回值是一个新的实例而不是之前的实例。因为promise规范规定除了pending状态，其他状态是不能改变的。如果返回的是一个相同实例的话，多个then调用就失去了意义。对于then来说，本质上可以看成是flatMap</li></ul><h2 id="promise的基本情况"><a href="#promise的基本情况" class="headerlink" title="promise的基本情况"></a>promise的基本情况</h2><div class="note primary flat"><p>简单来说他是一个容器，里面保存着某个未来才会结束的事件，通常是异步操作的结果。从语法上面来说，promise是一个对象，从他可以获取异步操作的消息。</p></div><p>一般 Promise 在执行过程中，必然会处于以下几种状态之一。</p><ul><li>待定（pending）：初始状态，既没有被完成，也没有被拒绝。</li><li>已完成（fulfilled）：操作成功完成。</li><li>已拒绝（rejected）：操作失败。<div class="note primary flat"><p>待定状态的promise对象指向的话，最后要么会通过一个值完成，要么会通过一个原因被拒绝。当其中一种情况发生的时候，我们用promise的then方法排列起来的相关处理程序就会被调用。因为最后<code>Promise.prototype.then</code> 和 <code>Promise.prototype.catch</code>方法返回的是一个<code>Promise</code>所以它们可以继续被链式调用。</p></div>关于 Promise 的状态流转情况，有一点值得注意的是，内部状态改变之后不可逆，你需要在编程过程中加以注意。文字描述比较晦涩，我们直接通过一张图就能很清晰地看出 Promise 内部状态流转的情况<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220405105526.png" alt=""><h2 id="then-catch"><a href="#then-catch" class="headerlink" title="then catch"></a>then catch</h2></li><li>thencatch都会返回一个新的promise</li><li>catch不管放在哪里都能捕获上层未捕获的错误</li><li>不写默认返回<code>return Promise.resolve(undefined)</code>也是成功回调</li><li>直接return 一个error对象不会抛出错误 所以不会被catch捕获</li><li>返回的值不能是promise本身 否则死循环</li><li>then可以接收两个参数的，在某些时候你可以认为catch是then第二个参数的简便写法。<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2></li><li>不管最后的状态如何都会执行</li><li>不接受任何参数 所以在finally中是没办法知道最终的状态的</li><li>默认返回上一次的promise对象值，如果抛出的是一个异常则返回异常的promise对象</li></ul><h2 id="new-Promise（大坑）"><a href="#new-Promise（大坑）" class="headerlink" title="new Promise（大坑）"></a><code>new Promise</code>（大坑）</h2><p>先看一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    reject()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;失败的状态&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><br>正确答案是1243<br>这是为什么呢？因为我们会忽略一个问题，就是在<code>new Promise</code>的时候，构造器的方法就已经开始执行了，虽然我们一般提倡用函数封装之后<code>return</code>出去这个promise对象。所以就是先执行<code>new Promise</code>里面的代码 输出12然后状态到<code>resolved</code>然后执行同步的4 最后因为成功的回调到3</p><h2 id="promise的静态方法"><a href="#promise的静态方法" class="headerlink" title="promise的静态方法"></a>promise的静态方法</h2><h3 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h3><ul><li>语法:<code>Promise.all(iterable)</code></li><li>参数：一个可迭代对象，例如Array（括号里面放数组）</li><li>描述：此方法对于汇总多个promise的结果很有用，在es6中可以将多个<code>Promise.all</code>异步请求并发操作，返回的结果一般有下面两种情况。<ol><li>当所有结果成功返回按照请求顺序返回成功结果</li><li>当其中一个方法失败就进入失败方法。</li></ol></li><li>业务场景 </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个页面中需要加载获取轮播列表、获取店铺列表、获取分类列表这三个操作，页面需要同时发出请求进行页面渲染，这样用 `Promise.all` 来实现，看起来更清晰、一目了然。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获取轮播数据列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBannerList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;轮播数据&#x27;</span>)</span><br><span class="line">      &#125;,<span class="number">300</span>) </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.获取店铺列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStoreList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">&#x27;店铺数据&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">500</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.获取分类列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCategoryList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">&#x27;分类数据&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">700</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initLoad</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">Promise</span>.all([getBannerList(),getStoreList(),getCategoryList()])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) </span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; </span><br><span class="line">initLoad()</span><br></pre></td></tr></table></figure><h4 id="all如果有一个抛出了异常会如何处理。"><a href="#all如果有一个抛出了异常会如何处理。" class="headerlink" title="all如果有一个抛出了异常会如何处理。"></a>all如果有一个抛出了异常会如何处理。</h4><div class="note primary flat"><p>all和race传入的数组中如果会有抛出异常的异步任务，那么只有最先抛出的错误会被捕获。并且是被then的第二个参数或者后面的catch捕获，但并不影响数组中其他的异步任务的执行。</p></div><h4 id="all是并发的还是串行的"><a href="#all是并发的还是串行的" class="headerlink" title="all是并发的还是串行的"></a>all是并发的还是串行的</h4><div class="note primary flat"><p>并发的。不过<code>promise.all().then()</code>结果中数组的顺序和<code>Promise.all()</code>接收到的数组顺序一致</p></div><h4 id="all的并发限制"><a href="#all的并发限制" class="headerlink" title="all的并发限制"></a>all的并发限制</h4><div class="note primary flat"><p>Promise.all可以保证，promises数组中所有promise对象都达到resolve状态，才执行then回调。</p><p>这时候考虑一个场景：如果你的promises数组中每个对象都是http请求，或者说每个对象包含了复杂的调用处理。而这样的对象有几十万个。</p><p>那么会出现的情况是，你在瞬间发出几十万http请求（tcp连接数不足可能造成等待），或者堆积了无数调用栈导致内存溢出。</p><p>这时候，我们就需要考虑对Promise.all做并发限制。</p><p>Promise.all并发限制指的是，每个时刻并发执行的promise数量是固定的，最终的执行结果还是保持与原来的Promise.all一致。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncPool</span>(<span class="params">poolLimit, array, iteratorFn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line">    <span class="keyword">const</span> executing = [];</span><br><span class="line">    <span class="keyword">const</span> enqueue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 边界处理，array为空数组</span></span><br><span class="line">        <span class="keyword">if</span> (i === array.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每调一次enqueue，初始化一个promise</span></span><br><span class="line">        <span class="keyword">const</span> item = array[i++];</span><br><span class="line">        <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> iteratorFn(item, array));</span><br><span class="line">        <span class="comment">// 放入promises数组</span></span><br><span class="line">        ret.push(p);</span><br><span class="line">        <span class="comment">// promise执行完毕，从executing数组中删除</span></span><br><span class="line">        <span class="keyword">const</span> e = p.then(<span class="function">() =&gt;</span> executing.splice(executing.indexOf(e), <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 插入executing数字，表示正在执行的promise</span></span><br><span class="line">        executing.push(e);</span><br><span class="line">        <span class="comment">// 使用Promise.rece，每当executing数组中promise数量低于poolLimit，就实例化新的promise并执行</span></span><br><span class="line">        <span class="keyword">let</span> r = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">        <span class="keyword">if</span> (executing.length &gt;= poolLimit) &#123;</span><br><span class="line">            r = <span class="built_in">Promise</span>.race(executing);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归，直到遍历完array</span></span><br><span class="line">        <span class="keyword">return</span> r.then(<span class="function">() =&gt;</span> enqueue());</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> enqueue().then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.all(ret));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allSettled方法"><a href="#allSettled方法" class="headerlink" title="allSettled方法"></a><code>allSettled</code>方法</h3><ul><li><code>Promise.allSettled</code>的语法及参数跟<code>Promise.all</code>类似.不同在于它执行完之后不会失败，会按顺序返回每个promise的状态</li><li>案例</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="built_in">Promise</span>.allSettled([resolved, rejected]);</span><br><span class="line">allSettledPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回结果：</span></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 2 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><h3 id="any方法-还在草案不能使用"><a href="#any方法-还在草案不能使用" class="headerlink" title="any方法(还在草案不能使用)"></a>any方法(还在草案不能使用)</h3><ul><li>语法：<code>Promise.any（iterable）</code></li><li>参数： iterable 可迭代的对象，例如 Array。</li><li>描述：any返回一个promise 只要参数promise实例中有一个变成fulfilled状态，最后any返回的实例就返回fulfilled状态，如果全部都是rejected，就返回rejected状态<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> anyPromise = <span class="built_in">Promise</span>.any([resolved, rejected]);</span><br><span class="line">anyPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回结果：</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="race方法"><a href="#race方法" class="headerlink" title="race方法"></a>race方法</h3><ul><li>语法：<code>Promise.race（iterable）</code></li><li>参数： iterable 可迭代的对象，例如 Array。</li><li>描述： race方法返回一个promise，只要参数的promise之中有一个实例率先改变状态，那么race方法的返回状态就跟着改变。那个率先改变的promise实例的返回值就传递给race方法的回调函数。</li><li>业务场景：图片加载 超时判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求某个图片资源</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestImg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; resolve(img); &#125;</span><br><span class="line">    img.src = <span class="string">&#x27;http://www.baidu.com/img/flexible/logo/pc/result.png&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//延时函数，用于给请求计时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; reject(<span class="string">&#x27;图片请求超时&#x27;</span>); &#125;, <span class="number">5000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([requestImg(), timeout()])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面的代码中可以看出，采用 Promise 的方式来判断图片是否加载成功，也是针对 Promise.race 方法的一个比较好的业务场</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220405111554.png" alt=""></p><h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><div class="note primary flat"><p>generator是es6新增的语法，和promise一样可以用来异步编程，最大的特点是它可以利用yield和next分段执行。</p></div><ul><li><code>function *foo(x)</code>使用<em>号来声明该函数是一个生成器函数，`</em>`的位置比较随意。</li><li><code>yield</code>关键字用来实现分段执行，它的意思是产出，当生成器函数遇到yield的时候会暂停并把他后面的表达式抛出去。（注意yield可以不写在生成器中）</li><li><code>next</code>表示将代码的控制权还给生成器函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = foo(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(it.next())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>过程：</p><ul><li>首先执行第一个next的时候传参会被忽略 因为赋值的时候已经传了参 所以参数就是5 且到第一个yield停止。返回后面的结果 就是6 此时x为5</li><li>来到第二个next 传入的参数覆盖上一次yield的结果 所以此时y为<code>12*2=24</code> 那么返回的结果就是8</li><li>第三个next 传入的参数覆盖上一次yield的结果 所以此时z为13 那么总体就是<code>5+24+13=42</code></li></ul><h2 id="简单实现generator"><a href="#简单实现generator" class="headerlink" title="简单实现generator"></a>简单实现generator</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cb 也就是编译过的 test 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generator</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> object = &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">stop</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = cb(object);</span><br><span class="line">        <span class="keyword">if</span> (ret === <span class="literal">undefined</span>) <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: ret,</span><br><span class="line">          <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果你使用 babel 编译后可以发现 test 函数变成了这样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="keyword">return</span> generator(<span class="function"><span class="keyword">function</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> ((_context.prev = _context.next)) &#123;</span><br><span class="line">        <span class="comment">// 可以发现通过 yield 将代码分割成几块</span></span><br><span class="line">        <span class="comment">// 每次执行 next 函数就执行一块代码</span></span><br><span class="line">        <span class="comment">// 并且表明下次需要执行哪块代码</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">          _context.next = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">          _context.next = <span class="number">6</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 执行完毕</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">          <span class="keyword">return</span> _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a><code>async/await</code></h1><div class="note primary flat"><p>Generator的语法糖，有更好的语义性和适用性，返回的是promise</p></div><ul><li>await和promise一样更多是笔试题</li><li>await相比直接使用promise来说 优势在于处理then的调用链，能够更清晰的写出代码。缺点在于await可能导致性能问题。因为await会阻塞代码。也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性，此时更应该使用<code>Promise.all</code></li><li>一个函数如果加上了async 那么就会返回一个promise<div class="note primary flat"><p><code>async =&gt; *</code> <code>await =&gt; yield</code></p></div>案例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + <span class="keyword">await</span> <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>, a) <span class="comment">// -&gt; &#x27;2&#x27; 10</span></span><br><span class="line">  a = (<span class="keyword">await</span> <span class="number">10</span>) + a</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>, a) <span class="comment">// -&gt; &#x27;3&#x27; 20</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>, a) <span class="comment">// -&gt; &#x27;1&#x27; 1</span></span><br></pre></td></tr></table></figure></li><li>首先函数b执行 但是遇到了<code>await</code>暂时返还了代码的控制权，所以到外面去执行了a++并输出a为1。</li><li>又因为await内部实现了generators，且它会保留堆栈中的东西，所以在返还之前的a=0被保留了下来。输出10 然后是20</li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><div class="note primary flat"><p>async/await的优势在于处理 then 的调用链，能够更清晰准确的写出代码，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。</p></div><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><div class="note primary flat"><p>首先js的任务分为同步任务和异步任务，异步中又分为宏任务和微任务，我们常见的settimeout，setinterval系列就是宏任务，promise，muationobserver系列就是微任务，微任务插队宏任务。</p></div><ul><li>默认代码从上到下执行，执行环境通过<code>script</code>来执行</li><li>代码执行过程中，先执行同步任务，再执行异步任务。</li><li>给异步任务划分队列，分别存在微任务（立即存放）和宏任务（时间到了或者事情发生了在存放）到队列中</li><li>script执行后清空所有微任务。</li><li>微任务执行完毕后渲染页面（不是每次都调用—）</li><li>再去宏任务队列中看看也没有到达时间的，拿出来其中一个执行。</li><li>执行完毕后按上述的步骤不停循环。<br>例子(UI渲染是宏任务)<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406095138.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406095150.png" alt=""><div class="note primary flat"><p>自动执行的情况 会输出 listener1 listener2 task1 task2</p></div><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406095222.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406100602.png" alt=""><div class="note primary flat"><p>如果手动点击click 会一个宏任务取出来一个个执行，先执行click的宏任务，取出微任务去执行。会输出 listener1 task1 listener2 task2</p></div></li></ul><p>案例1<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="comment">// await xx ==&gt; promise.resolve(()=&gt;&#123;console.log(3)&#125;).then()</span></span><br><span class="line">  <span class="comment">// console.log(3) 放到promise.resolve或立即执行</span></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="number">3</span>) </span><br><span class="line">  <span class="comment">// 相当于把console.log(4)放到了then promise.resolve(()=&gt;&#123;console.log(3)&#125;).then(()=&gt;&#123;</span></span><br><span class="line">  <span class="comment">//   console.log(4)</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line">  <span class="comment">// 微任务谁先注册谁先执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">  resolve(<span class="number">7</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">d</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(d)&#125;)</span><br><span class="line"></span><br><span class="line">asyncFunc()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 1 6 2 3 8 7 4 5</span></span><br></pre></td></tr></table></figure><br>案例2<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406101017.png" alt=""></p><h2 id="JS为什么是单线程？"><a href="#JS为什么是单线程？" class="headerlink" title="JS为什么是单线程？"></a>JS为什么是单线程？</h2><div class="note primary flat"><p>js的单线程和它的用途有关，作为浏览器脚本语言，JavaScript主要用途是与用户互动以及操作DOM。这决定了他只能是单线程，否则会带来很复杂的同步问题。比如假定js同时有两个线程，一个线程在某dom节点上添加内容，另外一个线程删除了节点。这个时候浏览器应该以哪个线程为准？所以为了避免复杂性，从一诞生，js就是单线程，这已经成为了这门语言的核心特征以后也不会改变。</p></div><h2 id="浏览器事件循环"><a href="#浏览器事件循环" class="headerlink" title="浏览器事件循环"></a>浏览器事件循环</h2><div class="note primary flat"><p>涉及面试题：异步代码的执行顺序？解释一下什么是Event Loop</p></div><ul><li>首先js是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来确保代码的有序进行。</li><li>在执行同步代码的时候，如果遇到了异步事件，js引擎并不会一致等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。</li><li>当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行</li><li>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行</li><li>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。<h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a><code>process.nextTick</code></h2><div class="note primary flat"><p><code>process.nextTick</code>指定的异步任务总是发生于所有异步任务之前。</p></div></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;);</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 2 5 4 3 1</span></span><br></pre></td></tr></table></figure><h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><ul><li><code>process.nextTick</code></li><li><code>promise</code></li><li><code>Object.observe</code></li><li><code>MutationObserver</code><h2 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h2></li><li><code>script</code></li><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code></li><li><code>I/O</code> 网络请求完成、文件读写完成事件</li><li><code>UI rendering</code></li><li>用户交互事件（比如鼠标点击、滚动页面、放大缩小等）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
</feed>
