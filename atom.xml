<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鱼与前端🐟</title>
  
  <subtitle>摸鱼和工作不可得兼~</subtitle>
  <link href="https://zlinni.github.io/atom.xml" rel="self"/>
  
  <link href="https://zlinni.github.io/"/>
  <updated>2022-06-13T13:49:32.368Z</updated>
  <id>https://zlinni.github.io/</id>
  
  <author>
    <name>Zlinni</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从零开始的mini-vue⑦--Scheduler篇</title>
    <link href="https://zlinni.github.io/posts/3541433463/"/>
    <id>https://zlinni.github.io/posts/3541433463/</id>
    <published>2022-06-13T00:44:49.000Z</published>
    <updated>2022-06-13T13:49:32.368Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是 scheduler 篇，是关于 Vue3 中调度机制的深入讨论。</p></div><h1 id="为什么需要-scheduler"><a href="#为什么需要-scheduler" class="headerlink" title="为什么需要 scheduler"></a>为什么需要 scheduler</h1><p>在我们上节组件的实践中，我们跑了一个这样的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render, h &#125; <span class="keyword">from</span> <span class="string">&quot;./runtime&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;./reactiveDemo/ref&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> Comp = &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      count.value++;</span><br><span class="line">      <span class="built_in">console</span>.log(count.value);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">      add,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      h(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, ctx.count),</span><br><span class="line">      h(</span><br><span class="line">        <span class="string">&quot;button&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">onClick</span>: ctx.add,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;add&quot;</span></span><br><span class="line">      ),</span><br><span class="line">    ];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnode = h(Comp);</span><br><span class="line">render(vnode, <span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure><p>如果我们将例子中的 add 函数修改成如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.value++;</span><br><span class="line">  count.value++;</span><br><span class="line">  count.value++;</span><br><span class="line">  <span class="built_in">console</span>.log(count.value);</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;render&#x27;</span>);</span><br><span class="line">   <span class="keyword">return</span> [</span><br><span class="line">     h(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, ctx.count),</span><br><span class="line">     h(</span><br><span class="line">       <span class="string">&quot;button&quot;</span>,</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="attr">onClick</span>: ctx.add,</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="string">&quot;add&quot;</span></span><br><span class="line">     ),</span><br><span class="line">   ];</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>我们会发现它是可以运行，一次加 3，但是右侧控制台中会发现这样的情况</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220613085131.png" alt=""></p><p>说明了我们每执行一次 add 操作，渲染函数就执行了三次。很明显这样是不对的，我们期望它每次执行 add 就只执行一次，回想一下之前 reactive 篇中的 effect 和 computed，我们用到了 scheduler 机制去帮助我们在 trigger 中优先执行 scheduler，所以我们也可以用同样的机制，优先执行完 add 操作再执行 render</p><h1 id="使用调度机制"><a href="#使用调度机制" class="headerlink" title="使用调度机制"></a>使用调度机制</h1><p>只需要在 update 里面加一个 scheduler 的配置项即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">instance.update = effect(</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">scheduler</span>: queueJob,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="queueJob"><a href="#queueJob" class="headerlink" title="queueJob"></a>queueJob</h1><p>接下来我们编写一个 queueJob 函数，它接收 job 作为参数，其实这个 job 就是我们的 effectFn，我们还需要一个任务栈用于放 job，并且还要对 job 进行去重(？)之后放入队列进行任务的执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue = [];</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueJob</span>(<span class="params">job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!queue.length || !queue.includes(job)) &#123;</span><br><span class="line">    queue.push(job);</span><br><span class="line">    <span class="comment">// 清空队列的操作</span></span><br><span class="line">    queueFlush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="queueFlush"><a href="#queueFlush" class="headerlink" title="queueFlush"></a>queueFlush</h1><p>这一步主要是看任务是否正在执行，如果有正在执行的任务就等待任务执行结束，如果没有就用异步任务执行 job</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueFlush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 任务是否正在执行 不在的话才能进入promise 且要等每次promise执行完才能进入下一个任务</span></span><br><span class="line">  <span class="keyword">if</span> (!isFlushing) &#123;</span><br><span class="line">    isFlushing = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(flushJobs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="flushJobs"><a href="#flushJobs" class="headerlink" title="flushJobs"></a>flushJobs</h1><p>我们的任务执行完才清空队列进行下一次任务,且由于 job 是用户代码可能会出错，所以要用 try 包裹起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushJobs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 因为是用户代码可能会出错</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 注意不能用len = queue.length 因为它可能在执行的时候继续添加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; queue.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> job = queue[i];</span><br><span class="line">      job();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isFlushing = <span class="literal">false</span>;</span><br><span class="line">    queue.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实践一下就会发现，要直接获取 dom 的数据还是不行或者获取，这里就需要 settimeout 或者 vue 的 nextTick</p><p>所以我们要实现一个 nextTick</p><h1 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h1><p>对于 nextTick 有两种情况，1 是使用的时候还存在正在执行的 promise，则直接返回当前正在执行的 promise 成功的回调，2 是当前的任务都已经执行完了，那么就返回一个新的 promise 成功执行的回调。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代表正在执行的promise</span></span><br><span class="line"><span class="keyword">let</span> currentFlushPromise = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 封装一下Promise.resolve()</span></span><br><span class="line"><span class="keyword">const</span> resolvedPromise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果有在执行的promise则返回当前在执行的promise成功回调的结果，如果没有则返回一个新的promise的成功回调结果</span></span><br><span class="line">    <span class="keyword">const</span> p = currentFlushPromise || resolvedPromise;</span><br><span class="line">    <span class="keyword">return</span> p.then(fn);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueFlush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 任务是否正在执行 不在的话才能进入promise 且要等每次promise执行完才能进入下一个任务</span></span><br><span class="line">    <span class="keyword">if</span> (!isFlushing) &#123;</span><br><span class="line">        isFlushing = <span class="literal">true</span>;</span><br><span class="line">        currentFlushPromise = resolvedPromise.then(flushJobs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清空队列了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushJobs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 因为是用户代码可能会出错</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        isFlushing = <span class="literal">false</span>;</span><br><span class="line">        queue.length = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意清空currentFlushPromise</span></span><br><span class="line">        currentFlushPromise = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们还会用到 es6 的 await 语法，比如<code>await nextTick()</code>这个时候是不传参的，所以针对这种写法我们也要注意</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = currentFlushPromise || resolvedPromise;</span><br><span class="line">  <span class="comment">// 如果fn存在就p.then否则就把p传回去</span></span><br><span class="line">  <span class="keyword">return</span> fn ? p.then(fn) : p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们已经写好了完整的 scheduler</p><h1 id="scheduler-完整代码"><a href="#scheduler-完整代码" class="headerlink" title="scheduler 完整代码"></a>scheduler 完整代码</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue = [];</span><br><span class="line"><span class="keyword">let</span> isFlushing = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> currentFlushPromise = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> resolvedPromise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果有在执行的promise则返回当前在执行的promise成功回调的结果，如果没有则返回一个新的promise的成功回调结果</span></span><br><span class="line">  <span class="keyword">const</span> p = currentFlushPromise || resolvedPromise;</span><br><span class="line">  <span class="keyword">return</span> fn ? p.then(fn) : p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;effectFn&#125;</span> <span class="variable">job</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueJob</span>(<span class="params">job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!queue.length || !queue.includes(job)) &#123;</span><br><span class="line">    queue.push(job);</span><br><span class="line">    <span class="comment">// 清空队列的操作</span></span><br><span class="line">    queueFlush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueFlush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 任务是否正在执行 不在的话才能进入promise 且要等每次promise执行完才能进入下一个任务</span></span><br><span class="line">  <span class="keyword">if</span> (!isFlushing) &#123;</span><br><span class="line">    isFlushing = <span class="literal">true</span>;</span><br><span class="line">    currentFlushPromise = resolvedPromise.then(flushJobs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清空队列了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushJobs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 因为是用户代码可能会出错</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 注意不能用len = queue.length 因为它可能在执行的时候继续添加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; queue.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> job = queue[i];</span><br><span class="line">      job();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isFlushing = <span class="literal">false</span>;</span><br><span class="line">    queue.length = <span class="number">0</span>;</span><br><span class="line">    currentFlushPromise = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="createApp"><a href="#createApp" class="headerlink" title="createApp"></a>createApp</h1><p>接下来我们写 minivue 的 createApp，我们一般都是 createApp 包裹住一个组件，然后<code>.mount(document.body)</code>这样写，不需要 render 和 h 函数生成 vnode</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Zlinni 984328216@qq.com</span></span><br><span class="line"><span class="comment"> * @Date: 2022-05-22 19:49:21</span></span><br><span class="line"><span class="comment"> * @LastEditors: Zlinni 984328216@qq.com</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2022-06-13 19:24:24</span></span><br><span class="line"><span class="comment"> * @FilePath: \mini-vue\zMini-vue\src\index.js</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2022 by Zlinni 984328216@qq.com, All Rights Reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123; render, h, createApp &#125; <span class="keyword">from</span> <span class="string">&quot;./runtime&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;./reactive/ref&quot;</span>;</span><br><span class="line">createApp(&#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      count.value++;</span><br><span class="line">      count.value++;</span><br><span class="line">      count.value++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">      add,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;render&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      h(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, ctx.count.value),</span><br><span class="line">      h(</span><br><span class="line">        <span class="string">&quot;button&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">onClick</span>: ctx.add,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;add&quot;</span></span><br><span class="line">      ),</span><br><span class="line">    ];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).mount(<span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure><p>首先我们创建一个<code>createApp.js</code>，这个 createApp 接受一个参数，是组件，返回一个组件实例，我们还需要将他用 mount 挂载起来，其中对于 mount 来说，可以接受一个 dom 也可以接收字符串，比如我们在创建 vue 实例的时候经常会写的<code>mount(#app)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isString &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">&quot;./render&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&quot;./vnode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;组件&#125;</span> <span class="variable">rootComponent</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;组件的实例&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params">rootComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = &#123;</span><br><span class="line">    <span class="function"><span class="title">mount</span>(<span class="params">rootContainer</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 如果它是字符串就把他转换成DOM对象</span></span><br><span class="line">      <span class="keyword">if</span> (isString(rootContainer)) &#123;</span><br><span class="line">        rootContainer = <span class="built_in">document</span>.querySelector(rootContainer);</span><br><span class="line">      &#125;</span><br><span class="line">      render(h(rootComponent), rootContainer);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就实现了这个 createApp，但是 vue 为什么要单独写一个 createApp 呢。实际上，它是为了后面更好的拓展 Vue 下面的其他方法，比如我们用过的 <code>use()</code>,<code>mixin()</code>等方法</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本节中我们学习了 vue 的 scheduler 调度机制，从之前 effect 和 computed 的案例开始说起，沿用 scheduler 的优先执行机制(异步任务)来帮助我们优化组件的更新过程，其中对于任务队列(queueJob)，我们只在队列为空或者不存在相同的任务的时候才将任务放进任务栈，然后去执行任务(queueFlush),这个过程中我们要把当前执行的任务保存起来，到真正执行环节(flushJobs)的时候，因为这些任务是用户代码需要包裹起来，然后将它们逐个从任务栈中取出来执行。执行结束之后改变标志位并清空当前执行任务的标志。</p><p>我们还学到了nextTick，其实nextTick就和我们的调度机制息息相关，我们拿到了scheduler中正在执行的任务，就将nextTick的事件放到它的成功回调后，当然还要考虑一种情况如果任务都执行完了，就将事件放在新的promise的成功回调中。不过最后我们还考虑到了es6的await使用nextTick的情况，我们就把nextTick的返回值稍作修改，当有fn传进来就返回任务的成功回调，否则就返回整个任务promise。</p><p>下一节我们将学习vue的模板编译。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的mini-vue⑥--Component篇</title>
    <link href="https://zlinni.github.io/posts/1033180007/"/>
    <id>https://zlinni.github.io/posts/1033180007/</id>
    <published>2022-06-12T02:21:17.000Z</published>
    <updated>2022-06-13T13:48:55.261Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是 Component 篇，是关于 Vue3 中组件的深入讨论。</p></div><h1 id="组件是什么"><a href="#组件是什么" class="headerlink" title="组件是什么"></a>组件是什么</h1><div class="note primary flat"><p>从开发者的视角来看，组件分为状态组件和函数组件，vue 其实也有函数式组件，但它和状态组件，从实现上来讲几乎没有多大区别，因此我们只考虑状态组件，以下所讲的组件都是状态组件</p></div><p>React 的组件示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.add&#125;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue3 的组件示例（optional）（渲染函数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">createApp(&#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      h(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, ctx.count),</span><br><span class="line">      h(</span><br><span class="line">        <span class="string">&quot;button&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">onClick</span>: ctx.add,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;add&quot;</span></span><br><span class="line">      ),</span><br><span class="line">    ];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><p>Vue3 的组件示例（composition）（渲染函数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">createApp(&#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> add = <span class="function">() =&gt;</span> count.value++;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">      add,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      h(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, ctx.count),</span><br><span class="line">      h(</span><br><span class="line">        <span class="string">&quot;button&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">onClick</span>: ctx.add,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;add&quot;</span></span><br><span class="line">      ),</span><br><span class="line">    ];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><p>所以从实现来看都有共同点：</p><ol><li>都有 instance 实例，以承载内部的状态，方法等</li><li>都有一个 render 函数</li><li>都通过 render 产出 vnode</li><li>都有一套更新策略，以重新执行 render 函数</li><li>在此基础上附加各种能力，如生命周期，通信机制，slot，provide，inject 等等</li></ol><p>不过我们不打算实现 optional API 的写法，只实现 composition API。也不打算实现 slot，provide，inject 等等</p><p>所以根据此基础我们先来改造一开始没用做完的 processComponent</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processComponent</span>(<span class="params">prevVNode, vnode, container, anchor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO processComponent</span></span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    <span class="comment">// TODO updateComponent</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountComponent(vnode, container, anchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将 mountComponent 放在<code>component.js</code>中并引入。</p><p>不过在编写 mountComponent 之前，我们看一个例子：</p><h1 id="prop-和-attr"><a href="#prop-和-attr" class="headerlink" title="prop 和 attr"></a>prop 和 attr</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Comp = &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&quot;foo&quot;</span>],</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;a&quot;</span>, <span class="attr">id</span>: ctx.bar &#125;, ctx.foo);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnodeProps = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnode = h(Comp, vnodeProps);</span><br><span class="line">render(vnode, root); <span class="comment">// 渲染为&lt;div class=&quot;a&quot; bar=&quot;bar&quot;&gt;foo&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p>这个例子只 prop 了一个 foo，没有接收 bar。所以对应也渲染了 foo 出来，没有渲染 id 为 bar。但是为什么又有一个 <code>bar=&quot;bar&quot;</code>属性呢？这个是因为 vue3 会默认的将没有 prop 进来的参数自动作为 attribute 添加到根节点上。</p><p>所以我们的实例要有 props 和 attrs 两个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params">vnode, container, anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">type</span>: Component &#125; = vnode;</span><br><span class="line">  <span class="comment">// 一个组件必然有一个实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = &#123;</span><br><span class="line">    <span class="attr">props</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">attrs</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 初始化props</span></span><br><span class="line">  initProps(instance, vnode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="initProps"><a href="#initProps" class="headerlink" title="initProps"></a>initProps</h2><p>这一步操作主要是为了分离 props 和 attrs，setup 的 props 中存在的就分配给 props，不存在的就分配给 attrs。然后再把 props 变成响应式放出去使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span>(<span class="params">instance, vnode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 我们知道type在vnode里面</span></span><br><span class="line">  <span class="comment">// 起别名免得命名冲突 此时这两个就对应了例子中的Comp和vnodeProps</span></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">type</span>: Component, <span class="attr">props</span>: vnodeProps &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> props = (instance.props = &#123;&#125;);</span><br><span class="line">  <span class="keyword">const</span> attrs = (instance.attrs = &#123;&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> vnodeProps) &#123;</span><br><span class="line">    <span class="comment">// 因为prop有很多种类型，我们把它当作只能接收数组类型来简单处理</span></span><br><span class="line">    <span class="comment">// 又因为这个props不一定声明，所以用可选链</span></span><br><span class="line">    <span class="keyword">if</span> (Component.props?.includes(key)) &#123;</span><br><span class="line">      props[key] = vnodeProps[key];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      attrs[key] = vnodeProps[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 因为props的数据也是响应式的，但是它不能被修改，这里就先用reactive来简单替代</span></span><br><span class="line">  instance.props = reactive(instance.props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><p>再次回到 mountComponent,我们接下来要去出发 setup 将我们的 props 和 attrs 传进去。根据 vue3 官网我们知道 setup 接收两个参数<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220612151936.png" alt=""></p><p>其中 props 我们已经写了，context 是一个对象，包含着 attrs，slot，emit，我们只简单实现 attrs，所以也就将 attrs 传进去即可。另外由于 setup 最终会把响应式数据 return 出去，所以我们还需要保存下这个结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">type</span>: Component &#125; = vnode;</span><br><span class="line"><span class="comment">// 一个组件必然有一个实例</span></span><br><span class="line"><span class="keyword">const</span> instance = &#123;</span><br><span class="line">  <span class="attr">props</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">attrs</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 将结果保存起来</span></span><br><span class="line">  <span class="attr">setupState</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 初始化props</span></span><br><span class="line">initProps(instance, vnode);</span><br><span class="line"><span class="comment">// 因为setup也可能不存在，所以可选链</span></span><br><span class="line">instance.setupState = Component.setup?.(instance.props, &#123;</span><br><span class="line">  <span class="attr">attrs</span>: instance.attrs,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接下来我们就继续执行 mountComponent 函数</p><h2 id="ctx"><a href="#ctx" class="headerlink" title="ctx"></a>ctx</h2><p>render 接收一个 ctx，通过观察发现 ctx 包含了 props 或者 setupState</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = &#123;</span><br><span class="line">  <span class="attr">props</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">attrs</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 将结果保存起来</span></span><br><span class="line">  <span class="attr">setupState</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 观测实例发现ctx可以取到setupState和props</span></span><br><span class="line">  <span class="attr">ctx</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意vue源码里面是采用代理从props里面找，找不到再找setupState，这里偷懒直接合并</span></span><br><span class="line">instance.ctx = &#123;</span><br><span class="line">  ...instance.props,</span><br><span class="line">  ...instance.setupState,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="封装-mount"><a href="#封装-mount" class="headerlink" title="封装 mount"></a>封装 mount</h2><p>然后我们将执行 render 函数的操作封装成一个方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 将执行render的操作封装成一个函数</span></span><br><span class="line">  <span class="attr">mount</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这里就不用可选链了,因为render对于组件来说必须存在的</span></span><br><span class="line">instance.mount = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">  Component.render(instance.ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="normalizeVNode"><a href="#normalizeVNode" class="headerlink" title="normalizeVNode"></a>normalizeVNode</h3><p>不过我们还要对 mount 返回的结果进行一个预处理</p><p>如果它只是一个 h 函数好说,但是如果它是一个数组的情况,就不是一个标准的 vnode,而且我们如果想对只返回一个字符串等操作做处理,那么我们就需要一个辅助函数 normalizeVNode,我们将他放到<code>vnode.js</code>里面做处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">normalizeVNode</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是个数组我们就用Fragment把他包装一下</span></span><br><span class="line">  <span class="keyword">if</span> (isArray(result)) &#123;</span><br><span class="line">    <span class="keyword">return</span> h(Fragment, <span class="literal">null</span>, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isObject(result)) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// string||number</span></span><br><span class="line">  <span class="keyword">return</span> h(Text, <span class="literal">null</span>, result.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次回到 mountComponent</p><p>我们将组件产物的 vnode 命名为 subTree</p><h3 id="subTree"><a href="#subTree" class="headerlink" title="subTree"></a>subTree</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">instance.mount = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subTree = normalizeVNode(Component.render(instance.ctx));</span><br><span class="line">  <span class="comment">// 直接patch 但是注意这里的引入方式,可以直接传入也可以导出然后使用</span></span><br><span class="line">  patch(<span class="literal">null</span>, subTree, container, anchor);</span><br><span class="line">&#125;;</span><br><span class="line">instance.mount();</span><br></pre></td></tr></table></figure><h1 id="案例-1"><a href="#案例-1" class="headerlink" title="案例 1"></a>案例 1</h1><p>之后我们跑一下这段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render, h &#125; <span class="keyword">from</span> <span class="string">&quot;./runtime&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> Comp = &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&quot;foo&quot;</span>],</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;a&quot;</span>, <span class="attr">id</span>: ctx.bar &#125;, ctx.foo);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnodeProps = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnode = h(Comp, vnodeProps);</span><br><span class="line">render(vnode, <span class="built_in">document</span>.body); <span class="comment">// 渲染为&lt;div class=&quot;a&quot; bar=&quot;bar&quot;&gt;foo&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p>第一次跑的时候会发现它少了一个 bar 属性，前面也提到了 vue3 会默认的将没有 prop 进来的参数自动作为 attribute 添加到根节点上。所以这个 bar 是一定存在的，至于为什么跑了这段代码他没出现，原因是我们没有处理 attr 的继承</p><h2 id="fallThrough"><a href="#fallThrough" class="headerlink" title="fallThrough"></a>fallThrough</h2><p>这个方法用于处理 attr 的继承，因为我们的这个 props 最后是会在 patchDomProp 中进行处理的。所以我们现在要把 bar 传过去的方法就是将他和我们现在的 props 合并(虽然 vue3 不是这样做的，从简吧)</p><p>具体做法是如果存在 attr 属性，就将组件的节点所在的 props 和 instance 的 attrs 合并.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fallThrough</span>(<span class="params">instance, subTree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(instance.attrs).length) &#123;</span><br><span class="line">    subTree.props = &#123;</span><br><span class="line">      ...subTree.props,</span><br><span class="line">      ...instance.attrs,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220612163006.png" alt=""></p><p>可以看到最后结果和我们预想的一致</p><h1 id="案例-2"><a href="#案例-2" class="headerlink" title="案例 2"></a>案例 2</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render, h &#125; <span class="keyword">from</span> <span class="string">&quot;./runtime&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;./reactiveDemo/ref&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> Comp = &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      count.value++;</span><br><span class="line">      <span class="built_in">console</span>.log(count.value);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">      add,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      h(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, ctx.count),</span><br><span class="line">      h(</span><br><span class="line">        <span class="string">&quot;button&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">onClick</span>: ctx.add,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;add&quot;</span></span><br><span class="line">      ),</span><br><span class="line">    ];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnode = h(Comp);</span><br><span class="line">render(vnode, <span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220612164141.png" alt=""></p><p>在案例二中我们发现跑出来的结果并没有 count，这个是因为真正的 vue 里面处理掉了这个 value 值，不需要 value 值就可以访问基础类型响应式数据，而我们图方便就不这样做了，选择直接改为<code>h(&quot;div&quot;, null, ctx.count.value)</code>重新跑</p><p>我们发现 dom 已经渲染出来了</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220612164130.png" alt=""></p><p>但是不论我们如何点击都没有改变值，现在我们输出一下 count 值试一试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.value++;</span><br><span class="line">  <span class="built_in">console</span>.log(count.value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220612164409.png" alt=""></p><p>我们发现结果已经加了 但是 dom 并没有更新，原因很简单，因为我们只 mount 了一次，没有写 update 操作</p><h1 id="update"><a href="#update" class="headerlink" title="update"></a>update</h1><p>既然是更新，就需要拿到上一次的结果进行 patch，所以我们要将 subTree 存起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">instance.update = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> prev = instance.subTree;</span><br><span class="line">  <span class="keyword">const</span> subTree = (instance.subTree = normalizeVNode(</span><br><span class="line">    Component.render(instance.ctx)</span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(instance.attrs).length) &#123;</span><br><span class="line">    subTree.props = &#123;</span><br><span class="line">      ...subTree.props,</span><br><span class="line">      ...instance.attrs,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 需要上一次的subTree来更新，所以要把subTree保存起来。</span></span><br><span class="line">  patch(prev, subTree, container, anchor);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么还有一个问题，就是怎么触发更新。</p><p>在我们之前的响应式学习中，我们知道响应式是由 reactive 建立，由 effect 触发的，只要改变了响应式数据，那么就会在 proxy 里面触发 trigger 方法，对依赖进行查找并执行相应的 effect。</p><p>那么对于这个 update 其实也很简单，只要用 effect 把 update 包裹起来即可实现更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">instance.update = effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> prev = instance.subTree;</span><br><span class="line">  <span class="keyword">const</span> subTree = (instance.subTree = normalizeVNode(</span><br><span class="line">    Component.render(instance.ctx)</span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(instance.attrs).length) &#123;</span><br><span class="line">    subTree.props = &#123;</span><br><span class="line">      ...subTree.props,</span><br><span class="line">      ...instance.attrs,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 需要上一次的subTree来更新，所以要把subTree保存起来。</span></span><br><span class="line">  patch(prev, subTree, container, anchor);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="合并-mount-和-update"><a href="#合并-mount-和-update" class="headerlink" title="合并 mount 和 update"></a>合并 mount 和 update</h2><p>这里又会出现一个问题，就是我们在写 effect 的时候默认是给他执行一次的，除了配置项 lazy 之外，所以为了解决这个问题，我们可以将 mount 和 update 合并</p><p>为了区分它是不是第一次 mount，需要一个变量 isMounted</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = &#123;</span><br><span class="line">  <span class="attr">props</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">attrs</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 将结果保存起来</span></span><br><span class="line">  <span class="attr">setupState</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 观测实例发现ctx可以取到setupState和props</span></span><br><span class="line">  <span class="attr">ctx</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 将执行render的操作封装成一个函数</span></span><br><span class="line">  <span class="attr">update</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">subTree</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">isMounted</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line">instance.update = effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!instance.isMounted) &#123;</span><br><span class="line">    <span class="keyword">const</span> subTree = (instance.subTree = normalizeVNode(</span><br><span class="line">      Component.render(instance.ctx)</span><br><span class="line">    ));</span><br><span class="line">    <span class="comment">// 此处的fallThrough就是之前的遍历</span></span><br><span class="line">    fallThrough(instance, subTree);</span><br><span class="line">    <span class="comment">// 直接patch 但是注意这里的引入方式</span></span><br><span class="line">    patch(<span class="literal">null</span>, subTree, container, anchor);</span><br><span class="line">    vnode.el = subTree.el;</span><br><span class="line">    instance.isMounted = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> prev = instance.subTree;</span><br><span class="line">    <span class="keyword">const</span> subTree = (instance.subTree = normalizeVNode(</span><br><span class="line">      Component.render(instance.ctx)</span><br><span class="line">    ));</span><br><span class="line">    fallThrough(instance, subTree);</span><br><span class="line">    <span class="comment">// 需要上一次的subTree来更新，所以要把subTree保存起来。</span></span><br><span class="line">    patch(prev, subTree, container, anchor);</span><br><span class="line">    vnode.el = subTree.el;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>至此就完成了组件的主动更新</p><h1 id="被动更新"><a href="#被动更新" class="headerlink" title="被动更新"></a>被动更新</h1><p>见例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Child = &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&quot;foo&quot;</span>],</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;a&quot;</span>, <span class="attr">id</span>: ctx.bar &#125;, ctx.foo);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Parent = &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> vnodeProps = reactive(&#123;</span><br><span class="line">      <span class="attr">foo</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">      <span class="attr">bar</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123; vnodeProps &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h(Child, ctx.vnodeProps);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">render(h(Parent), root);</span><br></pre></td></tr></table></figure><p>这个例子中，父组件发生了一次更新，是主动更新，但是父组件的渲染的时候，这个 child 是已经存在的组件，如果子组件对应的 props 也发生变化了，就会触发 updateComponent。导致了子组件的更新，也就是被动更新。</p><h1 id="updateComponent"><a href="#updateComponent" class="headerlink" title="updateComponent"></a>updateComponent</h1><p>先不考虑子组件的 props 发生变化的情况，我们来处理这个 updateComponent</p><p>它接收两个参数，一个是 prevVNode 一个是 vnode，由于是更新，所以我们要尽可能考虑能复用原先实例 instance 中的 update 方法。为了解决这个问题，我们可以将实例 instance 挂载到 vnode 上面，</p><h2 id="挂载实例到-vnode"><a href="#挂载实例到-vnode" class="headerlink" title="挂载实例到 vnode"></a>挂载实例到 vnode</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  type,</span><br><span class="line">  props,</span><br><span class="line">  children,</span><br><span class="line">  shapeFlag,</span><br><span class="line">  <span class="attr">el</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">anchor</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">key</span>: props &amp;&amp; props.key,</span><br><span class="line">  <span class="attr">component</span>: <span class="literal">null</span>, <span class="comment">//专门用于存储组件的实例</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> instance = (vnode.component = &#123;</span><br><span class="line">  <span class="attr">props</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">attrs</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">setupState</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">ctx</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">update</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">subTree</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">isMounted</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 回到updateComponent</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateComponent</span>(<span class="params">prevVNode,vnode</span>)</span>&#123;</span><br><span class="line">  vnode.component = prevVNode.component;</span><br><span class="line">  vnode.component.update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="next-传递节点"><a href="#next-传递节点" class="headerlink" title="next 传递节点"></a>next 传递节点</h2><p>这就到了实例的 instance 里面，但此时执行的还是原先的 prevVNode，我们还需要传递 vnode 新节点过去</p><p>这里就再给实例添加一个属性 next 初始值设置为 null，然后在 updateComponent 里面传递</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = (vnode.component = &#123;</span><br><span class="line">  <span class="attr">props</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">attrs</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 将结果保存起来</span></span><br><span class="line">  <span class="attr">setupState</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 观测实例发现ctx可以取到setupState和props</span></span><br><span class="line">  <span class="attr">ctx</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 将执行render的操作封装成一个函数</span></span><br><span class="line">  <span class="attr">update</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">subTree</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">isMounted</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 存储新的vnode</span></span><br><span class="line">  <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateComponent</span>(<span class="params">prevVNode, vnode</span>) </span>&#123;</span><br><span class="line">  vnode.component = prevVNode.component;</span><br><span class="line">  vnode.component.next = vnode;</span><br><span class="line">  vnode.component.update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重新初始化-next"><a href="#重新初始化-next" class="headerlink" title="重新初始化 next"></a>重新初始化 next</h2><p>现在如果 next 存在就是被动更新。我们复用 vnode，将节点传进来 并将 next 置为 null 防止下次主动更新触发被动更新出错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (instance.next) &#123;</span><br><span class="line">  <span class="comment">// 被动更新</span></span><br><span class="line">  <span class="comment">// 复用vnode，将节点传进来 并将next置为null防止下次主动更新触发被动更新出错</span></span><br><span class="line">  vnode = instance.next;</span><br><span class="line">  instance.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取最新-props"><a href="#获取最新-props" class="headerlink" title="获取最新 props"></a>获取最新 props</h2><p>回顾一下我们的案例，主要是父组件的 props 改变导致了子组件的被动更新。所以其原因还是在 props，我们这里也要去获取最新的 props 值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (instance.next) &#123;</span><br><span class="line">  <span class="comment">// 被动更新</span></span><br><span class="line">  <span class="comment">// 复用vnode，将节点传进来 并将next置为null防止下次主动更新触发被动更新出错</span></span><br><span class="line">  vnode = instance.next;</span><br><span class="line">  instance.next = <span class="literal">null</span>;</span><br><span class="line">  initProps(instance, vnode);</span><br><span class="line">  instance.ctx = &#123;</span><br><span class="line">    ...instance.props,</span><br><span class="line">    ...instance.setupState,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们的 context 是合并来的并不是像源码一样代理来的，所以要手动合并一次</p><h1 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h1><p>我们最开始遗留的问题，就是没考虑子组件的 props 是否改变，改变了才应该去更新。</p><p>这个方法就是 react 里面的方法，react 将这个方法暴露出来给用户让他决定是否更新，vue 就将其内置。主要的操作这里就省略了。</p><h1 id="unmountComponent"><a href="#unmountComponent" class="headerlink" title="unmountComponent"></a>unmountComponent</h1><p>直接把 vnode 里面挂载的 component 中的 subTree 卸载即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unmountComponent</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  unmount(vnode.component.subTree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然真实的卸载组件流程没那么简单，他还要去处理destroy和beforeDestroy的情况</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的mini-vue⑤--最长上升子序列篇</title>
    <link href="https://zlinni.github.io/posts/2778725059/"/>
    <id>https://zlinni.github.io/posts/2778725059/</id>
    <published>2022-06-11T01:57:31.000Z</published>
    <updated>2022-06-12T02:23:35.980Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是最长上升子序列 篇，是关于 Vue3 中 LIS 的深入讨论。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220612100818.png" alt=""></p><h1 id="LIS"><a href="#LIS" class="headerlink" title="LIS"></a>LIS</h1><p>Longest Increasing Subsequence 最长上升子序列。是指一个序列中最长的单调递增的子序列。</p><p>我们可以拿 leetcode 的题作为例子来编写：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220611154750.png" alt=""></p><h2 id="dp-O-n²"><a href="#dp-O-n²" class="headerlink" title="dp O(n²)"></a>dp O(n²)</h2><p>例子：<br><code>nums=[10,9,2,5,3,7,101,18]</code><br>dp 的思路如下:</p><p>初始化 dp 为 1 <code>dp=[1,1,1,1,1,1,1,1]</code>，然后循环比对前面的，只要它大于了前面的数就把下标置为前面的数的最大长度+1，当然这个过程还要比较和自身的大小，如果自身更大取自身.最后返回最大值</p><p>过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">9</span> <span class="number">2</span> <span class="number">5</span> <span class="number">3</span> <span class="number">7</span> <span class="number">101</span> <span class="number">18</span></span><br><span class="line"> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span>   <span class="number">4</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 最小是1</span></span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length).fill(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 比对前面的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        <span class="comment">// 取最大的</span></span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max = <span class="built_in">Math</span>.max(dp[i], max);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="贪心-O-n²"><a href="#贪心-O-n²" class="headerlink" title="贪心 O(n²)"></a>贪心 O(n²)</h2><p>这个算法的核心是看最大的数然后更新</p><p>例子：<br><code>nums=[10,9,2,5,3,7,101,18,1]</code></p><p>过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">9</span> <span class="number">2</span> <span class="number">5</span> <span class="number">101</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">init</span><br><span class="line">arr <span class="number">10</span></span><br><span class="line"><span class="number">9</span>&lt;<span class="number">10</span> replace</span><br><span class="line">arr <span class="number">9</span></span><br><span class="line"><span class="number">2</span>&lt;<span class="number">9</span> replace</span><br><span class="line">arr <span class="number">2</span></span><br><span class="line"><span class="number">5</span>&gt;<span class="number">2</span> add</span><br><span class="line">arr <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">101</span>&gt;<span class="number">5</span> add</span><br><span class="line">arr <span class="number">2</span> <span class="number">5</span> <span class="number">101</span></span><br><span class="line"><span class="number">3</span>&lt;<span class="number">101</span> but <span class="number">3</span>&gt;<span class="number">2</span> <span class="number">3</span>&lt;<span class="number">5</span>(find first num bigger than <span class="built_in">this</span>) replace</span><br><span class="line">arr <span class="number">2</span> <span class="number">3</span> <span class="number">101</span></span><br><span class="line"><span class="number">7</span>&lt;<span class="number">101</span> replace</span><br><span class="line">arr <span class="number">2</span> <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="number">18</span>&gt;<span class="number">7</span> add</span><br><span class="line">arr <span class="number">2</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span></span><br><span class="line"><span class="number">1</span>&lt;<span class="number">18</span> but <span class="number">1</span>&lt;<span class="number">2</span> replace</span><br><span class="line">arr <span class="number">1</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span></span><br><span class="line"><span class="attr">answer</span>:<span class="number">4</span></span><br></pre></td></tr></table></figure><p>所以我们可以知道，当他小于目标数组 arr 中末尾的数字的时候从头判断找到第一个比他大的数字执行替换的操作，大于的时候执行新增操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [nums[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt;= arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= arr[j]) &#123;</span><br><span class="line">          arr[j] = nums[i];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr.push(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="贪心-二分-O-nlogn"><a href="#贪心-二分-O-nlogn" class="headerlink" title="贪心+二分 O(nlogn)"></a>贪心+二分 O(nlogn)</h2><p>我们可以发现，在查找的过程中该数组是一个有序数组，所以我们可以用二分查找进行优化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [nums[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt;= arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">let</span> l = <span class="number">0</span>,</span><br><span class="line">        r = arr.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = ~~((l + r) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; arr[mid]) &#123;</span><br><span class="line">          l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; arr[mid]) &#123;</span><br><span class="line">          r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          l = mid;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[l] = nums[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr.push(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="position-形成-LIS-的集合"><a href="#position-形成-LIS-的集合" class="headerlink" title="position 形成 LIS 的集合"></a>position 形成 LIS 的集合</h2><p>我们真正需要做的实际上是生成一个带有原数据中对应下标的 LIS 的 seq 数组，而不是长度。所以我们应该先找到这一部分的 LIS，但为了找到这一部分的 LIS,我们又需要查看全部的元素的位置是否满足 LIS，举例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num <span class="number">10</span> <span class="number">9</span> <span class="number">2</span> <span class="number">5</span> <span class="number">101</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span> <span class="number">1</span></span><br><span class="line">pos  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>   <span class="number">2</span> <span class="number">1</span> <span class="number">2</span>  <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="comment">// 得到</span></span><br><span class="line">ans      <span class="number">2</span>       <span class="number">3</span> <span class="number">7</span> <span class="number">18</span></span><br></pre></td></tr></table></figure><p>如果我们有这么一个 pos 数组告诉我们具体的 LIS 下标，我们是不是就能很轻易得到对应的 LIS 元素了。</p><p>所以以这个出发去编写 pos 数组，它的过程如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">num <span class="number">10</span> <span class="number">9</span> <span class="number">2</span> <span class="number">5</span> <span class="number">101</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">init</span><br><span class="line">arr <span class="number">10</span></span><br><span class="line">pos <span class="number">0</span></span><br><span class="line"><span class="number">9</span>&lt;<span class="number">10</span> replace <span class="number">10.</span>index</span><br><span class="line">arr <span class="number">9</span></span><br><span class="line">pos <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span>&lt;<span class="number">9</span> replace <span class="number">9.</span>index</span><br><span class="line">arr <span class="number">2</span></span><br><span class="line">pos <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">5</span>&gt;<span class="number">2</span> add len-<span class="number">1</span></span><br><span class="line">arr <span class="number">2</span> <span class="number">5</span></span><br><span class="line">pos <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">101</span>&gt;<span class="number">5</span> add len-<span class="number">1</span></span><br><span class="line">arr <span class="number">2</span> <span class="number">5</span> <span class="number">101</span></span><br><span class="line">pos <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span>&lt;<span class="number">101</span> but <span class="number">3</span>&gt;<span class="number">2</span> <span class="number">3</span>&lt;<span class="number">5</span>(find first num bigger than <span class="built_in">this</span>) replace &amp;&amp; <span class="number">5.</span>index</span><br><span class="line">arr <span class="number">2</span> <span class="number">3</span> <span class="number">101</span></span><br><span class="line">pos <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">7</span>&lt;<span class="number">101</span> replace <span class="number">101.</span>index</span><br><span class="line">arr <span class="number">2</span> <span class="number">3</span> <span class="number">7</span></span><br><span class="line">pos <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">18</span>&gt;<span class="number">7</span> add len-<span class="number">1</span></span><br><span class="line">arr <span class="number">2</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span></span><br><span class="line">pos <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span>&lt;<span class="number">18</span> but <span class="number">1</span>&lt;<span class="number">2</span> replace <span class="number">2.</span>index</span><br><span class="line">arr <span class="number">1</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span></span><br><span class="line">pos <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">num <span class="number">10</span> <span class="number">9</span> <span class="number">2</span> <span class="number">5</span> <span class="number">101</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span> <span class="number">1</span></span><br><span class="line">idx  <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>   <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>  <span class="number">7</span> <span class="number">8</span></span><br><span class="line">pos  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>   <span class="number">2</span> <span class="number">1</span> <span class="number">2</span>  <span class="number">3</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">ans      <span class="number">2</span>       <span class="number">3</span> <span class="number">7</span> <span class="number">18</span></span><br><span class="line">idx      <span class="number">2</span>       <span class="number">5</span> <span class="number">6</span>  <span class="number">7</span></span><br><span class="line"><span class="attr">answerIdx</span>:[<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><p>所以我们需要做的是，在每次 arr 进行 add 操作的时候，pos 就把 arr 的长度-1 放进来；在每次执行 replace 操作的时候，把二分查找替换的 l 传进来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [nums[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">const</span> pos = [<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt;= arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">let</span> l = <span class="number">0</span>,</span><br><span class="line">        r = arr.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = ~~((l + r) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; arr[mid]) &#123;</span><br><span class="line">          l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; arr[mid]) &#123;</span><br><span class="line">          r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          l = mid;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[l] = nums[i];</span><br><span class="line">      pos.push(l);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr.push(nums[i]);</span><br><span class="line">      pos.push(arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过我们在操作到这里的时候，只是得到了一个下标集合，刚才的 answerIdx 是我们自己判断出来的，接下来我们就实现 answerIdx 这一步</p><h2 id="cur-得到-seq"><a href="#cur-得到-seq" class="headerlink" title="cur 得到 seq"></a>cur 得到 seq</h2><p>answerIdx 这一步，是将 pos 中的 LIS 转为了对应的 idx。我们仔细观察可以发现，其实 pos 的长度是和 idx 一样的，因为它就是全部元素形成 LIS 的一个集合，而我们又发现也得到 arr 了，arr 的长度-1 就是 pos 中最大的元素，所以我们不妨设置一个变量 cur，让他等于 arr 的最大长度-1，此时我们只要从后往前遍历 pos，当 cur 和 pos 的数据是一样的时候，就说明这个数据是不用移动的，就可以把 pos 中对应的下标加入到 seq 数组中。然后又因为我们这个 arr 其实是不会再用到的了，所以可以直接复用 arr。下面来演示这个过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">num <span class="number">10</span> <span class="number">9</span> <span class="number">2</span> <span class="number">5</span> <span class="number">101</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 已知</span></span><br><span class="line">num <span class="number">10</span> <span class="number">9</span> <span class="number">2</span> <span class="number">5</span> <span class="number">101</span> <span class="number">3</span> <span class="number">7</span> <span class="number">18</span> <span class="number">1</span></span><br><span class="line">idx <span class="number">0</span>  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>   <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>  <span class="number">8</span></span><br><span class="line">arr <span class="number">1</span>  <span class="number">3</span> <span class="number">7</span> <span class="number">18</span></span><br><span class="line">pos <span class="number">0</span>  <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span>   <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>  <span class="number">0</span></span><br><span class="line">cur <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从后往前遍历pos</span></span><br><span class="line">pos <span class="number">0</span></span><br><span class="line">pos <span class="number">3</span> cur-- arr[<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">7</span>]</span><br><span class="line">pos <span class="number">2</span> cur-- arr[<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">pos <span class="number">1</span> cur-- arr[<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">...</span><br><span class="line">pos <span class="number">0</span> cur-- arr[<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">cur=-<span class="number">1</span> stop</span><br><span class="line"></span><br><span class="line"><span class="attr">arr</span>:   [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"><span class="attr">answer</span>:[<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">18</span>]</span><br></pre></td></tr></table></figure><p>这样就获得了这个 seq 数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [nums[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">const</span> pos = [<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt;= arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">let</span> l = <span class="number">0</span>,</span><br><span class="line">        r = arr.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = ~~((l + r) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; arr[mid]) &#123;</span><br><span class="line">          l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; arr[mid]) &#123;</span><br><span class="line">          r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          l = mid;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[l] = nums[i];</span><br><span class="line">      pos.push(l);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr.push(nums[i]);</span><br><span class="line">      pos.push(arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> cur = arr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = pos.length - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; cur &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur === pos[i]) &#123;</span><br><span class="line">      arr[cur--] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="source"><a href="#source" class="headerlink" title="source"></a>source</h2><p>我们之前说过 source 为-1 的时候是直接更新，所以我们也应该在算法里面移除-1 的考虑</p><p>最后全部代码为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSequence</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [nums[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">const</span> pos = [<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] === -<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt;= arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">let</span> l = <span class="number">0</span>,</span><br><span class="line">        r = arr.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = ~~((l + r) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; arr[mid]) &#123;</span><br><span class="line">          l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; arr[mid]) &#123;</span><br><span class="line">          r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          l = mid;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[l] = nums[i];</span><br><span class="line">      pos.push(l);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr.push(nums[i]);</span><br><span class="line">      pos.push(arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> cur = arr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = pos.length - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; cur &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur === pos[i]) &#123;</span><br><span class="line">      arr[cur--] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>最后回到本源，我们要给 vnode 添加一个 key 属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  type,</span><br><span class="line">  props,</span><br><span class="line">  children,</span><br><span class="line">  shapeFlag,</span><br><span class="line">  <span class="attr">el</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">anchor</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">key</span>: props &amp;&amp; props.key,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外在 patchProps 里面也要注意 key 的判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除旧属性有的，新属性没有的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">  <span class="comment">// 当前属性是 &#x27;key&#x27; 则跳过</span></span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">&quot;key&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newProps[key] == <span class="literal">null</span>) &#123;</span><br><span class="line">    patchDomProp(oldProps[key], <span class="literal">null</span>, key, el);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加旧属性没有的，新属性有的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">&quot;key&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldProps[key] !== newProps[key]) &#123;</span><br><span class="line">    patchDomProp(oldProps[key], newProps[key], key, el);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本节中我们以 leetcode 为例学习了 LIS 算法的核心原理，使用 dp，贪心去实现，然后又通过二分优化了查找过程，后面我们发现我们需要的是实际的元素而不是下标，就采用了 pos 数组帮助我们得到了形成 LIS 的集合，再设置 cur 并复用 arr 得到我们的 seq 数组。下节我们将介绍组件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的mini-vue③--patch篇</title>
    <link href="https://zlinni.github.io/posts/2046694271/"/>
    <id>https://zlinni.github.io/posts/2046694271/</id>
    <published>2022-06-10T08:15:01.000Z</published>
    <updated>2022-06-11T02:15:25.473Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是patch 篇，是关于 Vue3 中 patch 的基本理解和实践。</p></div><h1 id="patch的介绍"><a href="#patch的介绍" class="headerlink" title="patch的介绍"></a>patch的介绍</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/patch.png" alt=""></p><p><code>patch</code> 是对比新旧节点的算法，当新节点不存在的时候，执行卸载操作，当新节点存在的时候，进行对比</p><p>卸载操作需要判断对应节点的类型，如果是组件执行组件的卸载，如果是 <code>Fragment</code> 执行 <code>Fragment</code> 的卸载，最后到 <code>Text</code> 和 <code>Element</code> 执行 <code>removeChild</code></p><p><code>patch</code> 操作需要判断新旧节点的类型是否相同，不同的话就要卸载旧的节点将原有的节点树完全卸载掉。</p><p>然后再判断新节点<br>新节点是否是组件，如果是则进行 <code>processComponent</code>；</p><p>新节点如果是 <code>Text</code> 类型，执行 <code>processText</code>。之后再来判断旧节点是否存在，如果存在说明之前已经创建过旧的文本内容了，直接复用这个文本节点，更新他的 <code>textContent</code>，如果不存在旧节点，直接使用 <code>mountTextNode</code> 挂载文本节点</p><p>新节点如果是 <code>Fragment</code> 类型，就执行 <code>processFragment</code>，如果此时旧节点不存在，直接使用 <code>mountChildren</code>，如果旧节点存在就要进行 <code>diff</code></p><p>新节点最后就判断为 <code>Element</code> 类型，执行 <code>processElement</code>。之后来判断旧节点是否存在，如果不存在，直接使用 <code>mountElement</code> 对新节点进行挂载。如果存在，则要对他进行 <code>diff</code> 操作了。</p><p>因为此时新旧节点的 <code>type</code> 一样，就直接复用 <code>type</code>，只要对 <code>props</code> 和 <code>children</code> 进行 <code>diff</code></p><p>分析完了之后就开始准备写新的 <code>render</code> 函数了</p><h1 id="render"><a href="#render" class="headerlink" title="render"></a>render</h1><p>我们之前的 <code>render</code> 是挂载了一个节点，怎么才能产生新旧节点呢？</p><p>实际上我们只要将 <code>vnode</code> 挂载在 <code>container</code> 上面，下次进入的时候获取 <code>container</code> 上面的 <code>vnode</code>，此时这个 <code>vnode</code> 就是旧节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prevNode = container._vnode;</span><br><span class="line">  container._vnode = vnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来进行判断了，我们首先判断新节点存不存在。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prevNode = container._vnode;</span><br><span class="line">  <span class="keyword">if</span> (!vnode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevNode) &#123;</span><br><span class="line">      unmount(prevNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    patch(prevNode, vnode, container);</span><br><span class="line">  &#125;</span><br><span class="line">  container._vnode = vnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就要编写 <code>unmount</code> 和 <code>patch</code></p><h2 id="unmount"><a href="#unmount" class="headerlink" title="unmount"></a>unmount</h2><p>前面的情况就是利用 shapeflag 判断组件的卸载或 <code>fragment</code> 的卸载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params">vnode</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;shapeFlag,el&#125; = vnode;</span><br><span class="line">    <span class="keyword">if</span>(shapeFlag&amp;ShapeFlags.COMPONENT)&#123;</span><br><span class="line">        unmountComponent(vnode)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shapeFlag&amp;ShapeFlags.FRAGMENT)&#123;</span><br><span class="line">        unmountFragment(vnode)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      ...?</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们发现最后一种情况：对 <code>Text</code> 或 <code>Element</code> 进行 <code>removeChild</code> 的时候，没有获取到具体的 el，所以我们要从 <code>vnode</code> 里面拿 el，也就是要在 <code>vnode</code> 的返回值里面添加一个 el</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  type,</span><br><span class="line">  props,</span><br><span class="line">  children,</span><br><span class="line">  shapeFlag,</span><br><span class="line">  <span class="attr">el</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>且在挂载 <code>element</code> 和 <code>textnode</code> 之后需要将 el 挂载到 <code>vnode</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountElement</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出元素 挂载元素 挂载props children</span></span><br><span class="line">  <span class="keyword">const</span> &#123; type, props &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">  <span class="comment">// 将props挂载到el上</span></span><br><span class="line">  mountProps(props, el);</span><br><span class="line">  <span class="comment">// 把节点挂载到el上</span></span><br><span class="line">  mountChildren(vnode, el);</span><br><span class="line">  container.appendChild(el);</span><br><span class="line">  <span class="comment">// 保存el</span></span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountTextNode</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(vnode.children);</span><br><span class="line">  container.appendChild(textNode);</span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以现在最后一种情况应该这样写了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag, el &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.COMPONENT) &#123;</span><br><span class="line">    unmountComponent(vnode);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.FRAGMENT) &#123;</span><br><span class="line">    unmountFragment(vnode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其次是Text或者Element 但要拿到child节点</span></span><br><span class="line">    <span class="comment">// 所以要在vnode里面初始化一个el</span></span><br><span class="line">    el.parentNode.removeChild(el);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>接下来是实现 <code>patch</code> 的部分，要通过他判断新旧节点的类型是否相同，设置一个函数。然后分情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">prevVNode, vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode &amp;&amp; !isSameVNode(prevVNode, vnode)) &#123;</span><br><span class="line">    unmount(prevVNode);</span><br><span class="line">    <span class="comment">// 注意卸载之后要将节点设置为null</span></span><br><span class="line">    prevVNode = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.COMPONENT) &#123;</span><br><span class="line">    processComponent(prevVNode, vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT) &#123;</span><br><span class="line">    processText(prevVNode, vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.FRAGMENT) &#123;</span><br><span class="line">    processFragment(prevVNode, vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    processElement(prevVNode, vnode, container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSameVNode</span>(<span class="params">prevVNode, vnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prevVNode.type === vnode.type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后要处理剩下的四个函数 <code>processComponent，processText，processFragment，processElement</code></p><h3 id="processText"><a href="#processText" class="headerlink" title="processText"></a>processText</h3><p>存在旧节点的时候，复用旧节点的 <code>textContent</code>。否则执行 <code>mountTextNode</code>，这个前面也写过了。直接 cv 即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processText</span>(<span class="params">prevVNode, vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    vnode.el = prevVNode.el;</span><br><span class="line">    prevVNode.el.textContent = vnode.children;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountTextNode(vnode, container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountTextNode</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(vnode.children);</span><br><span class="line">  container.appendChild(textNode);</span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="processElement"><a href="#processElement" class="headerlink" title="processElement"></a>processElement</h3><p>对于存在旧节点的情况下调用 <code>patchElement</code> 进行 <code>diff</code> 比较，不存在的情况则调用原先写过的 <code>mountElement</code> 进行挂载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processElement</span>(<span class="params">prevVNode, vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    patchElement(prevVNode, vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountElement(vnode, container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的一点是 <code>mountChildren</code> 中我们之前是没有实现 <code>mount</code> 的，其实在这里用 <code>patch</code> 实现即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountChildren</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag, children &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">    mountTextNode(vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    <span class="comment">// 递归调用挂载</span></span><br><span class="line">    children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">      patch(<span class="literal">null</span>, child, container);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外就是 <code>patchElement</code>，因为此时新旧节点的 <code>type</code> 都是一样的，所以将旧节点的 el 赋值给新节点的 el，然后对比它们之间的 <code>props</code> 和 <code>children</code> 的异同。</p><h4 id="patchProps"><a href="#patchProps" class="headerlink" title="patchProps"></a>patchProps</h4><p>其中包含了两个函数一个是 <code>patchProps</code> 一个是 <code>patchChildren</code></p><p>对于 <code>patchProps</code>，回顾一下 <code>props</code> 的内容,他是一个对象里面有很多属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">class</span>: <span class="string">&#x27;a b&#x27;</span>,</span><br><span class="line">  <span class="attr">style</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    <span class="attr">fontSize</span>: <span class="string">&#x27;14px&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>),</span><br><span class="line">  <span class="attr">checked</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">custom</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们对于新旧节点的 <code>props</code>，需要取出对应的 <code>value</code> 值，对比是否相同，如果相同我们才去进行重新赋值。并且我们还要遍历旧属性，移除旧属性中有的，新属性中没有的。遍历新属性，添加旧属性没有的新属性有的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchProps</span>(<span class="params">oldProps, newProps, el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (oldProps === newProps) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 防止传过来的props是空 注意这里没有用到es6赋默认值的写法是因为他有可能传递的是null，es6默认值只能处理undefined的情况</span></span><br><span class="line">  oldProps = oldProps || &#123;&#125;;</span><br><span class="line">  newProps = newProps || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除旧属性有的，新属性没有的</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">    <span class="comment">// 当前属性是 &#x27;key&#x27; 则跳过</span></span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&quot;key&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newProps[key] == <span class="literal">null</span>) &#123;</span><br><span class="line">      patchDomProp(oldProps[key], <span class="literal">null</span>, key, el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加旧属性没有的，新属性有的</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&quot;key&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldProps[key] !== newProps[key]) &#123;</span><br><span class="line">      patchDomProp(oldProps[key], newProps[key], key, el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="patchDomProp"><a href="#patchDomProp" class="headerlink" title="patchDomProp"></a>patchDomProp</h5><p><code>patchDomProp</code> 这一步操作和我们之前写的 <code>mountProps</code> 有点类似。不过有几个细节要注意：</p><p>如果 <code>next</code> 是 <code>false</code> 或者是 <code>null</code> 的话，他就会变成字符串，而不是去掉，我们希望的是去掉。所以要写<code>el.className = next || &#39;&#39;</code></p><p>如果新旧属性中的 <code>style</code> 有不一致的，我们添加新的 <code>styleName</code>，移除不需要的 <code>styleName</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next为空直接移除</span></span><br><span class="line"><span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">  el.removeAttribute(<span class="string">&quot;style&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 我们添加新的 styleName</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> styleName <span class="keyword">in</span> next) &#123;</span><br><span class="line">    el.style[styleName] = next[styleName];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除不需要的 `styleName`。</span></span><br><span class="line">  <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> styleName <span class="keyword">in</span> prev) &#123;</span><br><span class="line">      <span class="keyword">if</span> (next[styleName] == <span class="literal">null</span>) &#123;</span><br><span class="line">        el.style[styleName] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果事件中存在旧事件，移除旧事件，如果存在新事件，添加新事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="regexp">/^on[^a-z]/</span>.test(key)) &#123;</span><br><span class="line">  <span class="keyword">const</span> eventName = key.slice(<span class="number">2</span>).toLowerCase();</span><br><span class="line">  <span class="comment">// 移除旧事件</span></span><br><span class="line">  <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">    el.removeEventListener(eventName, prev);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加新事件</span></span><br><span class="line">  <span class="keyword">if</span> (next) &#123;</span><br><span class="line">    el.addEventListener(eventName, next);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line">  <span class="comment">// 如果是class 直接赋className</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;class&quot;</span>:</span><br><span class="line">    el.className = next;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">// 如果是style 遍历赋值value值</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;style&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> styleName <span class="keyword">in</span> next) &#123;</span><br><span class="line">      el.style[styleName] = next[styleName];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> styleName <span class="keyword">in</span> prev) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next[styleName] == <span class="literal">null</span>) &#123;</span><br><span class="line">          el.style[styleName] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">// 如果是事件，正则匹配on开头，并将后面的转为小写单词 然后添加事件</span></span><br><span class="line">  <span class="comment">// 如果是别的属性，分类判断，不能统一设置attribute</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^on[^a-z]/</span>.test(key)) &#123;</span><br><span class="line">      <span class="keyword">const</span> eventName = key.slice(<span class="number">2</span>).toLowerCase();</span><br><span class="line">      <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">        el.removeEventListener(eventName, prev);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (next) &#123;</span><br><span class="line">        el.addEventListener(eventName, next);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (domPropsRE.test(key)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (next === <span class="string">&quot;&quot;</span> || isBoolean(el[key])) &#123;</span><br><span class="line">        next = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      el[key] = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (next == <span class="literal">null</span> || next === <span class="literal">false</span>) &#123;</span><br><span class="line">        el.removeAttribute(key);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el.setAttribute(key, next);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意此时我们已经可以利用 <code>patchProps</code> 取代 <code>mountProps</code> 了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountElement</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出元素 挂载元素 挂载props children</span></span><br><span class="line">  <span class="keyword">const</span> &#123; type, props &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">  <span class="comment">// 将props挂载到el上</span></span><br><span class="line">  <span class="comment">// mountProps(props, el);</span></span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    patchProps(<span class="literal">null</span>, props, el);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把节点挂载到el上</span></span><br><span class="line">  mountChildren(vnode, el);</span><br><span class="line">  container.appendChild(el);</span><br><span class="line">  <span class="comment">// 保存el</span></span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="patchChildren"><a href="#patchChildren" class="headerlink" title="patchChildren"></a>patchChildren</h4><p>我们重新修改一下 <code>mountChildren</code>，让他的职责更加单一</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountElement</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出元素 挂载元素 挂载props children</span></span><br><span class="line">  <span class="keyword">const</span> &#123; type, props, shapeFlag, children &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">  <span class="comment">// 将props挂载到el上</span></span><br><span class="line">  <span class="comment">// mountProps(props, el);</span></span><br><span class="line">  patchProps(<span class="literal">null</span>, props, el);</span><br><span class="line">  <span class="comment">// 把节点挂载到el上</span></span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">    mountTextNode(vnode, el);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    mountChildren(children, el);</span><br><span class="line">  &#125;</span><br><span class="line">  container.appendChild(el);</span><br><span class="line">  <span class="comment">// 保存el</span></span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountChildren</span>(<span class="params">children, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归调用挂载</span></span><br><span class="line">  children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">    patch(<span class="literal">null</span>, child, container);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后开始写 <code>patchChildren</code>，这一部分中，我们需要对九种情况进行判断<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/patchChildren.jpg" alt=""></p><p>简单写一下模板大致如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchChildren</span>(<span class="params">prevVNode, vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">shapeFlag</span>: prevShapeFlag, <span class="attr">children</span>: c1 &#125; = prevVNode;</span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag, <span class="attr">children</span>: c2 &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">      container.textContent = c2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      unmountChildren(c1);</span><br><span class="line">      container.textContent = c2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      container.textContent = c2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">      container.textContent = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      mountChildren(c2, container);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      patchArrayChildren(c1, c2, container);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mountChildren(c2, container);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">      container.textContent = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      unmountChildren(c1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时剩下的 <code>unmountChildren</code> 和 <code>patchArrayChildren</code> 两个函数暂未实现，但是我们发现可以对这个模板做一个合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    unmountChildren(c1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c1 !== c2) &#123;</span><br><span class="line">    container.textContent = c2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面一段是 vue 源码的合并结构，虽然简介但是还是分情况比较好理解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    unmountChildren(c1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c2 !== c1) &#123;</span><br><span class="line">    container.textContent = c2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// c2 is array or null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    <span class="comment">// c1 was array</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      <span class="comment">// c2 is array</span></span><br><span class="line">      <span class="comment">// patchArrayChildren()</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// c2 is null</span></span><br><span class="line">      unmountChildren(c1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// c1 was text or null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">      container.textContent = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      mountChildren(c2, container, anchor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们编写 <code>unmountChildren</code>，其实他也就是遍历 <code>children</code> 然后卸载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unmountChildren</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">    unmount(child);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就到了 <code>patchArrayChildren</code>，这个部分</p><h5 id="patchArrayChildren"><a href="#patchArrayChildren" class="headerlink" title="patchArrayChildren"></a>patchArrayChildren</h5><p>举个例子，我们看他如何实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> n1 = h(<span class="string">&quot;ul&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">  h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;a&quot;</span>),</span><br><span class="line">  h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;b&quot;</span>),</span><br><span class="line">  h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;c&quot;</span>),</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> n2 = h(<span class="string">&quot;ul&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">  h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;d&quot;</span>),</span><br><span class="line">  h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;e&quot;</span>),</span><br><span class="line">  h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;f&quot;</span>),</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><blockquote><p>c1: a b c<br>c2: d e f</p><p>c1: a b c<br>c2: d e f g h</p><p>c1: a b c g h<br>c2: d e f</p></blockquote><p>对比新旧孩子，如果长度相同则执行 <code>patch</code> 对比，如果新孩子比旧孩子长则挂载新孩子多出来的部分，如果旧孩子比新孩子长则删除旧孩子多出来的部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchArrayChildren</span>(<span class="params">c1, c2, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldLength = c1.length;</span><br><span class="line">  <span class="keyword">const</span> newLength = c2.length;</span><br><span class="line">  <span class="keyword">const</span> commonLength = <span class="built_in">Math</span>.min(oldLength, newLength);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; commonLength; i++) &#123;</span><br><span class="line">    patch(c1[i], c2[i], container);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (oldLength &gt; newLength) &#123;</span><br><span class="line">    unmountChildren(c1.slice(commonLength));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldLength &lt; newLength) &#123;</span><br><span class="line">    mountChildren(c2.slice(commonLength), container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是处理 <code>processFragment</code> 了</p><h3 id="processFragment"><a href="#processFragment" class="headerlink" title="processFragment"></a>processFragment</h3><p>旧节点存在的时候对比新旧的孩子，不存在时候直接挂载新节点的孩子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processFragment</span>(<span class="params">prevVNode, vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    patchChildren(prevVNode, vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountChildren(vnode.children, container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render, Fragment, h &#125; <span class="keyword">from</span> <span class="string">&quot;./runtime&quot;</span>;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  h(<span class="string">&quot;ul&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;first&quot;</span>),</span><br><span class="line">    h(Fragment, <span class="literal">null</span>, []),</span><br><span class="line">    h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;last&quot;</span>),</span><br><span class="line">  ]),</span><br><span class="line">  <span class="built_in">document</span>.body</span><br><span class="line">);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  render(</span><br><span class="line">    h(<span class="string">&quot;ul&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">      h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;first&quot;</span>),</span><br><span class="line">      h(Fragment, <span class="literal">null</span>, [h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;middle&quot;</span>)]),</span><br><span class="line">      h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;last&quot;</span>),</span><br><span class="line">    ]),</span><br><span class="line">    <span class="built_in">document</span>.body</span><br><span class="line">  );</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>我们跑这个例子之前，知道这个 <code>Fragment</code> 节点应该是 2s 加入到 first 和 last 中间的，而实际的结果却是他到了最后面。</p><p>我们先分析一下原因：首先 <code>patch</code> 新旧节点，它们类型是相同的，是 <code>Fragment</code>，则进入 <code>processFragment</code>。此时旧节点不存在，执行 <code>mountChildren</code>，然后执行 <code>patch</code>，传的值是<code>(null, child, container)</code>，到 <code>patch</code>，此时孩子是一个元素节点，所以执行 <code>processElement</code>。之后 <code>mountElement</code>。</p><p>这一步就是问题所在了，<code>mountElement</code> 中，我们的 el 是直接挂载到 <code>container</code> 中的，也就是<code>container.appendChild(el);</code>代码。所以他被加到了最后面</p><p>为了解决这个问题我们要使用 <code>anchor</code> 属性。</p><h4 id="Anchor"><a href="#Anchor" class="headerlink" title="Anchor"></a>Anchor</h4><p><code>anchor</code> 属性和 el 类似，因为 <code>Fragment</code> 节点之前挂载到的是容器，所以我们不知道应该在何处插入或者删除我们的 <code>Fragment</code> 节点，就要使用 el 和 <code>anchor</code> 生成节点然后就可以在这两个节点中间插入 <code>Fragment</code>。</p><p>所以我们要在 <code>vnode</code> 返回值里面添加 <code>anchor</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  type,</span><br><span class="line">  props,</span><br><span class="line">  children,</span><br><span class="line">  shapeFlag,</span><br><span class="line">  <span class="attr">el</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">anchor</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后重新写一下 <code>processFragment</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processFragment</span>(<span class="params">prevVNode, vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果旧节点的el存在就复用，anchor也是一样</span></span><br><span class="line">  <span class="keyword">const</span> fragmentStartAnchor = (vnode.el = prevVNode</span><br><span class="line">    ? prevVNode.el</span><br><span class="line">    : <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>));</span><br><span class="line">  <span class="keyword">const</span> fragmentEndAnchor = (vnode.anchor = prevVNode</span><br><span class="line">    ? prevVNode.anchor</span><br><span class="line">    : <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    patchChildren(prevVNode, vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    container.appendChild(fragmentStartAnchor);</span><br><span class="line">    container.appendChild(fragmentEndAnchor);</span><br><span class="line">    <span class="comment">// 传递anchor</span></span><br><span class="line">    mountChildren(vnode.children, container, fragmentEndAnchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，就需要在后续的地方增加 <code>anchor</code> 属性了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountChildren</span>(<span class="params">children, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归调用挂载</span></span><br><span class="line">  children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">    patch(<span class="literal">null</span>, child, container,anchor);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">prevVNode, vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode &amp;&amp; !isSameVNode(prevVNode,vnode)) &#123;</span><br><span class="line">    unmount(prevVNode);</span><br><span class="line">    prevVNode = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    shapeFlag</span><br><span class="line">  &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.COMPONENT) &#123;</span><br><span class="line">    processComponent(prevVNode, vnode, container,anchor);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT) &#123;</span><br><span class="line">    processText(prevVNode, vnode, container,anchor);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.FRAGMENT) &#123;</span><br><span class="line">    processFragment(prevVNode, vnode, container,anchor);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    processElement(prevVNode, vnode, container,anchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processElement</span>(<span class="params">prevVNode, vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    patchElement(prevVNode, vnode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountElement(vnode, container,anchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountElement</span>(<span class="params">vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出元素 挂载元素 挂载props children</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    props,</span><br><span class="line">    shapeFlag,</span><br><span class="line">    children</span><br><span class="line">  &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">  <span class="comment">// 将props挂载到el上</span></span><br><span class="line">  <span class="comment">// mountProps(props, el);</span></span><br><span class="line">  patchProps(<span class="literal">null</span>, props, el);</span><br><span class="line">  <span class="comment">// 把节点挂载到el上</span></span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">    mountTextNode(vnode, el);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    mountChildren(children, el);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// container.appendChild(el);</span></span><br><span class="line">  container.insertBefore(el,anchor);</span><br><span class="line">  <span class="comment">// 保存el</span></span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processText</span>(<span class="params">prevVNode, vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    vnode.el = prevVNode.el;</span><br><span class="line">    prevVNode.el.textContent = vnode.children;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountTextNode(vnode, container,anchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountTextNode</span>(<span class="params">vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(vnode.children);</span><br><span class="line">  <span class="comment">// container.appendChild(textNode);</span></span><br><span class="line">  container.insertBefore(textNode,anchor);</span><br><span class="line">  vnode.el = textNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processFragment</span>(<span class="params">prevVNode, vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fragmentStartAnchor = vnode.el = prevVNode ? prevVNode.el : <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> fragmentEndAnchor = vnode.anchor = prevVNode ? prevVNode.anchor : <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">    <span class="comment">// 用fragmentEndAnchor作为他的anchor</span></span><br><span class="line">    patchChildren(prevVNode, vnode, container,fragmentEndAnchor);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 此处也要insertuu</span></span><br><span class="line">    container.insertBefore(fragmentStartAnchor,anchor)</span><br><span class="line">    container.insertBefore(fragmentEndAnchor,anchor)</span><br><span class="line">    mountChildren(vnode.children, container,fragmentEndAnchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>总之在需要 <code>anchor</code> 的节点都需要添加 <code>anchor</code> 属性，并且最后的时候需要替换 <code>appendChild</code> 为 <code>insertBefore</code></p><p>之后我们编写遗留的 <code>unmountFragment</code>，这个函数本身我们可以用 <code>unmountChildren</code> 的形式来写，但是现在由于添加了 el 和 <code>anchor</code> 两个文本节点，所以我们要换种方式了。</p><p>思路大概就是将他们循环删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unmountFragment</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; <span class="attr">el</span>: cur, <span class="attr">anchor</span>: end &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> &#123; parentNode &#125; = cur;</span><br><span class="line">  <span class="keyword">while</span> (cur != end) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = cur.nextSibling;</span><br><span class="line">    parentNode.removeChild(cur);</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  parentNode.removeChild(end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时回去测试我们的用例，发现可以成功 <code>patch</code> 了。</p><p>最后还有一个小问题，就是关于 <code>patchArrayChildren</code> 里面的。我们看这么个例子</p><blockquote><p>h1, h1, h1<br>h1, h2, h1</p></blockquote><p>例如，对上面这个例子进行 <code>patchChildren</code> 第一次 <code>patch</code> 时，<code>n2.el = n1.el</code>，没有创建元素，<code>anchor</code> 没有用。 第二次 <code>patch</code> 时，先删除了 n1，对 n2 进行创建，执行 <code>insertBefore</code>，<code>anchor</code> 就需要设置为 <code>n1</code> 的下一个兄弟节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">prevVNode, vnode, container,anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prevVNode &amp;&amp; !isSameVNode(prevVNode,vnode)) &#123;</span><br><span class="line">    anchor = prevVNode.el.nextSibling;</span><br><span class="line">    unmount(prevVNode);</span><br><span class="line">    prevVNode = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果是</p><blockquote><p>n1, “” n1 “”,<br>n1 n1, n2, n1</p></blockquote><p>如果 <code>n1</code> 是 <code>Fragment</code>，那么 <code>anchor</code> 应该设置为 <code>n1</code> 的 <code>anchor</code> 的下一个兄弟节点。</p><p>所以不妨将两个情况合并为以下的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anchor = (prevVNode.anchor || prevVNode.el).nextSibling;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本节里，我们学习了patch算法简单的对新旧节点进行比对，然后根据对应的情况去挂载新节点或删除旧节点，后面又重新编写了render方法来对我们之前的操作做一些补充和修改。下节将进行核心diff算法的学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的mini-vue总集篇</title>
    <link href="https://zlinni.github.io/posts/3894586884/"/>
    <id>https://zlinni.github.io/posts/3894586884/</id>
    <published>2022-06-10T00:48:38.000Z</published>
    <updated>2022-06-13T13:51:18.203Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是总集篇，包含了 mini-vue 的全部基本实现，参见传送门内容</p></div><h1 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h1><h1 id="reactive-篇"><a href="#reactive-篇" class="headerlink" title="reactive 篇"></a>reactive 篇</h1><div class="note primary flat"><p><a href="https://zlinni.github.io/posts/3451170570">从零开始的 mini-vue①—reactive 篇</a></p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/reactivedaotu.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/computedandref.png" alt=""></p><h1 id="vnode-篇"><a href="#vnode-篇" class="headerlink" title="vnode 篇"></a>vnode 篇</h1><div class="note primary flat"><p><a href="https://zlinni.github.io/posts/2797606246">从零开始的 mini-vue②—vnode 篇</a></p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/虚拟DOM.png" alt=""></p><h1 id="patch-篇"><a href="#patch-篇" class="headerlink" title="patch 篇"></a>patch 篇</h1><div class="note primary flat"><p><a href="https://zlinni.github.io/posts/2046694271">从零开始的 mini-vue③—patch 篇</a></p></div><h1 id="核心-diff-篇"><a href="#核心-diff-篇" class="headerlink" title="核心 diff 篇"></a>核心 diff 篇</h1><div class="note primary flat"><p><a href="https://zlinni.github.io/posts/606001916">从零开始的 mini-vue④—核心 diff 篇</a></p></div><h1 id="最长上升子序列篇"><a href="#最长上升子序列篇" class="headerlink" title="最长上升子序列篇"></a>最长上升子序列篇</h1><div class="note primary flat"><p><a href="https://zlinni.github.io/posts/2778725059">从零开始的 mini-vue⑤—最长上升子序列篇</a></p></div><h1 id="Component-篇"><a href="#Component-篇" class="headerlink" title="Component 篇"></a>Component 篇</h1><div class="note primary flat"><p><a href="https://zlinni.github.io/posts/1033180007">从零开始的 mini-vue⑥—Component 篇</a></p></div><h1 id="Scheduler-篇"><a href="#Scheduler-篇" class="headerlink" title="Scheduler 篇"></a>Scheduler 篇</h1><div class="note primary flat"><p><a href="https://zlinni.github.io/posts/3541433463">从零开始的 mini-vue⑦—Scheduler 篇</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的mini-vue④--核心diff篇</title>
    <link href="https://zlinni.github.io/posts/606001916/"/>
    <id>https://zlinni.github.io/posts/606001916/</id>
    <published>2022-06-08T08:52:44.000Z</published>
    <updated>2022-06-12T02:07:53.740Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是核心 diff 篇，是关于 Vue3 中 patch 的深入讨论。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/核心diff.png" alt=""></p><h1 id="patchArrayChildren-的问题"><a href="#patchArrayChildren-的问题" class="headerlink" title="patchArrayChildren 的问题"></a>patchArrayChildren 的问题</h1><p>在上一节我们实现了<code>patchArrayChildren</code>，但是我们这个实现是比较简单粗暴的，直接对数组一对一进行的 diff 操作。</p><p>实际上它还是存在一些问题的，看下面的例子</p><blockquote><p>c1: a b c<br>c2: x a b c</p></blockquote><p>我们在新孩子头部插入了一个节点，很明显我们只要在 a 前面插入一个 x 即可。但是按照我们现在的做法，它需要每个都变化一次。</p><p>所以有没有办法解决这个问题？有的，就是要引入一个 key 去告诉框架什么节点是应该去复用的，从而减小操作虚拟 DOM 的次数</p><p>而我们前面实现的 patchArrayChildren 其实就是 patchUnkeyedChildren</p><p>这里先偷个懒 只要第一个元素有 key 就当作有 key</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">  <span class="comment">// 只要第一个元素有key就当作有key</span></span><br><span class="line">  <span class="keyword">if</span> (c1[<span class="number">0</span>] &amp;&amp; c1[<span class="number">0</span>].key != <span class="literal">null</span> &amp;&amp; c2[<span class="number">0</span>] &amp;&amp; c2[<span class="number">0</span>].key != <span class="literal">null</span>) &#123;</span><br><span class="line">    patchkeyedChildren(c1, c2, container, anchor);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    patchUnkeyedChildren(c1, c2, container, anchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="patchUnkeyedChildren"><a href="#patchUnkeyedChildren" class="headerlink" title="patchUnkeyedChildren"></a>patchUnkeyedChildren</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220608202141.png" alt=""></p><p>根据上面的图，我们先按最简单的方式去写 patchkeyedChildren，首先我们遍历新旧孩子，然后，找到 key 一致的新旧孩子去进行 patch。patch 之后再移动到新节点的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchkeyedChildren</span>(<span class="params">c1, c2, container, anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; c2.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 找c2</span></span><br><span class="line">    <span class="keyword">const</span> next = c2[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; c1.length; j++) &#123;</span><br><span class="line">      <span class="comment">// 找c1</span></span><br><span class="line">      <span class="keyword">const</span> prev = c1[i];</span><br><span class="line">      <span class="comment">// key相同 patch</span></span><br><span class="line">      <span class="keyword">if</span> (next.key === prev.key) &#123;</span><br><span class="line">        patch(prev, next, container, anchor);</span><br><span class="line">        <span class="comment">// 考虑anchor,此时我们patch之后要重新排列,所以c2的第一个是要放在c1的最前面的,</span></span><br><span class="line">        <span class="comment">// const curAnchor = c1[0].el;</span></span><br><span class="line">        <span class="comment">// 然后c2的第二个节点是要放在第一个节点后面,以此类推</span></span><br><span class="line">        <span class="comment">// const curAnchor = c2[i-1].el.nextSibling;</span></span><br><span class="line">        <span class="comment">// 所以对这两个情况进行合并</span></span><br><span class="line">        <span class="keyword">const</span> curAnchor = i === <span class="number">0</span> ? c1[<span class="number">0</span>].el : c2[i - <span class="number">1</span>].el.nextSibling;</span><br><span class="line">        <span class="comment">// 移动 insertBefore特性,如果此节点不存在,则进行移动操作,存在则插入</span></span><br><span class="line">        container.insertBefore(next.el, curAnchor);</span><br><span class="line">        <span class="comment">// 找到就break</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="maxNewIndexSoFar"><a href="#maxNewIndexSoFar" class="headerlink" title="maxNewIndexSoFar"></a>maxNewIndexSoFar</h2><p>进一步优化,因为上个版本不管顺序如何都会进行 insertBefore 操作.当他确实需要移动的时候我们才去移动</p><p>举例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c1 &gt; a b c</span><br><span class="line">c2 &gt; a c b</span><br><span class="line">maxNewIndexSoFar = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">a -- a c1 = <span class="number">0</span> = <span class="number">0</span> =&gt; maxNewIndexSoFar = <span class="number">0</span></span><br><span class="line">c -- c c1 = <span class="number">2</span> &gt; <span class="number">0</span> =&gt; update maxNewIndexSoFar = <span class="number">2</span></span><br><span class="line">b -- b c1 = <span class="number">1</span> &lt; <span class="number">2</span> =&gt; move b</span><br></pre></td></tr></table></figure><p>我们需要设置一个变量来记录 next 在 c1 中找到的最大值,如果小于这个值则移动大于或等于则更新这个值.这样就做到了有需要移动的时候才移动.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchkeyedChildren</span>(<span class="params">c1, c2, container, anchor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 记录当前next在c1中找到的最大值</span></span><br><span class="line">  <span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; c2.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 找c2</span></span><br><span class="line">    <span class="keyword">const</span> next = c2[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; c1.length; j++) &#123;</span><br><span class="line">      <span class="comment">// 找c1</span></span><br><span class="line">      <span class="keyword">const</span> prev = c1[i];</span><br><span class="line">      <span class="comment">// key相同 patch</span></span><br><span class="line">      <span class="keyword">if</span> (next.key === prev.key) &#123;</span><br><span class="line">        patch(prev, next, container, anchor);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; maxNewIndexSoFar) &#123;</span><br><span class="line">          <span class="comment">// move 此时i必定大于0 所以不需要判断i===0的情况了</span></span><br><span class="line">          <span class="keyword">const</span> curAnchor = c2[i - <span class="number">1</span>].el.nextSibling;</span><br><span class="line">          container.insertBefore(next.el, curAnchor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// update</span></span><br><span class="line">          maxNewIndexSoFar = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find-标志位"><a href="#find-标志位" class="headerlink" title="find 标志位"></a>find 标志位</h2><p>再考虑 c1 中没有找到相同 key 的情况</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220608214640.png" alt=""></p><p>所以我们设置一个标志位,来决定是否存在这种情况,如果循环结束都没用改变状态则说明是新的节点,直接插入即可.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchkeyedChildren</span>(<span class="params">c1, c2, container, anchor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 记录当前next在c1中找到的最大值</span></span><br><span class="line">  <span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; c2.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 找c2</span></span><br><span class="line">    <span class="keyword">const</span> next = c2[i];</span><br><span class="line">    <span class="comment">// 标志位初始化</span></span><br><span class="line">    <span class="keyword">let</span> find = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; c1.length; j++) &#123;</span><br><span class="line">      <span class="comment">// 找c1</span></span><br><span class="line">      <span class="keyword">const</span> prev = c1[i];</span><br><span class="line">      <span class="comment">// key相同 patch</span></span><br><span class="line">      <span class="keyword">if</span> (next.key === prev.key) &#123;</span><br><span class="line">        find = <span class="literal">true</span>;</span><br><span class="line">        patch(prev, next, container, anchor);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; maxNewIndexSoFar) &#123;</span><br><span class="line">          <span class="comment">// move 此时i必定大于0 所以不需要判断i===0的情况了</span></span><br><span class="line">          <span class="keyword">const</span> curAnchor = c2[i - <span class="number">1</span>].el.nextSibling;</span><br><span class="line">          container.insertBefore(next.el, curAnchor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// update</span></span><br><span class="line">          maxNewIndexSoFar = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果到最后都没找到说明要插入</span></span><br><span class="line">    <span class="keyword">if</span> (!find) &#123;</span><br><span class="line">      <span class="keyword">const</span> curAnchor = i === <span class="number">0</span> ? c1[<span class="number">0</span>].el : c2[i - <span class="number">1</span>].el.nextSibling;</span><br><span class="line">      patch(<span class="literal">null</span>, next, container, curAnchor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旧节点多于新节点的时候"><a href="#旧节点多于新节点的时候" class="headerlink" title="旧节点多于新节点的时候"></a>旧节点多于新节点的时候</h2><p>还有一种情况,就是旧节点多于新节点的时候</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220608215815.png" alt=""></p><p>这时候我们就要移除多余的旧节点,遍历旧节点如果 c2 中找不到此节点就卸载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历c1如果找不到则卸载</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; c1.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> prev = c1[i];</span><br><span class="line">  <span class="keyword">if</span> (!c2.find(<span class="function">(<span class="params">next</span>) =&gt;</span> next.key === prev.key)) &#123;</span><br><span class="line">    unmount(prev);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map-优化"><a href="#map-优化" class="headerlink" title="map 优化"></a>map 优化</h2><p>此时我们的算法复杂度是 O(n²),我们可以拿 map 来优化一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="comment">// 保存prev和它的下标</span></span><br><span class="line">c1.forEach(<span class="function">(<span class="params">prev, j</span>) =&gt;</span> &#123;</span><br><span class="line">  map.set(prev.key, &#123;</span><br><span class="line">    prev,</span><br><span class="line">    j,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 记录当前next在c1中找到的最大值</span></span><br><span class="line"><span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; c2.length; i++) &#123;</span><br><span class="line">  <span class="comment">// 找c2</span></span><br><span class="line">  <span class="keyword">const</span> next = c2[i];</span><br><span class="line">  <span class="comment">// 如果存在就看情况替换</span></span><br><span class="line">  <span class="keyword">if</span> (map.has(next.key)) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; prev, j &#125; = map.get(next.key);</span><br><span class="line">    patch(prev, next, container, anchor);</span><br><span class="line">    <span class="keyword">if</span> (j &lt; maxNewIndexSoFar) &#123;</span><br><span class="line">      <span class="comment">// move 此时i必定大于0 所以不需要判断i===0的情况了</span></span><br><span class="line">      <span class="keyword">const</span> curAnchor = c2[i - <span class="number">1</span>].el.nextSibling;</span><br><span class="line">      container.insertBefore(next.el, curAnchor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// update</span></span><br><span class="line">      maxNewIndexSoFar = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不存在就相当于之前find=false的情况.直接patch挂载</span></span><br><span class="line">    <span class="keyword">const</span> curAnchor = i === <span class="number">0</span> ? c1[<span class="number">0</span>].el : c2[i - <span class="number">1</span>].el.nextSibling;</span><br><span class="line">    patch(<span class="literal">null</span>, next, container, curAnchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于我们最后的旧节点多余的情况的优化,可以采用这样的思路,如果前面的节点找到就删除,一直到最后,如果还有存在的节点,就是多余的节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (map.has(next.key)) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; prev, j &#125; = map.get(next.key);</span><br><span class="line">  patch(prev, next, container, anchor);</span><br><span class="line">  <span class="keyword">if</span> (j &lt; maxNewIndexSoFar) &#123;</span><br><span class="line">    <span class="comment">// move 此时i必定大于0 所以不需要判断i===0的情况了</span></span><br><span class="line">    <span class="keyword">const</span> curAnchor = c2[i - <span class="number">1</span>].el.nextSibling;</span><br><span class="line">    container.insertBefore(next.el, curAnchor);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// update</span></span><br><span class="line">    maxNewIndexSoFar = j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 每次匹配完就删除</span></span><br><span class="line">  map.delete(next.key);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 最后多余的节点就卸载</span></span><br><span class="line">map.forEach(<span class="function">(<span class="params">&#123;prev&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  unmount(prev);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>至此算法复杂度就降低到了 O(N)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchkeyedChildren</span>(<span class="params">c1, c2, container, anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  c1.forEach(<span class="function">(<span class="params">prev, j</span>) =&gt;</span> &#123;</span><br><span class="line">    map.set(prev.key, &#123;</span><br><span class="line">      prev,</span><br><span class="line">      j,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 记录当前next在c1中找到的最大值</span></span><br><span class="line">  <span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; c2.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 找c2</span></span><br><span class="line">    <span class="keyword">const</span> next = c2[i];</span><br><span class="line">    <span class="keyword">const</span> curAnchor = i === <span class="number">0</span> ? c1[<span class="number">0</span>].el : c2[i - <span class="number">1</span>].el.nextSibling;</span><br><span class="line">    <span class="keyword">if</span> (map.has(next.key)) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; prev, j &#125; = map.get(next.key);</span><br><span class="line">      patch(prev, next, container, anchor);</span><br><span class="line">      <span class="keyword">if</span> (j &lt; maxNewIndexSoFar) &#123;</span><br><span class="line">        container.insertBefore(next.el, curAnchor);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// update</span></span><br><span class="line">        maxNewIndexSoFar = j;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 每次匹配完就删除</span></span><br><span class="line">      map.delete(next.key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      patch(<span class="literal">null</span>, next, container, curAnchor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后多余的节点就卸载</span></span><br><span class="line">  map.forEach(<span class="function">(<span class="params">&#123; prev &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    unmount(prev);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>据说以上的 diff 算法就是 react 的 diff 算法</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>对于此算法来说,有一个缺点:<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220608221923.png" alt=""></p><p>这个情况肉眼可见只需要移动一次 li-c 节点即可.但实际上,react 的 diff 算法移动了两次</p><p>原因是:首先比较 li-c 发现旧节点下标 2 的地方就是 li-c,于是刷新 maxNewIndexSoFar 为 2,接着 li-a 开始找,找到下标 0,0 小于 2,此时需要交换 li-a,li-b 开始找,找到下标 1,1 小于 2,也需要交换,所以这里有缺点.</p><h1 id="vue2-diff"><a href="#vue2-diff" class="headerlink" title="vue2 diff"></a>vue2 diff</h1><p>为了解决这个问题,vue2 采用了双端比较的方法,来对四个端点进行比较和移动,如果都不行再逐个比较.<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220609230958.png" alt=""></p><h1 id="vue3-diff"><a href="#vue3-diff" class="headerlink" title="vue3 diff"></a>vue3 diff</h1><p>在 Vue3 中将采用另外一种核心 Diff 算法，它借鉴于 ivi 和 inferno</p><h2 id="从左往右再从右往左"><a href="#从左往右再从右往左" class="headerlink" title="从左往右再从右往左"></a>从左往右再从右往左</h2><p>首先从左往右依次比对 然后从右往左依次比对<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220609231057.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> e1 = c1.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> e2 = c2.length - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 从左到右依次比对</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2 &amp;&amp; c1[i].key === c2[i].key) &#123;</span><br><span class="line">  patch(c1[i], c2[i], container, anchor);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从右至左依次比对</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2 &amp;&amp; c1[e1].key === c2[e2].key) &#123;</span><br><span class="line">  patch(c1[e1], c2[e2], container, anchor);</span><br><span class="line">  e1--;</span><br><span class="line">  e2--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对比完的情况一"><a href="#对比完的情况一" class="headerlink" title="对比完的情况一"></a>对比完的情况一</h2><p>经过上述操作如果将旧节点比对完,则 mount 剩下的新节点 此时 i&gt;e1<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220609231202.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; e1) &#123;</span><br><span class="line">  <span class="comment">// 作为此区间的所有节点都mount</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt;= e2; j++) &#123;</span><br><span class="line">    <span class="comment">// 找到下一个节点</span></span><br><span class="line">    <span class="keyword">const</span> nextPos = e2 + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 因为此时这个节点可能为末尾节点，所以得存在才取</span></span><br><span class="line">    <span class="comment">// 否则就取原来的anchor</span></span><br><span class="line">    <span class="keyword">const</span> curAnchor = (c2[nextPos] &amp;&amp; c2[nextPos].el) || anchor;</span><br><span class="line">    <span class="comment">// 执行插入</span></span><br><span class="line">    patch(<span class="literal">null</span>, c2[j], container, curAnchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对比完的情况二"><a href="#对比完的情况二" class="headerlink" title="对比完的情况二"></a>对比完的情况二</h2><p>经过上述操作如果将新节点对比完,则 unmount 剩下的旧节点 此时 i&gt;e2<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220609231337.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123;</span><br><span class="line"> <span class="comment">// 说明新的节点被比对完毕，要去卸载旧的节点</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt;= e1; j++) &#123;</span><br><span class="line">   unmount(c1[j]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不满足则采用传统-diff-标记和删除"><a href="#不满足则采用传统-diff-标记和删除" class="headerlink" title="不满足则采用传统 diff(标记和删除)"></a>不满足则采用传统 diff(标记和删除)</h2><p>若不满足以上的情况,则采用传统的 diff 算法,但不真的添加和移动,只进行标记和删除 取得一个 source 数组，<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220609231503.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 若以上都不满足则采用传统的diff算法，但不真的添加和移动，只做标记和删除</span></span><br><span class="line"> <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="comment">//  c1也可能被截断了 所以是</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt;= e1; j++) &#123;</span><br><span class="line">  <span class="keyword">const</span> prev = c1[j];</span><br><span class="line">  map.set(prev.key, &#123;</span><br><span class="line">    prev,</span><br><span class="line">    j</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  c1.forEach((prev, j) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//    map.set(prev.key, &#123;</span></span><br><span class="line"><span class="comment">//      prev,</span></span><br><span class="line"><span class="comment">//      j</span></span><br><span class="line"><span class="comment">//    &#125;);</span></span><br><span class="line"><span class="comment">//  &#125;)</span></span><br><span class="line"> <span class="comment">// 记录当前next在c1中找到的最大值</span></span><br><span class="line"> <span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">// 移动判断标识</span></span><br><span class="line"> <span class="keyword">let</span> move = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//  这个source数组里面就是对应的c1的下标，多余的情况就是-1，-1就是需要直接mount的情况</span></span><br><span class="line"><span class="comment">// 且长度是之前e2的长度减去i再+1</span></span><br><span class="line"> <span class="keyword">const</span> source = <span class="keyword">new</span> <span class="built_in">Array</span>(e2-i+<span class="number">1</span>).fill(-<span class="number">1</span>);</span><br><span class="line"><span class="comment">// c2也可能被截断了所以是</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; source.length; k++) &#123;</span><br><span class="line">   <span class="comment">// 找c2</span></span><br><span class="line">   <span class="keyword">const</span> next = c2[k+i];</span><br><span class="line">   <span class="comment">// const curAnchor = i === 0 ? c1[0].el : c2[i - 1].el.nextSibling;</span></span><br><span class="line">   <span class="keyword">if</span> (map.has(next.key)) &#123;</span><br><span class="line">     <span class="keyword">const</span> &#123;</span><br><span class="line">       prev,</span><br><span class="line">       j</span><br><span class="line">     &#125; = map.get(next.key);</span><br><span class="line">     patch(prev, next, container, anchor);</span><br><span class="line">     <span class="keyword">if</span> (j &lt; maxNewIndexSoFar) &#123;</span><br><span class="line">       <span class="comment">// 代表需要移动</span></span><br><span class="line">       move = <span class="literal">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// update</span></span><br><span class="line">       maxNewIndexSoFar = j;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 得到source数组</span></span><br><span class="line">     source[k] = j;</span><br><span class="line">     <span class="comment">// 每次匹配完就删除</span></span><br><span class="line">     map.delete(next.key);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// todo</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 最后多余的节点就卸载</span></span><br><span class="line"> map.forEach(<span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">   prev</span></span></span><br><span class="line"><span class="params"><span class="function"> &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">   unmount(prev)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们要编写 move 的情况了,需要移动的话,我们要采用最长上升子序列算法.</p><h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><p>先说结论,最长上升子序列的节点不需要移动,用这个算法会得到 source 数组里面最长上升子序列的对应下标，合起来是一个 seq 数组，这个数组里面的元素不需要移动。</p><div class="note primary flat"><p>TIP</p><p>什么是最长递增子序列：给定一个数值序列，找到它的一个子序列，并且子序列中的值是递增的，子序列中的元素在原序列中不一定连续。</p><p>例如给定数值序列为：[ 0, 8, 4, 12 ]</p><p>那么它的最长递增子序列就是：[0, 8, 12]</p><p>当然答案可能有多种情况，例如：[0, 4, 12] 也是可以的</p></div><p>假设我们现在已经采取了最长上升子序列算法完成了 seq 数组，进行下一步的判断。</p><p>设两个指针都指向 source 和 seq 的末尾。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> seq = getSequence(source);</span><br><span class="line"><span class="comment">// 从末尾向前遍历</span></span><br><span class="line"><span class="keyword">let</span> j = seq.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k = source.length - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="不需要移动的情况"><a href="#不需要移动的情况" class="headerlink" title="不需要移动的情况"></a>不需要移动的情况</h3><p>如果此时 seq 中的值和 source 的下标对应，说明不需要移动,两指针都减一进行下一轮比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (seq[j] == k) &#123;</span><br><span class="line">  <span class="comment">// 不用移动</span></span><br><span class="line">  <span class="comment">// 此时k和最长上升子序列的值一样,直接j--让他进入下一轮的比较</span></span><br><span class="line">  j--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="需要-mount-的情况"><a href="#需要-mount-的情况" class="headerlink" title="需要 mount 的情况"></a>需要 mount 的情况</h3><p>如果此时 source 的值为-1，说明这个节点需要 mount，source 指针减一</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (source[k] === -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// mount todo curAnchor pos</span></span><br><span class="line">  patch(<span class="literal">null</span>, c2[pos], container, curAnchor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="需要移动的情况"><a href="#需要移动的情况" class="headerlink" title="需要移动的情况"></a>需要移动的情况</h3><p>如果此时 source 的值不为-1 且它的下标又不和 seq 中的值对应，则需要移动，source 减一</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">  <span class="comment">// 移动 todo curAnchor pos</span></span><br><span class="line">  container.insertBefore(c2[pos].el, curAnchor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-anchor"><a href="#注意-anchor" class="headerlink" title="注意 anchor"></a>注意 anchor</h3><p>那么现在的问题是这个 anchor 和 pos 要怎么写，对于 pos，因为此时我们是进行了前面说的一二大步骤才进入这个传统 diff 的，已经走了 i 步，所以起点要加 i。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pos = k + i;</span><br></pre></td></tr></table></figure><p>对于 anchor 来说，它其实就是当前节点的下一位，当然还要考虑末尾的情况所以是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nextPos = pos + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> curAnchor = (c2[nextPos] &amp;&amp; c2[nextPos].el) || anchor;</span><br></pre></td></tr></table></figure><p>我们会发现上面有两种情况都需要 anchor 和 pos，所以我们可以合并一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (move) &#123;</span><br><span class="line">  <span class="comment">// 得到最长上升子序列的下标</span></span><br><span class="line">  <span class="keyword">const</span> seq = getSequence(source);</span><br><span class="line">  <span class="comment">// 从末尾向前遍历</span></span><br><span class="line">  <span class="keyword">let</span> j = seq.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = source.length - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (seq[j] == k) &#123;</span><br><span class="line">      <span class="comment">// 不用移动</span></span><br><span class="line">      <span class="comment">// 此时k和最长上升子序列的值一样,直接j--让他进入下一轮的比较</span></span><br><span class="line">      j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 挂载节点的下标就是k，因为起点变了所以要加i</span></span><br><span class="line">      <span class="keyword">const</span> pos = k + i;</span><br><span class="line">      <span class="comment">// anchor就是当前节点的下一位</span></span><br><span class="line">      <span class="keyword">const</span> nextPos = pos + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> curAnchor = (c2[nextPos] &amp;&amp; c2[nextPos].el) || anchor;</span><br><span class="line">      <span class="keyword">if</span> (source[k] === -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// mount</span></span><br><span class="line">        patch(<span class="literal">null</span>, c2[pos], container, curAnchor);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 移动</span></span><br><span class="line">        container.insertBefore(c2[pos].el, curAnchor);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊情况：不需要移动，但还有未添加的元素"><a href="#特殊情况：不需要移动，但还有未添加的元素" class="headerlink" title="特殊情况：不需要移动，但还有未添加的元素"></a>特殊情况：不需要移动，但还有未添加的元素</h2><blockquote><p>c1: a b c<br>c2: a x b y c<br>source: [1,-1,2,-1,3]<br>seq: [1,2,3]</p></blockquote><p>上面的例子，<code>move</code> 是 <code>false</code>，因此专门用一个 <code>toMounted</code> 去处理这种情况<br><code>toMounted</code> 记录待新增的元素的下标</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toMounted = [];</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 如果不满足条件，把下标添加给toMounted</span></span><br><span class="line"><span class="keyword">if</span>(...)&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  toMounted(k+i);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>(toMounted.length)&#123;</span><br><span class="line">  <span class="comment">// 因为判断插入所以依旧是从后往前</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> k=toMounted.length-<span class="number">1</span>;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">    <span class="comment">// 因为刚刚下标就是给了toMounted 所以此时的坐标就是toMounted中的元素</span></span><br><span class="line">    <span class="keyword">const</span> pos = toMounted[k];</span><br><span class="line">    <span class="keyword">const</span> nextPos = pos+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> curAnchor = (c2[nextPos]&amp;&amp;c2[nextPos].el) || anchor;</span><br><span class="line">    patch(<span class="literal">null</span>,c2[pos],container,curAnchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>至此除了最长上升子序列方法之外都完成了</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们在这一节通过 patchArrayChildren 暴露出来的一对一对比低效的问题,找到了添加 key 去判断的解决方法,其中编写了 patchUnkeyedChildren 来对比新旧孩子,找到 key 一致的孩子去进行 patch,然后我们通过 maxNewIndexSoFar 去优化 insertBefore 的情况，让它在合适的时候才插入，再通过 find 标志位标志新节点没有找到旧节点的情况，直接 mount，随后再判断旧节点多于新节点的情况，直接卸载多余的旧节点。接着我们通过 map 优化了上述的循环代码，让复杂度从 O(n²)降低到 O(n).</p><p>当我们完成后又根据一个简单的例子(移动多次)发现该 diff 算法的缺点，随后看到了 vue2 vue3 解决该问题的方法。其中我们对 vue3 的 diff 算法进行深入了解。vue3 的 diff 是先从左往右对比再从右往左对比，找到需要 mount 的新节点区间或需要卸载的旧节点区间。找不到这两个情况就进行传统的 diff，不过不进行挂载和移动，还是用一个 map 进行标记和删除。之后对于先前 react 算法的缺点，用最长上升子序列解决。最长上升子序列的数组内的元素不需要移动。我们又判断了挂载(source 为-1)和移动(不为-1 又不和 seq 对上)的情况，来进行挂载和移动的操作。最后对于特殊的情况，就是旧节点间夹杂需要挂载的新节点的情况。去设置一个 toMounted 数组，在非 move 的情况时把对应的下标加入到数组中，后面单独拿出来挂载。</p><p>本节的遗漏的最长上升子序列算法将在下一节讲述。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的mini-vue②--vnode篇</title>
    <link href="https://zlinni.github.io/posts/2797606246/"/>
    <id>https://zlinni.github.io/posts/2797606246/</id>
    <published>2022-06-06T02:26:33.000Z</published>
    <updated>2022-06-10T08:29:49.555Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是虚拟 DOM 篇，是关于 Vue3 中响应式的篇章，包含了<code>vnode</code>,<code>render</code>的实现</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/虚拟DOM.png" alt=""></p><h1 id="vnode"><a href="#vnode" class="headerlink" title="vnode"></a>vnode</h1><p>本节中我们将会实现这样的例子(注意 html 中使用 <code>defer</code> 挂载 js，以及使用样式)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render, h, Text &#125; <span class="keyword">from</span> <span class="string">&quot;./runtime&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用h生成vnode</span></span><br><span class="line"><span class="keyword">const</span> vnode = h(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">class</span>: <span class="string">&quot;a b&quot;</span>,</span><br><span class="line">    <span class="attr">style</span>: &#123;</span><br><span class="line">      <span class="attr">border</span>: <span class="string">&quot;1px solid&quot;</span>,</span><br><span class="line">      <span class="attr">fontSize</span>: <span class="string">&quot;14px&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;click&quot;</span>),</span><br><span class="line">    <span class="attr">checked</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">custom</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  [</span><br><span class="line">    h(<span class="string">&quot;ul&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">      h(<span class="string">&quot;li&quot;</span>, &#123; <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span> &#125; &#125;, <span class="number">1</span>),</span><br><span class="line">      h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="number">2</span>),</span><br><span class="line">      h(<span class="string">&quot;li&quot;</span>, &#123; <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">&quot;blue&quot;</span> &#125; &#125;, <span class="number">3</span>),</span><br><span class="line">      h(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, [h(Text, <span class="literal">null</span>, <span class="string">&quot;hello world&quot;</span>)]),</span><br><span class="line">    ]),</span><br><span class="line">  ]</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 将生成的vnode挂载到body上</span></span><br><span class="line">render(vnode, <span class="built_in">document</span>.body);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* &lt;style&gt;</span></span><br><span class="line"><span class="comment">  .a &#123;</span></span><br><span class="line"><span class="comment">    background-color: aqua;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  .b &#123;</span></span><br><span class="line"><span class="comment">    padding: 20px;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&lt;/style&gt; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们在完成这个例子之前，还是有必要了解一下虚拟 DOM 的种类</p><h1 id="虚拟-DOM-的种类"><a href="#虚拟-DOM-的种类" class="headerlink" title="虚拟 DOM 的种类"></a>虚拟 DOM 的种类</h1><ol><li>Element<br>element 对应普通元素，原理是使用 <code>document.createElement()</code>创建的。<code>type</code> 指的是标签名，<code>props</code> 指的是元素属性，<code>children</code> 指子元素，可以为字符串或者数组，为字符串的时候代表只有一个文本节点。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">props</span>:<span class="built_in">Object</span>,</span><br><span class="line">  <span class="attr">children</span>:<span class="built_in">string</span> | VNode[]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>:&#123;<span class="attr">class</span>:<span class="string">&#x27;a&#x27;</span>&#125;,</span><br><span class="line">  <span class="attr">children</span>:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Text<br>text 对应文本节点，原理是使用 <code>document.createTextNode()</code>创建的。<code>type</code> 定义为一个 <code>Symbol</code>，<code>props</code> 为空，<code>children</code> 为字符串，指具体的文本内容</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="built_in">Symbol</span>,</span><br><span class="line">  <span class="attr">props</span>:<span class="literal">null</span>,</span><br><span class="line">  <span class="attr">children</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Fragment<br>Fragment 为一个不会真实渲染的节点。相当于 <code>template</code> 或 <code>react</code> 的 Fragment。<code>type</code> 为一个 <code>Symbol</code>，<code>props</code> 为空，<code>children</code> 为一个数组，表示子节点。最后渲染的时候会挂载到 Fragment 的父节点上面。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="built_in">Symbol</span>,</span><br><span class="line">  <span class="attr">props</span>:<span class="literal">null</span>,</span><br><span class="line">  <span class="attr">children</span>:[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Component<br>Component 是组件，组件有自己的一套特殊的渲染方法，但组件最终的产物也是上面三种 VNode 的集合。组件的 <code>type</code>，就是定义组件的对象，<code>props</code> 即是外部传入组件的 <code>props</code> 数据，<code>children</code> 即是组件的 <code>slot</code>(不准备实现 <code>slot</code> 跳过)</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="built_in">Object</span>,</span><br><span class="line">  <span class="attr">props</span>:<span class="built_in">Object</span>,</span><br><span class="line">  <span class="attr">children</span>:<span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:&#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`&#123;&#123;msg&#125;&#125;&#123;&#123;name&#125;&#125;`</span>,</span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">props</span>:&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;world&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ShapeFlags-快速标识-VNode-的类型"><a href="#ShapeFlags-快速标识-VNode-的类型" class="headerlink" title="ShapeFlags 快速标识 VNode 的类型"></a>ShapeFlags 快速标识 VNode 的类型</h1><p><code>ShapeFlags</code> 是一组标记，用于快速辨识 VNode 的类型</p><h2 id="复习位运算"><a href="#复习位运算" class="headerlink" title="复习位运算"></a>复习位运算</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按位与运算 相同的不变 不同的为0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">&amp;</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// 按位或运算 相同的不变 不同的为1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">|</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="ShapeFlags-的生成"><a href="#ShapeFlags-的生成" class="headerlink" title="ShapeFlags 的生成"></a>ShapeFlags 的生成</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ShapeFlags = &#123;</span><br><span class="line">  <span class="attr">ELEMENT</span>: <span class="number">1</span>, <span class="comment">// 00000001</span></span><br><span class="line">  <span class="attr">TEXT</span>: <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">// 00000010</span></span><br><span class="line">  <span class="attr">FRAGMENT</span>: <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">// 00000100</span></span><br><span class="line">  <span class="attr">COMPONENT</span>: <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">// 00001000</span></span><br><span class="line">  <span class="attr">TEXT_CHILDREN</span>: <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">// 00010000</span></span><br><span class="line">  <span class="attr">ARRAY_CHILDREN</span>: <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">// 00100000</span></span><br><span class="line">  <span class="attr">CHILDREN</span>: (<span class="number">1</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">5</span>), <span class="comment">//00110000</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以发现他利用了二进制位运算<code>&lt;&lt;</code>和<code>|</code>生成，使用的时候用<code>&amp;</code>判断，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag &amp; ShapeFlags.ELEMENT)</span><br></pre></td></tr></table></figure><p>再例如，一个值为 33 的 flag，它的二进制值为 00100001，那么它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="number">33</span>;</span><br><span class="line">flag &amp; ShapeFlags.ELEMENT; <span class="comment">// true</span></span><br><span class="line">flag &amp; ShapeFlags.ARRAY_CHILDREN; <span class="comment">// true</span></span><br><span class="line">flag &amp; ShapeFlags.CHILDREN; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>它的生成还可以用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = ShapeFlags.ELEMENT | ShapeFlags.ARRAY_CHILDREN;</span><br></pre></td></tr></table></figure><h1 id="VNode-初步形态"><a href="#VNode-初步形态" class="headerlink" title="VNode 初步形态"></a>VNode 初步形态</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type,</span><br><span class="line">  props,</span><br><span class="line">  children,</span><br><span class="line">  shapeFlag,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="h-函数—生成-VNode"><a href="#h-函数—生成-VNode" class="headerlink" title="h 函数—生成 VNode"></a>h 函数—生成 VNode</h1><p><code>h</code> 函数的用途就是生成 VNode。<br>它接收三个参数：<code>type</code>, <code>props</code>, <code>children</code>, 返回一个 VNode</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isArray, isNumber, isString &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ShapeFlags = &#123;</span><br><span class="line">  <span class="attr">ELEMENT</span>: <span class="number">1</span>, <span class="comment">// 00000001</span></span><br><span class="line">  <span class="attr">TEXT</span>: <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">// 00000010</span></span><br><span class="line">  <span class="attr">FRAGMENT</span>: <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">// 00000100</span></span><br><span class="line">  <span class="attr">COMPONENT</span>: <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">// 00001000</span></span><br><span class="line">  <span class="attr">TEXT_CHILDREN</span>: <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">// 00010000</span></span><br><span class="line">  <span class="attr">ARRAY_CHILDREN</span>: <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">// 00100000</span></span><br><span class="line">  <span class="attr">CHILDREN</span>: (<span class="number">1</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">5</span>), <span class="comment">//00110000</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Text = <span class="built_in">Symbol</span>(<span class="string">&quot;Text&quot;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Fragment = <span class="built_in">Symbol</span>(<span class="string">&quot;Fragment&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String | Object | Text | Fragment&#125;</span> <span class="variable">type</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object | null&#125;</span> <span class="variable">props</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String | Number | Array | null&#125;</span> <span class="variable">children</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="variable">VNode</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">type, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断shapeFlag得到它的类型</span></span><br><span class="line">  <span class="keyword">let</span> shapeFlag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (isString(type)) &#123;</span><br><span class="line">    shapeFlag = ShapeFlags.ELEMENT;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === Text) &#123;</span><br><span class="line">    shapeFlag = ShapeFlags.TEXT;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === Fragment) &#123;</span><br><span class="line">    shapeFlag = ShapeFlags.FRAGMENT;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    shapeFlag = ShapeFlags.COMPONENT;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 再判断children</span></span><br><span class="line">  <span class="keyword">if</span> (isString(children) || isNumber(children)) &#123;</span><br><span class="line">    shapeFlag |= ShapeFlags.TEXT_CHILDREN;</span><br><span class="line">    <span class="comment">// 数字转字符串</span></span><br><span class="line">    children = children.toString();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(children)) &#123;</span><br><span class="line">    shapeFlag |= ShapeFlags.ARRAY_CHILDREN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    props,</span><br><span class="line">    children,</span><br><span class="line">    shapeFlag,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="render-挂载虚拟-DOM"><a href="#render-挂载虚拟-DOM" class="headerlink" title="render 挂载虚拟 DOM"></a>render 挂载虚拟 DOM</h1><p>这一步我们要将 <code>vnode</code> 中的 shapeFlag 解析并判断节点类型，根据不同的节点类型进行不同的挂载操作</p><p><code>render</code> 需要接收两个参数，一个是节点 <code>vnode</code>，一个是挂载的容器 <code>container</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isBoolean &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ShapeFlags &#125; <span class="keyword">from</span> <span class="string">&quot;./vnode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  mount(vnode, container);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 挂载虚拟dom</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 解析shapeFlag</span></span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ELEMENT) &#123;</span><br><span class="line">    mountElement(vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT) &#123;</span><br><span class="line">    mountTextNode(vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.FRAGMENT) &#123;</span><br><span class="line">    mountFragment(vnode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountComponent(vnode, container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，我们还要操作四种类型的挂载，分别是</p><ol><li>元素挂载 <code>mountElement</code></li><li>文本节点挂载 <code>mountTextNode</code></li><li>虚拟节点挂载 <code>mountFragment</code></li><li>组件挂载 <code>mountComponent</code></li></ol><h2 id="mountElement"><a href="#mountElement" class="headerlink" title="mountElement"></a>mountElement</h2><p>对于我们的 element 类型，我们也知道了他的底层是靠 <code>document.createElement</code> 方法来生成元素的，生成之后我们需要将 <code>props</code> 挂载到该元素上，再将子节点挂载到元素上，然后挂载到容器内。</p><p>综上所述分为以下几个步骤：</p><ol><li>生成元素 el</li><li>挂载 <code>props</code> 到 el <code>mountProps</code></li><li>挂载子节点到 el <code>mountChildren</code></li><li>挂载 el 到 <code>container</code></li></ol><p>代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountElement</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出元素 挂载元素 挂载props children</span></span><br><span class="line">  <span class="keyword">const</span> &#123; type, props &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">  <span class="comment">// 将props挂载到el上</span></span><br><span class="line">  mountProps(props, el);</span><br><span class="line">  <span class="comment">// 把节点挂载到el上</span></span><br><span class="line">  mountChildren(vnode, el);</span><br><span class="line">  container.appendChild(el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>mountProps</code> 和 <code>mountChildren</code>，我们先来做后者</p><h3 id="mountChildren"><a href="#mountChildren" class="headerlink" title="mountChildren"></a>mountChildren</h3><p>前面介绍 element 的时候我们讲到：</p><div class="note primary flat"><p>children 指子元素，可以为字符串或者数组，为字符串的时候代表只有一个文本节点。</p></div><p>所以我们就要对子元素的两种情况进行判断并挂载</p><p><code>mountChildren</code> 也是接收两个参数，一个是节点 <code>vnode</code>，一个是容器 <code>container</code></p><p>对于数组的操作我们递归调用挂载即可。对于字符串我们还需要编写挂载文本节点的情况，这个下面会讲到文本节点所以先掠过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountChildren</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag, children &#125; = vnode;</span><br><span class="line">  <span class="comment">// 文本节点</span></span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">    mountTextNode(vnode, container);</span><br><span class="line">    <span class="comment">// 数组的时候</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">    <span class="comment">// 递归调用挂载</span></span><br><span class="line">    children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">      mount(child, container);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mountProps"><a href="#mountProps" class="headerlink" title="mountProps"></a>mountProps</h3><p><code>mountProps</code> 接收两个参数，一个是 <code>props</code> 渲染器，一个是生成的元素 <code>el</code></p><p>对于我们的 <code>props</code> 有以下几个种类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">class</span>: <span class="string">&#x27;a b&#x27;</span>,</span><br><span class="line">  <span class="attr">style</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    <span class="attr">fontSize</span>: <span class="string">&#x27;14px&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>),</span><br><span class="line">  <span class="attr">checked</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">custom</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先要分析一下我们有几种情况</p><ol><li><code>class</code> 字符串</li><li><code>style</code> 对象</li><li><code>event</code> 事件</li><li>其他属性</li></ol><p>那么来按点分析：</p><h4 id="class-字符串"><a href="#class-字符串" class="headerlink" title="class 字符串"></a>class 字符串</h4><p>如果是 <code>class</code>，直接赋 <code>className</code> 即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;class&#x27;</span>:</span><br><span class="line">    el.className = value;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h4 id="style-对象"><a href="#style-对象" class="headerlink" title="style 对象"></a>style 对象</h4><p>如果是 <code>style</code>，因为他是一个对象，所以我们要遍历这个 <code>style</code>，把对应的值赋给<code>el.style[styleName]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是style 遍历赋值value值</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;style&quot;</span>:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> styleName <span class="keyword">in</span> value) &#123;</span><br><span class="line">    el.style[styleName] = value[styleName];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h4 id="event-事件"><a href="#event-事件" class="headerlink" title="event 事件"></a>event 事件</h4><p>如果是事件，这里偷懒一下，只触发以 <code>on</code> 开头的事件，利用正则我们很快可以匹配上，再把 <code>Click</code> 变小写，然后利用<code>el.addEventListener(eventName, value);</code>这个 api 即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="regexp">/^on[^a-z]/</span>.test(key)) &#123;</span><br><span class="line">  <span class="keyword">const</span> eventName = key.slice(<span class="number">2</span>).toLowerCase();</span><br><span class="line">  el.addEventListener(eventName, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><p>如果是其他属性，这时候我们就要注意了，虽然一般情况下我们用<code>setAttribute</code>这个 <code>api</code>，就可以帮助我们设置属性以及属性对应的值，但是如果我们的属性是<code>value|checked|selected|muted|disabled</code>这几种，那么我们设置<code>true|false</code>的时候，他会被转换成字符串导致赋值失效。所以，我们要正则匹配这种情况，单独给他赋值这个属性<code>el[key] = value;</code></p><p>另外不仅如此,也可能存在没有赋值的情况，比如我只想让多选框选中，那么就给他<code>checked</code>，我们需要将他处理成 true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (domPropsRE.test(key)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (value === <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    value = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  el[key] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，我们设置成 <code>false</code> 或者 <code>null</code> 的时候，代表我们希望移除掉这个属性，所以要利用到 <code>removeAttribute</code>，最后的情况就是 <code>setAttribute</code> 了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span> || value === <span class="literal">false</span>) &#123;</span><br><span class="line">  el.removeAttribute(key);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  el.setAttribute(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> domPropsRE = <span class="regexp">/[A-Z]|^(value|checked|selected|muted|disabled)$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountProps</span>(<span class="params">props, el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = props[key];</span><br><span class="line">    <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">      <span class="comment">// 如果是class 直接赋className</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;class&quot;</span>:</span><br><span class="line">        el.className = value;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 如果是style 遍历赋值value值</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;style&quot;</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> styleName <span class="keyword">in</span> value) &#123;</span><br><span class="line">          el.style[styleName] = value[styleName];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 如果是事件，正则匹配on开头，并将后面的转为小写单词 然后添加事件</span></span><br><span class="line">      <span class="comment">// 如果是别的属性，分类判断，不能统一设置attribute</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/^on[^a-z]/</span>.test(key)) &#123;</span><br><span class="line">          <span class="keyword">const</span> eventName = key.slice(<span class="number">2</span>).toLowerCase();</span><br><span class="line">          el.addEventListener(eventName, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (domPropsRE.test(key)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (value === <span class="string">&quot;&quot;</span> &amp;&amp; isBoolean(el[key])) &#123;</span><br><span class="line">            value = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          el[key] = value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (value == <span class="literal">null</span> || value === <span class="literal">false</span>) &#123;</span><br><span class="line">            el.removeAttribute(key);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            el.setAttribute(key, value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>至此处理完了 <code>mountElement</code>，我们知道了 <code>element</code> 中对于子元素的处理为数组遍历和文本挂载，对于 <code>props</code> 的处理按四种大情况讨论，其中对于其他属性我们还要按照一般的属性和特殊的几种属性讨论，以及赋值的情况下给移除还是挂载。下面进入 <code>mountTextNode</code> 环节</p></div><h2 id="mountTextNode"><a href="#mountTextNode" class="headerlink" title="mountTextNode"></a>mountTextNode</h2><div class="note primary flat"><p>上面我们遗留了一个问题，就是关于子元素的文本节点处理的问题。</p></div><p>其实 <code>mountTextNode</code> 原理就是 <code>document.createTextNode()</code>，具体传入的内容是 <code>vnode</code>.<code>children</code>,因为我们前面讲到,<code>TEXT</code> 节点他的孩子就是具体的文本内容。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="built_in">Symbol</span>,</span><br><span class="line">  <span class="attr">props</span>:<span class="literal">null</span>,</span><br><span class="line">  <span class="attr">children</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountTextNode</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(vnode.children);</span><br><span class="line">  container.appendChild(textNode);</span><br><span class="line">  vnode.el = el;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mountFragment"><a href="#mountFragment" class="headerlink" title="mountFragment"></a>mountFragment</h2><p>他本身不渲染，直接把父节点挂载上去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountFragment</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 本身不渲染 直接把父节点挂载上去</span></span><br><span class="line">  mountChildren(vnode, container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a>mountComponent</h2><p>暂时不写</p><div class="note primary flat"><p>至此我们的挂载虚拟 DOM 暂时完成，下面看我们的 <code>patch</code> 部分</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个部分的篇幅有点长，我们学到了何为vnode，然后初步的编写一个虚拟 DOM 并生成vnode然后挂载并渲染，下节进行<code>patch</code>的学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的mini-vue①--reactive篇</title>
    <link href="https://zlinni.github.io/posts/3451170570/"/>
    <id>https://zlinni.github.io/posts/3451170570/</id>
    <published>2022-05-30T02:33:04.000Z</published>
    <updated>2022-06-10T08:29:28.670Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>mini-Vue 是精简版本的 Vue3，包含了 vue3 源码中的核心内容，附加上 demo 的具体实现。<br>本篇是 reactive 篇，是关于 Vue3 中响应式的篇章，包含了<code>reactive</code>,<code>ref</code>,<code>computed</code>的实现</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/reactivedaotu.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/computedandref.png" alt=""></p><h1 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h1><p>项目使用 webpack 构建，demo 的代码放在<code>index.js</code>之中，将其打包成为<code>mini-vue.js</code>,之后<code>index.html</code>引入，控制台查看 demo 输出。</p><h1 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h1><p>Vue3 中的<code>reactive</code>用于处理对象数据，将引用类型的数据转化为响应式。其实它是由两个部分组成的，见例子。我们知道它由 <code>reactive</code> 和 <code>effect</code> 组成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observed = reactive(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">&#125;);</span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;observed.count is:&quot;</span>, observed.count);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们把这个 effect 叫做副作用函数，副作用函数的执行会影响其他变量或者函数的执行。这里它是作用是收集依赖，在依赖发生改变的时候触发更新。</p><p>它们两个是怎么产生联系的呢?核心是进行依赖收集 track 和触发依赖更新 trigger</p><p>依赖收集就是保存依赖和副作用之间的关系.</p><p>触发依赖更新就是当依赖变更的时候,找到并执行依赖它的副作用</p><p>我们知道了上述的操作，将它们分为两个部分进行编写，一是<code>reactive.js</code> 二是<code>effect.js</code></p><h2 id="reactive-部分"><a href="#reactive-部分" class="headerlink" title="reactive 部分"></a>reactive 部分</h2><p>刚才提及到，reactive 处理的是对象类型的数据，所以我们要编写一个方法判断对象</p><p>所以我们新建<code>utils</code>文件夹，写入<code>index.js</code>,用于编写我们的工具类方法</p><p>判断对象类型的数据的方法,需要注意的是由于<code>null</code>也会被判断为 object，所以要多加判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> funtcion <span class="function"><span class="title">isObject</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们要考虑怎么去将数据变为响应式。</p><p>学过 vue3 基础的都知道，vue3 使用的是 Proxy 来对响应式数据进行 track 和 trigger</p><p>proxy 接收两个参数，一个是 target 一个是 handler，前者是拦截的对象，后者是分为了 get 和 set 两步操作。</p><p>同时 get 接收三个参数，对象，需要拦截的属性 key，接收者 receiver</p><p>这个 receiver 指向原始读操作所在的对象，一般指的是 Proxy 实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, property, receiver</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> receiver;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">d.a === d; <span class="comment">// true</span></span><br><span class="line"><span class="comment">//d对象本身没有a属性，所以读取d.a的时候，会去d的原型proxy对象找。这时，receiver就指向d，代表原始的读操作所在的那个对象。</span></span><br></pre></td></tr></table></figure><p>set 接收四个参数，对象，需要拦截的属性，改变的 value 值，接收者 receiver。最后返回一个布尔值</p><p>我们还需要反射对象 Reflect，我们通过它可以获取对象上的某个指定属性的方法(get)，也可以去修改对象属性上的值(set)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">      track(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">      trigger(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们入手<code>effect.js</code></p><h2 id="effect-部分"><a href="#effect-部分" class="headerlink" title="effect 部分"></a>effect 部分</h2><p>我们在这个部分需要对副作用函数进行处理和剖析，以及对我们的 track 和 trigger 进行编写</p><p>首先我们需要拿到并执行这个副作用函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//todo</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  effectFn();</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是用户写的 effect，可能会报错，所以要用 try 来包裹住,且我们的 track 要收集我们的依赖，就要知道依赖有没有被执行，也就是有没有调用 effect 中的方法，所以我们要设计一个标识记录该方法。这里就用到全局变量<code>activeEffect</code>,去缓存我们的 effect，然后在执行完之后给它还原回去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = effectFn;</span><br><span class="line">      <span class="keyword">return</span> fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      activeEffect = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  effectFn();</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们要来写 track 和 trigger 部分，但我们得先考虑一下，我们依赖的数据结构应该怎么设计</p><p>先了解一下这样的一个执行过程：</p><p>副作用执行=&gt;副作用依赖的响应式对象改变=&gt;响应式对象改变=&gt;响应式对象的属性改变</p><p>且响应式对象的属性可以由多个副作用依赖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  响应式对象<span class="number">1</span>:&#123;</span><br><span class="line">    属性<span class="number">1</span>:[副作用<span class="number">1</span>，副作用<span class="number">2</span>，副作用<span class="number">3.</span>..],</span><br><span class="line">    属性<span class="number">2</span>:[副作用<span class="number">1</span>，副作用<span class="number">2</span>，副作用<span class="number">3.</span>..],</span><br><span class="line">  &#125;,</span><br><span class="line">  响应式对象<span class="number">2</span>:&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们就知道得先存储响应式对象，这里就使用<code>WeakMap</code>作为它的数据结构，这样的好处是里面的响应式对象在不被使用的时候会被垃圾回收。命名为<code>targetMap</code></p><p>再考虑响应式对象的属性，我们将他存放在一个<code>map</code>中，命名为<code>depsMap</code></p><p>接着是它的副作用，副作用存放在一个<code>set</code>中，因为可能有多个副作用依赖同样的属性，命名为<code>deps</code></p><p>这样，我们的结构就是如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">targetMap:&#123;</span><br><span class="line">  响应式对象(target):&#123;</span><br><span class="line">    <span class="attr">depsMap</span>:&#123;</span><br><span class="line">      属性(key):&#123;</span><br><span class="line">        <span class="attr">deps</span>:&#123;</span><br><span class="line">          副作用(activeEffect)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完依赖的数据结构之后，就可以开始写 track 了</p><p>我们现在再次了解一下 track 的作用:添加依赖，也就是要找到层级结构中的依赖，对此，我们进行下面写法。</p><h3 id="track-部分"><a href="#track-部分" class="headerlink" title="track 部分"></a>track 部分</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="comment">// track的作用是收集依赖</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果不是正在执行的依赖 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!activeEffect) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构建depsMap</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构建deps</span></span><br><span class="line">  <span class="keyword">let</span> deps = depsMap.get(key);</span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    depsMap.set(key, (deps = <span class="keyword">new</span> <span class="built_in">Set</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加依赖</span></span><br><span class="line">  deps.add(activeEffect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trigger-部分"><a href="#trigger-部分" class="headerlink" title="trigger 部分"></a>trigger 部分</h3><p>对于 trigger 部分，其实就是 track 的逆运算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trigger用于触发更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果它有副作用,才执行</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> deps = depsMap.get(key);</span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  deps.forEach(<span class="function">(<span class="params">effectFn</span>) =&gt;</span> &#123;</span><br><span class="line">    effectFn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此一个最简单的响应式已经设计好了,接下来我们通过一些特例,来处理特殊情况以及优化</p><h1 id="特例处理与优化"><a href="#特例处理与优化" class="headerlink" title="特例处理与优化"></a>特例处理与优化</h1><div class="note primary flat"><p>下面有六个特例，对应处理 reactive 的六种情况</p></div><ol><li><code>reactive(reactive(obj))</code></li><li><code>let a = reactive(obj), b = reactive(obj)</code></li><li><code>hasChanged</code></li><li>深层对象代理</li><li>数组</li><li>嵌套 effect</li></ol><h2 id="嵌套-reactive"><a href="#嵌套-reactive" class="headerlink" title="嵌套 reactive"></a>嵌套 reactive</h2><p><code>reactive(reactive(obj))</code></p><p>对于第一种情况，是同一个对象被多次响应式处理了。正常的情况应该是只处理一次。</p><p>我们可以给响应式对象添加一个<code>_isReactive</code>属性，依此来判断.</p><p>注意这里用了<code>!!</code>将结果转为 boolean</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isReactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(target &amp;&amp; target._isReactive);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断是否已经是响应式对象</span></span><br><span class="line">  <span class="keyword">if</span> (isReactive(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">      <span class="comment">//判断key是否为__isReactive</span></span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&quot;__isReactive&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      track(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">      trigger(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isReactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(target &amp;&amp; target.__isReactive);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多次对同个对象进行响应式处理"><a href="#多次对同个对象进行响应式处理" class="headerlink" title="多次对同个对象进行响应式处理"></a>多次对同个对象进行响应式处理</h2><div class="note primary flat"><p><code>let a = reactive(obj), b = reactive(obj)</code></p><p>这个可以说是和上面的特例优点类似，但是实际上的处理却不太一样。</p></div><p>对于第一个特例，我们是通过判断标识<code>__isReactive</code>来判断它是否被代理过，然后如果已经存在这个属性，则将其拦截为 true。</p><p>对于第二个特例，我们要通过一个数据结构来存储我们的响应式对象，当目标对象下次被响应式处理的时候，判断数据结构中是否有该响应式对象，有则直接返回该响应式对象。</p><!-- 所以这两个处理主要的区别在于，是否返回同样的响应式，对于第一种，多次嵌套，它返回的是嵌套内容，对于第二种，它返回的是处理过的响应式对象。 --><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"><span class="comment">// 创建proxyMap</span></span><br><span class="line"><span class="keyword">const</span> proxyMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isReactive(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有则直接返回该响应式对象</span></span><br><span class="line">  <span class="keyword">if</span> (proxyMap.get(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&quot;__isReative&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      track(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">      trigger(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 设置</span></span><br><span class="line">  proxyMap.set(target, proxy);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isReactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(target &amp;&amp; target.__isReative);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="响应式内容是否改变-懒处理不触发更新"><a href="#响应式内容是否改变-懒处理不触发更新" class="headerlink" title="响应式内容是否改变(懒处理不触发更新)"></a>响应式内容是否改变(懒处理不触发更新)</h2><p><code>hasChanged</code>是代表着响应式对象是否被改变的操作。在 vue3 中，如果响应式的数据和上一次的没有改变，则不触发更新</p><p>那么很快就知道入手点在 proxy 的 set 中了。不过在此之前我们得编写<code>hasChanged</code>函数,它需要对我们此次的值和上一次的值比较。</p><p>不过光是对比，很容易就遗留一个特殊情况，就是<code>NaN</code>和<code>NaN</code>的情况，看起来是一样的值，实际上的比较是 false 的，所以要对这个特殊值进行处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">hasChanged</span>(<span class="params">oldValue, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> oldValue !== value &amp;&amp; !(<span class="built_in">Number</span>.isNaN(oldValue) &amp;&amp; <span class="built_in">Number</span>.isNaN(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们开始处理 set 了，我们就还要搞清楚<code>oldValue</code>和<code>value</code>是怎么处理的。对于前者，它就是我们现在响应式对象中的属性值，<code>target[key]</code>，value 则是本次传入的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hasChanged, isObject &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxyMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isReactive(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (proxyMap.get(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&quot;__isReative&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      track(target, key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">      <span class="comment">// 处理hasChanged</span></span><br><span class="line">      <span class="keyword">let</span> oldValue = target[key];</span><br><span class="line">      <span class="keyword">if</span> (hasChanged(oldValue, value)) &#123;</span><br><span class="line">        trigger(target, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  proxyMap.set(target, proxy);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isReactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(target &amp;&amp; target.__isReative);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深层对象代理"><a href="#深层对象代理" class="headerlink" title="深层对象代理"></a>深层对象代理</h2><p>我们的响应式对象可能是多层嵌套的，首先这个在 vue2 中，它对于深层对象的处理方式是暴力遍历然后为每个对象赋上响应式。但在 vue3 中，对于这些深层对象是进行一个懒处理。也就是它没有对每个对象进行响应式处理，只对当前层次的对象进行响应式处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&quot;__isReative&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    track(target, key);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">    <span class="keyword">let</span> oldValue = target[key];</span><br><span class="line">    <span class="keyword">if</span> (hasChanged(oldValue, value)) &#123;</span><br><span class="line">      trigger(target, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是对象继续响应式处理，如果不是，就只处理当前层次</span></span><br><span class="line">    <span class="keyword">return</span> isObject(res) ? reactive(res) : res;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxyMap.set(target, proxy);</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observed1 = reactive(&#123;</span><br><span class="line">  <span class="attr">count1</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">count2</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">obj</span>: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observed2 = reactive(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">100</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;sum is:&quot;</span>, observed1.count1 + observed1.count2 + observed2.count);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;sum is:&quot;</span>, observed1.count1 + observed1.count2 + observed2.count);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="数组处理"><a href="#数组处理" class="headerlink" title="数组处理"></a>数组处理</h2><p>在 vue2 中，我们知道它是重写了数据的几个 api，然后拦截了数组进行处理，且因为 vue2 对<code>defineProperty</code>处理，性能的原因，我们修改数组下标和长度是没办法被检测的，但在 vue3 中 proxy 解决了这个问题。</p><p>在这一部分，对于数组的处理主要是避免 length 多次被触发，只有在值真正被改变了才去 trigger 这个 length</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">    <span class="keyword">let</span> oldLength = target.length;</span><br><span class="line">    <span class="keyword">let</span> oldValue = target[key];</span><br><span class="line">    <span class="keyword">if</span>(hasChanged(oldValue,value))&#123;</span><br><span class="line">        <span class="keyword">if</span>(isArray(target)&amp;&amp;hasChanged(oldLength,target.length))&#123;</span><br><span class="line">            trigger(target,<span class="string">&#x27;length&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        trigger(target, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isObject(res)?reactive(res):res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observed = (<span class="built_in">window</span>.observed = reactiv([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));</span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;index 4 is:&quot;</span>, observed[<span class="number">4</span>]);</span><br><span class="line">&#125;);</span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;length is:&quot;</span>, observed.length);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="嵌套-effect"><a href="#嵌套-effect" class="headerlink" title="嵌套 effect"></a>嵌套 effect</h2><p>说完了这些，剩下一个嵌套 effect 的部分，见例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observed = (<span class="built_in">window</span>.observed = reactive(&#123;</span><br><span class="line">  <span class="attr">count1</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">count2</span>: <span class="number">10</span>,</span><br><span class="line">&#125;));</span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;count2 is:&quot;</span>, observed.count2);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;count1 is:&quot;</span>, observed.count1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们可以来测试一下目前写的例子，会发现我们触发<code>count2</code>是正常的，触发<code>count1</code>是不正常的,没有打印出<code>count2</code>。</p><p>换句话说，就是内层依赖正常触发更新，但是外层依赖没有正确触发。这是为什么呢？这是因为，我们在执行副作用函数的时候，先执行了外层，之后再执行内层，此时外层的 effect 已经丢失了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = effectFn;</span><br><span class="line">      <span class="keyword">return</span> fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      activeEffect = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  effectFn();</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们要换个角度来说，就是要用数据结构去保存我们的<code>activeEffect</code>然后再结束的时候去弹出末尾的<code>activeEffect</code>并还原<code>activeEffect</code>为新的末尾项。</p><p>于是可以想到栈结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="keyword">const</span> effectStack = [];</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = effectFn;</span><br><span class="line">      effectStack.push(activeEffect);</span><br><span class="line">      <span class="keyword">return</span> fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      effectStack.pop();</span><br><span class="line">      activeEffect = effectStack[effectStack.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  effectFn();</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就解决了嵌套 effect 的问题</p><h2 id="完整-reactive"><a href="#完整-reactive" class="headerlink" title="完整 reactive"></a>完整 reactive</h2><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject, hasChanged, isArray &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"><span class="comment">// 存储proxy对象</span></span><br><span class="line"><span class="keyword">const</span> proxyMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 类型判断是否需要做响应式代理</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只能代理一次</span></span><br><span class="line">  <span class="keyword">if</span> (isReactive(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果已经有这个代理对象 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (proxyMap.get(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy</span></span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&quot;__isReactive&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      track(target, key);</span><br><span class="line">      <span class="comment">// 不需要对每层对象进行劫持，只对需要的对象进行。</span></span><br><span class="line">      <span class="keyword">return</span> isObject(res) ? reactive(res) : res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> oldLength = target.length;</span><br><span class="line">      <span class="keyword">const</span> oldValue = target[key];</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">      <span class="keyword">if</span> (hasChanged(oldValue, value)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isArray(target) &amp;&amp; hasChanged(oldLength, target.length)) &#123;</span><br><span class="line">          trigger(target, <span class="string">&quot;length&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        trigger(target, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  proxyMap.set(target, proxy);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isReactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(target &amp;&amp; target.__isReactive);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整 effect</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录当前正在执行的副作用函数</span></span><br><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="comment">// 使用一个栈记录当前正在执行的副作用</span></span><br><span class="line"><span class="keyword">const</span> effectStack = [];</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 因为是用户输入的fn可能有错要包裹</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = effectFn;</span><br><span class="line">      effectStack.push(activeEffect);</span><br><span class="line">      <span class="keyword">return</span> fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 执行完函数之后还原当前副作用</span></span><br><span class="line">      effectStack.pop();</span><br><span class="line">      <span class="comment">// 将外层副作用记录下来</span></span><br><span class="line">      activeEffect = effectStack[effectStack.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集依赖</span></span><br><span class="line"><span class="comment">// 存储我们的依赖</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// target是响应式对象 key是对象的属性</span></span><br><span class="line">  <span class="keyword">if</span> (!activeEffect) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> deps = depsMap.get(key);</span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    depsMap.set(key, (deps = <span class="keyword">new</span> <span class="built_in">Set</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  deps.add(activeEffect);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触发更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> deps = depsMap.get(key);</span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  deps.forEach(<span class="function">(<span class="params">effectFn</span>) =&gt;</span> &#123;</span><br><span class="line">    effectFn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>至此，我们的响应式就都已经处理完了，下面进入<code>ref</code>章节</p></div><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><p><code>ref</code>是 vue3 的一个新 api，目的是为了处理基本数据类型的响应式，访问<code>ref</code>处理过的数据需要使用<code>.value</code></p><p>有了前面<code>reactive</code>的基础，下面我们要实现<code>ref</code>api 就容易多了，例子如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = ref(<span class="number">1</span>);</span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo: &quot;</span>, foo.value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>首先<code>ref</code>返回的是一个<code>RefImpl</code>对象,这个对象接收的是<code>value</code>，拥有<code>get</code>和<code>set</code>两个方法，这之中它也是使用到了<code>track</code>和<code>trigger</code>去跟踪和更新值</p><p>其次它只对基础类型进行处理，其他情况交给<code>reactive</code>去做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&quot;./reactive&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回RefImpl对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RefImpl(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = convert(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    track(<span class="built_in">this</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = newValue;</span><br><span class="line">    trigger(<span class="built_in">this</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对不同类型的数据 使用reative或者ref</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isObject(value) ? reactive(value) : value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两点优化"><a href="#两点优化" class="headerlink" title="两点优化"></a>两点优化</h2><p>到了这一步其实已经做好了一个<code>ref</code>api，但是我们还需要对以下两点优化:</p><ol><li>已经 ref 过的数据不需要再进行响应式处理</li><li>如果前一次的值和后一次的值一样，不触发更新</li></ol><p>对于第一点，我们设置一个<code>isRef</code>函数即可。处理的方式和之前<code>isReactive</code>类似</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isRef</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(value &amp;&amp; value.__isRef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第二点，我们也是照样使用<code>hasChanged</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasChanged(newValue, <span class="built_in">this</span>._value)) &#123;</span><br><span class="line">        <span class="built_in">this</span>._value = convert(newValue);</span><br><span class="line">        <span class="comment">// trigger后置 因为值改变了才切换</span></span><br><span class="line">        trigger(<span class="built_in">this</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整-ref"><a href="#完整-ref" class="headerlink" title="完整 ref"></a>完整 ref</h2><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    hasChanged,</span><br><span class="line">    isObject</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    reactive</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./reactive&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    track,</span><br><span class="line">    trigger</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isRef(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RefImpl(value);·</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isRef</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !!(value &amp;&amp; value.__isRef)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.__isRef = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>._value = convert(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">        track(<span class="built_in">this</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasChanged(newValue, <span class="built_in">this</span>._value)) &#123;</span><br><span class="line">            <span class="built_in">this</span>._value = convert(newValue);</span><br><span class="line">            <span class="comment">// trigger后置 因为值改变了才切换</span></span><br><span class="line">            trigger(<span class="built_in">this</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isObject(value) ? reactive(value) : value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>那么至此对<code>ref</code>的处理也结束了，下面轮到<code>computed</code></p></div><h1 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h1><p>在这个模块开始我们不再详细的一步步写方法,以分析代码的方式走会比较容易理解.</p><p>在 vue3 中计算属性被归为了一个 api，因为不再像 vue2 一样，将<code>method</code>和<code>computed</code>分开，而是都组合在了一起，有点像又回到了一开始 js 编程的时候了。</p><p>例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = ref(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> sum = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="computed-机制"><a href="#computed-机制" class="headerlink" title="computed 机制"></a>computed 机制</h2><p>写这个 <code>computed</code> 之前,我们要明白 <code>computed</code> 的机制<br>使用了什么?</p><ol><li><code>computed</code> 使用了和 <code>effect</code> 相同的一套机制,但不同在于 <code>computed</code> 不会立刻触发</li><li><code>computed</code> 使用了 <code>track</code> 和 <code>trigger</code> 收集依赖和触发更新</li></ol><p>做了什么?</p><ol><li>调用了 <code>computed</code>,才返回更新值</li><li><code>computed</code> 中的依赖更新,computed 才能更新</li></ol><p>那么对于第一点,<code>computed</code> 不会立刻触发,那么触发的权力就是交给了调用 <code>computed</code> 的变量,这里拿 <code>sum</code> 作为例子.</p><p>本来我们的 <code>effect</code>,是在函数内部直接调用 <code>effectFn</code> 这个方法,返回触发的依赖,现在我们不需要直接调用 <code>effectFn</code>,我们需要将调用 <code>effectFn</code> 的权力交给我们的 <code>computed</code>,让他去调用然后获取更新值.所以我们需要一个变量去标识这个情况.</p><h2 id="lazy-懒处理-effectFn"><a href="#lazy-懒处理-effectFn" class="headerlink" title="lazy 懒处理 effectFn"></a>lazy 懒处理 effectFn</h2><p>也就是要在 <code>effect</code> 中增加一个 <code>option</code> 对象,传入的变量是 <code>lazy</code>,<code>lazy</code> 为真的时候,直接返回 <code>effectFn</code> 方法(<code>computed</code> 使用),<code>lazy</code> 为假或者不存在的时候,直接触发.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本来effect会直接执行,现在传入配置项让他根据配置项执行</span></span><br><span class="line"><span class="comment">// 增加option选项</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn, option = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = effectFn;</span><br><span class="line">      effectStack.push(activeEffect);</span><br><span class="line">      <span class="keyword">return</span> fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      effectStack.pop();</span><br><span class="line">      activeEffect = effectStack[effectStack.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// lazy为false的时候执行,否则就直接返回effectFn给computed自行操作</span></span><br><span class="line">  <span class="keyword">if</span> (!option.lazy) &#123;</span><br><span class="line">    effectFn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dirty-标识内部依赖是否更新"><a href="#dirty-标识内部依赖是否更新" class="headerlink" title="dirty 标识内部依赖是否更新"></a>dirty 标识内部依赖是否更新</h2><p>对于第二点,首先,<code>computed</code> 设计了一个 <code>dirty</code> 变量,用于标识内部依赖是否更新,默认为 <code>true</code>,所以我们第一次调用的时候他会拿到 <code>effect</code> 返回的 <code>effectFn</code> 并触发给<code>_value</code> 去缓存.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputedImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">getter</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存它的值</span></span><br><span class="line">    <span class="built_in">this</span>._value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 标识依赖是否更新</span></span><br><span class="line">    <span class="built_in">this</span>._dirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 区别在于computed不会立刻执行 effect会</span></span><br><span class="line">    <span class="comment">// 所以要拓展一下effect</span></span><br><span class="line">    <span class="built_in">this</span>.effect = effect(getter, &#123;</span><br><span class="line">      <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="comment">// 如果依赖更新了就要重新计算</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">      <span class="built_in">this</span>._value = <span class="built_in">this</span>.effect();</span><br><span class="line">      <span class="built_in">this</span>._dirty = <span class="literal">false</span>;</span><br><span class="line">      track(<span class="built_in">this</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="value-缓存依赖数据"><a href="#value-缓存依赖数据" class="headerlink" title="value 缓存依赖数据"></a>value 缓存依赖数据</h2><p>如果下次依赖没有更新我们直接返回<code>_value</code> 缓存的值.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">        <span class="built_in">this</span>._value = <span class="built_in">this</span>.effect();</span><br><span class="line">        <span class="built_in">this</span>._dirty = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接走_value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们下次内部依赖更新了之后怎么继续获得 <code>effectFn</code> 呢?</p><h2 id="scheduler-调度函数"><a href="#scheduler-调度函数" class="headerlink" title="scheduler 调度函数"></a>scheduler 调度函数</h2><p>这就要使用到调度函数,他的作用就是,当 <code>computed</code> 内部的依赖发生更新的时候,去通知 <code>computed</code> 改变 <code>dirty</code>,在下次调用 <code>sum</code> 的时候触发更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.effect = effect(getter, &#123;</span><br><span class="line">  <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 还要将dirty变为true 所以要用一个调度机制</span></span><br><span class="line">  <span class="comment">// 让他去触发更新的时候不是立即去执行getter,而是去执行调度程序</span></span><br><span class="line">  <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">      <span class="built_in">this</span>._dirty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>effect</code> 挂载这个 <code>scheduler</code> 并优先触发 <code>scheduler</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn,options=&#123;&#125;</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(!options.lazy)&#123;</span><br><span class="line">        effectFn();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 挂载在副作用函数上</span></span><br><span class="line">    effectFn.scheduler = options.scheduler;</span><br><span class="line">    <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target,key</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    deps.forEach(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 如果它有调度程序 优先执行 否则才去执行副作用函数本身</span></span><br><span class="line">        <span class="keyword">if</span>(effectFn.scheduler)&#123;</span><br><span class="line">            effectFn.scheduler(effectFn)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            effectFn();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决嵌套-effect"><a href="#解决嵌套-effect" class="headerlink" title="解决嵌套 effect"></a>解决嵌套 effect</h2><p>这下一个完整的 <code>computed</code> 已经做好了,但还是有一些不足的地方.比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sumRes = computed(<span class="function">() =&gt;</span> obj.foo + obj.bar);</span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在该副作用函数中读取 sumRes.value</span></span><br><span class="line">  <span class="built_in">console</span>.log(sumRes.value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改obj.foo的值</span></span><br><span class="line">obj.foo++;</span><br></pre></td></tr></table></figure><p>我们原意是修改 <code>obj</code> 的 <code>foo</code> 然后副作用函数重新执行,但做到这里,会发现修改 <code>foo</code> 的值并不会触发副作用函数的渲染.</p><p>回想一下我们的依赖数据结构,响应式对象的属性可以被多个副作用依赖,那么这个问题就很简单了,就是 <code>effect</code> 嵌套的问题,我们 <code>computed</code> 只收集了内部的 <code>effect</code> 作为依赖,并没有外层的这个 <code>effect</code>,自然就不触发更新了</p><p>解决办法也很简单,就是通过手动触发的方式,在我们计算属性所依赖的响应式数据发生变化的时候手动调用 <code>trigger</code> 触发更新,在每次读取结束就手动 <code>track</code> 响应式数据.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">getter, setter</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="built_in">this</span>.effect = effect(getter, &#123;</span><br><span class="line">        <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 还要将dirty变为true 所以要用一个调度机制</span></span><br><span class="line">        <span class="comment">// 让他去触发更新的时候不是立即去执行getter,而是去执行调度程序</span></span><br><span class="line">        <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">                <span class="built_in">this</span>._dirty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 手动trigger</span></span><br><span class="line">                trigger(<span class="built_in">this</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="comment">// 如果依赖更新了就要重新计算</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">        <span class="built_in">this</span>._value = <span class="built_in">this</span>.effect();</span><br><span class="line">        <span class="built_in">this</span>._dirty = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 手动track</span></span><br><span class="line">        track(<span class="built_in">this</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此综上所述,<code>computed</code> 比较关键的几个变量,<code>_value</code>,<code>lazy</code>,<code>_dirty</code> 和 <code>scheduler</code></p><h2 id="完整-computed"><a href="#完整-computed" class="headerlink" title="完整 computed"></a>完整 computed</h2><p>完整的 <code>computed</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isFunction &#125; <span class="keyword">from</span> <span class="string">&quot;../utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; effect, track, trigger &#125; <span class="keyword">from</span> <span class="string">&quot;./effect&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">computed</span>(<span class="params">getterOrOption</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> getter, setter;</span><br><span class="line">  <span class="comment">// 判断是否是函数</span></span><br><span class="line">  <span class="keyword">if</span> (isFunction(getterOrOption)) &#123;</span><br><span class="line">    getter = getterOrOption;</span><br><span class="line">    setter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">&quot;computed is readonly&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = getterOrOption.get;</span><br><span class="line">    setter = getterOrOption.set;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ComputedImpl(getter, setter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputedImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">getter, setter</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存setter</span></span><br><span class="line">    <span class="built_in">this</span>._setter = setter;</span><br><span class="line">    <span class="comment">// 缓存它的值</span></span><br><span class="line">    <span class="built_in">this</span>._value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 标识依赖是否更新</span></span><br><span class="line">    <span class="built_in">this</span>._dirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 区别在于computed不会立刻执行 effect会</span></span><br><span class="line">    <span class="comment">// 所以要拓展一下effect</span></span><br><span class="line">    <span class="built_in">this</span>.effect = effect(getter, &#123;</span><br><span class="line">      <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 还要将dirty变为true 所以要用一个调度机制</span></span><br><span class="line">      <span class="comment">// 让他去触发更新的时候不是立即去执行getter,而是去执行调度程序</span></span><br><span class="line">      <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">          <span class="built_in">this</span>._dirty = <span class="literal">true</span>;</span><br><span class="line">          trigger(<span class="built_in">this</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="comment">// 如果依赖更新了就要重新计算</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">      <span class="built_in">this</span>._value = <span class="built_in">this</span>.effect();</span><br><span class="line">      <span class="built_in">this</span>._dirty = <span class="literal">false</span>;</span><br><span class="line">      track(<span class="built_in">this</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">    <span class="built_in">this</span>._setter(newValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="note primary flat"><p>那么至此reactive篇幅的全部内容都已经讲完，接下来会进入patch篇章研究vue是怎么设计并挂载节点到虚拟dom的</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>快速上手mongoose</title>
    <link href="https://zlinni.github.io/posts/1323151960/"/>
    <id>https://zlinni.github.io/posts/1323151960/</id>
    <published>2022-05-30T01:10:28.000Z</published>
    <updated>2022-05-30T02:19:21.444Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>Mongoose 是 MongoDB 的一个对象模型工具，是基于 node-mongodb-native 开发的 MongoDB nodejs 驱动，可以在异步的环境下执行。同时它也是针对 MongoDB 操作的一个对象模型库，封装了MongoDB 对文档的的一些增删改查等常用方法，让 NodeJS 操作 Mongodb 数据库变得更加灵活简单。<br>记录使用MongoDB非关系型数据库时，使用Express+Mongoose的操作。</p></div><h1 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h1><p>初始化项目之后复制如下到package.json安装即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;body-parser&quot;</span>: <span class="string">&quot;^1.20.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cors&quot;</span>: <span class="string">&quot;^2.8.5&quot;</span>,</span><br><span class="line">  <span class="string">&quot;express&quot;</span>: <span class="string">&quot;^4.18.1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;mongoose&quot;</span>: <span class="string">&quot;^6.3.4&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="express模板"><a href="#express模板" class="headerlink" title="express模板"></a>express模板</h1><p>由于只是演示操作，下列全部都写在了app.js中，具体使用按业务场景划分文件模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>); <span class="comment">// 引入body-parser模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>); <span class="comment">// 引入express模块</span></span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>); <span class="comment">// 引入cors模块</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(bodyParser.json()); <span class="comment">// 解析json数据格式</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;</span><br><span class="line">    <span class="attr">extended</span>: <span class="literal">true</span></span><br><span class="line">&#125;)); <span class="comment">// 解析form表单提交的数据application/x-www-form-urlencoded</span></span><br><span class="line">app.use(cors()); <span class="comment">// 注入cors模块解决跨域</span></span><br></pre></td></tr></table></figure></p><h1 id="mongoose模板"><a href="#mongoose模板" class="headerlink" title="mongoose模板"></a>mongoose模板</h1><p>分为几部分：</p><ol><li>引入mongoose</li><li>定义连接的数据库</li><li>连接数据库</li></ol><p>代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入mongoose</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br><span class="line"><span class="comment">//定义字符串常量</span></span><br><span class="line"><span class="keyword">const</span> db_url = <span class="string">&quot;mongodb://localhost:27017/miniprogram&quot;</span></span><br><span class="line"><span class="comment">//1.连接数据库</span></span><br><span class="line">mongoose.connect(db_url, &#123;</span><br><span class="line">    <span class="attr">useNewUrlParser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">useUnifiedTopology</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//2.连接成功</span></span><br><span class="line">mongoose.connection.on(<span class="string">&#x27;connected&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;连接成功：&#x27;</span>, db_url);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//3.连接失败</span></span><br><span class="line">mongoose.connection.on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;连接错误：&#x27;</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//4.断开连接</span></span><br><span class="line">mongoose.connection.on(<span class="string">&#x27;disconnection&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;断开连接&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="新建schema"><a href="#新建schema" class="headerlink" title="新建schema"></a>新建schema</h2><p>mongoose是封装过后的mongodb指令，它需要我们先新建一个schema，内部是所需的字段名称和类型。</p><p>下面是schema的介绍<br><div class="note primary flat"><p>Schema是一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力，仅仅只是定义数据库模型在程序片段中的一种表现，可以说是数据属性模型(传统意义的表结构)，又或着是“集合”的模型骨架。</p></div></p><p>代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> commoditiesSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    <span class="attr">_id</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">goods</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">Object</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">typeID</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">typeImage</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">typeTitle</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h2><p>模型的定义<br><div class="note primary flat"><p>模型(Model)是由Schema构造生成的模型，除了Schema定义的数据库骨架以外，还具有数据库操作的行为，类似于管理数据库属性、行为的类</p></div><br>第二步需要创建模型，如果数据库中没有这张表(复数名称)，则新建一张。</p><p>创建表名的规则是：传入的单词的复数，如果已经是复数，则使用复数</p><p>eg<br><code>food</code> -&gt; <code>foods</code></p><p>code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引号内传入的是表名 自动转为复数</span></span><br><span class="line"><span class="keyword">const</span> commodities = mongoose.model(<span class="string">&#x27;commodities&#x27;</span>, commoditiesSchema);</span><br></pre></td></tr></table></figure></p><div class="note warning flat"><p>schema和model最好不要在接口里面写<br>原因1: 请求多次会由于利用了重复的模型报错(模型不允许overwrite)<br>原因2: 全局可复用</p></div><h1 id="查询find"><a href="#查询find" class="headerlink" title="查询find"></a>查询find</h1><p>mongoose中提供了几种查询方法，<code>find</code>、<code>findById</code>、<code>findOne</code>。都是模型的api，所以一定要新建模型</p><p><code>findById</code> 返回的结果是数组<br>需要传入两个参数，一个是对象包裹的id，可以是<code>_id</code>,第二个是一个回调函数，其中有两个参数<code>err</code>和<code>data</code>，返回查询的结果或者异常情况。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">commodities.findById(&#123;</span><br><span class="line">    _id</span><br><span class="line">&#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 一般返回三个值 code msg 和 result</span></span><br><span class="line">        res.json(&#123;</span><br><span class="line">            <span class="attr">code</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">result</span>: data</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><code>find</code> 返回的结果是数组<br>两种情况<br>第一种只传一个回调函数，则返回对应模型的全部字段值</p><p>第二种：<br>需要传入三个参数，第一个是对象包裹的查询条件，第二个是对象包裹的返回结果(用于筛选),key是模型的字段，value是1或者0，如果是1则返回该结果，如果是0则不返回，第三个是回调函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">commodities.find(&#123;</span><br><span class="line">    _id,</span><br><span class="line">&#125;,&#123;<span class="attr">goods</span>:<span class="number">1</span>&#125;,<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;查找异常&#x27;</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;data&#x27;</span>,data)</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            <span class="attr">result</span>:data</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>findOne</code>返回单个结果，是一个数据对象。也是可以传入三个参数，依据是否大量查询使用不同的指令对性能的影响可能不一样</p><h1 id="新增-创建实体"><a href="#新增-创建实体" class="headerlink" title="新增(创建实体)"></a>新增(创建实体)</h1><p>实体的定义如下<br><div class="note primary flat"><p>实体(Entity)是由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性。</p></div></p><p>新增需要建立实体，实体是根据模型建立的。实体中有save方法，可以让我们对数据库进行插入操作，也是传递一个回调参数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取query参数</span></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    addr,</span><br><span class="line">    name,</span><br><span class="line">    phone,</span><br><span class="line">    time</span><br><span class="line">&#125; = req.query;</span><br><span class="line"><span class="comment">//创建实体</span></span><br><span class="line"><span class="keyword">let</span> AddEntity = <span class="keyword">new</span> address(&#123;</span><br><span class="line">    addr,</span><br><span class="line">    name,</span><br><span class="line">    phone,</span><br><span class="line">    time</span><br><span class="line">&#125;)</span><br><span class="line">AddEntity.save(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;插入失败：&#x27;</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            <span class="attr">code</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">msg</span>: <span class="string">&#x27;插入成功&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="删除delete"><a href="#删除delete" class="headerlink" title="删除delete"></a>删除delete</h1><p>删除的操作是基于模型的，是模型中的方法<br>删除有两个方法，一个是<code>deleteOne</code>和<code>remove</code></p><p><code>deleteOne</code>传递两个参数，一个是查找条件，一个是回调函数</p><p>代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">address.deleteOne(&#123;</span><br><span class="line">    _id</span><br><span class="line">&#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;删除失败：&#x27;</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            <span class="attr">code</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">msg</span>: <span class="string">&#x27;删除成功&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="更新update"><a href="#更新update" class="headerlink" title="更新update"></a>更新update</h1><p>更新的操作是基于模型的，是模型的api</p><p><code>updateOne</code>方法，传入三个参数</p><ol><li>对象包裹的查询条件</li><li>对象包裹的更新数据</li><li>回调参数</li></ol><p>代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">address.updateOne(&#123;</span><br><span class="line">    _id</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    addr,</span><br><span class="line">    name,</span><br><span class="line">    phone,</span><br><span class="line">    time</span><br><span class="line">&#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;修改失败：&#x27;</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            <span class="attr">code</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">msg</span>: <span class="string">&#x27;修改成功&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>另外还有<code>findByIdAndUpdate</code>,<code>findOneAndUpdate</code>方法</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在mongoose操作中需要注意如果数据库中没有该表，会新建为复数名称的表，所以导入数据的时候应该在库建立好之后再考虑导入</p><p>如果已经有表，对应的规则在schema中也不能出错，否则返回错误类型的约束</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="nodejs" scheme="https://zlinni.github.io/tags/nodejs/"/>
    
    <category term="nosql" scheme="https://zlinni.github.io/tags/nosql/"/>
    
  </entry>
  
  <entry>
    <title>Http打怪升级1.0-3.0</title>
    <link href="https://zlinni.github.io/posts/1703341700/"/>
    <id>https://zlinni.github.io/posts/1703341700/</id>
    <published>2022-05-21T01:49:01.000Z</published>
    <updated>2022-06-01T07:32:43.369Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>介绍http1.0-3.0的版本优缺点</p></div><h1 id="Http1-0"><a href="#Http1-0" class="headerlink" title="Http1.0"></a>Http1.0</h1><div class="note warning flat"><p>http1.0之前还有别的版本吗？<br>答:http0.9</p></div><p>特点：</p><ul><li>可以传输任何格式的内容 0.9只能文本</li><li>引入了POST和HEAD 0.9只有GET</li><li>每次通信都得携带头信息 0.9没有标记信息的手段</li><li>增加了响应状态码</li><li>缓存的标准是<code>Expires</code>和<code>If-Modified-Since</code></li></ul><p>缺点：</p><ul><li>不支持断点续传</li><li>没有传递主机名hostname</li></ul><h2 id="没有解决的问题"><a href="#没有解决的问题" class="headerlink" title="没有解决的问题"></a>没有解决的问题</h2><p>服务器发送完响应就关闭了TCP连接。</p><p>http连接是在TCP连接里面的，如果这样做，后面再次请求，就要重新建立连接，然鹅我们知道TCP三次握手的成本是比较高的</p><p>1.0缓解的方法：</p><p>1.0可以使用headers发送信息，其中<code>Connection：keep-alive</code>，就能告诉服务器，客户端后面可能还会请求，先不要关闭TCP连接，从而达到了类似于TCP复用的目的。</p><p>为什么说是缓解的方法呢？<br>因为这个头部字段不是标准的，不同的实现可能导致表现得不一致，因此不能从根本上解决这个问题。</p><h1 id="Http1-1"><a href="#Http1-1" class="headerlink" title="Http1.1"></a>Http1.1</h1><p>解决了上个版本的问题：</p><ol><li>引入长连接，默认TCP不关闭，可以被多个请求复用</li><li>支持断点续传</li></ol><p>特点：</p><ol><li>引入并发连接</li><li>管道机制(一个TCP连接里可以同时发送多个请求，但是响应的顺序和请求的顺序一致，因此不常用)</li><li>增加了PUT、DELETE、OPTIONS、PATCH等方法</li><li>允许响应数据分块chunked，利于传输大文件</li><li>强制要求host头，让主机托管成为可能</li></ol><p>缺点：</p><ol><li>队头阻塞(长连接带来)</li><li>无状态</li><li>明文传输</li><li>不支持服务器端推送</li></ol><h1 id="队头阻塞的思考"><a href="#队头阻塞的思考" class="headerlink" title="队头阻塞的思考"></a>队头阻塞的思考</h1><p>队头阻塞特点：顺序发送的请求因为某些原因被阻塞的时候，后面排队的请求也会一并被阻塞，导致服务端收不到数据。</p><p>HTTP1.1为了解决这个问题，有两个方案：</p><ol><li>域名分片+并发连接</li><li>管道机制</li></ol><h2 id="域名分片-并发连接"><a href="#域名分片-并发连接" class="headerlink" title="域名分片+并发连接"></a>域名分片+并发连接</h2><p>在chrome中，允许一个域名拥有6个TCP持久连接，那么当拥有多级域名的时候，就能将更多的资源分配出来。</p><p>但是也会引起一些别的问题，因为TCP的连接需要经过dns，三次握手，慢启动等操作，所以对于服务器来说连接太多容易造成网络拥挤。</p><h2 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h2><p>指的是在一个TCP连接里面，多个HTTP请求可以并行，客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务端内必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能区分每次响应的内容</p><p>简单来说就是客户端可以一直发，但服务端要按顺序回</p><p>一定程度上能解决队头阻塞的问题，但治标不治本，因为如果前面的一个请求很耗费时间，比如大图片的处理，那么后面的即使服务器处理完了也只能等待这个请求处理完才能返回</p><h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h2><ul><li>合并小文件减小资源数。精灵图</li><li>内联资源。图片放到css的url里面，减少请求次数</li><li>减小请求数量。拼接，将多个体积较小的js打包成一个大js，但如果其中一个文件改动就会导致大量数据被重新下载和传输</li></ul><h1 id="无状态特性—巨大的HTTP头部"><a href="#无状态特性—巨大的HTTP头部" class="headerlink" title="无状态特性—巨大的HTTP头部"></a>无状态特性—巨大的HTTP头部</h1><p>无状态指的是对于连接状态没有记忆能力。纯净的http是没有cookie等机制的，每个连接都是新的连接。</p><p>但是由于新增了header标识信息的操作，每次收发都会携带大量的header字段到服务端，这样就逐渐的增加了传输的成本</p><p>所以2.0设计的Hpack算法就是为了解决这个问题诞生的。</p><h1 id="明文传输—不安全性"><a href="#明文传输—不安全性" class="headerlink" title="明文传输—不安全性"></a>明文传输—不安全性</h1><p>1.1在传输数据的时候，所有的内容都是明文的，这样意味着客户端和服务端没办法验证对方的身份，一定程度上无法保证数据的安全性</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>http1.1因为引入了长连接带来了队头阻塞的问题，使用了域名分片和管道机制缓解，但是没有从根本上解决问题，且引入了header头字段标识信息，但是没有压缩以及存储导致头部信息很大，最后是明文传输的问题，不安全。</p><h1 id="SPDY-改进版Http1-1"><a href="#SPDY-改进版Http1-1" class="headerlink" title="SPDY 改进版Http1.1"></a>SPDY 改进版Http1.1</h1><p>SPDY：speedy 迅速的。SPDY协议是2012年谷歌提出的方案，优化了http1.x的请求延迟，解决了http的安全性。</p><ol><li>针对http高延迟的问题,speedy采用了多路复用.它通过多个请求stream共享一个tcp连接的方式,解决了http队头阻塞的问题.</li><li>设置了请求优先级,重要的请求优先响应</li><li>header压缩</li><li>加密传输</li><li>服务端推送</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220525114043.png" alt=""></p><p>如上图所示,SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。</p><p>后面的http2.0就是基于speedy协议操作的</p><h1 id="Http2"><a href="#Http2" class="headerlink" title="Http2"></a>Http2</h1><p>解决了上版本什么问题：</p><ol><li>HTTP队头阻塞(流)(多路复用)</li><li>头部过大的问题(头部压缩)</li></ol><p>特性：</p><ol><li>二进制分帧</li><li>头部压缩</li><li>多路复用</li><li>服务端推送</li><li>流</li></ol><h2 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h2><p>HTTP2传输的数据量减少，两个原因，一个是二进制分帧一个是头部压缩。</p><p>首先二进制分帧就是采用二进制的形式传输数据，比起1.x的时候采用的纯文本的形式，更容易解析。</p><p>详细的来讲，它将Headers+Body的报文形式拆分成一个个二进制的帧，用Headers帧存放头部字段，用Data帧存放请求体数据。</p><p>分帧带来的影响就是，服务器接收到的是一堆乱序的二进制帧，所以也就是不存在先后的问题，也就解决了HTTP队头阻塞的问题。（但是TCP队头阻塞还没有解决）</p><p>乱序的帧。指的是对于不同ID的流是乱序的，但是同一个ID的流还是顺序的。到达服务端后将顺序的ID组合成完整的报文。</p><p>有其他的字段可以实现优先级和流量控制</p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>废弃了1.x中的管道。同一个TCP连接里面客户端和服务端可以同时发送多个请求和多个响应，且不用按照顺序来。</p><h2 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h2><p>HPACK算法，在服务端和客户端之间建立哈希表，用到的字段存放在这张表里面，传输过程中已经出现过的字段就穿索引给对方即可。</p><p>对于整数和字符串进行哈夫曼编码，原理是将所有出现的字符建立一张索引表，让出现次数多的字符对于的索引尽可能短，传输的时候也是传输这样的索引序列，可以达到非常高的压缩效率。</p><h2 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h2><p>另外值得一说的是HTTP2的服务器推送Server Push。在HTTP2中，服务器已经不再是被动的接收请求，响应请求，他也能新建Stream来给客户端发送信息，当TCP连接建立之后，比如浏览器请求一个HTML文件，服务器就可以在返回HTML的基础上，将HTML中引用到的一些其他资源文件一起返回给客户端，减少客户端等待。</p><h1 id="2-0缺点"><a href="#2-0缺点" class="headerlink" title="2.0缺点"></a>2.0缺点</h1><p>2.0没有解决TCP队头阻塞问题，而TCP仍然是web的构建基础，当TCP传输的数据包在传输过程中丢失的时候，在服务端重新发送丢失的数据包之前，接收方无法确认传入的数据包。由于TCP在设计上不遵循HTTP之类的高级协议，因此单个丢失的数据包将阻塞所有正在进行的HTTP请求中的流，直到重新发送丢失的数据为止。这个问题在不可靠的连接上尤为突出。</p><p>多路复用导致服务器压力上升</p><p>多路复用没有限制同时请求数，请求的平均数量与往常相同，但实际上会有很多请求短暂爆发，造成瞬时QPS暴增</p><p>多路复用容易timeout<br>大批量的请求同时发送，由于HTTP2连接内存在多个并行的流，而网络请求和服务器资源有限，每个流的资源都会被稀释，虽然它们开始相差更短，但都可能超时</p><p>即使是使用NGINX这样的负载均衡器，想正确的进行节流也可能很棘手。 其次，就算你向应用程序引入或调整排队机制，但一次能处理的连接也是有限的。如果对请求进行排队，还要注意在响应超时后丢弃请求，以避免浪费不必要的资源。</p><h1 id="HTTP3-0"><a href="#HTTP3-0" class="headerlink" title="HTTP3.0"></a>HTTP3.0</h1><p>解决了上个版本的问题：</p><ol><li>TCP队头阻塞</li></ol><h2 id="面向UDP寻找新可能"><a href="#面向UDP寻找新可能" class="headerlink" title="面向UDP寻找新可能"></a>面向UDP寻找新可能</h2><p>HTTP2由于采用二进制分帧进行多路复用，通常只使用一个TCP连接进行传输，丢包或者网络中断的情况下后面所有的数据都会被阻塞。</p><p>HTTP/2 的问题不能仅靠应用程序层来解决，因此协议的新迭代必须更新传输层。但是，创建新的传输层协议并非易事。传输协议需要硬件供应商的支持，并且需要大多数网络运营商的部署才能普及。<br>幸运的是还有另一种选择。UDP 协议与 TCP 一样得到广泛支持，但前者足够简单，可以作为在其之上运行的自定义协议的基础。UDP 数据包是一劳永逸的：没有握手、持久连接或错误校正。HTTP3 背后的主要思想是放弃 TCP，转而使用基于 UDP 的 QUIC （快速UDP互联网连接）协议。</p><p>与 HTTP2 在技术上允许未加密的通信不同，QUIC 严格要求加密后才能建立连接。此外，加密不仅适用于 HTTP 负载，还适用于流经连接的所有数据，从而避免了一大堆安全问题。建立持久连接、协商加密协议，甚至发送第一批数据都被合并到 QUIC 中的单个请求/响应周期中，从而大大减少了连接等待时间。如果客户端具有本地缓存的密码参数，则可以通过简化的握手重新建立与已知主机的连接。<br>为了解决传输级别的线头阻塞问题，通过 QUIC 连接传输的数据被分为一些流。流是持久性 QUIC 连接中短暂、独立的“子连接”。每个流都处理自己的错误纠正和传递保证，但使用连接全局压缩和加密属性。每个客户端发起的 HTTP 请求都在单独的流上运行，因此丢失数据包不会影响其他流/请求的数据传输。</p><h2 id="实现了快速握手功能"><a href="#实现了快速握手功能" class="headerlink" title="实现了快速握手功能"></a>实现了快速握手功能</h2><p>由于QUIC是基于UDP的，所以QUIC可以实现使用0RTT或1RTT来建立连接，意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。</p><h2 id="集成了TLS加密功能"><a href="#集成了TLS加密功能" class="headerlink" title="集成了TLS加密功能"></a>集成了TLS加密功能</h2><p>目前QUIC使用的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。<br>在完全握手情况下，需要 1-RTT 建立连接。 TLS1.3 恢复会话可以直接发送加密后的应用数据，不需要额外的 TLS 握手，也就是 0-RTT。<br>但是 TLS1.3 也并不完美。TLS 1.3 的 0-RTT 无法保证前向安全性(Forward secrecy)。简单讲就是，如果当攻击者通过某种手段获取到了 Session Ticket Key，那么该攻击者可以解密以前的加密数据。<br>要缓解该问题可以通过设置使得与 Session Ticket Key 相关的 DH 静态参数在短时间内过期（一般几个小时）。</p><h2 id="多路复用，彻底解决TCP中队头阻塞的问题"><a href="#多路复用，彻底解决TCP中队头阻塞的问题" class="headerlink" title="多路复用，彻底解决TCP中队头阻塞的问题"></a>多路复用，彻底解决TCP中队头阻塞的问题</h2><p>和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e114f32c7404a4fab04b17910453111~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt=""></p><h2 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h2><p>TCP 是按照 4 要素（客户端 IP、端口, 服务器 IP、端口）确定一个连接的。而 QUIC 则是让客户端生成一个 Connection ID （64 位）来区别不同连接。只要 Connection ID 不变，连接就不需要重新建立，即便是客户端的网络发生变化。由于迁移客户端继续使用相同的会话密钥来加密和解密数据包，QUIC 还提供了迁移客户端的自动加密验证。</p><h1 id="Http0-9"><a href="#Http0-9" class="headerlink" title="Http0.9"></a>Http0.9</h1><p>1991年由W3C制定的标准，诞生之初是为了传输HTML，并且支持GET请求。</p><p>当时的请求报文只有一行，GET+请求的路径。服务器在收到请求之后会返回一个以ASCII编码的HTML文档。</p><p>缺点：</p><ol><li>没有描述数据的信息，1.0引入了headers</li><li>也只有一个命令</li><li>发送完就关闭TCP连接</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="网络系列" scheme="https://zlinni.github.io/categories/%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="计算机网络" scheme="https://zlinni.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP" scheme="https://zlinni.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Node.js结合express-jwt的实战教程</title>
    <link href="https://zlinni.github.io/posts/2906490375/"/>
    <id>https://zlinni.github.io/posts/2906490375/</id>
    <published>2022-05-15T08:42:29.000Z</published>
    <updated>2022-05-15T13:58:32.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>本文记录node使用express-jwt校验token以及前端发送token的全过程</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220515191529.png" alt=""></p><h1 id="什么是Token-什么是JWT"><a href="#什么是Token-什么是JWT" class="headerlink" title="什么是Token?什么是JWT?"></a>什么是Token?什么是JWT?</h1><p>Token产生原因:常规模式的session存放用户登录态导致服务器压力大,服务器多的时候,需要同步session,于是诞生了token,存到客户端,由服务端被动验证</p><p>缺点:</p><ol><li>被动验证,导致收回权限稍微困难.</li><li>每次请求都要携带,增加性能开销</li></ol><p>JWT: Json Web Token,一种token的验证方式,本质上是带有前面的json数据.</p><p>JWT由三部分组成:</p><ol><li>Header:描述JWT的元数据,定义了生成签名的算法以及Token的类型</li><li>Payload:用于存放实际需要传递的数据</li><li>Signature:签名,服务器通过Payload、Header和一个密钥(secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。</li></ol><h1 id="后端职责"><a href="#后端职责" class="headerlink" title="后端职责"></a>后端职责</h1><p>使用md5对密码进行加盐加密放入数据库,使用jwt在合适的时机发放token以及token的校验,模块化以及代码复用.</p><h1 id="后端项目目录"><a href="#后端项目目录" class="headerlink" title="后端项目目录"></a>后端项目目录</h1><div class="note primary flat"><p>vscode的project-tree插件生成</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">footok</span><br><span class="line">├─ app.js</span><br><span class="line">├─ db</span><br><span class="line">│  └─ dbConfig.js</span><br><span class="line">├─ package-lock.json</span><br><span class="line">├─ package.json</span><br><span class="line">├─ routes</span><br><span class="line">│  ├─ index.js //路由初始化+自定义状态异常</span><br><span class="line">│  ├─ tasks.js //任务模块</span><br><span class="line">│  └─ user.js //用户模块</span><br><span class="line">├─ services</span><br><span class="line">│  ├─ taskService.js //业务逻辑层 任务接口</span><br><span class="line">│  └─ userService.js //用户接口</span><br><span class="line">├─ utils</span><br><span class="line">│  ├─ constant.js //自定义常量</span><br><span class="line">│  ├─ index.js //封装连接mysql</span><br><span class="line">│  ├─ md5.js //md5</span><br><span class="line">│  └─ user-jwt.js //jwt验证和解析函数</span><br><span class="line">└─ views</span><br></pre></td></tr></table></figure><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm i --save express</span><br><span class="line">npm i --save body-parser</span><br><span class="line">npm i --save express-validator</span><br><span class="line">npm i --save cors</span><br><span class="line">npm i --save jsonwebtoken</span><br><span class="line">npm i --save express-jwt</span><br><span class="line">npm i --save mysql</span><br></pre></td></tr></table></figure><h1 id="db部分-数据库的配置"><a href="#db部分-数据库的配置" class="headerlink" title="db部分(数据库的配置)"></a>db部分(数据库的配置)</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>, <span class="comment">// 主机名称，一般是本机</span></span><br><span class="line">    <span class="attr">port</span>: <span class="string">&#x27;3306&#x27;</span>, <span class="comment">// 数据库的端口号，如果不设置，默认是3306</span></span><br><span class="line">    <span class="attr">user</span>: <span class="string">&#x27;yourname&#x27;</span>, <span class="comment">// 创建数据库时设置用户名</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;yourpassword&#x27;</span>, <span class="comment">// 创建数据库时设置的密码</span></span><br><span class="line">    <span class="attr">database</span>: <span class="string">&#x27;yourdatabase&#x27;</span>, <span class="comment">// 创建的数据库</span></span><br><span class="line">    <span class="attr">connectTimeout</span>: <span class="number">5000</span> <span class="comment">// 连接超时</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = mysql;</span><br></pre></td></tr></table></figure><h1 id="utils部分"><a href="#utils部分" class="headerlink" title="utils部分"></a>utils部分</h1><div class="note primary flat"><p>该部分负责md5.jwt和mysql的连接配置</p></div><h2 id="constant-js-定义固定参数"><a href="#constant-js-定义固定参数" class="headerlink" title="constant.js 定义固定参数"></a><code>constant.js</code> 定义固定参数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">CODE_ERROR</span>: -<span class="number">1</span>, <span class="comment">// 请求响应失败code码</span></span><br><span class="line">  <span class="attr">CODE_SUCCESS</span>: <span class="number">0</span>, <span class="comment">// 请求响应成功code码</span></span><br><span class="line">  <span class="attr">CODE_TOKEN_EXPIRED</span>: <span class="number">401</span>, <span class="comment">// 授权失败</span></span><br><span class="line">  <span class="attr">PRIVATE_KEY</span>: <span class="string">&#x27;yourKey&#x27;</span>, <span class="comment">// 自定义jwt加密的私钥</span></span><br><span class="line">  <span class="attr">JWT_EXPIRED</span>: <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>, <span class="comment">// 过期时间24小时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是定义参数的地方,还有些成功和失败的响应码可以和前端协商.</p><h2 id="user-jwt-js-定义jwt校验规则"><a href="#user-jwt-js-定义jwt校验规则" class="headerlink" title="user-jwt.js 定义jwt校验规则"></a><code>user-jwt.js</code> 定义jwt校验规则</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>); <span class="comment">// 引入验证jsonwebtoken模块</span></span><br><span class="line"><span class="keyword">const</span> expressJwt = <span class="built_in">require</span>(<span class="string">&#x27;express-jwt&#x27;</span>); <span class="comment">// 引入express-jwt模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; PRIVATE_KEY &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./constant&#x27;</span>); <span class="comment">// 引入自定义的jwt密钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证token是否过期</span></span><br><span class="line"><span class="keyword">const</span> jwtAuth = expressJwt(&#123;</span><br><span class="line">  <span class="comment">// 设置密钥</span></span><br><span class="line">  <span class="attr">secret</span>: PRIVATE_KEY,</span><br><span class="line">  <span class="comment">// 设置为true表示校验，false表示不校验</span></span><br><span class="line">  <span class="attr">credentialsRequired</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 加入算法 </span></span><br><span class="line">  <span class="attr">algorithms</span>:[<span class="string">&#x27;HS256&#x27;</span>],</span><br><span class="line">  <span class="comment">// 自定义获取token的函数</span></span><br><span class="line">  <span class="attr">getToken</span>: <span class="function">(<span class="params">req</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (req.headers.authorization &amp;&amp; req.headers.authorization.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>] === <span class="string">&#x27;Bearer&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> req.headers.authorization.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.query &amp;&amp; req.query.token) &#123;</span><br><span class="line">      <span class="keyword">return</span> req.query.token</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置jwt认证白名单，比如/login登录接口不需要拦截</span></span><br><span class="line">&#125;).unless(&#123;</span><br><span class="line">  <span class="attr">path</span>: [</span><br><span class="line">    <span class="string">&#x27;/register&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/login&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  jwtAuth,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里比较容易踩坑的地方是这个Bearer,这里分两种情况:</p><ol><li>前端请求发送token的时候,自己添加了Bearer,组成<code>Bearer token</code></li><li>后端响应发送token的时候,自己添加了Bearer,组成<code>Bearer token</code></li></ol><p>不管是上面哪一种签发,验证都需要去掉Bearer,用后面的东西进行校验.</p><p>这个unless也比较容易踩坑,一般来说,登陆和注册是不需要权限的,所以默认会有这两个.</p><h2 id="md5-js-定义md5"><a href="#md5-js-定义md5" class="headerlink" title="md5.js 定义md5"></a><code>md5.js</code> 定义md5</h2><p>这部分就不用多说了,常规操作<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>); <span class="comment">// 引入crypto加密模块</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">md5</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> crypto.createHash(<span class="string">&#x27;md5&#x27;</span>).update(<span class="string">&#x27;&#x27;</span> + s).digest(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = md5;</span><br></pre></td></tr></table></figure></p><h2 id="index-js-封装数据库的查询"><a href="#index-js-封装数据库的查询" class="headerlink" title="index.js 封装数据库的查询"></a>index.js 封装数据库的查询</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;../db/dbConfig&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接mysql</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; host, user, password, database &#125; = config;</span><br><span class="line">  <span class="keyword">return</span> mysql.createConnection(&#123;</span><br><span class="line">    host,</span><br><span class="line">    user,</span><br><span class="line">    password,</span><br><span class="line">    database</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建查询连接</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">querySql</span>(<span class="params">sql</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">const</span> conn = connect();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      conn.query(sql, <span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//释放连接</span></span><br><span class="line">      conn.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询一条语句</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryOne</span>(<span class="params">sql</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    querySql(sql).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;res===&#x27;</span>,res)</span><br><span class="line">      <span class="keyword">if</span> (res &amp;&amp; res.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        resolve(res[<span class="number">0</span>]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(<span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  querySql,</span><br><span class="line">  queryOne</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="services层"><a href="#services层" class="headerlink" title="services层"></a>services层</h1><p>对于很久没有使用node的小伙伴,这里提醒一下,node获取get请求的请求体使用的方法是<code>req.query.xxx</code>,获取post的请求体的方法是<code>req.body.xxx</code>(前提是装了body-parser),以及单条数据查询的时候,最好使用解构的方式,比如说对于下面的sql查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> count <span class="keyword">from</span> foodData <span class="keyword">where</span> tag <span class="operator">=</span> <span class="string">&#x27;炒&#x27;</span></span><br></pre></td></tr></table></figure></p><p>那么获取的时候,就应该是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;count&#125; = result[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></p><p>如果下面的代码测试不行,可以将代码写在app.js里面测试,因为很大程度上是你的路径没有写对.</p><h2 id="userService"><a href="#userService" class="headerlink" title="userService"></a>userService</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    querySql,</span><br><span class="line">    queryOne</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../utils/index&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> md5 = <span class="built_in">require</span>(<span class="string">&#x27;../utils/md5&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    CODE_ERROR,</span><br><span class="line">    CODE_SUCCESS,</span><br><span class="line">    PRIVATE_KEY,</span><br><span class="line">    JWT_EXPIRED</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../utils/constant&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">        username,</span><br><span class="line">        password</span><br><span class="line">    &#125; = req.body;</span><br><span class="line">    <span class="comment">// md5加盐加密</span></span><br><span class="line">    password = md5(md5(username + md5(password))) <span class="comment">//储存密码</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;psw&#x27;</span>, password);</span><br><span class="line">    <span class="keyword">const</span> query = <span class="string">`select * from userdata where username=&#x27;<span class="subst">$&#123;username&#125;</span>&#x27; and password=&#x27;<span class="subst">$&#123;password&#125;</span>&#x27;`</span>;</span><br><span class="line">    querySql(query)</span><br><span class="line">        .then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!user || user.length === <span class="number">0</span>) &#123;</span><br><span class="line">                res.json(&#123;</span><br><span class="line">                    <span class="attr">code</span>: CODE_ERROR,</span><br><span class="line">                    <span class="attr">msg</span>: <span class="string">&#x27;用户名或密码错误&#x27;</span>,</span><br><span class="line">                    <span class="attr">records</span>: <span class="literal">null</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 登录成功，签发一个token并返回给前端</span></span><br><span class="line">                <span class="keyword">const</span> tokenStr = jwt.sign(</span><br><span class="line">                    <span class="comment">// payload：签发的 token 里面要包含的一些数据。</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        username</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">// 私钥</span></span><br><span class="line">                    PRIVATE_KEY,</span><br><span class="line">                    <span class="comment">// 设置过期时间</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">expiresIn</span>: JWT_EXPIRED</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> userData = &#123;</span><br><span class="line">                    <span class="attr">id</span>: user[<span class="number">0</span>].id,</span><br><span class="line">                    <span class="attr">username</span>: user[<span class="number">0</span>].username,</span><br><span class="line">                    <span class="attr">nickname</span>: user[<span class="number">0</span>].nickname,</span><br><span class="line">                    <span class="attr">avator</span>: user[<span class="number">0</span>].avator,</span><br><span class="line">                    <span class="attr">sex</span>: user[<span class="number">0</span>].sex,</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                res.json(&#123;</span><br><span class="line">                    <span class="attr">code</span>: CODE_SUCCESS,</span><br><span class="line">                    <span class="attr">msg</span>: <span class="string">&#x27;登录成功&#x27;</span>,</span><br><span class="line">                    <span class="attr">records</span>: &#123;</span><br><span class="line">                        <span class="attr">token</span>: <span class="string">&#x27;Bearer &#x27;</span> + tokenStr,</span><br><span class="line">                        userData</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">        username,</span><br><span class="line">        password</span><br><span class="line">    &#125; = req.body;</span><br><span class="line">    findUser(username)</span><br><span class="line">        .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data) &#123;</span><br><span class="line">                res.json(&#123;</span><br><span class="line">                    <span class="attr">code</span>: CODE_ERROR,</span><br><span class="line">                    <span class="attr">msg</span>: <span class="string">&#x27;用户已存在&#x27;</span>,</span><br><span class="line">                    <span class="attr">records</span>: <span class="literal">null</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// md5加盐加密</span></span><br><span class="line">                password = md5(md5(username + md5(password)));</span><br><span class="line">                <span class="keyword">const</span> query = <span class="string">`insert into userdata(username, password) values(&#x27;<span class="subst">$&#123;username&#125;</span>&#x27;, &#x27;<span class="subst">$&#123;password&#125;</span>&#x27;)`</span>;</span><br><span class="line">                querySql(query)</span><br><span class="line">                    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!result || result.length === <span class="number">0</span>) &#123;</span><br><span class="line">                            res.json(&#123;</span><br><span class="line">                                <span class="attr">code</span>: CODE_ERROR,</span><br><span class="line">                                <span class="attr">msg</span>: <span class="string">&#x27;注册失败&#x27;</span>,</span><br><span class="line">                                <span class="attr">records</span>: <span class="literal">null</span></span><br><span class="line">                            &#125;)</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> queryUser = <span class="string">`select * from userdata where username=&#x27;<span class="subst">$&#123;username&#125;</span>&#x27; and password=&#x27;<span class="subst">$&#123;password&#125;</span>&#x27;`</span>;</span><br><span class="line">                            querySql(queryUser)</span><br><span class="line">                                .then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">                                    <span class="keyword">const</span> tokenStr = jwt.sign(&#123;</span><br><span class="line">                                            username</span><br><span class="line">                                        &#125;,</span><br><span class="line">                                        PRIVATE_KEY, &#123;</span><br><span class="line">                                            <span class="attr">expiresIn</span>: JWT_EXPIRED</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    )</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">let</span> userData = &#123;</span><br><span class="line">                                        <span class="attr">id</span>: user[<span class="number">0</span>].id,</span><br><span class="line">                                        <span class="attr">username</span>: user[<span class="number">0</span>].username,</span><br><span class="line">                                        <span class="attr">nickname</span>: user[<span class="number">0</span>].nickname,</span><br><span class="line">                                        <span class="attr">avator</span>: user[<span class="number">0</span>].avator,</span><br><span class="line">                                        <span class="attr">sex</span>: user[<span class="number">0</span>].sex,</span><br><span class="line">                                    &#125;;</span><br><span class="line"></span><br><span class="line">                                    res.json(&#123;</span><br><span class="line">                                        <span class="attr">code</span>: CODE_SUCCESS,</span><br><span class="line">                                        <span class="attr">msg</span>: <span class="string">&#x27;注册成功&#x27;</span>,</span><br><span class="line">                                        <span class="attr">records</span>: &#123;</span><br><span class="line">                                            <span class="attr">token</span>: <span class="string">&#x27;Bearer &#x27;</span> + tokenStr,</span><br><span class="line">                                            userData</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;)</span><br><span class="line">                                &#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过用户名查询用户信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findUser</span>(<span class="params">username</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> query = <span class="string">`select id, username from userdata where username=&#x27;<span class="subst">$&#123;username&#125;</span>&#x27;`</span>;</span><br><span class="line">    <span class="keyword">return</span> queryOne(query);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    login,</span><br><span class="line">    register,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>md5的加盐可以自己定义,比如一个<code>secret key</code>或者是什么别的常量,层级也可以相应深一点</p><p>这里的token我选择了在后端加上Bearer返回给前端</p><h1 id="routes层"><a href="#routes层" class="headerlink" title="routes层"></a>routes层</h1><h2 id="users"><a href="#users" class="headerlink" title="users"></a>users</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../services/userService&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户登录路由</span></span><br><span class="line">router.post(<span class="string">&#x27;/login&#x27;</span>,service.login);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户注册路由</span></span><br><span class="line">router.post(<span class="string">&#x27;/register&#x27;</span>,service.register);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure><h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&#x27;./user.js&#x27;</span>); <span class="comment">// 引入user路由模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; jwtAuth,decode &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../utils/user-jwt&#x27;</span>); <span class="comment">// 引入jwt认证函数</span></span><br><span class="line"><span class="keyword">const</span> router = express.Router(); <span class="comment">// 注册路由 </span></span><br><span class="line"></span><br><span class="line">router.use(jwtAuth); <span class="comment">// 注入认证模块</span></span><br><span class="line"></span><br><span class="line">router.use(<span class="string">&#x27;/&#x27;</span>, userRouter); <span class="comment">// 注入用户路由模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义统一异常处理中间件，需要放在代码最后</span></span><br><span class="line">router.use(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 自定义用户认证失败的错误返回</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;err===&#x27;</span>, err);</span><br><span class="line">  <span class="keyword">if</span> (err &amp;&amp; err.name === <span class="string">&#x27;UnauthorizedError&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; status = <span class="number">401</span>, message &#125; = err;</span><br><span class="line">    <span class="comment">// 抛出401异常</span></span><br><span class="line">    res.status(status).json(&#123;</span><br><span class="line">      <span class="attr">code</span>: status,</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&#x27;token失效，请重新登录&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: <span class="literal">null</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; output &#125; = err || &#123;&#125;;</span><br><span class="line">    <span class="comment">// 错误码和错误信息</span></span><br><span class="line">    <span class="keyword">const</span> errCode = (output &amp;&amp; output.statusCode) || <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">const</span> errMsg = (output &amp;&amp; output.payload &amp;&amp; output.payload.error) || err.message;</span><br><span class="line">    res.status(errCode).json(&#123;</span><br><span class="line">      <span class="attr">code</span>: errCode,</span><br><span class="line">      <span class="attr">msg</span>: errMsg</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里有一点比较重要,如果没有分类的话,那么这里的<code>router.use(&#39;/&#39;, userRouter);</code>路径直接写斜杠即可</p><h1 id="app层"><a href="#app层" class="headerlink" title="app层"></a>app层</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>); <span class="comment">// 引入body-parser模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>); <span class="comment">// 引入express模块</span></span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>); <span class="comment">// 引入cors模块</span></span><br><span class="line"><span class="keyword">const</span> routes = <span class="built_in">require</span>(<span class="string">&#x27;./routes/index&#x27;</span>); <span class="comment">//导入自定义路由文件，创建模块化路由</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.json()); <span class="comment">// 解析json数据格式</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>: <span class="literal">true</span>&#125;)); <span class="comment">// 解析form表单提交的数据application/x-www-form-urlencoded</span></span><br><span class="line"></span><br><span class="line">app.use(cors()); <span class="comment">// 注入cors模块解决跨域</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/&#x27;</span>, routes);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8081</span>, <span class="function">() =&gt;</span> &#123; <span class="comment">// 监听8081端口</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;服务已启动 http://localhost:8081&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>依然是路径需要注意</p><p>至此后端的部分就已经写完了,接下来是前端的部分</p><h1 id="前端职责"><a href="#前端职责" class="headerlink" title="前端职责"></a>前端职责</h1><p>前端负责登陆和注册的页面编写,请求的编写,axios的封装</p><h1 id="前端目录"><a href="#前端目录" class="headerlink" title="前端目录"></a>前端目录</h1><p>这里比较多,简单说一下几个模块<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- components</span><br><span class="line">    - userLogin.vue //登陆模块</span><br><span class="line">    - userRegister.vue //注册模块</span><br><span class="line">- api</span><br><span class="line">    - apiInfo.js //接口信息</span><br><span class="line">    - axios.js /封装axios</span><br><span class="line">- vite.config.js //vite配置</span><br></pre></td></tr></table></figure></p><h1 id="vite配置"><a href="#vite配置" class="headerlink" title="vite配置"></a>vite配置</h1><p>这一部分主要是解决跨域的问题,然后起别名方便后续的代码路径编写<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    defineConfig</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; resolve &#125; <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pathResolve</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> resolve(__dirname, <span class="string">&quot;.&quot;</span>, dir)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">    <span class="attr">plugins</span>: [vue()],</span><br><span class="line">    <span class="attr">resolve</span>:&#123;</span><br><span class="line">        <span class="attr">alias</span>:&#123;</span><br><span class="line">            <span class="string">&quot;@&quot;</span>:pathResolve(<span class="string">&quot;src/&quot;</span>),</span><br><span class="line">            <span class="string">&quot;assets&quot;</span>:pathResolve(<span class="string">&quot;src/assets&quot;</span>),</span><br><span class="line">            <span class="string">&quot;common&quot;</span>:pathResolve(<span class="string">&quot;src/components/common&quot;</span>),</span><br><span class="line">            <span class="string">&quot;userLogin&quot;</span>:pathResolve(<span class="string">&quot;src/components/userLogin&quot;</span>),</span><br><span class="line">            <span class="string">&quot;swiper&quot;</span>:pathResolve(<span class="string">&quot;src/components/swiper&quot;</span>),</span><br><span class="line">            <span class="string">&quot;share&quot;</span>:pathResolve(<span class="string">&quot;src/components/share&quot;</span>),</span><br><span class="line">            <span class="string">&quot;category&quot;</span>:pathResolve(<span class="string">&quot;src/components/category&quot;</span>),</span><br><span class="line">            <span class="string">&quot;map&quot;</span>:pathResolve(<span class="string">&quot;src/components/map&quot;</span>),</span><br><span class="line">            <span class="string">&quot;person&quot;</span>:pathResolve(<span class="string">&quot;src/components/person&quot;</span>),</span><br><span class="line">            <span class="string">&quot;store&quot;</span>:pathResolve(<span class="string">&quot;src/stores&quot;</span>),</span><br><span class="line">            <span class="string">&quot;plugins&quot;</span>:pathResolve(<span class="string">&quot;src/plugins&quot;</span>),</span><br><span class="line">            <span class="string">&quot;myApi&quot;</span>:pathResolve(<span class="string">&quot;src/api&quot;</span>),</span><br><span class="line">            <span class="string">&quot;utils&quot;</span>:pathResolve(<span class="string">&quot;src/utils&quot;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">extensions</span>:[<span class="string">&#x27;.js&#x27;</span>,<span class="string">&#x27;.json&#x27;</span>,<span class="string">&#x27;.ts&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">base</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">    <span class="attr">build</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;modules&#x27;</span>,</span><br><span class="line">        <span class="attr">outDir</span>: <span class="string">&#x27;dist&#x27;</span>, <span class="comment">//指定输出路径</span></span><br><span class="line">        <span class="attr">assetsDir</span>: <span class="string">&#x27;assets&#x27;</span>, <span class="comment">// 指定生成静态资源的存放路径</span></span><br><span class="line">        <span class="attr">minify</span>: <span class="string">&#x27;terser&#x27;</span> <span class="comment">// 混淆器，terser构建后文件体积更小</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">server</span>: &#123;</span><br><span class="line">        <span class="attr">cors</span>: <span class="literal">true</span>, <span class="comment">// 默认启用并允许任何源</span></span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">// 在服务器启动时自动在浏览器中打开应用程序</span></span><br><span class="line">        <span class="comment">//反向代理配置，注意rewrite写法，开始没看文档在这里踩了坑</span></span><br><span class="line">        <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">        <span class="attr">https</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&#x27;http://localhost:8081&#x27;</span>,</span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">rewrite</span>: <span class="function">(<span class="params">path</span>) =&gt;</span> path.replace(<span class="regexp">/^\/api/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&#x27;/ipApi&#x27;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&#x27;http://pv.sohu.com&#x27;</span>,</span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">rewrite</span>: <span class="function">(<span class="params">path</span>) =&gt;</span> path.replace(<span class="regexp">/^\/ipApi/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="axios的封装"><a href="#axios的封装" class="headerlink" title="axios的封装"></a>axios的封装</h1><p>先讲一下axios的封装,这个对于后续的token发送特别重要,如果你已经会设置拦截器,这一部分可以跳过</p><p>目的:通过请求拦截器,对需要权限的接口自动携带token验证.</p><p>分为以下几个part:</p><ol><li>基础配置</li><li>取消重复请求</li><li>自动携带token</li></ol><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>就是配置统一的url和超时配置<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAxios</span>(<span class="params">axiosConfig</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> service = axios.create(&#123;</span><br><span class="line">        <span class="attr">baseURL</span>:<span class="string">&#x27;http://localhost:3000&#x27;</span>,<span class="comment">//设置统一url</span></span><br><span class="line">        <span class="attr">timeout</span>:<span class="number">10000</span> <span class="comment">//十秒超时</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myAxios;</span><br></pre></td></tr></table></figure></p><h2 id="取消重复请求"><a href="#取消重复请求" class="headerlink" title="取消重复请求"></a>取消重复请求</h2><p>这个部分不是本文的重点,可以适当跳过</p><h2 id="自动携带token"><a href="#自动携带token" class="headerlink" title="自动携带token"></a>自动携带token</h2><p>为了照顾ssr,这里要做一次判断然后再获取,发送token我们采取的方案是后端设置Bearer,所以这里前端直接发送即可.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">service.interceptors.request.use(</span><br><span class="line">       <span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">           removePending(config);</span><br><span class="line">           <span class="comment">// 自动携带token</span></span><br><span class="line">           <span class="keyword">if</span>(getTokenAuth()&amp;&amp;<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span>)&#123;</span><br><span class="line">               config.headers.Authorization = getTokenAuth();</span><br><span class="line">           &#125;</span><br><span class="line">           options.repeat_request_cancel&amp;&amp;addPending(config);</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">&#x27;config&#x27;</span>,config)</span><br><span class="line">           <span class="keyword">return</span> config;</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">       &#125;</span><br><span class="line">   )</span><br></pre></td></tr></table></figure></p><p>完整代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;getTokenAuth&#125; <span class="keyword">from</span> <span class="string">&#x27;utils/auth&#x27;</span>;</span><br><span class="line"><span class="comment">// 拦截器</span></span><br><span class="line"><span class="comment">// customOption:boolean 是否开启取消重复请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAxios</span>(<span class="params">axiosConfig,customOption</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> service = axios.create(&#123;</span><br><span class="line">        <span class="attr">baseURL</span>:<span class="string">&#x27;http://localhost:3000&#x27;</span>,<span class="comment">//设置统一url</span></span><br><span class="line">        <span class="attr">timeout</span>:<span class="number">10000</span> <span class="comment">//十秒超时</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> options = <span class="built_in">Object</span>.assign(&#123;<span class="attr">repeat_request_cancel</span>:<span class="literal">false</span>&#125;,customOption);</span><br><span class="line">    service.interceptors.request.use(</span><br><span class="line">        <span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">            removePending(config);</span><br><span class="line">            <span class="comment">// 自动携带token</span></span><br><span class="line">            <span class="keyword">if</span>(getTokenAuth()&amp;&amp;<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span>)&#123;</span><br><span class="line">                config.headers.Authorization = getTokenAuth();</span><br><span class="line">            &#125;</span><br><span class="line">            options.repeat_request_cancel&amp;&amp;addPending(config);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;config&#x27;</span>,config)</span><br><span class="line">            <span class="keyword">return</span> config;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    service.interceptors.response.use(</span><br><span class="line">        <span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">            removePending(response);</span><br><span class="line">            <span class="keyword">return</span> response</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">            error.config&amp;&amp;removePending(error.config);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> service(axiosConfig);<span class="comment">//返回的是一个promsie对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取消重复请求</span></span><br><span class="line"><span class="comment">// 判断重复请求并存入队列</span></span><br><span class="line"><span class="keyword">const</span> pendingMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成每个请求唯一的键</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPendingKey</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;url,method,params,data&#125; = config;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> data === <span class="string">&#x27;string&#x27;</span>)data=<span class="built_in">JSON</span>.parse(data)<span class="comment">//响应回来的config data是一个字符串</span></span><br><span class="line">    <span class="keyword">return</span> [url,method,<span class="built_in">JSON</span>.stringify(params),<span class="built_in">JSON</span>.stringify(data)].join(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储每个请求的值，也就是cancel方法，用于取消请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addPending</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> pendingKey = getPendingKey(config);</span><br><span class="line">    config.cancelToken = config.cancelToken || <span class="keyword">new</span> axios.CancelToken(<span class="function">(<span class="params">cancel</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pendingMap.has(pendingKey))&#123;</span><br><span class="line">            pendingMap.set(pendingKey,cancel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除重复的请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removePending</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> pendingKey = getPendingKey(config);</span><br><span class="line">    <span class="keyword">if</span>(pendingMap.has(pendingKey))&#123;</span><br><span class="line">        <span class="keyword">const</span> cancelToken = pendingMap.get(pendingKey);</span><br><span class="line">        cancelToken(pendingKey);</span><br><span class="line">        pendingMap.delete(pendingKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myAxios;</span><br></pre></td></tr></table></figure></p><h1 id="接口信息"><a href="#接口信息" class="headerlink" title="接口信息"></a>接口信息</h1><p>这一部分是为了方便后期接口的管理而写<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> myAxios <span class="keyword">from</span> <span class="string">&#x27;./axios&#x27;</span>;</span><br><span class="line"><span class="comment">// 用户登陆</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">userLoginAPI</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> myAxios(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/api/login&#x27;</span>,</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        data</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用户注册</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">userRegisterAPI</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> myAxios(&#123;</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&#x27;/api/register&#x27;</span>,</span><br><span class="line">        <span class="attr">method</span>:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        data</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="登陆模块逻辑"><a href="#登陆模块逻辑" class="headerlink" title="登陆模块逻辑"></a>登陆模块逻辑</h1><p>页面的代码就不放了,大致的请求逻辑如下<br>将数据发送到后端,得到成功的响应后将token放置在前端的localStorage中,或者cookie中.这里选择了localStorage</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;userLoginAPI&#125; <span class="keyword">from</span> <span class="string">&quot;myApi/apiInfo&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> rawData = toRaw(userData);</span><br><span class="line">userLoginAPI(rawData)</span><br><span class="line">  .then(</span><br><span class="line">    <span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">      data: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        code,</span></span></span><br><span class="line"><span class="params"><span class="function">        msg,</span></span></span><br><span class="line"><span class="params"><span class="function">        records: &#123; token, userData &#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">      &#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (code === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">localStorage</span>.setItem(<span class="string">&quot;token&quot;</span>,token);<span class="comment">//将token存放到</span></span><br><span class="line">        router.push(&#123; <span class="attr">name</span>: <span class="string">&quot;index&quot;</span> &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        loginTips.passwordTips = <span class="string">&quot;&quot;</span>;<span class="comment">//清空密码提示</span></span><br><span class="line">        loginTips.userNameTips = msg;<span class="comment">//回显错误内容</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    loginTips.passwordTips = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    loginTips.userNameTips = <span class="string">&quot;该用户不存在&quot;</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h1 id="注册模块逻辑"><a href="#注册模块逻辑" class="headerlink" title="注册模块逻辑"></a>注册模块逻辑</h1><p>页面的代码就不放了,注册的逻辑大概如下</p><ol><li>做密码的校验,比如限制长度,大小写等.</li><li>发送用户信息,成功后设置token到本地,跳转到主页</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;userRegisterAPI&#125; <span class="keyword">from</span> <span class="string">&#x27;myApi/apiInfo&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> userRegister = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    isSuccess.userNameSuccess &amp;&amp;</span><br><span class="line">    isSuccess.passWordSuccess &amp;&amp;</span><br><span class="line">    isSuccess.commitpswSuccess</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> rawData = toRaw(userData);</span><br><span class="line">    userRegisterAPI(rawData)</span><br><span class="line">      .then(<span class="function">(<span class="params">&#123; data: &#123; code, msg,records &#125; &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (code === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">let</span> &#123;token,userData&#125; = records;</span><br><span class="line">          <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;token&#x27;</span>,token);</span><br><span class="line">          router.push(&#123; <span class="attr">name</span>: <span class="string">&quot;index&quot;</span> &#125;);</span><br><span class="line">          </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resgisterTips.userNameTips = <span class="string">&quot;用户名已存在&quot;</span>;</span><br><span class="line">          isSuccess.userNameSuccess = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        resgisterTips.userNameTips = <span class="string">&quot;用户名已存在&quot;</span>;</span><br><span class="line">        isSuccess.userNameSuccess = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="keyword">if</span> (!userData.username) &#123;</span><br><span class="line">      resgisterTips.userNameTips = <span class="string">&quot;用户名不能为空&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!userData.password) &#123;</span><br><span class="line">      resgisterTips.passwordTips = <span class="string">&quot;密码不能为空&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TOKEN_KEY = <span class="string">&#x27;token&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getTokenAuth</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">localStorage</span>.getItem(TOKEN_KEY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次对jwt和md5加密的登陆注册进行了一次编写,还有一些没有了解到的,比如以下问题:</p><ol><li>吊销token(了解到是express-jwt里面的isRevoked)</li><li>是否需要每次访问有权限的接口都携带token(需要,因为只有这样才能判断)</li><li>token的续签</li></ol><p>关联知识点:<br>web网络安全XSS,CSRF<br>token,cookie,session</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="nodejs" scheme="https://zlinni.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>代码之美JS篇</title>
    <link href="https://zlinni.github.io/posts/811989321/"/>
    <id>https://zlinni.github.io/posts/811989321/</id>
    <published>2022-05-08T11:40:08.000Z</published>
    <updated>2022-05-09T01:31:58.168Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>本篇文章讲述如何编写高效美丽的JavaScript代码，让你在开发中有更多的选择而不是停留在基础编码环节。</p></div><h1 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h1><div class="note primary flat"><p>纯函数指的是在给定相同输入的情况下始终返回相同输出的函数。除了他提供的输入以外，他不依赖于任何外部变量，也不更改任何外部变量。拥有纯函数使得测试更加容易，因为可以随时模拟并测试输入的值,如下：</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plusAbc</span>(<span class="params">a, b, c</span>) </span>&#123;  <span class="comment">// 这个函数的输出将变化无常，因为api返回的值一旦改变，同样输入函数的a，b,c的值，但函数返回的结果却不一定相同。</span></span><br><span class="line">  <span class="keyword">var</span> c = fetch(<span class="string">&#x27;../api&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上面的代码看起来很合理，但是该函数本身依赖一个外部变量，所以如果这个变量他被修改，就会有不同的输出，在我们排查错误的时候就比较不方便。如果写了纯函数，确保他没有引入和修改外部的变量，那么就能降低错误的发生。下面是经过改造后的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plusAbc</span>(<span class="params">a, b, c</span>) </span>&#123;  <span class="comment">// 同样输入函数的a，b,c的值，但函数返回的结果永远相同。</span></span><br><span class="line">  <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参数传递与解析"><a href="#参数传递与解析" class="headerlink" title="参数传递与解析"></a>参数传递与解析</h1><p>使用函数的时候，如果我们需要大量的传入参数，那么这会在调用的时候变成一件非常可怕的事情<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createButton = <span class="function">(<span class="params">title, color, disabled, padding, margin, border, shadow</span>)  =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(title, color, disabled, padding, margin, border, shadow)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">createButton(<span class="string">&#x27;Sudongyu er&#x27;</span>, <span class="literal">undefined</span> <span class="comment">/* optional color */</span>, <span class="literal">true</span> ,<span class="string">&#x27;2px....&#x27;</span>, <span class="literal">undefined</span>  <span class="comment">/* optional margin*/</span>);</span><br></pre></td></tr></table></figure></p><p>使用对象的形式来传入数据也许会变得更容易观看<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createButton = <span class="function">(<span class="params">&#123;title, color, disabled, padding, margin, border, shadow&#125;</span>)  =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(title, color, disabled, padding, margin, border, shadow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createButton(&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Sudongyu er&#x27;</span>,</span><br><span class="line">  <span class="attr">disabled</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">shadow</span>: <span class="string">&#x27;2px....&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>不知道大家有没有在用异步请求的时候，写过下面的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;/api/xxx&#x27;</span>,<span class="attr">params</span>:&#123;</span><br><span class="line">    mydata</span><br><span class="line">&#125;,<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = res.data;</span><br><span class="line">    <span class="keyword">if</span>(res.code === <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="comment">//doSomething</span></span><br><span class="line">        res.data.records...    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>使用数据解构的方式让代码更加清晰<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;/api/xxx&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">        mydata</span><br><span class="line">&#125;,<span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    data:&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        code,</span></span></span><br><span class="line"><span class="params"><span class="function">        msg,</span></span></span><br><span class="line"><span class="params"><span class="function">        foodData:&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            records</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(code === <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="comment">//doSomething...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h1 id="对象数组解构"><a href="#对象数组解构" class="headerlink" title="对象数组解构"></a>对象数组解构</h1><p>也许大家都知道这样的解构<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Sudongyu&#x27;</span>,</span><br><span class="line">  <span class="attr">email</span>: <span class="string">&#x27;hi@xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">designation</span>: <span class="string">&#x27;Software Architect&#x27;</span>,</span><br><span class="line">  <span class="attr">loves</span>: <span class="string">&#x27;The Code&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;name, email, loves&#125; = user;</span><br></pre></td></tr></table></figure></p><p>另外一个例子，能显示很多问题<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getDetails = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;sudongyu&#x27;</span>, <span class="string">&#x27;Some Street&#x27;</span>, <span class="string">&#x27;Some City&#x27;</span>, <span class="string">&#x27;Some Zip&#x27;</span>, <span class="string">&#x27;Some Country&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> details = getDetails();</span><br><span class="line"><span class="keyword">const</span> uName = details[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> uEmail = details[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> uAddress = <span class="string">`<span class="subst">$&#123;details[<span class="number">2</span>]&#125;</span>, <span class="subst">$&#123;details[<span class="number">3</span>]&#125;</span>, <span class="subst">$&#123;details[<span class="number">4</span>]&#125;</span>, <span class="subst">$&#123;details[<span class="number">5</span>]&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">const</span> uFirstName = uName.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> uLastName = uName.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>非常的恶心，下面来看解构代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getDetails = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;sudongyu&#x27;</span>, <span class="string">&#x27;Some Street&#x27;</span>, <span class="string">&#x27;Some City&#x27;</span>, <span class="string">&#x27;Some Zip&#x27;</span>, <span class="string">&#x27;Some Country&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [uName, uEmail, ...uAddressArr] = getDetails();</span><br><span class="line"><span class="keyword">const</span> uAddress = uAddressArr.join(<span class="string">&#x27;, &#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> [uFirstName, uLastName] = uName.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(&#123;</span><br><span class="line">  uFirstName,</span><br><span class="line">  uLastName,</span><br><span class="line">  uEmail,</span><br><span class="line">  uAddress</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>我们可以通过上面的代码了解到对于一条数据的解构时机</p><ol><li>需要直接获取就能使用的数据，直接解构</li><li>需要获取之后通过相同功能加工的数据，用剩余参数解构出来加工</li><li>split之后的数据，建议直接用数组解构</li></ol><p>总之就是减少数组下标的访问</p><h1 id="避免硬编码"><a href="#避免硬编码" class="headerlink" title="避免硬编码"></a>避免硬编码</h1><p>看例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, <span class="number">86400000</span>);</span><br><span class="line"><span class="comment">// WHAT IS THIS 86400000 ??? 🤔</span></span><br></pre></td></tr></table></figure></p><p>看代码的人可能不知道这个数字代表什么以及他是如何计算的，以及他背后的业务逻辑是什么，我们可以创建一个常量来代替它。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DAY_IN_MILLISECONDS = <span class="number">3600</span> * <span class="number">24</span> * <span class="number">1000</span>; <span class="comment">// 86400000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, DAY_IN_MILLISECONDS);</span><br><span class="line"><span class="comment">// now this makes sense</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>看另外一个例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createUser = <span class="function">(<span class="params">name, designation, type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(&#123;name, designation, type&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createUser(<span class="string">&#x27;SudongYu&#x27;</span>, <span class="string">&#x27;Software Architect&#x27;</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="comment">// WHAT IS this &#x27;1&#x27;? 🤔</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>这里这个1很难让人理解代表的含义是什么，即type这是什么用户。因此，我们可以创建一个我们拥有的用户类型的对象映射，而不是在这里对值进行硬编码’1’，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> USER_TYPES = &#123;</span><br><span class="line">  <span class="attr">REGULAR_EMPLOYEE</span>: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createUser = <span class="function">(<span class="params">name, designation, type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(&#123;name, designation, type&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createUser(<span class="string">&#x27;Sudongyu&#x27;</span>, <span class="string">&#x27;Software Architect&#x27;</span>, USER_TYPES.REGULAR_EMPLOYEE);</span><br><span class="line"><span class="comment">// smoooooooth 😎</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="避免使用简写变量名"><a href="#避免使用简写变量名" class="headerlink" title="避免使用简写变量名"></a>避免使用简写变量名</h1><p>速记变量在需要它们的地方才有意义。就像如果你有像xand这样的位置坐标y，那是可行的。p但是，如果我们在没有上下文的情况下创建像,t之类的变量c，那么真的很难阅读、跟踪和维护这样的代码。例如看这个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> t = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> users = [<span class="string">&#x27;Sudongyuer&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>];</span><br><span class="line"></span><br><span class="line">users = users.map(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...user,</span><br><span class="line">    <span class="attr">tax</span>: user.salary * t / <span class="number">100</span> <span class="comment">// WHAT IS `t` again? 🤔</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>上面的例子表明，现在开发人员/读者必须一直向上滚动或转到定义来尝试理解这个变量是什么。因此是不干净的代码😠。这也称为对变量进行思维导图，其中只有作者知道它们的含义。因此，我们可以给它一个适当的名称，而不是简写变量名称，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> taxFactor = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> users = [<span class="string">&#x27;Sudongyuer&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>];</span><br><span class="line"></span><br><span class="line">users = users.map(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...user,</span><br><span class="line">    <span class="attr">tax</span>: user.salary * taxFactor / <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="设置默认对象值"><a href="#设置默认对象值" class="headerlink" title="设置默认对象值"></a>设置默认对象值</h1><p>在某些情况下，你可能希望你的对象能够提供一些默认值，如果没有就使用传入的值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createButton = <span class="function">(<span class="params">&#123;title, color, disabled, padding&#125;</span>)  =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> button = &#123;&#125;;</span><br><span class="line">  button.color = color || <span class="string">&#x27;#333&#x27;</span>;</span><br><span class="line">  button.disabled = disabled || <span class="literal">false</span>;</span><br><span class="line">  button.title = title || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  button.padding = padding || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> button;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buttonConfig = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Click me!&#x27;</span>,</span><br><span class="line">  <span class="attr">disabled</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newButton = createButton(buttonConfig);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;newButton&#x27;</span>, newButton)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>修改后<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createButton = <span class="function">(<span class="params">config</span>)  =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...&#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&#x27;#dcdcdc&#x27;</span>,</span><br><span class="line">      <span class="attr">disabled</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">padding</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...config </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buttonConfig = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Click me!&#x27;</span>,</span><br><span class="line">  <span class="attr">disabled</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newButton = createButton(buttonConfig);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;newButton&#x27;</span>, newButton)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="使用方法链"><a href="#使用方法链" class="headerlink" title="使用方法链"></a>使用方法链</h1><p>如果我们知道类/对象的用户将一起使用多个函数，则方法链接是一种很有用的技术。您可能已经在诸如 moment.js 之类的库中看到了这一点。让我们看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name, score, position</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.position = position;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setName</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setPosition</span>(<span class="params">position</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.position = position;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setScore</span>(<span class="params">score</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> player = <span class="keyword">new</span> Player();</span><br><span class="line">player.setScore(<span class="number">0</span>);</span><br><span class="line">player.setName(<span class="string">&#x27;Sudongyuer&#x27;</span>);</span><br><span class="line">player..setPosition([<span class="number">2</span>, <span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(player)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>你可以看到我们需要为这个实例调用一系列的函数，这看起来有点不太美观，修改后的代码如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name, score, position</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.position = position;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setName</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// &lt;-- THIS</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setPosition</span>(<span class="params">position</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.position = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// &lt;-- THIS</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setScore</span>(<span class="params">score</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// &lt;-- THIS</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> player = <span class="keyword">new</span> Player();</span><br><span class="line">player.setScore(<span class="number">0</span>).setName(<span class="string">&#x27;Sudongyuer&#x27;</span>).setPosition([<span class="number">2</span>, <span class="number">0</span>]);</span><br><span class="line"><span class="comment">// SUPER COOL 😎</span></span><br><span class="line"><span class="built_in">console</span>.log(player)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>该方法的核心是每个方法都返回this对象，让他能够链式调用</p><h1 id="在回调上使用Promise"><a href="#在回调上使用Promise" class="headerlink" title="在回调上使用Promise"></a>在回调上使用Promise</h1><p>回调地狱.jpg<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220508202356.png" alt=""></p><p>看例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> getSocials = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      callback(&#123;<span class="attr">socials</span>: &#123;<span class="attr">youtube</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="attr">twitter</span>: <span class="string">&#x27;xxx&#x27;</span>&#125;&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getBooks = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    callback(&#123;<span class="attr">books</span>: [<span class="string">&#x27;React Cookbook&#x27;</span>]&#125;);</span><br><span class="line">  &#125;, <span class="number">1500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getDesignation = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    callback(&#123;<span class="attr">designation</span>: <span class="string">&#x27;Software Architect&#x27;</span>&#125;);</span><br><span class="line">  &#125;, <span class="number">1500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    callback(&#123;<span class="attr">user</span>: <span class="string">&#x27;Sudongyuer&#x27;</span>&#125;);</span><br><span class="line">  &#125;, <span class="number">1500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> getUser(<span class="function">(<span class="params">&#123;user&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;user retrieved&#x27;</span>, user)</span><br><span class="line">    getDesignation(<span class="function">(<span class="params">&#123;designation&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;designation retrieved&#x27;</span>, designation)</span><br><span class="line">      getBooks(<span class="function">(<span class="params">&#123;books&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;books retrieved&#x27;</span>, books)</span><br><span class="line">        getSocials(<span class="function">(<span class="params">&#123;socials&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;socials retrieved&#x27;</span>, socials)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>这代码看起来非常不顺眼，如果有大量的异步任务，写起来会更加难看，特别是缩进。为了更好的可读性，我们使用Promise包装<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getSocials = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">socials</span>: &#123;<span class="attr">youtube</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="attr">twitter</span>: <span class="string">&#x27;xxx&#x27;</span>&#125;&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getBooks = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">books</span>: [<span class="string">&#x27;React Cookbook&#x27;</span>]&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getDesignation = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">designation</span>: <span class="string">&#x27;Software Architect&#x27;</span>&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">user</span>: <span class="string">&#x27;Sudongyuer&#x27;</span>&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  getUser()</span><br><span class="line">    .then(<span class="function">(<span class="params">&#123;user&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;user retrieved&#x27;</span>, user);</span><br><span class="line">      <span class="keyword">return</span> getDesignation();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">&#123;designation&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;designation retrieved&#x27;</span>, designation)</span><br><span class="line">      <span class="keyword">return</span> getBooks();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">&#123;books&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;books retrieved&#x27;</span>, books);</span><br><span class="line">      <span class="keyword">return</span> getSocials();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">&#123;socials&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;socials retrieved&#x27;</span>, socials)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>这样的话，很大程度就解决了缩进的问题，而且也比较美观，当然我们还有更具可读性的方法,利用到async和await</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getSocials = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">socials</span>: &#123;<span class="attr">youtube</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="attr">twitter</span>: <span class="string">&#x27;xxx&#x27;</span>&#125;&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getBooks = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">books</span>: [<span class="string">&#x27;React Cookbook&#x27;</span>]&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getDesignation = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">designation</span>: <span class="string">&#x27;Software Architect&#x27;</span>&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">user</span>: <span class="string">&#x27;Sudongyuer&#x27;</span>&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> performTasks = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;user&#125; = <span class="keyword">await</span> getUser();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;user retrieved&#x27;</span>, user);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;designation&#125; = <span class="keyword">await</span> getDesignation();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;designation retrieved&#x27;</span>, designation);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;books&#125; = <span class="keyword">await</span> getBooks();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;books retrieved&#x27;</span>, books);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;socials&#125; = <span class="keyword">await</span> getSocials();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;socials retrieved&#x27;</span>, socials);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`     </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 明确函数意图</span></span><br><span class="line"><span class="string">对于返回的是true/false的函数,最好以should/can/is/has开头</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="comment">// 👎 自我感觉良好的缩写:</span></span><br><span class="line"><span class="keyword">let</span> rContent = <span class="string">&#x27;willen&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 👍 无需对每个变量都写注释，从名字上就看懂</span></span><br><span class="line"><span class="keyword">let</span> firstName = <span class="string">&#x27;jackie&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 👎 从命名无法知道返回值类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showFriendsList</span>(<span class="params"></span>) </span>&#123;....&#125; <span class="comment">// // 无法辨别函数意图,返回的是一个数组，还是一个对象，还是true or false?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 👍 明确函数意图，对于返回true or false的函数，最好以should/is/can/has开头</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldShowFriendsList</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmpty</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canCreateDocuments</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasLicense</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendEmailToUser</span>(<span class="params">user</span>) </span>&#123;.... &#125; <span class="comment">//动词开头，函数意图就很明显</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="变量兜底"><a href="#变量兜底" class="headerlink" title="变量兜底"></a>变量兜底</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 👎 对于求值获取的变量，没有兜底</span></span><br><span class="line"><span class="keyword">const</span> &#123; data &#125; = getApiRequest();</span><br><span class="line">data.map(<span class="function">(<span class="params">s</span>) =&gt;</span> s.id); <span class="comment">//没有考虑data异常的情况，代码一跑就爆炸</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 👍 对于求值变量，做好兜底</span></span><br><span class="line"><span class="keyword">const</span> &#123; data = [] &#125; = getApiRequest();</span><br><span class="line">data.map(<span class="function">(<span class="params">s</span>) =&gt;</span> s?.id); <span class="comment">//没有考虑data异常的情况，代码一跑就爆炸</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Tree二叉搜索树笔记⑧--构造篇</title>
    <link href="https://zlinni.github.io/posts/3090245434/"/>
    <id>https://zlinni.github.io/posts/3090245434/</id>
    <published>2022-05-08T06:57:01.000Z</published>
    <updated>2022-05-08T11:13:29.306Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在上一篇基操篇我们讲述了BST的判断合法性和增删改查，下面来学习BST的构造，读完本文你对下面的题目会有更深入的了解。</p></div><p>Leetcode<br><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96.不同的二叉搜索树</a><br><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95.不同的二叉搜索树 II</a></p><h1 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220508155308.png" alt=""></p><p>这是一道穷举的题目，首先我们做个例子:比如输入<code>n=3</code>，那么就有以下几个情况</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220508155735.png" alt=""></p><p>这个是一个正宗的穷举问题，那么有什么方法可以正确的穷举BST的数量呢？</p><p>再看一个例子 比如给算法输入<code>n=5</code>也就是要求他从<code>1,2,3,4,5</code>里面找数字构成BST</p><p>显然会有五种情况，因为每个数字都可以作为根节点，那么我们固定3为根节点，看到底能构成多少个BST</p><p>因为BST左小右大的性质，很明显3为根节点的时候，左子树节点就是<code>1,2</code>右子树节点就是<code>4,5</code></p><p>那么左子树的组合数和右子树的组合数的乘积就是3作为根节点的时候的BST个数</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220508160416.png" alt=""></p><p>在代码方面，其实我们只需要递归就可以了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算闭区间[1,n]组成的BST数量</span></span><br><span class="line"><span class="keyword">const</span> numTree = <span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> count(<span class="number">1</span>,n);</span><br><span class="line">  <span class="keyword">const</span> count = <span class="function">(<span class="params">start,end</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">// base case</span></span><br><span class="line">      <span class="keyword">if</span>(start&gt;end)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">          <span class="keyword">let</span> left = count(start,i-<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">let</span> right = count(i+<span class="number">1</span>,end);</span><br><span class="line">          res += left*right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是这样做显然是不行的，因为会存在很多重叠子问题，我们可以利用一个memo备忘录来解决这个问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numTrees = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> memo = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">const</span> count = <span class="function">(<span class="params">lo,hi</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(lo&gt;hi)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> memoKey = <span class="string">`<span class="subst">$&#123;lo&#125;</span>&amp;<span class="subst">$&#123;hi&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo.has(memoKey))&#123;</span><br><span class="line">          <span class="keyword">return</span> memo.get(memoKey)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> mid = lo;mid&lt;=hi;mid++)&#123;</span><br><span class="line">          <span class="keyword">let</span> left = count(lo,mid-<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">let</span> right = count(mid+<span class="number">1</span>,hi);</span><br><span class="line">          res += left*right;</span><br><span class="line">        &#125;</span><br><span class="line">        memo.set(memoKey,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不同的二叉搜索树II"><a href="#不同的二叉搜索树II" class="headerlink" title="不同的二叉搜索树II"></a>不同的二叉搜索树II</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220508163630.png" alt=""></p><p>题目类似，但是最后要返回全部组合的BST</p><p>我们不难想到还是要用memo去记录我们的子问题，并且这里还存在一个关键，就是我们可以用简单的memoKey来帮助我们记录<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generateTrees = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">0</span>)<span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> memo = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> count = <span class="function">(<span class="params">lo,hi</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res = [];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(lo&gt;hi)&#123;</span><br><span class="line">            res.push(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义memoKey</span></span><br><span class="line">        <span class="keyword">let</span> memoKey = <span class="string">`<span class="subst">$&#123;lo&#125;</span>&amp;<span class="subst">$&#123;hi&#125;</span>`</span>;</span><br><span class="line">        <span class="comment">//查找备忘录</span></span><br><span class="line">        <span class="keyword">if</span>(memo.has(memoKey))&#123;</span><br><span class="line">            <span class="keyword">return</span> memo.get(memoKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 穷举root节点的所有BST可能</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=lo;i&lt;=hi;i++)&#123;</span><br><span class="line">            <span class="comment">// i作为根节点</span></span><br><span class="line">            <span class="keyword">let</span> leftTree = count(lo,i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">let</span> rightTree = count(i+<span class="number">1</span>,hi);</span><br><span class="line">            <span class="comment">// 穷举root的所有左右子树组合</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> left <span class="keyword">of</span> leftTree) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> right <span class="keyword">of</span> rightTree) &#123;</span><br><span class="line">                    res.push(<span class="keyword">new</span> TreeNode(i,left,right))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存放res</span></span><br><span class="line">        memo.set(memoKey,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>BST的构造核心还是BT的构造，但是不同的是，我们可以根据BST的root划分左右去穷举并构造。穷举的过程就是看左右子树有多少种可能的过程，最后可能性相乘就是组合。还学习到了memo的记录方式来排除重复子问题，以及用简单的memoKey。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Tree二叉搜索树笔记⑦--基操篇</title>
    <link href="https://zlinni.github.io/posts/3737568820/"/>
    <id>https://zlinni.github.io/posts/3737568820/</id>
    <published>2022-05-07T08:49:21.000Z</published>
    <updated>2022-05-08T07:51:33.430Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在前面的文章我们学习了BST二叉搜索树的性质，以及结合中序遍历的性质，可以实现树的升序和降序，以及累加树的操作。下面这篇文章深入讲解BST的性质，判断BST的合法性，增删改查，读完本文你对下面的算法题会有更深入的了解</p></div><p>Leetcode<br><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450.删除二叉搜索树的节点</a><br><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701.二叉搜索树中的插入操作</a><br><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700.二叉搜索树中的搜索</a><br><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98.验证二叉搜索树</a></p><h1 id="BST简介"><a href="#BST简介" class="headerlink" title="BST简介"></a>BST简介</h1><div class="note primary flat"><p>所谓的二叉搜索树，就是左小右大的二叉树。利用他的性质，我们可以做到类似二分搜索的操作，搜索一个元素的效率很高，</p></div><p>对于BST相关的问题，我们经常会看到以下代码逻辑<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BST = <span class="function">(<span class="params">root,target</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.val===target)&#123;</span><br><span class="line">        <span class="comment">//do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.val&lt;target)&#123;</span><br><span class="line">        BST(root.right,target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.val&gt;target)&#123;</span><br><span class="line">        BST(root.left,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个代码框架其实和二叉树遍历差不多，无非就是利用了BST左小右大的特性</p><p>下面来讲几道BST必会的题目</p><h1 id="判断BST的合法性"><a href="#判断BST的合法性" class="headerlink" title="判断BST的合法性"></a>判断BST的合法性</h1><p>这里存在了坑点，按照我们之前思考的二叉树节点应该做什么的做法，这里会写出以下的code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> judgeBST = <span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(n.left!==<span class="literal">null</span>&amp;&amp;n.val&lt;n.left.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n.right!==<span class="literal">null</span>&amp;n.val&gt;n.right.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> judgeBST(n.left)&amp;&amp;judgeBST(n.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看似好像没什么问题，但是实际上这个算法出现了错误，原因在于BST的性质。对于这个算法来说，他判断的是每个节点的值要大于左边小于右边，但是BST的性质是对于每个节点，他的值都要小于右子树的全部值，大于左子树的全部值，看图：</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220507182900.png" alt=""></p><p>该图不是BST，但是他会被这个算法判定为BST</p><p>那么我们应该怎么做呢？既然要满足当前节点大于左子树全部值，小于右子树全部值，我们不妨设个变量max和min，分别来代替左右子树的最大值，一旦没有满足这个条件就视为非BST</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果满足max&gt;root.val&gt;min就正确</span></span><br><span class="line"><span class="keyword">const</span> isValidBST = <span class="function">(<span class="params">n,max,min</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//注意这里是判断子树不为空</span></span><br><span class="line">    <span class="keyword">if</span>(min!==<span class="literal">null</span>&amp;&amp;n.val&lt;=min.val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(max!==<span class="literal">null</span>&amp;&amp;n.val&gt;=max.val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//对于左子树来说，最大值是n，对于右子树来说，最小值是n</span></span><br><span class="line">    <span class="keyword">return</span> isValidBST(n.left,n,min)&amp;&amp;isValidBST(n.right,max,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isValidBST(root,<span class="literal">null</span>,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h1 id="在BST中搜索元素"><a href="#在BST中搜索元素" class="headerlink" title="在BST中搜索元素"></a>在BST中搜索元素</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220507184411.png" alt=""></p><p>如果是一颗普通的二叉树可以写如下的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> searchBST = <span class="function">(<span class="params">n,target</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(n.val === target) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">let</span> left = searchBST(n.left,target);</span><br><span class="line">    <span class="keyword">let</span> right = searchBST(n.right,target); </span><br><span class="line">    <span class="keyword">return</span> left!==<span class="literal">null</span>?left:right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码相当于穷举了二叉树中的所有节点，如果找的到就返回对应的子树.</p><p>但我们拥有BST的性质，就应该利用起来，比较root和target的值，将其中的一边舍去。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> searchBST = <span class="function">(<span class="params">n,target</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(n.val&lt;target)<span class="keyword">return</span> searchBST(n.right,target);</span><br><span class="line">    <span class="keyword">if</span>(n.val&gt;target)<span class="keyword">return</span> searchBST(n.left,target);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="在BST中插入一个数"><a href="#在BST中插入一个数" class="headerlink" title="在BST中插入一个数"></a>在BST中插入一个数</h1><div class="note primary flat"><p>对于数据结构的操作无非就是遍历+访问，其中遍历就是找，访问就是改。具体而言，插入一个数据就首先要找到插入的位置，然后进行插入操作。</p></div><p>上一个问题，我们总结了BST的遍历框架，也就是找的问题，直接套框架，然后我们只要进行改的操作就可以了。但是要注意的是，一旦涉及到改，函数就要返回treenode类型，并且对递归调用的返回值进行接收</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertIntoBST = <span class="function"><span class="keyword">function</span>(<span class="params">root, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    <span class="keyword">if</span>(root.val&lt;val)&#123;</span><br><span class="line">        root.right = insertIntoBST(root.right,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.val&gt;val)&#123;</span><br><span class="line">        root.left = insertIntoBST(root.left,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在BST中删除一个数"><a href="#在BST中删除一个数" class="headerlink" title="在BST中删除一个数"></a>在BST中删除一个数</h1><p>这个问题比较复杂，但是思路也差不多，先找到再改，框架如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">root, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.val === key)&#123;</span><br><span class="line">        <span class="comment">//delete</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;key)&#123;</span><br><span class="line">        root.left = deleteNode(root.left,key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        root.right = deleteNode(root.right,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于如何删除这个节点，有下面的几种情况：</p><p>情况一：A这个节点恰好是末端节点，两个子节点为空，那么他就可以当场去世了。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220507194014.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root.left&amp;&amp;!root.right)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况二：A只有一个非空字节点，那么就要让这子节点替代自己的位置<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220507194203.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root.left)<span class="keyword">return</span> root.right;</span><br><span class="line"><span class="keyword">if</span>(!root.right)<span class="keyword">return</span> root.left;</span><br></pre></td></tr></table></figure><p>情况三：A有两个子节点，那么就比较复杂了，需要找到右子树最小的节点来替代自己<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220507194517.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root.left&amp;&amp;root.right)&#123;</span><br><span class="line">    <span class="keyword">let</span> minNode = getMin(root.right);</span><br><span class="line">    root.val = minNode.val;</span><br><span class="line">    root.right = deleteNode(root.right,minNode.val)</span><br><span class="line">    minNode.left = root.left;</span><br><span class="line">    minNode.right = root.right;</span><br><span class="line">    root = minNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span> (<span class="params">root, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.val === key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root.left)<span class="keyword">return</span> root.right;</span><br><span class="line">        <span class="keyword">if</span>(!root.right)<span class="keyword">return</span> root.left;</span><br><span class="line">        <span class="keyword">if</span>(root.left&amp;&amp;root.right)&#123;</span><br><span class="line">            <span class="keyword">let</span> minNode = root.right;</span><br><span class="line">            <span class="keyword">while</span>(minNode.left)&#123;</span><br><span class="line">                minNode = minNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root.right = deleteNode(root.right,minNode.val);</span><br><span class="line">            minNode.left = root.left;</span><br><span class="line">            minNode.right = root.right;</span><br><span class="line">            root = minNode</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key)&#123;</span><br><span class="line">        root.right = deleteNode(root.right,key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        root.left = deleteNode(root.left,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就完成了删除的操作，但是有人可能在这一步会好奇，为什么修改root节点这么麻烦，直接修改val值不是更方便吗<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">minNode.left = root.left;</span><br><span class="line">minNode.right = root.right;</span><br><span class="line">root = minNode</span><br><span class="line"></span><br><span class="line">=》</span><br><span class="line"></span><br><span class="line">root.val = minNode.val;</span><br></pre></td></tr></table></figure></p><p>对于这道题来说是可以这么做的，但是不提倡，因为在实际应用中，BST 节点内部的数据域是用户自定义的，可以非常复杂，而 BST 作为数据结构（一个工具人），其操作应该和内部存储的数据域解耦，所以我们更倾向于使用指针操作来交换节点，根本没必要关心内部数据。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><div class="note primary flat"><p>通过这篇文章，我们能学会几个关键的操作，BST的增删改查，和合法性判断。</p></div><p>技巧如下：<br>根据二叉树的递归得到BST的代码框架<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BST = <span class="function">(<span class="params">n,target</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.val===target)&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;val)&#123;</span><br><span class="line">        BST(root.right,target);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&gt;val)&#123;</span><br><span class="line">        BST(root.left,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Pinia大菠萝--新一代状态管理</title>
    <link href="https://zlinni.github.io/posts/3383846748/"/>
    <id>https://zlinni.github.io/posts/3383846748/</id>
    <published>2022-05-06T09:57:23.000Z</published>
    <updated>2022-05-08T11:30:35.545Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>如今已经是vue3+ts的时代，但对于我们的状态管理工具vuex来说，他也是存在一定的缺陷的，下文讲解pinia的由来和基础的用法，用于构建个人的轻量级项目。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220506181436.png" alt=""></p><h1 id="Pinia大菠萝"><a href="#Pinia大菠萝" class="headerlink" title="Pinia大菠萝"></a>Pinia大菠萝</h1><div class="note primary flat"><p>pinia是新的一门状态管理工具，他是vue官方推荐的替代vuex的产品。特点如下：</p></div><ul><li>拥有完整的ts支持，这点和vuex比起来更舒适。</li><li>更小的体积(约1kb)</li><li>没有muatation，只有action</li><li>store可以直接使用，不需要辅助函数</li></ul><h1 id="pinia为什么体积小于vuex"><a href="#pinia为什么体积小于vuex" class="headerlink" title="pinia为什么体积小于vuex"></a>pinia为什么体积小于vuex</h1><p>这得从它们两者的代码分割机制来讲：</p><div class="note primary flat"><p>举个例子：某项目有3个store「user、job、pay」，另外有2个路由页面「首页、个人中心页」，首页用到job store，个人中心页用到了user store，分别用Pinia和Vuex对其状态管理。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220506183109.png" alt=""></p><p>先看Vuex的代码分割： 打包时，vuex会把3个store合并打包，当首页用到Vuex时，这个包会引入到首页一起打包，最后输出1个js chunk。这样的问题是，其实首页只需要其中1个store，但其他2个无关的store也被打包进来，造成资源浪费。</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220506183122.png" alt=""></p><p>Pinia的代码分割： 打包时，Pinia会检查引用依赖，当首页用到job store，打包只会把用到的store和页面合并输出1个js chunk，其他2个store不耦合在其中。Pinia能做到这点，是因为它的设计就是store分离的，解决了项目的耦合问题。</p><p>总结：pinia根据引用打包store文件，但vuex就是全部打包。</p><h1 id="安装pinia"><a href="#安装pinia" class="headerlink" title="安装pinia"></a>安装pinia</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pinia</span><br></pre></td></tr></table></figure><h1 id="挂载实例"><a href="#挂载实例" class="headerlink" title="挂载实例"></a>挂载实例</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createPinia&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> pinia = createPinia();</span><br><span class="line">app.use(pinia);</span><br></pre></td></tr></table></figure><h1 id="创建第一个store"><a href="#创建第一个store" class="headerlink" title="创建第一个store"></a>创建第一个store</h1><p>在<code>src/store/index.ts</code>里面创建你的store，其中定义store的方式有两种 </p><ul><li><p>使用optionAPI模式定义，这种方式和vue2的类似</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mainStore = defineStore(<span class="string">&#x27;main&#x27;</span>,&#123;</span><br><span class="line">  <span class="attr">state</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      <span class="attr">count</span>:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.count++:</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">getters</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">doubleCount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>使用setup模式定义，符合Vue3 setup的编程模式，让结构更加扁平化，更推荐使用这种方式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mainStore = defineStore(<span class="string">&#x27;main&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = ref&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> increment:<span class="built_in">number</span> = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    count.value++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> doubleCount:<span class="built_in">number</span> = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count.value*<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;count,increment,doubleCount&#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><div class="note primary flat"><p>state定义数据，action放同步或者异步的方法，getters获取state的计算结果</p></div><p>上面两个的方式效果都是一样的，区别在于使用了setup的方式更贴近于vue3，然后我们不用在意action和getters关键字。而第一种方式的话，我们还是需要写getters和actions等来区分我们的代码</p><h1 id="调用store的数据"><a href="#调用store的数据" class="headerlink" title="调用store的数据"></a>调用store的数据</h1><div class="note primary flat"><p>这一部分讲解怎么调用store的数据,主要是解析响应式数据，对于ref我们需要引入<code>storeToRefs</code>再解构，否则丢失响应</p></div><p>code 使用setup的格式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mainStore&#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/mainStore.ts&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;storeToRefs&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = mainStore();</span><br><span class="line">  <span class="comment">//解析数据 可以解构reactive的</span></span><br><span class="line">  <span class="keyword">const</span> &#123; data &#125; = store;</span><br><span class="line">  <span class="comment">//ref类型需要这样</span></span><br><span class="line">  <span class="keyword">const</span> &#123; refData &#125; = storeToRefs(store); </span><br><span class="line">  <span class="keyword">const</span> &#123; fun1,fun2 &#125; = store;</span><br><span class="line">  <span class="comment">//使用ref的数据 </span></span><br><span class="line">  <span class="built_in">console</span>.log(refData.value);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p><h1 id="创建多个store"><a href="#创建多个store" class="headerlink" title="创建多个store"></a>创建多个store</h1><p>项目复杂了就需要多个store管理。其实pinia创建新的store方式很简单，就是export的时候命名和文件名一致就行了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> index = defineStore(<span class="string">&#x27;index&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> map = defineStore(<span class="string">&#x27;map&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Tree二叉搜索树笔记⑥--特性篇</title>
    <link href="https://zlinni.github.io/posts/2732070170/"/>
    <id>https://zlinni.github.io/posts/2732070170/</id>
    <published>2022-05-05T08:38:38.000Z</published>
    <updated>2022-05-08T03:37:53.742Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在前面的文章我们学习了寻找一颗二叉树的重复子树，这个问题结合了第四章节的序列化内容加第三章节的构造内容，接下来我们学习二叉搜索树的知识，读完本文你对以下的题目有更深刻的了解：</p></div><p>Leetcode<br><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230.二叉树中的第k小元素</a><br><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538.把二叉搜索树转为累加树</a><br><a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">1038.把二叉搜索树转为累加树</a></p><h1 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h1><div class="note primary flat"><p>全称二叉搜索树，简写BST，特性如下：</p></div><ol><li>BST的每个节点，左子树节点的值都比他小，右子树节点的值都比他大。</li><li>对于BST的每一个节点，他的左侧子树和右侧子树都是BST</li></ol><div class="note primary flat"><p>labuladong原话：二叉搜索树并不算复杂，但我觉得它可以算是数据结构领域的半壁江山，直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。</p></div><p>从算法题的角度来讲，中序遍历一个BST，是升序的，因为他先构造了左子树再构造右子树，所以如果是以一个数组的形式显示，就是从小到大的。</p><h1 id="寻找第-K-小的元素"><a href="#寻找第-K-小的元素" class="headerlink" title="寻找第 K 小的元素"></a>寻找第 K 小的元素</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505183122.png" alt=""><br>按照上面的思路，我们只要中序遍历这个二叉树然后找第k个就行了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kthSmallest = <span class="function"><span class="keyword">function</span>(<span class="params">root, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res;</span><br><span class="line">    <span class="keyword">const</span> inorder = <span class="function"><span class="params">root</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span>(k===<span class="number">0</span>)res = root.val;</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然这道题做完了，但是这个解法在目前来说并不是最高效的。下面引自labuladong</p><div class="note primary flat"><p>如果按照我们刚才说的方法，利用「BST 中序遍历就是升序排序结果」这个性质，每次寻找第 k 小的元素都要中序遍历一次，最坏的时间复杂度是 O(N)，N 是 BST 的节点个数。</p><p>要知道 BST 性质是非常牛逼的，像红黑树这种改良的自平衡 BST，增删查改都是 O(logN) 的复杂度，让你算一个第 k 小元素，时间复杂度竟然要 O(N)，有点低效了。</p><p>所以说，计算第 k 小元素，最好的算法肯定也是对数级别的复杂度，不过这个依赖于 BST 节点记录的信息有多少。</p><p>我们想一下 BST 的操作为什么这么高效？就拿搜索某一个元素来说，BST 能够在对数时间找到该元素的根本原因还是在 BST 的定义里，左子树小右子树大嘛，所以每个节点都可以通过对比自身的值判断去左子树还是右子树搜索目标值，从而避免了全树遍历，达到对数级复杂度。</p><p>那么回到这个问题，想找到第 k 小的元素，或者说找到排名为 k 的元素，如果想达到对数级复杂度，关键也在于每个节点得知道他自己排第几。</p><p>比如说你让我查找排名为 k 的元素，当前节点知道自己排名第 m，那么我可以比较 m 和 k 的大小：</p><p>1、如果 m == k，显然就是找到了第 k 个元素，返回当前节点就行了。</p><p>2、如果 k &lt; m，那说明排名第 k 的元素在左子树，所以可以去左子树搜索第 k 个元素。</p><p>3、如果 k &gt; m，那说明排名第 k 的元素在右子树，所以可以去右子树搜索第 k - m - 1 个元素。</p><p>这样就可以将时间复杂度降到 O(logN) 了。</p><p>那么，如何让每一个节点知道自己的排名呢？</p><p>这就是我们之前说的，需要在二叉树节点中维护额外信息。每个节点需要记录，以自己为根的这棵二叉树有多少个节点。</p><p>也就是说，我们 TreeNode 中的字段应该如下：</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    int val;</span><br><span class="line">    <span class="comment">// 以该节点为根的树的节点总数</span></span><br><span class="line">    int size;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 size 字段，外加 BST 节点左小右大的性质，对于每个节点 node 就可以通过 node.left 推导出 node 的排名，从而做到我们刚才说到的对数级算法。</p><p>当然，size 字段需要在增删元素的时候需要被正确维护，力扣提供的 TreeNode 是没有 size 这个字段的，所以我们这道题就只能利用 BST 中序遍历的特性实现了，但是我们上面说到的优化思路是 BST 的常见操作，还是有必要理解的。</p><h1 id="BST转累加树"><a href="#BST转累加树" class="headerlink" title="BST转累加树"></a>BST转累加树</h1><p>力扣538和1038题都是这一道，可以一起做了。</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220507162402.png" alt=""></p><p>按照二叉树的通用思路，我们要思考每个节点本身应该做什么，但是这道题很难想到什么思路。</p><p>但是我们可以这样想，我们的目的是什么，是将节点进行一个累加然后赋值到这个节点，中序遍历的性质就是能将BST变成升序。</p><p>不过一般的中序可做不到这个特点，因为是左根右，只能打印出升序的，我们现在需要从右子树开始计算，所以可以使用右根左，打印出降序的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> convertBST = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> inorder = <span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    inorder(n.right);</span><br><span class="line">    sum+=n.val;</span><br><span class="line">    n.val = sum;</span><br><span class="line">    inorder(n.left);</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inorder(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>BST可以结合中序遍历的特性去帮助我们完成树的升序或者降序，这一点需要牢记。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree二叉树笔记--合集</title>
    <link href="https://zlinni.github.io/posts/3500150157/"/>
    <id>https://zlinni.github.io/posts/3500150157/</id>
    <published>2022-05-05T07:06:00.000Z</published>
    <updated>2022-06-10T00:47:43.396Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>根据这五篇的二叉树学习，你将从一个只会根左右，左根右和左右根的算法小白中领略二叉树的核心算法。</p><h1 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h1><p><a href="https://zlinni.github.io/posts/1410341477">手把手二叉树笔记①—纲领篇</a><br><a href="https://zlinni.github.io/posts/1410341478">手把手二叉树笔记②—思路篇</a><br><a href="https://zlinni.github.io/posts/686027467">手把手二叉树笔记③—构造篇</a><br><a href="https://zlinni.github.io/posts/3440987103">手把手二叉树笔记④—序列化篇</a><br><a href="https://zlinni.github.io/posts/3318597918">手把手二叉树笔记⑤—后序篇</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree二叉树笔记⑤--后序篇</title>
    <link href="https://zlinni.github.io/posts/732690854/"/>
    <id>https://zlinni.github.io/posts/732690854/</id>
    <published>2022-05-05T07:05:40.000Z</published>
    <updated>2022-05-08T03:34:51.372Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在上一篇我们学习了用js解决二叉树的序列化和反序列化的问题，其实序列化的过程就是考察二叉树遍历的过程，反序列化的过程就是考察了二叉树的构造过程，结合了前几章的知识。本篇文章深入学习二叉树后序的妙用，带你了解以下题目：</p></div><p>Leetcode<br>652.寻找重复的子树</p><h1 id="寻找重复的子树"><a href="#寻找重复的子树" class="headerlink" title="寻找重复的子树"></a>寻找重复的子树</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505151327.png" alt=""></p><p>这道题实际上就是找子树的问题，看下图<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505151425.png" alt=""></p><p>首先节点4可以作为一颗子树，二叉树中有多个节点4<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505151457.png" alt=""></p><p>类似的还存在两颗以2为根的重复子树<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505151521.png" alt=""></p><p>那么我们返回的list就应该有两个treenode，2和4 </p><p>具体这道题要怎么做呢？先思考对于一个节点他应该做什么？</p><p>我们拿这个2节点作为例子，他是不是重复的子树，是不是就要先知道自己是一颗怎么样的子树，再去找别的子树进行对比？<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505152207.png" alt=""></p><p>那么我们解题的关键就来了：</p><ol><li>先知道自己长什么样</li><li>去看看别人有没有和自己一样的</li></ol><p>那么对于第一个问题，根据本文你可以知道我们要用后序遍历的操作去做，其实前序中序都可以，只不过后序在这个阶段看的东西更明显，怎么知道自己是谁呢？其实就是自身加左右子树<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postoreder = <span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> left = postoreder(n.left);</span><br><span class="line">  <span class="keyword">let</span> right = postoreder(n.right);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;left&#125;</span>,<span class="subst">$&#123;right&#125;</span>,<span class="subst">$&#123;n.val&#125;</span>`</span>;</span><br><span class="line">  <span class="comment">//n 就是一颗树了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样不就能知道自己是谁了吗？一看这个问题，你就会发现，和之前的序列化二叉树及其相似，其实知道自己是谁的这个过程，就是经历了一次序列化。</p><p>那么现在怎么解决找同伴的问题呢？其实很简单，我们运用js的set或者map，考量这两个api用哪个的时候，我们先看我们需要什么？我们需要记录出现次数超过一次的子树，也就是记录子树+子树出现次数，所以用map更好。完整代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findDuplicateSubtrees = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//定义map集合和存放的数组</span></span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(),res = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> tranverse = <span class="function"><span class="params">root</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">const</span> left = tranverse(root.left);</span><br><span class="line">        <span class="keyword">const</span> right = tranverse(root.right);</span><br><span class="line">        <span class="keyword">const</span> str = <span class="string">`<span class="subst">$&#123;left&#125;</span>,<span class="subst">$&#123;right&#125;</span>,<span class="subst">$&#123;root.val&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">const</span> count = map.get(str);</span><br><span class="line">        <span class="keyword">if</span>(count===<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//等于1就存放子树</span></span><br><span class="line">            res.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(str,(count||<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tranverse(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>寻找重复子树的过程就是后序序列化+搜索的过程，注意序列化的时候要放入的是val，搜索的时候结合map和满足一次加入res的条件优化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree二叉树笔记④--序列化篇</title>
    <link href="https://zlinni.github.io/posts/3440987103/"/>
    <id>https://zlinni.github.io/posts/3440987103/</id>
    <published>2022-05-04T11:44:11.000Z</published>
    <updated>2022-05-08T03:19:58.608Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在上一期我们对二叉树的构造进行了深入的了解，重点掌握了构造的核心原理以及一些细节上面的问题。下面来学习二叉树的序列化，通过本篇文章你可以学会以下的题目</p></div><p>Leetcode<br><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297.二叉树的序列化与反序列化</a></p><h1 id="二叉树的序列化与反序列化"><a href="#二叉树的序列化与反序列化" class="headerlink" title="二叉树的序列化与反序列化"></a>二叉树的序列化与反序列化</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505111425.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505145026.png" alt=""></p><p>该题目本质上，就是把二叉树转换为字符串，再从字符串转为二叉树的过程。</p><p>至于我们序列化的过程，使用什么符号定义并不重要，只要最后能够反序列化出来即可。</p><p>eg<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505145259.png" alt=""></p><p>对于一颗这样的树，我们可以将他序列化成<code>2,1,#,6,3,#,#</code>其实他考察的就是如何对二叉树进行遍历。</p><p>二叉树的递归遍历有三种，前序中序后序，迭代遍历有层序，那么就从层序开始，看如何解题</p><h1 id="前序遍历解法"><a href="#前序遍历解法" class="headerlink" title="前序遍历解法"></a>前序遍历解法</h1><p>我们知道，前序遍历的代码就是在递归之前写的，那么就有以下的逻辑<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">traverse(root.left);</span><br><span class="line">traverse(root.right);</span><br></pre></td></tr></table></figure></p><p>那么我们就很容易得出序列化的过程了，就是字符串的连接<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serialize = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;root&#125;</span>,<span class="subst">$&#123;serialize(root.left)&#125;</span>,<span class="subst">$&#123;serialize(root.right)&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>那么其实反序列化，就是把序列化的这一串字符串转换为treenode。</p><p>对于一个字符串来说，js提供了split方法帮我们进行分割，也就是说以下的逻辑，会分割出一个数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nodeArr = data.split(<span class="string">&quot;,&quot;</span>);</span><br></pre></td></tr></table></figure></p><p>我们拿到了这个数组，因为他是前序的序列化而来的，那么我们根据前序的特性可以得到以下条件<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220505145931.png" alt=""></p><p>第一个值是根，这就是我们的递归关键，回想一下前序构造二叉树，我们可以得到如下的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> build = <span class="function">(<span class="params">preorder</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> val = preorder.shift();</span><br><span class="line">  <span class="keyword">if</span>(val === <span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">  root.left = build(preorder);</span><br><span class="line">  root.right = build(preorder);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么我们的反序列化就能写出来了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deserialize = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nodearr = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!nodearr.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> build = <span class="function">(<span class="params">nodearr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> val = nodearr.shift();</span><br><span class="line">        <span class="keyword">if</span> (val === <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root.left = build(nodearr);</span><br><span class="line">        root.right = build(nodearr);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(nodearr);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>完整代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serialize = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;root.val&#125;</span>,<span class="subst">$&#123;serialize(root.left)&#125;</span>,<span class="subst">$&#123;serialize(root.right)&#125;</span>`</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deserialize = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nodearr = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!nodearr.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> build = <span class="function">(<span class="params">nodearr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> val = nodearr.shift();</span><br><span class="line">        <span class="keyword">if</span> (val === <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root.left = build(nodearr);</span><br><span class="line">        root.right = build(nodearr);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(nodearr);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>序列化就是转字符串的过程，这个过程用什么符号代替并不重要，只要最后能解析即可。一般是利用前序空节点返回#然后模板字符串拼接根+递归的左右</p><p>反序列化的就是解析字符串重构树的过程，注意需要用split分割字符串为数组，遇到#就返回null。</p><p>重构树的过程，由于他是数组转树，我们递归的时候就要注意递归的是数组，我们取节点就应该使用shift</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree二叉树笔记③--构造篇</title>
    <link href="https://zlinni.github.io/posts/686027467/"/>
    <id>https://zlinni.github.io/posts/686027467/</id>
    <published>2022-05-04T11:43:28.000Z</published>
    <updated>2022-05-08T03:01:55.154Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在上一篇笔记里面，我们深入了解了前序和后序遍历的本质，学会了翻转二叉树，将二叉树转为链表和填充二叉树右侧指针三道问题。接下来进一步学习，在本篇能理解并运用以下题目：</p></div><p>Leetcode<br><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654.最大二叉树</a><br><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105.从前序遍历和中序遍历构造二叉树</a><br><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106.从中序和后序遍历构造二叉树</a><br><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889.根据前序和后序遍历构造二叉树</a></p><h1 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220504201032.png" alt=""></p><p>我们细分这道题，其实他在做这样的事情<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constructMaximumBinaryTree = <span class="function"><span class="keyword">function</span> (<span class="params">[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">5</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 找到数组的最大值</span></span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(<span class="number">6</span>)</span><br><span class="line">    <span class="comment">// 递归调用构造左右子树</span></span><br><span class="line">    root.left = constructMaximumBinaryTree([<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]);</span><br><span class="line">    root.right = constructMaximumBinaryTree([<span class="number">0</span>,<span class="number">5</span>]);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再详细一点就是如下的思路：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constructMaximumBinaryTree = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> build = <span class="function">(<span class="params">nums,start,end</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//查找最大值和他的下标</span></span><br><span class="line">        <span class="keyword">let</span> max = -<span class="literal">Infinity</span>,index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;max)&#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构造二叉树</span></span><br><span class="line">        <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(max);</span><br><span class="line">        root.left = build(nums,start,index-<span class="number">1</span>);</span><br><span class="line">        root.right = build(nums,index+<span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(nums,<span class="number">0</span>,len);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 或者可以这样</span></span><br><span class="line"><span class="keyword">var</span> constructMaximumBinaryTree = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//查找最大值和他的下标</span></span><br><span class="line">    <span class="keyword">if</span>(!nums.length)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> max = -<span class="literal">Infinity</span>, index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; max) &#123;</span><br><span class="line">            max = nums[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造二叉树</span></span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(max);</span><br><span class="line">    root.left = constructMaximumBinaryTree(nums.slice(<span class="number">0</span>, index));</span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    root.right = constructMaximumBinaryTree(nums.slice(index + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>至此第一道构造二叉树的题目就做完了，接下看看另外两道题目</p><h1 id="通过前序和中序遍历结果构造二叉树"><a href="#通过前序和中序遍历结果构造二叉树" class="headerlink" title="通过前序和中序遍历结果构造二叉树"></a>通过前序和中序遍历结果构造二叉树</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220504201525.png" alt=""></p><p>我们知道前序遍历的第一个节点就是整个树的根，那么中序遍历的根节点前面就是左子树，后面就是右子树，利用这个特性，自然而然的会想出以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> build = <span class="function">(<span class="params">preorder, inorder</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//找到根节点</span></span><br><span class="line">    <span class="keyword">const</span> root = preorder.shift();</span><br><span class="line">    <span class="comment">// 中序找到该节点的下标</span></span><br><span class="line">    <span class="keyword">const</span> rootIndex = inorder.indexOf(root);</span><br><span class="line">    <span class="keyword">const</span> tree = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">    <span class="comment">//递归调用构造左右子树</span></span><br><span class="line">    tree.left = fun(...);</span><br><span class="line">    tree.right = fun(...);</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，我们这里要创建一个什么样的函数去递归呢？<br>其实我们只要利用我们的中序数组就可以了，因为能依靠他查找，就能依靠他构造</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> build = <span class="function">(<span class="params">inorder</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inorder||!inorder.length)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> root = preorder.shift();</span><br><span class="line">        <span class="keyword">const</span> rootIndex = inorder.indexOf(root);</span><br><span class="line">        <span class="keyword">const</span> tree = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">        tree.left = build(inorder.slice(<span class="number">0</span>,rootIndex));</span><br><span class="line">        tree.right = build(inorder.slice(rootIndex+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(inorder);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者我们可以这样,我们知道了其实前序的左子树终止边界就是中序到根节点的长度+1，那么我们也就可以带入前序递归<br><img src="https://labuladong.github.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/6.jpeg" alt=""><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!preorder.length) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> root = preorder.shift();</span><br><span class="line">    <span class="keyword">const</span> tree = <span class="keyword">new</span> TreeNode(root)</span><br><span class="line">    <span class="keyword">const</span> rootIndex = inorder.indexOf(root)</span><br><span class="line">    tree.left = buildTree(preorder.slice(<span class="number">0</span>, rootIndex), inorder.slice(<span class="number">0</span>,rootIndex))</span><br><span class="line">    tree.right = buildTree(preorder.slice(rootIndex), inorder.slice(rootIndex+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="通过后序和中序遍历结果构造二叉树"><a href="#通过后序和中序遍历结果构造二叉树" class="headerlink" title="通过后序和中序遍历结果构造二叉树"></a>通过后序和中序遍历结果构造二叉树</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220504204143.png" alt=""></p><p>后序遍历的最后一个节点是root，那么我们知道了这个道理，其实就把shift的操作变成pop即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">inorder, postorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!postorder.length)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> root = postorder.pop();</span><br><span class="line">    <span class="keyword">const</span> rootIndex = inorder.indexOf(root);</span><br><span class="line">    <span class="keyword">const</span> tree = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">    tree.left = buildTree(inorder.slice(<span class="number">0</span>,rootIndex),postorder.slice(<span class="number">0</span>,rootIndex));</span><br><span class="line">    tree.right = buildTree(inorder.slice(rootIndex+<span class="number">1</span>),postorder.slice(rootIndex));</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="通过前序和后序构造二叉树"><a href="#通过前序和后序构造二叉树" class="headerlink" title="通过前序和后序构造二叉树"></a>通过前序和后序构造二叉树</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220508105922.png" alt=""><br>我们知道了结合中序构造的方法，就是从中序中找到对应的index然后分离左右，最后递归。</p><p>那么前序和后序怎么构造呢？</p><p>实际上，拿前序当参照物，第一个就是根节点，第二个就是左子树的根节点，那么我们就可以同样的在后序中找到这个左子树根节点，去分离我们的左右子树。</p><p><img src="https://labuladong.github.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/8.jpeg" alt=""><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constructFromPrePost = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, postorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!preorder.length||!postorder.length)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(preorder.length===<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> root = preorder[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> index = postorder.indexOf(root);</span><br><span class="line">    <span class="keyword">const</span> tree = <span class="keyword">new</span> TreeNode(preorder.shift());</span><br><span class="line">    <span class="comment">//之前找的是根节点前面的一段，所以是index，现在找的是左子树根节点，所以index+1</span></span><br><span class="line">    tree.left = constructFromPrePost(preorder.slice(<span class="number">0</span>,index+<span class="number">1</span>),postorder.slice(<span class="number">0</span>,index+<span class="number">1</span>),)</span><br><span class="line">    tree.right = constructFromPrePost(preorder.slice(index+<span class="number">1</span>),postorder.slice(index+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后总结一下，构造二叉树实际上就是找到根节点+构造左子树+构造右子树。根节点使用indexof和遍历的性质寻找，左右子树的构造使用递归的方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    <category term="Binary Tree" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/Binary-Tree/"/>
    
    
    <category term="算法" scheme="https://zlinni.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
