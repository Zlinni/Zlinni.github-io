<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>你所不知道的JavaScript① | Zlinni's Blog For Study</title><meta name="keywords" content="前端,js"><meta name="author" content="Zlinni"><meta name="copyright" content="Zlinni"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="类型首先js的类型有基本数据类型和引用类型前者有七种 后者是一种根据以前的USONB理论 大致是Undefined,String,Symbol,Object,Null,Number,BigInt,Boolean 基本数据类型的作用？基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。 object为什么是引用类型？而引用类型">
<meta property="og:type" content="article">
<meta property="og:title" content="你所不知道的JavaScript①">
<meta property="og:url" content="https://zlinni.github.io/posts/fee85c52fd07/index.html">
<meta property="og:site_name" content="Zlinni&#39;s Blog For Study">
<meta property="og:description" content="类型首先js的类型有基本数据类型和引用类型前者有七种 后者是一种根据以前的USONB理论 大致是Undefined,String,Symbol,Object,Null,Number,BigInt,Boolean 基本数据类型的作用？基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。 object为什么是引用类型？而引用类型">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zlinni.github.io/img/js%E7%B3%BB%E5%88%97/js%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F%E5%A0%86%E5%92%8C%E6%A0%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.jpg">
<meta property="article:published_time" content="2022-03-17T00:46:42.000Z">
<meta property="article:modified_time" content="2022-04-08T01:33:43.065Z">
<meta property="article:author" content="Zlinni">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="js">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zlinni.github.io/img/js%E7%B3%BB%E5%88%97/js%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F%E5%A0%86%E5%92%8C%E6%A0%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://zlinni.github.io/posts/fee85c52fd07/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="#000000"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/favicon-16x16.png"/><link rel="mask-icon" href="/img/siteicon/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Zlinni","link":"链接: ","source":"来源: Zlinni's Blog For Study","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '你所不知道的JavaScript①',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-08 09:33:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link data-pjax rel="stylesheet" href="/css/bgc.css"><link data-pjax rel="stylesheet" href="/css/neonlight.css"><link data-pjax rel="stylesheet" href="/css/custom.css"><link data-pjax rel="stylesheet" href="/css/aplayer.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" media="defer" onload="this.media='all'"><div class="aplayer" data-id="7123261369" data-server="netease" data-type="playlist" data-fixed="true" data-listFolded="false" data-order="list" data-preload="none"></div><link rel="stylesheet" href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js"></script><script src="./lib/Meting.min.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Zlinni's Blog For Study" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/head/boji.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 闲言碎语</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-comment-dots"></i><span> 日常吐槽</span></a></li><li><a class="site-page child" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留个说法</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"><i class="fa-fw fa fa-bookmark"></i><span> 前端基础</span></a></li><li><a class="site-page child" href="/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"><i class="fa-fw fa fa-bookmark"></i><span> 前端进阶</span></a></li><li><a class="site-page child" href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BF%AE/"><i class="fa-fw fa fa-bookmark"></i><span> 程序员必修</span></a></li><li><a class="site-page child" href="/categories/%E9%9D%A2%E8%AF%95/"><i class="fa-fw fa fa-bookmark"></i><span> 面试</span></a></li><li><a class="site-page child" href="/categories/%E9%AD%94%E6%94%B9/"><i class="fa-fw fa fa-bookmark"></i><span> 魔改</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 镜像网站</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://zlinni.gitee.io/"><i class="fa-fw fa fa-link"></i><span> gitee</span></a></li><li><a class="site-page child" href="https://zlinni.github.io/"><i class="fa-fw fa fa-link"></i><span> github</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-desktop"></i><span> 关于本站</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-tag"></i><span> 和我无关</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/js%E7%B3%BB%E5%88%97/js%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F%E5%A0%86%E5%92%8C%E6%A0%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Zlinni's Blog For Study</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 闲言碎语</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-comment-dots"></i><span> 日常吐槽</span></a></li><li><a class="site-page child" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留个说法</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"><i class="fa-fw fa fa-bookmark"></i><span> 前端基础</span></a></li><li><a class="site-page child" href="/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"><i class="fa-fw fa fa-bookmark"></i><span> 前端进阶</span></a></li><li><a class="site-page child" href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BF%AE/"><i class="fa-fw fa fa-bookmark"></i><span> 程序员必修</span></a></li><li><a class="site-page child" href="/categories/%E9%9D%A2%E8%AF%95/"><i class="fa-fw fa fa-bookmark"></i><span> 面试</span></a></li><li><a class="site-page child" href="/categories/%E9%AD%94%E6%94%B9/"><i class="fa-fw fa fa-bookmark"></i><span> 魔改</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 镜像网站</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://zlinni.gitee.io/"><i class="fa-fw fa fa-link"></i><span> gitee</span></a></li><li><a class="site-page child" href="https://zlinni.github.io/"><i class="fa-fw fa fa-link"></i><span> github</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-desktop"></i><span> 关于本站</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-tag"></i><span> 和我无关</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">你所不知道的JavaScript①</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-17T00:46:42.000Z" title="发表于 2022-03-17 08:46:42">2022-03-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-08T01:33:43.065Z" title="更新于 2022-04-08 09:33:43">2022-04-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/">前端进阶</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20,084</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>81分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="你所不知道的JavaScript①"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>首先js的类型有基本数据类型和引用类型<br>前者有七种 后者是一种<br>根据以前的USONB理论 大致是<br><code>Undefined</code>,<code>String</code>,<code>Symbol</code>,<code>Object</code>,<code>Null</code>,<code>Number</code>,<code>BigInt</code>,<code>Boolean</code></p>
<h2 id="基本数据类型的作用？"><a href="#基本数据类型的作用？" class="headerlink" title="基本数据类型的作用？"></a>基本数据类型的作用？</h2><p>基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p>
<h2 id="object为什么是引用类型？"><a href="#object为什么是引用类型？" class="headerlink" title="object为什么是引用类型？"></a><code>object</code>为什么是引用类型？</h2><p>而引用类型 在创建对象的时候会在堆内存中开辟一个空间 用来存放对象的属性 在为对象添加属性的时候，是将属性放在堆内存中开辟的空间里。<br>在栈内存中保存显示 对象名+一个地址 类似于指针 执行堆内存中对象开辟的空间<br>引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念；占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。<br>引申出栈和堆的概念！</p>
<h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a><code>BigInt</code></h2><div class="note primary flat"><p>js的精度只有2的53次方，所以当数据大于这个数的时候会出现解析不准确(最后一位被四舍五入)，这个时候就需要这个库来帮忙解决。</p>
</div>
<ul>
<li>业务场景</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = axios.create(&#123;</span><br><span class="line">  <span class="attr">transformResponse</span>:[</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JSONbigint.parse(data);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//注意这里的jsonbigint是引入bigint所随意取的一个名称，一般在请求之前将数据使用这个库帮助js进行解析，这里是挂载axios进行预处理。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建bigint，只需要在数字结尾加个n即可。或者使用<code>BigInt()</code>构造函数，但此时要传入字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">99151651515165151n</span>)<span class="comment">//99151651515165151n</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">99151651515165151</span>)<span class="comment">//99151651515165150 会四舍五入最后一位，解析不准确</span></span><br><span class="line"><span class="built_in">BigInt</span>(<span class="string">&quot;99151651515165151&quot;</span>)<span class="comment">//99151651515165151n 注意要传入字符串！！</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意控制台中输出bigint的数据 是绿色的。</li>
<li>不能用三个等于判断<code>BigInt</code>和常规数字 因为它们的类型不同</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">10n</span>===<span class="number">10</span>)<span class="comment">//false;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">10n</span>)<span class="comment">//BigInt</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不支持一元加号(+)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10n</span> + <span class="number">20n</span>;    <span class="comment">// → 30n</span></span><br><span class="line"><span class="number">10n</span> - <span class="number">20n</span>;    <span class="comment">// → -10n</span></span><br><span class="line">+<span class="number">10n</span>;         <span class="comment">// → TypeError: Cannot convert a BigInt value to a number</span></span><br><span class="line">-<span class="number">10n</span>;         <span class="comment">// → -10n</span></span><br><span class="line"><span class="number">10n</span> * <span class="number">20n</span>;    <span class="comment">// → 200n</span></span><br><span class="line"><span class="number">20n</span> / <span class="number">10n</span>;    <span class="comment">// → 2n</span></span><br><span class="line"><span class="number">23n</span> % <span class="number">10n</span>;    <span class="comment">// → 3n</span></span><br><span class="line"><span class="number">10n</span> ** <span class="number">3n</span>;    <span class="comment">// → 1000n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">10n</span>;</span><br><span class="line">++x;          <span class="comment">// → 11n</span></span><br><span class="line">--x;          <span class="comment">// → 9n</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h1><p>在js的执行过程中，主要有三种类型的内存空间，一是代码空间，二是栈空间，三是堆空间。代码空间顾名思义就是存储代码用的，栈空间是用来保存变量和变量值的，堆空间是保存地址的。<br>对于栈空间来说，原始类型存储的是变量的值，而引用类型存储的是在堆空间中的地址，所以当js需要访问数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手程序</p>
<h2 id="闭包是怎么存储"><a href="#闭包是怎么存储" class="headerlink" title="闭包是怎么存储"></a>闭包是怎么存储</h2><p>js引擎对于闭包的处理，是当遇到一个闭包的时候，在堆空间中创建一个<code>closure(fn)</code>对象，用来保存闭包中的变量，所以闭包中的变量是存储在堆空间中的。这就是为什么闭包可以常驻在内存的原因。</p>
<h2 id="js为什么需要栈和堆"><a href="#js为什么需要栈和堆" class="headerlink" title="js为什么需要栈和堆"></a>js为什么需要栈和堆</h2><p>首先知道栈是让变量循环利用，通常也是设置一些小数据来放入栈中，而我们知道引用类型数据obj一般占用的空间都比较大。所以js引擎需要栈和堆来维持内存的平衡。 </p>
<ul>
<li>题目1<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lee&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(a.name);  <span class="comment">//第一个console</span></span><br><span class="line">b.name = <span class="string">&#x27;son&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.name);  <span class="comment">//第二个console</span></span><br><span class="line"><span class="built_in">console</span>.log(b.name);  <span class="comment">//第三个console</span></span><br></pre></td></tr></table></figure>
第一个是lee显而易见，第二个console是son 第三个也是。这是因为a是对象 是引用类型 在赋值给b的时候 实际上是给了a在堆中的地址 所以b访问的是堆空间中a的变量 那么修改了b 自然a也会发生变动，这里就引出了堆空间共享的概念</li>
<li>题目2<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Julia&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o.age = <span class="number">24</span>;</span><br><span class="line">  o = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Kath&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = change(a);     <span class="comment">// 注意这里没有new，后面new相关会有专门文章讲解</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age);    <span class="comment">// 第一个console</span></span><br><span class="line"><span class="built_in">console</span>.log(a.age);    <span class="comment">// 第二个console</span></span><br></pre></td></tr></table></figure>
第一个输出30 第二个输出24<br>原因是function里面传入的是a在堆中的地址，那么自然a的age就会变成24 但是到了return这一步 它会把传入的内存地址修改 导致o变成另外一个内存地址 将o的数据存放在该内存中， 所以b就是kath和30</li>
</ul>
<h1 id="检测方式"><a href="#检测方式" class="headerlink" title="检测方式"></a>检测方式</h1><div class="note primary flat"><p>数据类型检测有很多种，常用的是<code>typeof instanceof constructor Object.prototype.toString.call([])</code></p>
</div>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a><code>typeof</code></h2><div class="note primary flat"><p>该方法是基于计算机底层的数据类型的二进制进行判断。 用于判断除了<code>array null</code>之外的类型,即可以判断除了<code>null</code>之外的基础数据类型和除了<code>array</code>之外的应用数据类型<br>下面看一下它对于所有类型的处理 注意它可以处理function</p>
</div>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object     []数组的数据类型在 typeof 中被解释为 object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object     null 的数据类型被 typeof 解释为 object</span></span><br></pre></td></tr></table></figure>
<ul>
<li>为什么null会被<code>typeof</code>识别成<code>object</code>？<br>这个是一个历史遗留问题 js底层是二进制存储的 前三位代表的是数据的存储类型 对于object来说则是000 而刚好null也是全0 正好代表object类型的数据格式 所以null才会输出object</li>
</ul>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h2><p>由于上面的方法不能精确判断数组和null的原因 所以产生了新的方法<code>instanceof</code><br>康康它对于所有类型的处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false  </span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true    </span></span><br><span class="line"><span class="comment">// console.log(undefined instanceof Undefined);</span></span><br><span class="line"><span class="comment">// console.log(null instanceof Null);</span></span><br></pre></td></tr></table></figure>
<p>和由此可见 <code>instanceof</code>方法能准确的判断引用数据类型 但是不能判断基础数据类型<br>因为它的原理是和原型链相关的 ,相当于判断是不是这个类的实例，所以对于<code>undefined和null</code>来说，这两者是没有原型的 所以无法判断。<br>引申一下 <code>null</code>是所有原型的终点 <code>undefined</code>是表示没有这个值 缺少这个值 </p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><code>constructor</code></h2><p>构造器判断方法 注意带括号 否则会报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">2</span>).constructor === <span class="built_in">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).constructor === <span class="built_in">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="string">&#x27;str&#x27;</span>).constructor === <span class="built_in">String</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(([]).constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).constructor === <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;).constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>弊端是 如果改变了对象原型，该方法会失效</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">Fn.prototype=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> f=<span class="keyword">new</span> Fn();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===Fn);    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===<span class="built_in">Array</span>); <span class="comment">// true </span></span><br></pre></td></tr></table></figure>
<h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a><code>Object.prototype.toString.call()</code></h2><p>使用<code>Object</code>上面的<code>toString</code>方法 会返回一个格式为<code>[object Xxx]</code>的字符串，通过call重新调用就可以精确判断对象类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString(&#123;&#125;)       <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;)  <span class="comment">// 同上结果，加上call也ok</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>)    <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;1&#x27;</span>)  <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>)  <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)  <span class="comment">// &quot;[object Function]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)   <span class="comment">//&quot;[object Null]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">//&quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/123/g</span>)    <span class="comment">//&quot;[object RegExp]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">//&quot;[object Date]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([])       <span class="comment">//&quot;[object Array]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>)  <span class="comment">//&quot;[object HTMLDocument]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>)   <span class="comment">//&quot;[object Window]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面这段代码可以看出，Object.prototype.toString.call() 可以很好地判断引用类型，甚至可以把 document 和 window 都区分开来。</span></span><br></pre></td></tr></table></figure>
<p>由于代码过长 推荐封装一下<code>Object.prototype.toString</code><br>实现一个全局通用的判断方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> type = <span class="keyword">typeof</span> obj;</span><br><span class="line">	<span class="comment">//如果是基本类型 直接返回</span></span><br><span class="line">	<span class="keyword">if</span>(type!==<span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> type;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toStirng.call(obj).replace(<span class="regexp">/^\[object (\S+)\]$/</span>, <span class="string">&#x27;$1&#x27;</span>);  <span class="comment">// 注意正则中间有个空格</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 代码验证，需要注意大小写，哪些是typeof判断，哪些是toString判断？思考下 */</span></span><br><span class="line">getType([])     <span class="comment">// &quot;Array&quot; typeof []是object，因此toString返回</span></span><br><span class="line">getType(<span class="string">&#x27;123&#x27;</span>)  <span class="comment">// &quot;string&quot; typeof 直接返回</span></span><br><span class="line">getType(<span class="built_in">window</span>) <span class="comment">// &quot;Window&quot; toString返回</span></span><br><span class="line">getType(<span class="literal">null</span>)   <span class="comment">// &quot;Null&quot;首字母大写，typeof null是object，需toString来判断</span></span><br><span class="line">getType(<span class="literal">undefined</span>)   <span class="comment">// &quot;undefined&quot; typeof 直接返回</span></span><br><span class="line">getType()            <span class="comment">// &quot;undefined&quot; typeof 直接返回</span></span><br><span class="line">getType(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// &quot;function&quot; typeof能判断，因此首字母小写</span></span><br><span class="line">getType(<span class="regexp">/123/g</span>)      <span class="comment">//&quot;RegExp&quot; toString返回</span></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220316104931.png" alt=""></p>
<h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><div class="note primary flat"><p>在js中 类型转换有三种情况 分别是</p>
</div>
<ul>
<li>转换为布尔值</li>
<li>转换为数字</li>
<li>转化为字符串</li>
</ul>
<p>一图流：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220330090846.png" alt=""></p>
<h2 id="转Boolean"><a href="#转Boolean" class="headerlink" title="转Boolean"></a>转<code>Boolean</code></h2><div class="note primary flat"><p>在条件判断的时候，除了<code>undefined</code>,<code>null</code>,<code>false</code>,<code>NaN</code>,<code>`,0,</code>-0`，其他值都会转成true 包括对象</p>
</div>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>)          <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>)       <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>)  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>)        <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">1</span>)          <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">13</span>)         <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27;12&#x27;</span>)       <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h2 id="对象转原始类型"><a href="#对象转原始类型" class="headerlink" title="对象转原始类型"></a>对象转原始类型</h2><div class="note primary flat"><p>对象转原始类型的时候，会调用内置的<code>[[ToPrimitive]]</code>函数，对于该函数来说，算法逻辑一般如下</p>
</div>
<ul>
<li>如果已经是原始类型了，那么就不需要转换了</li>
<li>调用<code>x.valueOf()</code>如果转换为基础类型，那么就返回转换的值。</li>
<li>调用<code>toString()</code>如果转换为基础类型，就返还转换的值。</li>
<li>如果都没有返回原始类型，就会报错。</li>
</ul>
<div class="note primary flat"><p>当然你也可以重写<code>Symbol.toPrimitive</code>该方法在转原始类型的时候调用优先级最高</p>
</div>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">toStirng</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>+a <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<h2 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a>四则运算符</h2><div class="note primary flat"><p>他有以下几个特点：</p>
</div>
<ul>
<li>运算中如果其中一方为字符串，就会把另外一方也转换成字符串。</li>
<li>如果其中一方不是字符串或者数字，那么会将他转换成数字或者字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>+<span class="string">&#x27;1&#x27;</span> <span class="comment">//11</span></span><br><span class="line"><span class="literal">true</span>+<span class="literal">true</span> <span class="comment">//2</span></span><br><span class="line"><span class="number">4</span>+[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">//41,2,3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第一行 特点一</li>
<li>第二行 特点二</li>
<li>第三行 特点二</li>
</ul>
<div class="note primary flat"><p>另外对于加法还需要注意表达式<code>a ++ b</code></p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> + + <span class="string">&#x27;b&#x27;</span> <span class="comment">// &quot;aNaN&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>因为<code>+ &#39;b&#39;</code>的结果是<code>NaN</code> 所以…且在部分代码中有尝试使用+某个值的形式来快速获取number类型</li>
<li>那么对于除了加法的运算符来说，只要其中一方是数字，那么另外一方就会被转为数字。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>*<span class="string">&#x27;3&#x27;</span><span class="comment">//12</span></span><br><span class="line"><span class="number">4</span>*[] <span class="comment">//0</span></span><br><span class="line"><span class="number">4</span>*[<span class="number">1</span>,<span class="number">2</span>] <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><ul>
<li>如果是对象，就通过<code>toPrimitive</code>转换对象。</li>
<li>如果是字符串，就通过<code>unicode</code>字符索引来比较。 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a&gt;-<span class="number">1</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>在以上代码中，a是对象，所以通过<code>valueOf</code>转化为原始类型再比较</p>
</div>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><div class="note primary flat"><p>强制类型转换的方式包括<code>Number()</code>,<code>parseInt()</code>,<code>parseFloat()</code>,<code>toString()</code>,<code>String()</code>,<code>Boolean()</code>这几种方法都比较类似。</p>
</div>
<ul>
<li><code>Number</code>的强制转换规则</li>
<li>如果是布尔值 <code>true</code>是1 <code>false</code>是0</li>
<li>如果是数字，返回自身</li>
<li>如果是<code>null</code> 返回 0</li>
<li>如果是<code>undefined</code> 返回<code>NaN</code></li>
<li>如果是字符串 遵循以下规则：如果字符串中只包含数字 或者是<code>0x</code>开头的十六进制数字字符串，允许包含正负号。则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为0；如果不是以上格式的字符串，均返回<code>NaN</code></li>
<li>如果是<code>Symbol</code> 抛出错误</li>
<li>如果是对象，并且部署了<code>[Symbol.toPrimitive]</code>，那么调用此方法，否则调用<code>valueOf</code>方法，然后根据前面的规则返回转换的值。如果转换的结果是<code>NaN</code>，那么调用对象的<code>toString()</code>方法，再次按照前面的规则返回对应的值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>);        <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>);       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;0111&#x27;</span>);      <span class="comment">//111</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>);        <span class="comment">//0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;&#x27;</span>);          <span class="comment">//0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;1a&#x27;</span>);        <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">Number</span>(-<span class="number">0X11</span>);       <span class="comment">//-17</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;0X11&#x27;</span>)       <span class="comment">//17</span></span><br></pre></td></tr></table></figure>
<h2 id="Object的转换规则"><a href="#Object的转换规则" class="headerlink" title="Object的转换规则"></a>Object的转换规则</h2><div class="note primary flat"><p>对象转换的规则，会先调用内置的<code>[Symbol.ToPrimitive]</code>函数，其规则逻辑如下：</p>
</div>
<ul>
<li>如果部署了该方法，优先调用再返回。</li>
<li>调用<code>valueOf</code>如果转换为基础类型 则返回</li>
<li>调用<code>toStirng</code>如果转换为基础类型 则返回</li>
<li>如果都没有 则报错</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="number">1</span>); <span class="comment">// 输出5</span></span><br><span class="line"><span class="comment">// 因为有[Symbol.toPrimitive]所以输出的是5</span></span><br><span class="line"><span class="comment">// 如果没有则使用valueOf 输出3</span></span><br><span class="line"><span class="comment">// 如果删掉valueOf 则返回31 字符串拼接</span></span><br><span class="line"><span class="comment">// 再看两个特殊的case：</span></span><br><span class="line"><span class="number">10</span> + &#123;&#125;</span><br><span class="line"><span class="comment">// &quot;10[object Object]&quot;</span></span><br><span class="line"><span class="comment">// 没有primitive 则先调用valueOf 发现返回的值是&#123;&#125; 不是基础类型 所以调用toString 返回[object Object]再拼接</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="literal">undefined</span>,<span class="number">4</span>,<span class="number">5</span>] + <span class="number">10</span></span><br><span class="line"><span class="comment">// &quot;1,2,,4,510&quot;，</span></span><br><span class="line"><span class="comment">// 没有primitive 则先调用valueOf 发现返回的是数组 不是基础类型 继续调用toString 返回1,2,,4,5 字符串拼接 最后结果是1,2,,4,510</span></span><br></pre></td></tr></table></figure>
<h2 id="的隐式转换规则"><a href="#的隐式转换规则" class="headerlink" title="==的隐式转换规则"></a><code>==</code>的隐式转换规则</h2><ul>
<li>如果类型相同，无需进行类型转换。</li>
<li>如果其中一个是<code>null</code>或者<code>undefined</code> 那么另外一个操作符必须是<code>null</code>或者<code>undefined</code>才会返true 否则都是false</li>
<li>如果其中一个是<code>Symbol</code>类型 那么返回true</li>
<li>两个操作值如果是<code>string</code>和<code>number</code>类型，则转字符串为<code>number</code></li>
<li>如果一个是<code>boolean</code>则转<code>number</code></li>
<li>如果一个操作值为<code>object</code>且另一方为<code>number string or Symbol</code>就会把<code>object</code>转化为原始类型再进行判断</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>       <span class="comment">// true  规则2</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span>               <span class="comment">// false 规则2</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="literal">null</span>              <span class="comment">// false 规则2</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span>                 <span class="comment">// true  规则4 字符串转隐式转换成Number之后再对比</span></span><br><span class="line"><span class="string">&#x27;123&#x27;</span> == <span class="number">123</span>            <span class="comment">// true  规则4 字符串转隐式转换成Number之后再对比</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>              <span class="comment">// true  e规则 布尔型隐式转换成Number之后再对比</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span>               <span class="comment">// true  e规则 布尔型隐式转换成Number之后再对比</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意这里a又可以等于1、2、3</span></span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a ==<span class="number">3</span>);  <span class="comment">//true f规则 Object隐式转换</span></span><br><span class="line"><span class="comment">// 注：但是执行过3遍之后，再重新执行a==3或之前的数字就是false，因为value已经加上去了，这里需要注意一下</span></span><br></pre></td></tr></table></figure>
<h2 id="的隐式转换规则-1"><a href="#的隐式转换规则-1" class="headerlink" title="+的隐式转换规则"></a><code>+</code>的隐式转换规则</h2><div class="note primary flat"><p>加号操作符，，不仅可以用作数字相加，还可以用作字符串拼接，仅当加号两边都是数字的到时候，进行的是加法运算，如果两边都是字符串，直接拼接，无需进行隐式转换。</p>
</div>
<ul>
<li>如果其中有一个是字符串，另外一个是<code>undefined</code>,<code>null</code>或者布尔型，则调用<code>toStirng</code>方法进行字符串拼接；如果是纯对象，数组，正则等。则默认调用对象的转换方法会存在优先级，然后再进行拼接。</li>
<li>如果其中有一个是数字，另外一个是<code>undefined</code>,<code>null</code>或者布尔型，则会将其转换成数字进行加法运算，对象同上一条规则。</li>
<li>如果其中一个是字符串，另一个是数字，则拼接。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span>        <span class="comment">// 3  常规情况</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="string">&#x27;2&#x27;</span>    <span class="comment">// &#x27;12&#x27; 常规情况</span></span><br><span class="line"><span class="comment">// 下面看一下特殊情况</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="literal">undefined</span>   <span class="comment">// &quot;1undefined&quot; 规则1，undefined转换字符串</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="literal">null</span>        <span class="comment">// &quot;1null&quot; 规则1，null转换字符串</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="literal">true</span>        <span class="comment">// &quot;1true&quot; 规则1，true转换字符串</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="number">1n</span>          <span class="comment">// &#x27;11&#x27; 比较特殊字符串和BigInt相加，BigInt转换为字符串</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">undefined</span>     <span class="comment">// NaN  规则2，undefined转换数字相加NaN</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">null</span>          <span class="comment">// 1    规则2，null转换为0</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">true</span>          <span class="comment">// 2    规则2，true转换为1，二者相加为2</span></span><br><span class="line"><span class="number">1</span> + <span class="number">1n</span>            <span class="comment">// 错误  不能把BigInt和Number类型直接混合相加</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="number">3</span>           <span class="comment">// &#x27;13&#x27; 规则3，字符串拼接</span></span><br></pre></td></tr></table></figure>
<h2 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a><code>null</code>和<code>undefined</code>的区别</h2><ul>
<li>首先<code>undefined</code>和<code>null</code>都是基本数据类型，这两个基本数据类型分别都只有一个值。就是<code>undefined</code>和<code>null</code></li>
<li><code>undefined</code>代表的含义是未定义，<code>null</code>代表的含义是空对象，其实不是真的对象。一般变量声明了还没有定义的时候是<code>undefined</code>，<code>null</code>主要用于赋值给一些可能返回对象的变量，作为初始化。</li>
</ul>
<div class="note primary flat"><p>其实null不是对象，虽然<code>typeof null</code>会输出<code>object</code>，但是这个只是js的历史遗留问题，000开头的是对象，null也是正好全0 所以判了是object 但实际不是</p>
</div>
<ul>
<li><code>undefined</code>在js中不是一个保留字，这意味着我们可以用<code>undefined</code>来作为一个变量名，but这样的做法非常的危险，他会影响我们对<code>undefined</code>值的判断。但我们可以通过一些方法获取安全的<code>undefined</code>值，比如说<code>void 0</code></li>
</ul>
<h1 id="This"><a href="#This" class="headerlink" title="This"></a><code>This</code></h1><div class="note primary flat"><p>this指向调用其的对象。顺带一提，es6中的箭头函数没有<code>this</code>,<code>argument</code>,<code>super</code>等。这些只依赖包含箭头函数最接近的函数。</p>
</div>
<div class="note primary flat"><p>先来看适用场景</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">foo()<span class="comment">//指向window window没有a 输出undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo() <span class="comment">//指向obj 输出2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> foo() <span class="comment">//指向c new绑定了c c没有a 输出undefined</span></span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>箭头函数中的this</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a()()())</span><br><span class="line"><span class="comment">//箭头函数的this指向第一个包含他的普通函数的this这里是window</span></span><br></pre></td></tr></table></figure>
<ul>
<li>另外对箭头函数使用bind这类函数是没有用的</li>
<li>那么说到bind 有没有考虑过一个函数多次bind的结果是什么？</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>) &#125;</span><br><span class="line">fn.bind().bind(a)() <span class="comment">// =&gt; window</span></span><br><span class="line"><span class="comment">//可以发现给函数bind几次 fn中的this永远由第一次bind决定</span></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="comment">// fn.bind().bind(a) 等于</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply()</span><br><span class="line">  &#125;.apply(a)</span><br><span class="line">&#125;</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>this的绑定优先级如下：<br><code>new</code>最高，然后是<code>bind</code>，之后是<code>obj.foo()</code> 最后是<code>foo()</code> 同时<code>this</code>一旦被绑定，就不会被任何方式改变。</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220331091103.png" alt=""></p>
<p>因为满足不了业务需求 所以产生了三种方式让我们手动改变this的指向<code>call apply bind</code></p>
<h1 id="apply-call-bind-原理"><a href="#apply-call-bind-原理" class="headerlink" title="apply/call/bind 原理"></a>apply/call/bind 原理</h1><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220331091536.png" alt=""></p>
<div class="note primary flat"><p>这三个方法都是挂载在Function对象上的三个方法，调用这三个方法的必须是一个函数。</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func.call(thisArg, param1, param2, ...)</span><br><span class="line">func.apply(thisArg, [param1,param2,...])</span><br><span class="line">func.bind(thisArg, param1, param2, ...)</span><br></pre></td></tr></table></figure>
<ul>
<li>在浏览器中，全局范围内的this指向window对象</li>
<li>在函数中，this永远指向最后调用它的那个对象</li>
<li>构造函数中，this指向被new出来的新对象</li>
<li><code>call apply bind</code>中的this被强绑定在指定的那个对象上</li>
<li>箭头函数中的this比较特殊。箭头函数this作为父作用域的this，不是调用时的this，要知道前四种方式都是调用时确定，也就是动态的，然而箭头函数的this是静态的，声明的时候就确定了下来。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220331092027.png" alt=""></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value)</span><br><span class="line">&#125;</span><br><span class="line">getValue.call(a, <span class="string">&#x27;poe&#x27;</span>, <span class="string">&#x27;24&#x27;</span>)</span><br><span class="line">getValue.apply(a, [<span class="string">&#x27;poe&#x27;</span>, <span class="string">&#x27;24&#x27;</span>])</span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化</p>
</div>
<h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><div class="note primary flat"><p>用<code>Object.prototype.toStirng</code>来判断类型是最合适的，借用它我们几乎可以判断所有类型的数据。</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="keyword">typeof</span> obj;</span><br><span class="line">  <span class="keyword">if</span>(type!==<span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).replace(<span class="regexp">/^$/</span>,<span class="string">&#x27;$1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类数组借用方法"><a href="#类数组借用方法" class="headerlink" title="类数组借用方法"></a>类数组借用方法</h2><div class="note primary flat"><p>var arrayLike = {<br>  0: ‘java’,<br>  1: ‘script’,<br>  length: 2<br>}<br>Array.prototype.push.call(arrayLike, ‘jack’, ‘lily’);<br>console.log(typeof arrayLike); // ‘object’<br>console.log(arrayLike);<br>// {0: “java”, 1: “script”, 2: “jack”, 3: “lily”, length: 4}</p>
</div>
<div class="note primary flat"><p>用call方法来借用Array原型链上面的push方法 实现一个类数组的push方法，给arrayLike添加元素</p>
</div>
<h2 id="获取数组最大值-最小值"><a href="#获取数组最大值-最小值" class="headerlink" title="获取数组最大值/最小值"></a>获取数组最大值/最小值</h2><div class="note primary flat"><p>我们可以用apply来实现数组中判断最大最小值，apply直接传递数组作为调用方法的参数。也可以减少一步展开数组，直接使用Math的方法来获取最大最小。</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">13</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>];</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, arr); </span><br><span class="line"><span class="keyword">const</span> min = <span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, arr);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(max);  <span class="comment">// 16</span></span><br><span class="line"><span class="built_in">console</span>.log(min);  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<h2 id="实现一个bind函数"><a href="#实现一个bind函数" class="headerlink" title="实现一个bind函数"></a>实现一个bind函数</h2><p>对于实现以下几个函数，可以从几个方面思考。</p>
<ul>
<li>不传入第一个参数，那么默认为window</li>
<li>改变了this指向，让新的对象可以执行该函数，那么思路是否可以变成给新的对象添加一个函数 最后执行完再删除。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否是new 是的话变成指向function 否则指向context</span></span><br><span class="line">        <span class="keyword">var</span> _this = <span class="built_in">this</span> <span class="keyword">instanceof</span> self ? <span class="built_in">this</span> : context;</span><br><span class="line">        <span class="comment">//改变f的原型链</span></span><br><span class="line">        F.prototype = self.prototype;</span><br><span class="line">        <span class="keyword">return</span> self.apply(_this, args.concat(...arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现一个call函数"><a href="#实现一个call函数" class="headerlink" title="实现一个call函数"></a>实现一个call函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(args)</span><br><span class="line">  <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现一个apply函数"><a href="#实现一个apply函数" class="headerlink" title="实现一个apply函数"></a>实现一个apply函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myapply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">Symbol</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line">    context[key] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> result = context[key](...args);</span><br><span class="line">    <span class="keyword">delete</span> context[key];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h1><div class="note primary flat"><p>当执行js代码的时候，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数的代码会产生函数执行环境，只此两种执行环境。</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b() <span class="comment">// call b</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;Hello world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;call b&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>上面的输出是因为变量提升。通常的解释是声明的代码移动到顶部。但更准确的解释是，在生成执行环境时，会有两个阶段，一个是创建阶段:js解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为undefined，所以在第二个阶段，也就是代码执行阶段，我们可以提前使用。</p>
</div>
<ul>
<li>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b() <span class="comment">// call b second</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;call b fist&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;call b second&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;Hello world&#x27;</span></span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p><code>var</code>会产生很多错误，所以在es6中引入了<code>let</code>，它不能在声明前使用，但并不是说它没有提升，他有提升，且也在声明的时候开辟了内存，但因为它的这个特性导致它不能在声明前使用。</p>
</div>
<h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><div class="note primary flat"><p>当执行js代码的时候，会产生三种执行上下文</p>
</div>
<ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li><code>eval</code>执行上下文</li>
</ul>
<div class="note primary flat"><p>每个执行上下文都有三种重要属性</p>
</div>
<ul>
<li>变量对象（VO),包含变量，函数声明和函数的形参，该属性只能在全局上下文中访问。</li>
<li>作用域链，js采用词法作用域链，也就是说变量的作用域是在定义的时候决定了。</li>
<li><code>this</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>对于上述代码代码中，执行栈中有两个上下文：全局上下文和函数foo上下文</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack = [</span><br><span class="line">    globalContext,</span><br><span class="line">    fooContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>对于全局上下文来说，VO大概是这样的</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">globalContext.VO === globe</span><br><span class="line">globalContext.VO = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="literal">undefined</span>,</span><br><span class="line">	<span class="attr">foo</span>: &lt;<span class="built_in">Function</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>对于函数foo来说，VO不能访问，只能访问到活动对象AO</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fooContext.VO === foo.AO</span><br><span class="line">fooContext.AO &#123;</span><br><span class="line">    <span class="attr">i</span>: <span class="literal">undefined</span>,</span><br><span class="line">	<span class="attr">b</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">arguments</span>: <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// arguments 是函数独有的对象(箭头函数没有)</span></span><br><span class="line"><span class="xml">// 该对象是一个伪数组，有 `length` 属性且可以通过下标访问元素</span></span><br><span class="line"><span class="xml">// 该对象中的 `callee` 属性代表函数本身</span></span><br><span class="line"><span class="xml">// `caller` 属性代表函数的调用者</span></span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>IIFE注意事项</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo = <span class="number">10</span></span><br><span class="line">    <span class="built_in">console</span>.log(foo)</span><br><span class="line">&#125;()) <span class="comment">// -&gt; ƒ foo() &#123; foo = 10 ; console.log(foo) &#125;</span></span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>js解释器在遇到IIFE的时候，会创建一个辅助的特定对象，然后将函数的名称（这里是foo）作为这个特定对象的属性。因此函数内部才可以访问到foo，但这个值是只读的，所以我们并不能修改 也不能像这样对他赋值改变，所以最后打印的还是这个函数，并且外部的值也没有改变</p>
</div>
<p>总结<br><div class="note primary flat"><p>执行上下文可以简单理解为一个对象</p>
</div></p>
<p>它包含三个部分</p>
<ul>
<li>变量对象VO</li>
<li>作用域链 词法作用域</li>
<li>this指向</li>
</ul>
<p>它的类型</p>
<ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li><code>eval</code>执行上下文</li>
</ul>
<p>代码执行的过程</p>
<ul>
<li>创建全局执行上下文 （global EC）</li>
<li>全局执行上下文(caller)逐行 自上而下执行。遇到函数的时候，函数执行上下文(callee)被push到执行栈顶层</li>
<li>函数执行上下文被激活后，成为<code>active EC</code> 开始执行函数中的代码，<code>caller</code>被挂起</li>
<li>函数执行完后，<code>callee</code>被pop出执行栈，控制权还给全局上下文(caller)继续执行</li>
</ul>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><ul>
<li>作用域：作用域就是定义变量的区域，他有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找</li>
<li>作用域链：作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数</li>
</ul>
<div class="note primary flat"><p>作用域链本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象</p>
</div>
<ul>
<li>当我们查找一个变量的时候，如果在当前执行环境中没有找到，我们可以沿着作用域链向后查找</li>
<li>作用域链的创建过程和执行上下文的建立有关。</li>
</ul>
<div class="note primary flat"><p>作用域可以理解为变量的可访问性 总共分为三种类型 分别为：</p>
</div>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域</li>
</ul>
<h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><div class="note primary flat"><p>全局变量是挂载在window对象下的变量，所以在网页中的任何位置都可以使用并且访问到这个全局变量。</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalName = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(globalName) <span class="comment">// global</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;inner&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(name) <span class="comment">// inner</span></span><br><span class="line">&#125; </span><br><span class="line">getName();</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// </span></span><br><span class="line"><span class="built_in">console</span>.log(globalName); <span class="comment">//global</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  vName = <span class="string">&#x27;setName&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">setName();</span><br><span class="line"><span class="built_in">console</span>.log(vName); <span class="comment">// setName</span></span><br></pre></td></tr></table></figure>
<ul>
<li>全局变量在什么地方可以被访问到</li>
<li>但是可能会引起命名冲突的问题，所以定义变量的时候注意作用域</li>
</ul>
<h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><div class="note primary flat"><p>函数中定义的变量叫做函数变量，这个时候只有在函数内部才能访问到它，所以它的作用域也就是函数的内部称为函数作用域</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;inner&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">//inner</span></span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>除了这个函数内部，其他地方都是不能访问到它的，同时当这个函数被执行完之后，这个局部变量也会相应被销毁，所以外面访问不到这个局部变量</p>
</div>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><div class="note primary flat"><p>es6新增了块级作用域，直接的表现就是let关键字。使用它定义的变量只能在块级作用域中被访问。有暂时性死区的特点。也就是说这个变量在定义之前是不能被使用的。</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//a is not defined</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&#x27;123&#x27;</span>；</span><br><span class="line">  <span class="built_in">console</span>.log(a)； <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//a is not defined</span></span><br><span class="line"><span class="comment">//如果这里是var 那么结果就是三个123</span></span><br></pre></td></tr></table></figure>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><div class="note primary flat"><p>闭包其实就是一个可以访问其他函数内部变量的函数。创建闭包的常见方式是在一个函数内创建另外一个函数，创建的函数可以访问到当前函数的局部变量。</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(a);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br><span class="line"><span class="keyword">var</span> result = fun1();</span><br><span class="line">result();  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合闭包的概念，我们把这段代码放到控制台执行一下，就可以发现最后输出的结果是 1（即 a 变量的值）。那么可以很清楚地发现，a 变量作为一个 fun1 函数的内部变量，正常情况下作为函数内的局部变量，是无法被外部访问到的。但是通过闭包，我们最后还是可以拿到 a 变量的值</span></span><br></pre></td></tr></table></figure>
<h2 id="闭包的两个常用的用途"><a href="#闭包的两个常用的用途" class="headerlink" title="闭包的两个常用的用途"></a>闭包的两个常用的用途</h2><ul>
<li>闭包的第一个用途是使我们在函数外部能够访问到内部的变量。</li>
<li>另外一个用途是使得已经允许结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象 的引用，所以这个变量对象不会被回收。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// fn 是闭包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="comment">// 这里也是闭包</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn2 = fn1()</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure>
<h2 id="闭包产生的原因"><a href="#闭包产生的原因" class="headerlink" title="闭包产生的原因"></a>闭包产生的原因</h2><div class="note primary flat"><p>闭包产生的本质是：当前环境中存在指向父级作用域的引用。</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">//2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fun2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = fun1();</span><br><span class="line">result();</span><br></pre></td></tr></table></figure>
<ul>
<li>在上面这段代码中，我们知道，result会拿到父级作用域的变量输出2。因为在当前的环境中，含有对fun2函数的引用，而fun2中又引用了window和fun1，fun2，那么此时fun2可以访问到fun1中的2 那么就输出2</li>
<li>那是不是只有返回函数才算是产生了闭包？其实不是，回到闭包的本质。我们只需要让父级作用域的引用存在即可。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun3;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  fun3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br><span class="line">fun3();</span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>可以看出其中输出的结果还是2 因为在给fun3赋值的时候，fun3就可以访问到window fun1和本身的作用域，然后由下往上查找 找到了fun1中的2 输出2</p>
</div>
<p>结论：<br>不能通过最后有没有返回函数来判断闭包。</p>
<h2 id="闭包的表现形式"><a href="#闭包的表现形式" class="headerlink" title="闭包的表现形式"></a>闭包的表现形式</h2><ol>
<li>返回一个函数</li>
<li>在定时器，事件监听，ajax请求，webworkers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时器</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;，<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">$(<span class="string">&#x27;#app&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Event Listener&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>作为函数参数传递的形式<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(baz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 这就是闭包</span></span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 输出2，而不是1</span></span><br></pre></td></tr></table></figure></li>
<li>IIFE创建了闭包 保存了全局作用域window和当前函数的作用域。因此可以输出全局作用域的变量。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">// 输出2</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IIFE 这个函数会稍微有些特殊，算是一种自执行匿名函数，这个匿名函数拥有独立的作用域。这不仅可以避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域，我们经常能在高级的 JavaScript 编程中看见此类函数。</span><br></pre></td></tr></table></figure>
<h2 id="如何解决循环输出问题？"><a href="#如何解决循环输出问题？" class="headerlink" title="如何解决循环输出问题？"></a>如何解决循环输出问题？</h2><div class="note primary flat"><p>code如下</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难发现 最后的结果是五个6 那么为什么是五个6？如何实现输出12345？</p>
<ul>
<li>首先是事件循环机制 同步任务执行完之后再去执行任务栈中的宏任务微任务，settimeout是宏任务，因此循环结束后它的回调才依次执行。</li>
<li>因为settimeout是一种闭包，往上查找它的父级作用域是window，而变量i是var声明，是window对象上面的全局变量，所以开始执行settimeout的时候i已经是6了 所以最后连续输出的都是6</li>
</ul>
<div class="note primary flat"><p>那么如何依次输出12345呢？</p>
</div>
<ol>
<li>利用IIFE <div class="note primary flat"><p>可以利用IIFE 每次for循环的时候把此时的变量传递到定时器里面，然后执行。</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>利用es6的let<div class="note primary flat"><p>let有块级作用域，代码以块级执行 相当于任务每次都是等待块级执行完再执行下一个块级</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>利用定时器传入第三个参数<div class="note primary flat"><p>定时器的第三个参数是传入的值，可以是一个function</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j)</span><br><span class="line">  &#125;, <span class="number">0</span>,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="New的原理"><a href="#New的原理" class="headerlink" title="New的原理"></a>New的原理</h1><h2 id="常见考点"><a href="#常见考点" class="headerlink" title="常见考点"></a>常见考点</h2><ul>
<li>new做了什么事情？</li>
<li>new返回不同的类型时有声明表现？</li>
<li>手写new的实现过程<div class="note primary flat"><p>new关键字的主要作用就是执行一个构造函数，返回一个实例对象，在new的过程中，根据构造函数的情况，来确定是否可以接收参数的传递。下面见例子。</p>
</div>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.log(p.name)  <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>
<p>p是通过person这个构造函数生成的一个实例对象。</p>
<div class="note primary flat"><p>new可以帮助我们构建出一个实例，并且绑定上this，执行的步骤为以下：</p>
</div>
<ol>
<li>创建一个新的对象</li>
<li>将对象连接到构造函数原型上，并绑定this this指向新对象</li>
<li>执行构造函数的代码（为这个新对象添加属性）</li>
<li>返回新对象</li>
</ol>
<p>在第四步返回新对象的时候会有一个情况例外：<br><div class="note primary flat"><p>如果不用new关键字会怎么样？</p>
</div></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = Person();</span><br><span class="line"><span class="built_in">console</span>.log(p) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// &#x27;name&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<ul>
<li>从上面的代码可以看出，不用new 结果是undefined。因为默认情况下this指向window 所以name是Jack </li>
<li>那么如果构造函数中return一个对象，结果会是怎么样呢？</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&#x27;Jack&#x27;</span>; </span><br><span class="line">   <span class="keyword">return</span> &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.log(p)  <span class="comment">// &#123;age: 18&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p.age) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>通过这段代码可以看出，当构造函数最后return出来的是一个和this无关的对象的时候，new会直接返回这个对象，而不是通过new执行步骤生成的this对象</p>
</div>
<p>但如果这里构造函数返回的不是一个对象 还是会按照new的原则返回新生成的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&#x27;Jack&#x27;</span>; </span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;tom&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.log(p)  <span class="comment">// &#123;name: &#x27;Jack&#x27;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>总结：new关键字执行之后返回一个对象，要么是实例对象，要不是return语句指定的对象</p>
</div>
<h2 id="手写new的实现过程"><a href="#手写new的实现过程" class="headerlink" title="手写new的实现过程"></a>手写new的实现过程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">fn,...args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> fn != <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//我们知道obj.__proto__ = fn.prototype的</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">  <span class="keyword">var</span> res = fn.apply(obj,args);</span><br><span class="line">  <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用<code>Object.create</code>创建一个空对象并将obj的proto指定为构造函数原型</li>
<li>使用apply方法 将构造函数内的this指向为obj</li>
<li>在create返回的时候使用三目运算符决定返回结果</li>
</ol>
<h1 id="原型、原型链"><a href="#原型、原型链" class="headerlink" title="原型、原型链"></a>原型、原型链</h1><p><code>__proto__</code>和prototype的关系：<code>__proto__</code>和<code>constructor</code>是对象独有的，<code>prototype</code>是函数独有的。</p>
<div class="note primary flat"><p>在js中我们使用构造函数来新建一个对象，每一个构造函数的内部都有一个prototype属性，这个属性是一个对象，这个对象包含了可以由该构造函数的所有实例共享的方法和属性。当我们使用构造函数新建一个对象之后，在这个对象的内部将包含一个指针，这个指针指向构造函数的prototype属性对应的值，在es5中这个指针被称为对象的原型。一般来说不能获取到这个值，但是浏览器下载都实现了<code>proto</code>属性让我们来访问，但是最好是不要使用这个属性，因为他不是规范的，最好使用<code>Object.getPrototypeOf()</code>来获取对象的原型</p>
</div>
<p>当我们访问一个对象的属性的时候，如果这个对象内部不存在这个属性，那么他就会去他的原型对象里面找这个属性，这个原型对象又会有自己的原型，于是就一直找下去，也就是原型链的概念。原型链的尽头一般来说是<code>Object.prototype</code>所以这就是我们新建的对象为什么能够使用<code>toString</code>等方法的原因</p>
<div class="note primary flat"><p>特点：js的对象都是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型的时候，与之相关的对象也会继承这一改变。</p>
</div>
<ul>
<li>原型，一个简单的对象，用于实现对象的属性继承。</li>
<li>构造函数 可以通过new来创建对象的一个函数</li>
<li>实例 通过构造函数和new创建出来的对象。通过<code>__proto__</code>指向原型，通过<code>constructor</code>指向构造函数。</li>
</ul>
<div class="note primary flat"><p>以<code>Object</code>为例，他是一个构造函数，因此可以用它创建实例</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>则此时， 实例为instance, 构造函数为Object，我们知道，构造函数拥有一个prototype的属性指向原型，因此原型为:</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型</span></span><br><span class="line"><span class="keyword">const</span> prototype = <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure>
<p>三者关系：</p>
<ul>
<li><code>实例.__proto__ === 原型</code></li>
<li><code>原型.constructor === 构造函数</code></li>
<li><code>构造函数.prototype = 原型</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402093146.png" alt=""></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><div class="note primary flat"><p>原型链是由原型对象组成，每个对象都有<code>__proto__</code>属性，指向了创建该对象的构造函数的原型。<code>__proto__</code>将对象连接起来组成了原型链，是一个用来实现继承和共享属性的有限的对象链。</p>
</div>
<ul>
<li>属性查找机制：当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象<code>Object.prototype</code>，如还是没找到，则输出<code>undefined</code>；</li>
<li>属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: <code>b.prototype.x = 2</code>；但是这样会造成所有继承于该对象的实例的属性发生改变。</li>
</ul>
<h2 id="js获取原型的方法"><a href="#js获取原型的方法" class="headerlink" title="js获取原型的方法"></a>js获取原型的方法</h2><ul>
<li><code>p.__proto__</code></li>
<li><code>p.constructor.prototype</code></li>
<li><code>Object.getPrototypeOf(p)</code></li>
</ul>
<p>另外：</p>
<ul>
<li>每个函数都有<code>prototype</code>属性，除了<code>Function.prototype.bind()</code> 该属性指向原型。</li>
<li>每个对象都有<code>__proto__</code>属性，指向了创建该对象的构造函数的原型</li>
<li>对象可以通过<code>__proto__</code>来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了原型链。</li>
</ul>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220402094159.png" alt=""><br><div class="note primary flat"><p>涉及面试题：原型如何实现继承？class如何实现继承？class本质</p>
</div><br>首先讲一下class，其实在js中不存在类，class只是语法糖，本质还是函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line">Person <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><div class="note primary flat"><p>组合继承是最常用的继承方式</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = value;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//通过call的方式来继承父类的属性(调用构造x1)</span></span><br><span class="line">    Parent.call(<span class="built_in">this</span>,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过改变子类的原型来继承父类的函数（x2 此时继承了构造函数，多了不必要的属性）</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> children = <span class="keyword">new</span> Child(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">children.getValue()</span><br><span class="line"><span class="built_in">console</span>.log(children <span class="keyword">instanceof</span> Parent)<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过call来继承父类的属性，然后改变子类的原型来继承父类的函数。</li>
<li>优点：构造函数可以传参，不会和父类引用属性共享，可以复用父类的函数。</li>
<li>缺点：继承父类的时候调用了两次父类的构造函数，把父类不必要的属性也给继承了。内存上面浪费</li>
</ul>
<h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><div class="note primary flat"><p>这种方法对组合继承进行了优化，组合继承的缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点即可。</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.val = value</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>,value);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype,&#123;</span><br><span class="line">  <span class="attr">constructor</span>:&#123;</span><br><span class="line">    <span class="attr">value</span>:Child,</span><br><span class="line">    <span class="attr">enumerable</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line">child.getValue();</span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Parent)</span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>以上继承将父类的原型赋值给了子类，并且将构造函数设置成了子类，这样解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p>
</div>
<h2 id="Class继承"><a href="#Class继承" class="headerlink" title="Class继承"></a>Class继承</h2><div class="note primary flat"><p>以上两种方式都是通过原型去解决的，在es6中我们可以通过class去实现继承，并且实现起来很简单</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(value)</span><br><span class="line">    <span class="built_in">this</span>.val = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line">child.getValue();</span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Parent)</span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>class实现继承的核心在于使用extends表明继承自哪个父类，并且在子类构造函数中必须调用super<br>super可以看作<code>Parent.call(this,value)</code></p>
</div>
<div class="note warning flat"><p>其实这样做还是有缺陷的，比如父类的静态方法还是不能继承。</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寄生组合继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = value</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.val)</span><br><span class="line">&#125;</span><br><span class="line">Parent.staticMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是静态&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, value);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: Child,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line">child.getValue();</span><br><span class="line"><span class="comment">//Child.staticMethod()//报错</span></span><br><span class="line">Parent.staticMethod()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而class继承则可以<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">caseA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我是静态&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(value)</span><br><span class="line">    <span class="built_in">this</span>.val = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line">child.getValue();</span><br><span class="line">Child.caseA()</span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Parent)</span><br></pre></td></tr></table></figure></p>
<h2 id="其他继承"><a href="#其他继承" class="headerlink" title="其他继承"></a>其他继承</h2><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="对象遍历"><a href="#对象遍历" class="headerlink" title="对象遍历"></a>对象遍历</h2><ol>
<li><code>for in</code></li>
<li><code>Object.keys(xxx)</code>把key取出来作为一个数组。</li>
<li><code>Object.values(xxx)</code>遍历对象的值作为一个数组<h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2></li>
</ol>
<ul>
<li>基本思想是使用对象，类，继承，封装等基本概念来进行程序设计</li>
<li>优点：<ul>
<li>易维护：采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，维护也只是在局部模块，所以维护起来非常方便，成本较低</li>
<li>易拓展</li>
<li>开发工作的重用性，继承性高，降低重复工作量</li>
<li>缩短了开发周期<div class="note primary flat"><p>一般面向对象包括：继承，封装，多态，抽象</p>
</div>
</li>
</ul>
</li>
</ul>
<h2 id="对象形式的继承"><a href="#对象形式的继承" class="headerlink" title="对象形式的继承"></a>对象形式的继承</h2><div class="note primary flat"><p>讲深浅拷贝之前，我们需要知道，基本数据类型在栈里面，被复制了就算修改也不会改变原来的的值，引用数据类型在堆里面，因为共享内存所以复制后被修改会改变源对象的值，至此引申出深浅拷贝。</p>
</div>
<ul>
<li>浅拷贝<div class="note primary flat"><p>基本的浅拷贝就是对象的赋值，但我们需要注意，实际上我们的需求是复制源对象上面的属性，那么单纯的赋值，会把新对象的值给覆盖掉。参见下面</p>
</div>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;allin&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">home</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">        <span class="attr">office</span>: <span class="string">&#x27;office&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">sclools</span>: [<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;z&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> programer = &#123;</span><br><span class="line">    <span class="attr">language</span>: <span class="string">&#x27;js&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果不使用该方法 programmer里面的language会被覆盖掉</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">p, c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = c || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> prop <span class="keyword">in</span> p)&#123;</span><br><span class="line">        c[prop] = p[prop];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">extend(Person, programer);</span><br><span class="line"><span class="comment">//or </span></span><br><span class="line"><span class="comment">// programer = Object.assign(programer,Person);</span></span><br><span class="line">programer.name;  <span class="comment">// allin</span></span><br><span class="line">programer.address.home;  <span class="comment">// home</span></span><br><span class="line">programer.address.home = <span class="string">&#x27;house&#x27;</span>;  <span class="comment">//house</span></span><br><span class="line">Person.address.home;  <span class="comment">// house</span></span><br><span class="line"><span class="comment">//programmer依旧保留自己的language</span></span><br></pre></td></tr></table></figure>
<div class="note warning flat"><p>注意 浅拷贝不是新对象的地址指向整个旧对象的地址，而是拷贝旧对象的属性的地址。即自己原先的内容不变，拷贝的过程中如果key重复覆盖，否则保留。<br>思路是遍历对象 赋值。</p>
</div>
<p>深拷贝<br><div class="note primary flat"><p>深拷贝是开辟一个新的内存地址，将源对象的各个属性复制进去<br>注意的点：对象原型上面的属性不应该去拷贝，使用到<code>Object.hasOwnProperty(key)</code></p>
</div></p>
<ol>
<li>通过<code>JSON.parse(JSON.stringfy())</code>进行深拷贝</li>
</ol>
<ul>
<li>是序列化和反序列化的过程，序列化是存储地址的一个映射，所以反序列化之后，修改并不会影响原先的地址。就可以达成深拷贝。</li>
<li>缺点：不能拷贝<code>undefined function 正则 Error对象</code></li>
</ul>
<ol>
<li>递归</li>
</ol>
<ul>
<li>通过判断引用类型数据进行初始化之后赋值的操作指向新的地址。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断是否是引用类型或者null 否则返回源对象进行浅拷贝</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>||obj===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是数组，初始化地址。</span></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        result = [];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归调用 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            result[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
<li>缺点：栈会溢出。</li>
</ul>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul>
<li>命名空间<ul>
<li>js是没有命名空间的，因此可以用对象来模拟</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = &#123;&#125;<span class="comment">//命名空间app</span></span><br><span class="line"><span class="comment">//模块1</span></span><br><span class="line">app.module1 = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;allin&#x27;</span>,</span><br><span class="line">  <span class="attr">f</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">app.module1.name;</span><br><span class="line">app.module1.f();</span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>对象的属性外界是可读可写的，那么如何达到封装的目的？通过闭包和局部变量</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Girl</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//通过方法访问变量</span></span><br><span class="line">  <span class="keyword">var</span> love = <span class="string">&#x27;jojo&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.name =name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> love;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.movelove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    love = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Girl(<span class="string">&#x27;bb&#x27;</span>,<span class="number">19</span>);</span><br><span class="line">g.say();</span><br><span class="line">g.movelove();</span><br><span class="line">g.say();</span><br></pre></td></tr></table></figure>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><div class="note primary flat"><p>就是在函数外面定义静态方法，静态方法只有该类能够使用。</p>
</div>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员</span></span><br><span class="line">Person.walk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;static&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Person.walk();  <span class="comment">// static</span></span><br></pre></td></tr></table></figure>
<h2 id="私有与公有"><a href="#私有与公有" class="headerlink" title="私有与公有"></a>私有与公有</h2><div class="note primary flat"><p>对象的方法和属性分为私有和公有，公有的属性需要在实例化的时候传入对应的值去调用，私有的属性和方法只能通过公有的方法暴露出去。注意私有的方法如果返回的是公有的属性，还需要使用call改变this指向</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 私有属性与方法</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;allin&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//公有属性与方法</span></span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;say hello&#x27;</span>);</span><br><span class="line">        work.call(<span class="built_in">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="number">123</span>);</span><br><span class="line">p1.name; <span class="comment">// undefined</span></span><br><span class="line">p1.id;  <span class="comment">// 123</span></span><br><span class="line">p1.say();  <span class="comment">// say hello 123</span></span><br></pre></td></tr></table></figure>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><div class="note primary flat"><p>同一个父类继承出来的子类有各自的形态,写的时候注意<code>子类,prototype = new 父类()</code></p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.eat = <span class="string">&#x27;肉&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tiger</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.color = <span class="string">&#x27;黑黄相间&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cheetah</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.color = <span class="string">&#x27;报文&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Lion</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.color = <span class="string">&#x27;土黄色&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tiger.prototype =  Cheetah.prototype = Lion.prototype = <span class="keyword">new</span> Cat();<span class="comment">//共享一个祖先 Cat</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> T = <span class="keyword">new</span> Tiger();</span><br><span class="line"><span class="keyword">var</span> C = <span class="keyword">new</span> Cheetah();</span><br><span class="line"><span class="keyword">var</span> L = <span class="keyword">new</span> Lion();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(T.color);</span><br><span class="line"><span class="built_in">console</span>.log(C.color);</span><br><span class="line"><span class="built_in">console</span>.log(L.color);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(T.eat);</span><br><span class="line"><span class="built_in">console</span>.log(C.eat);</span><br><span class="line"><span class="built_in">console</span>.log(L.eat);</span><br></pre></td></tr></table></figure>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><div class="note primary flat"><p>虚函数是类成员中的概念，是只做了一个声明而未实现的方法，具有虚函数的类称之为抽象类。抽象类不能被实例化因为其中的虚函数并不是一个完整的函数，不能被调用。<br>在js中实现抽象类就是在父类中调用一个未定义的方法，但这个方法在子类中必须被实现。</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AbstractClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象类不能直接被调用&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">AbstractClass.prototype.detect = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">AbstractClass.prototype.stop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;stop&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">AbstractClass.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NormalClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  NormalClass.prototype = <span class="built_in">Object</span>.create(AbstractClass.prototype);</span><br><span class="line">  NormalClass.prototype.constructor = NormalClass;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> NormalClass();</span><br><span class="line"><span class="built_in">console</span>.log(n)</span><br><span class="line">n.detect();</span><br><span class="line">n.init();</span><br></pre></td></tr></table></figure>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><ol>
<li>面向对象的三个基本特征</li>
<li>手写一下函数的公有和私有方法以及调用的形式<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;jojo&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">    sayName.call(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><div class="note primary flat"><p>事件的触发过程？事件代理？</p>
</div>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><div class="note primary flat"><p>事件流是一个事件沿着特定数据结构传播的过程。冒泡和捕获是事件流在DOM中的两种不同的传播方式。</p>
</div>
<h2 id="事件流的三个阶段"><a href="#事件流的三个阶段" class="headerlink" title="事件流的三个阶段"></a>事件流的三个阶段</h2><ul>
<li>事件捕获阶段</li>
<li>目标阶段</li>
<li>事件冒泡阶段</li>
</ul>
<h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><div class="note primary flat"><p>事件捕获通俗的理解就是鼠标点击或者触发dom事件的时候，浏览器从根节点开始由外到内的进行事件传播，即点击了子元素。如果父元素通过捕获方式注册了对应的事件的话，会先触发父元素绑定的事件</p>
</div>
<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><div class="note primary flat"><p>事件冒泡和事件捕获相反，顺序是由内到外直到根节点</p>
</div>
<p>无论是事件捕获还是冒泡，都有一个共同的特征就是事件传播<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220404101558.png" alt=""></p>
<h2 id="事件流阻止"><a href="#事件流阻止" class="headerlink" title="事件流阻止"></a>事件流阻止</h2><div class="note primary flat"><p>在一些情况下要阻止事件流的传播，阻止默认动作的发生</p>
</div>
<ul>
<li><code>event.preventDefault()</code>取消事件对象的默认动作以及继续传播</li>
<li><code>event.stopPropagation()/event.cancelBubble = true</code>阻止事件冒泡<h3 id="在不同浏览器的处理"><a href="#在不同浏览器的处理" class="headerlink" title="在不同浏览器的处理"></a>在不同浏览器的处理</h3></li>
<li>在IE下使用 <code>event.returnValue= false</code>，</li>
<li>在非IE下则使用 <code>event.preventDefault()</code>进行阻止<h3 id="preventDefault与stopPropagation的区别"><a href="#preventDefault与stopPropagation的区别" class="headerlink" title="preventDefault与stopPropagation的区别"></a><code>preventDefault</code>与<code>stopPropagation</code>的区别</h3></li>
<li><code>preventDefault</code>告诉浏览器不用执行与事件相关联的默认动作（如表单提交）</li>
<li><code>stopPropagation</code>是停止事件继续冒泡，但是对IE9以下的浏览器无效<h2 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h2></li>
<li>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 <code>false</code>。useCapture 决定了注册的事件是捕获事件还是冒泡事件</li>
<li>一般来说，我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件<div class="note warning flat"><p>注意<code>addEventListener</code>需要销毁，<code>onClick</code>则不需要因为每次都替换</p>
</div>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2></li>
<li>优化性能，当子节点过多的时候给父元素绑定事件通过冒泡只执行一次事件节省内存并且不需要给子节点注销事件。<h2 id="事件的兼容写法"><a href="#事件的兼容写法" class="headerlink" title="事件的兼容写法"></a>事件的兼容写法</h2><div class="note primary flat"><p>ie的event和非ie的event不太一样，也不能一起用</p>
</div>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gete</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//兼容ie的事件</span></span><br><span class="line">  e = e || <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="comment">//兼容ie的target</span></span><br><span class="line">  <span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><div class="note primary flat"><p>四种方案：commonjs，AMD，CMD，ES6</p>
</div>
<ul>
<li><p>CommonJS，node的，通过require来引入模块，通过<code>module.exports</code>定义输出接口。是以同步的方式引入模块的。</p>
</li>
<li><p>AMD是采用异步的方式加载模块，模块的加载不影响后面语句的执行 所有依赖这个模块的语句都定义在一个回调函数里面，等加载完再执行回调函数。requirejs实现了AMD规范</p>
</li>
<li>CMD方案，也是解决异步加载的委托。代表有seajs。和requirejs的区别在于模块定义的时候堆依赖的处理不同和对依赖模块的执行时机处理不同。</li>
<li>最后是es6的，通过import和export进行导入导出。默认暴露统一暴露分别暴露。<ul>
<li>默认暴露：<code>export default</code></li>
<li>分别暴露：<code>export xxx1;exportxxx2</code>，引入<code>import &#123;xxx1,xxx2&#125; from &#39;xxx&#39;</code></li>
<li>统一暴露：<code>export &#123;aa1,aa1&#125;</code>，引入<code>import &#123;aa1,aa2&#125; from &#39;xxx&#39;</code></li>
</ul>
</li>
</ul>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><ul>
<li>写法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.a;<span class="comment">//1</span></span><br></pre></td></tr></table></figure></li>
<li>注意浏览器中使用的话用<code>browserify</code><div class="note primary flat"><p>和es6的区别如下：</p>
</div></li>
<li>前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案,前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。</li>
<li>而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li>
<li>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。</li>
<li>但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li>
<li>后者会编译成 require/exports 来执行的</li>
</ul>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><div class="note primary flat"><p>和CMD的区别：</p>
</div>
<ul>
<li>对依赖的处理不一样。AMD是依赖前置。定义模块的时候就要声明依赖的模块，CMD就近依赖，用到哪个才去require</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>); <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐</span></span><br><span class="line">define([<span class="string">&quot;./a&quot;</span>, <span class="string">&quot;./b&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>对于依赖模块的执行实际处理不同。AMD和CMD异步加载，但是AMD在模块加载完就立刻执行依赖模块，依赖模块的执行顺序和我们写的顺序不一定一致。而CMD在依赖模块加载完成后并不执行，只是下载。等全部的依赖模块都加载好后，再去执行，和我们的书写顺序一致。</li>
</ul>
<h1 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h1><div class="note primary flat"><p>Iterator是一种接口，也可以说是一种规范，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。即依次处理该数据结构的所有成员</p>
</div>
<p>语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note primary flat"><p><code>[Symbol.iterator]</code>属性名是固定的写法，只要拥有了该属性的对象，就能用迭代器的方式进行遍历。</p>
</div></p>
<ul>
<li>迭代器的遍历方法是首先获得一个迭代器的指针。初始时该指针指向第一条数据之前，接着通过调用next方法，改变指针的指向，让他调用下一条数据。</li>
<li>每次的next都会返回一个对象 有两个属性<ul>
<li>value： 表示你想获取的数据</li>
<li>done：布尔值 代表遍历是否结束 true则结束<h2 id="iterator的作用"><a href="#iterator的作用" class="headerlink" title="iterator的作用"></a>iterator的作用</h2>三个作用</li>
</ul>
</li>
<li>创建一个指针对象指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>
<li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li>
<li>第二次调用指针对象的next方法 指针指向第二个成元</li>
<li>不断调用next 直到结束位置(假如有三个数据 需要next四次 最后一次的结果是<code>&#123; value: undefined, done: true &#125;</code>)<br>案例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123;<span class="attr">nums</span>:<span class="number">1</span>&#125;,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="built_in">Symbol</span>.iterator]();<span class="comment">//获取数组的迭代器</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: Object &#123; num: 1 &#125;, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="具有iterator接口的数据结构"><a href="#具有iterator接口的数据结构" class="headerlink" title="具有iterator接口的数据结构"></a>具有iterator接口的数据结构</h2><div class="note primary flat"><p>一个数据结构只要有iterator接口就能被认为是可以遍历的。可以用forof。</p>
</div>
具有iterator接口的数据结构的有四种：</li>
</ul>
<ol>
<li>数组</li>
<li>类数组</li>
<li>Set</li>
<li>Map<h2 id="为什么对象没有iterator接口"><a href="#为什么对象没有iterator接口" class="headerlink" title="为什么对象没有iterator接口"></a>为什么对象没有iterator接口</h2></li>
</ol>
<ul>
<li>对象只能用forin和<code>Object.keys、values</code>遍历</li>
<li>因为一个对象的哪个属性先遍历和后便利是不确定的，需要开发者手动指定。</li>
<li>对对象部署iterator接口没有必要 因为map弥补了他的缺陷而且map有iterator接口<br>对对象部署iterator<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    <span class="attr">hobbie</span>: <span class="string">&#x27;睡觉&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keyArr = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> index&lt;keyArr.length?&#123;</span><br><span class="line">        <span class="attr">value</span>:&#123;</span><br><span class="line">          <span class="attr">key</span>:keyArr[index],</span><br><span class="line">          <span class="attr">val</span>:obj[keyArr[index++]]</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;:&#123;</span><br><span class="line">        <span class="attr">done</span>:<span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><div class="note primary flat"><p>谈到promise的时候，除了将他解决的痛点以及常用的api之外，最好进行拓展吧eventloop带进来好好讲一下。微任务，任务的指向顺序，如果看过promise源码，最好可以谈一谈原生promise是如何实现的，还有就是promise的链式调用</p>
</div>
<ul>
<li>promise是es6新增的语法，解决了回调地狱的问题</li>
<li>promise可以被看成是一个状态机，初始是<code>pending</code>可以通过函数<code>resolve</code>和<code>reject</code>将状态转变为<code>resolved</code>or<code>rejected</code>状态。状态一旦发生改变就不能再次变化。</li>
<li>then函数会返回一个promise实例，并且该返回值是一个新的实例而不是之前的实例。因为promise规范规定除了pending状态，其他状态是不能改变的。如果返回的是一个相同实例的话，多个then调用就失去了意义。对于then来说，本质上可以看成是flatMap</li>
</ul>
<h2 id="promise的基本情况"><a href="#promise的基本情况" class="headerlink" title="promise的基本情况"></a>promise的基本情况</h2><div class="note primary flat"><p>简单来说他是一个容器，里面保存着某个未来才会结束的事件，通常是异步操作的结果。从语法上面来说，promise是一个对象，从他可以获取异步操作的消息。</p>
</div>
<p>一般 Promise 在执行过程中，必然会处于以下几种状态之一。</p>
<ul>
<li>待定（pending）：初始状态，既没有被完成，也没有被拒绝。</li>
<li>已完成（fulfilled）：操作成功完成。</li>
<li>已拒绝（rejected）：操作失败。<div class="note primary flat"><p>待定状态的promise对象指向的话，最后要么会通过一个值完成，要么会通过一个原因被拒绝。当其中一种情况发生的时候，我们用promise的then方法排列起来的相关处理程序就会被调用。因为最后<code>Promise.prototype.then</code> 和 <code>Promise.prototype.catch</code>方法返回的是一个<code>Promise</code>所以它们可以继续被链式调用。</p>
</div>
关于 Promise 的状态流转情况，有一点值得注意的是，内部状态改变之后不可逆，你需要在编程过程中加以注意。文字描述比较晦涩，我们直接通过一张图就能很清晰地看出 Promise 内部状态流转的情况<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220405105526.png" alt=""><h2 id="then-catch"><a href="#then-catch" class="headerlink" title="then catch"></a>then catch</h2></li>
<li>thencatch都会返回一个新的promise</li>
<li>catch不管放在哪里都能捕获上层未捕获的错误</li>
<li>不写默认返回<code>return Promise.resolve(undefined)</code>也是成功回调</li>
<li>直接return 一个error对象不会抛出错误 所以不会被catch捕获</li>
<li>返回的值不能是promise本身 否则死循环</li>
<li>then可以接收两个参数的，在某些时候你可以认为catch是then第二个参数的简便写法。<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2></li>
<li>不管最后的状态如何都会执行</li>
<li>不接受任何参数 所以在finally中是没办法知道最终的状态的</li>
<li>默认返回上一次的promise对象值，如果抛出的是一个异常则返回异常的promise对象</li>
</ul>
<h2 id="new-Promise（大坑）"><a href="#new-Promise（大坑）" class="headerlink" title="new Promise（大坑）"></a><code>new Promise</code>（大坑）</h2><p>先看一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    reject()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;失败的状态&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><br>正确答案是1243<br>这是为什么呢？因为我们会忽略一个问题，就是在<code>new Promise</code>的时候，方法就已经开始执行了，虽然我们一般提倡用函数封装之后<code>return</code>出去这个promise对象。所以就是先执行<code>new Promise</code>里面的代码 输出12然后状态到<code>resolved</code>然后执行同步的4 最后因为成功的回调到3</p>
<h2 id="promise的静态方法"><a href="#promise的静态方法" class="headerlink" title="promise的静态方法"></a>promise的静态方法</h2><h3 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h3><ul>
<li>语法:<code>Promise.all(iterable)</code></li>
<li>参数：一个可迭代对象，例如Array（括号里面放数组）</li>
<li>描述：此方法对于汇总多个promise的结果很有用，在es6中可以将多个<code>Promise.all</code>异步请求并发操作，返回的结果一般有下面两种情况。<ol>
<li>当所有结果成功返回按照请求顺序返回成功结果</li>
<li>当其中一个方法失败就进入失败方法。</li>
</ol>
</li>
<li>业务场景 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个页面中需要加载获取轮播列表、获取店铺列表、获取分类列表这三个操作，页面需要同时发出请求进行页面渲染，这样用 `Promise.all` 来实现，看起来更清晰、一目了然。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获取轮播数据列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBannerList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;轮播数据&#x27;</span>)</span><br><span class="line">      &#125;,<span class="number">300</span>) </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.获取店铺列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStoreList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">&#x27;店铺数据&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">500</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.获取分类列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCategoryList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">&#x27;分类数据&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">700</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initLoad</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">Promise</span>.all([getBannerList(),getStoreList(),getCategoryList()])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) </span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; </span><br><span class="line">initLoad()</span><br></pre></td></tr></table></figure>
<h4 id="all如果有一个抛出了异常会如何处理。"><a href="#all如果有一个抛出了异常会如何处理。" class="headerlink" title="all如果有一个抛出了异常会如何处理。"></a>all如果有一个抛出了异常会如何处理。</h4><div class="note primary flat"><p>all和race传入的数组中如果会有抛出异常的异步任务，那么只有最先抛出的错误会被捕获。并且是被then的第二个参数或者后面的catch捕获，但并不影响数组中其他的异步任务的执行。</p>
</div>
<h4 id="all是并发的还是串行的"><a href="#all是并发的还是串行的" class="headerlink" title="all是并发的还是串行的"></a>all是并发的还是串行的</h4><div class="note primary flat"><p>并发的。不过<code>promise.all().then()</code>结果中数组的顺序和<code>Promise.all()</code>接收到的数组顺序一致</p>
</div>
<h4 id="all的并发限制"><a href="#all的并发限制" class="headerlink" title="all的并发限制"></a>all的并发限制</h4><div class="note primary flat"><p>Promise.all可以保证，promises数组中所有promise对象都达到resolve状态，才执行then回调。</p>
<p>这时候考虑一个场景：如果你的promises数组中每个对象都是http请求，或者说每个对象包含了复杂的调用处理。而这样的对象有几十万个。</p>
<p>那么会出现的情况是，你在瞬间发出几十万http请求（tcp连接数不足可能造成等待），或者堆积了无数调用栈导致内存溢出。</p>
<p>这时候，我们就需要考虑对Promise.all做并发限制。</p>
<p>Promise.all并发限制指的是，每个时刻并发执行的promise数量是固定的，最终的执行结果还是保持与原来的Promise.all一致。</p>
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncPool</span>(<span class="params">poolLimit, array, iteratorFn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line">    <span class="keyword">const</span> executing = [];</span><br><span class="line">    <span class="keyword">const</span> enqueue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 边界处理，array为空数组</span></span><br><span class="line">        <span class="keyword">if</span> (i === array.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每调一次enqueue，初始化一个promise</span></span><br><span class="line">        <span class="keyword">const</span> item = array[i++];</span><br><span class="line">        <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> iteratorFn(item, array));</span><br><span class="line">        <span class="comment">// 放入promises数组</span></span><br><span class="line">        ret.push(p);</span><br><span class="line">        <span class="comment">// promise执行完毕，从executing数组中删除</span></span><br><span class="line">        <span class="keyword">const</span> e = p.then(<span class="function">() =&gt;</span> executing.splice(executing.indexOf(e), <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 插入executing数字，表示正在执行的promise</span></span><br><span class="line">        executing.push(e);</span><br><span class="line">        <span class="comment">// 使用Promise.rece，每当executing数组中promise数量低于poolLimit，就实例化新的promise并执行</span></span><br><span class="line">        <span class="keyword">let</span> r = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">        <span class="keyword">if</span> (executing.length &gt;= poolLimit) &#123;</span><br><span class="line">            r = <span class="built_in">Promise</span>.race(executing);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归，直到遍历完array</span></span><br><span class="line">        <span class="keyword">return</span> r.then(<span class="function">() =&gt;</span> enqueue());</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> enqueue().then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.all(ret));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="allSettled方法"><a href="#allSettled方法" class="headerlink" title="allSettled方法"></a><code>allSettled</code>方法</h3><ul>
<li><code>Promise.allSettled</code>的语法及参数跟<code>Promise.all</code>类似.不同在于它执行完之后不会失败，会按顺序返回每个promise的状态</li>
<li>案例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="built_in">Promise</span>.allSettled([resolved, rejected]);</span><br><span class="line">allSettledPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回结果：</span></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 2 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>
<h3 id="any方法-还在草案不能使用"><a href="#any方法-还在草案不能使用" class="headerlink" title="any方法(还在草案不能使用)"></a>any方法(还在草案不能使用)</h3><ul>
<li>语法：<code>Promise.any（iterable）</code></li>
<li>参数： iterable 可迭代的对象，例如 Array。</li>
<li>描述：any返回一个promise 只要参数promise实例中有一个变成fulfilled状态，最后any返回的实例就返回fulfilled状态，如果全部都是rejected，就返回rejected状态<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> anyPromise = <span class="built_in">Promise</span>.any([resolved, rejected]);</span><br><span class="line">anyPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回结果：</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="race方法"><a href="#race方法" class="headerlink" title="race方法"></a>race方法</h3><ul>
<li>语法：<code>Promise.race（iterable）</code></li>
<li>参数： iterable 可迭代的对象，例如 Array。</li>
<li>描述： race方法返回一个promise，只要参数的promise之中有一个实例率先改变状态，那么race方法的返回状态就跟着改变。那个率先改变的promise实例的返回值就传递给race方法的回调函数。</li>
<li>业务场景：图片加载 超时判断</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求某个图片资源</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestImg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; resolve(img); &#125;</span><br><span class="line">    img.src = <span class="string">&#x27;http://www.baidu.com/img/flexible/logo/pc/result.png&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//延时函数，用于给请求计时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; reject(<span class="string">&#x27;图片请求超时&#x27;</span>); &#125;, <span class="number">5000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([requestImg(), timeout()])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面的代码中可以看出，采用 Promise 的方式来判断图片是否加载成功，也是针对 Promise.race 方法的一个比较好的业务场</span></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220405111554.png" alt=""></p>
<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><div class="note primary flat"><p>generator是es6新增的语法，和promise一样可以用来异步编程，最大的特点是它可以利用yield和next分段执行。</p>
</div>
<ul>
<li><code>function *foo(x)</code>使用<em>号来声明该函数是一个生成器函数，`</em>`的位置比较随意。</li>
<li><code>yield</code>关键字用来实现分段执行，它的意思是产出，当生成器函数遇到yield的时候会暂停并把他后面的表达式抛出去。（注意yield可以不写在生成器中）</li>
<li><code>next</code>表示将代码的控制权还给生成器函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = foo(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(it.next())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>过程：</p>
<ul>
<li>首先执行第一个next的时候传参会被忽略 因为赋值的时候已经传了参 所以参数就是5 且到第一个yield停止。返回后面的结果 就是6 此时x为5</li>
<li>来到第二个next 传入的参数覆盖上一次yield的结果 所以此时y为<code>12*2=24</code> 那么返回的结果就是8</li>
<li>第三个next 传入的参数覆盖上一次yield的结果 所以此时z为13 那么总体就是<code>5+24+13=42</code></li>
</ul>
<h2 id="简单实现generator"><a href="#简单实现generator" class="headerlink" title="简单实现generator"></a>简单实现generator</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cb 也就是编译过的 test 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generator</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> object = &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">stop</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = cb(object);</span><br><span class="line">        <span class="keyword">if</span> (ret === <span class="literal">undefined</span>) <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: ret,</span><br><span class="line">          <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果你使用 babel 编译后可以发现 test 函数变成了这样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="keyword">return</span> generator(<span class="function"><span class="keyword">function</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> ((_context.prev = _context.next)) &#123;</span><br><span class="line">        <span class="comment">// 可以发现通过 yield 将代码分割成几块</span></span><br><span class="line">        <span class="comment">// 每次执行 next 函数就执行一块代码</span></span><br><span class="line">        <span class="comment">// 并且表明下次需要执行哪块代码</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">          _context.next = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">          _context.next = <span class="number">6</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">		<span class="comment">// 执行完毕</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">          <span class="keyword">return</span> _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a><code>async/await</code></h1><div class="note primary flat"><p>Generator的语法糖，有更好的语义性和适用性，返回的是promise</p>
</div>
<ul>
<li>await和promise一样更多是笔试题</li>
<li>await相比直接使用promise来说 优势在于处理then的调用链，能够更清晰的写出代码。缺点在于await可能导致性能问题。因为await会阻塞代码。也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性，此时更应该使用<code>Promise.all</code></li>
<li>一个函数如果加上了async 那么就会返回一个promise<div class="note primary flat"><p><code>async =&gt; *</code> <code>await =&gt; yield</code></p>
</div>
案例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + <span class="keyword">await</span> <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>, a) <span class="comment">// -&gt; &#x27;2&#x27; 10</span></span><br><span class="line">  a = (<span class="keyword">await</span> <span class="number">10</span>) + a</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>, a) <span class="comment">// -&gt; &#x27;3&#x27; 20</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>, a) <span class="comment">// -&gt; &#x27;1&#x27; 1</span></span><br></pre></td></tr></table></figure></li>
<li>首先函数b执行 但是遇到了<code>await</code>暂时返还了代码的控制权，所以到外面去执行了a++并输出a为1。</li>
<li>又因为await内部实现了generators，且它会保留堆栈中的东西，所以在返还之前的a=0被保留了下来。输出10 然后是20</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><div class="note primary flat"><p>async/await的优势在于处理 then 的调用链，能够更清晰准确的写出代码，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。</p>
</div>
<h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><div class="note primary flat"><p>首先js的任务分为同步任务和异步任务，异步中又分为宏任务和微任务，我们常见的settimeout，setinterval系列就是宏任务，promise，muationobserver系列就是微任务，微任务插队宏任务。</p>
</div>
<ul>
<li>默认代码从上到下执行，执行环境通过<code>script</code>来执行</li>
<li>代码执行过程中，先执行同步任务，再执行异步任务。</li>
<li>给异步任务划分队列，分别存在微任务（立即存放）和宏任务（时间到了或者事情发生了在存放）到队列中</li>
<li>script执行后清空所有微任务。</li>
<li>微任务执行完毕后渲染页面（不是每次都调用—）</li>
<li>再去宏任务队列中看看也没有到达时间的，拿出来其中一个执行。</li>
<li>执行完毕后按上述的步骤不停循环。<br>例子(UI渲染是宏任务)<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406095138.png" alt=""><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406095150.png" alt=""><div class="note primary flat"><p>自动执行的情况 会输出 listener1 listener2 task1 task2</p>
</div>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406095222.png" alt=""><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406100602.png" alt=""><div class="note primary flat"><p>如果手动点击click 会一个宏任务取出来一个个执行，先执行click的宏任务，取出微任务去执行。会输出 listener1 task1 listener2 task2</p>
</div>
</li>
</ul>
<p>案例1<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="comment">// await xx ==&gt; promise.resolve(()=&gt;&#123;console.log(3)&#125;).then()</span></span><br><span class="line">  <span class="comment">// console.log(3) 放到promise.resolve或立即执行</span></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="number">3</span>) </span><br><span class="line">  <span class="comment">// 相当于把console.log(4)放到了then promise.resolve(()=&gt;&#123;console.log(3)&#125;).then(()=&gt;&#123;</span></span><br><span class="line">  <span class="comment">//   console.log(4)</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line">  <span class="comment">// 微任务谁先注册谁先执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">  resolve(<span class="number">7</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">d</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(d)&#125;)</span><br><span class="line"></span><br><span class="line">asyncFunc()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 1 6 2 3 8 7 4 5</span></span><br></pre></td></tr></table></figure><br>案例2<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220406101017.png" alt=""></p>
<h2 id="JS为什么是单线程？"><a href="#JS为什么是单线程？" class="headerlink" title="JS为什么是单线程？"></a>JS为什么是单线程？</h2><div class="note primary flat"><p>js的单线程和它的用途有关，作为浏览器脚本语言，JavaScript主要用途是与用户互动以及操作DOM。这决定了他只能是单线程，否则会带来很复杂的同步问题。比如假定js同时有两个线程，一个线程在某dom节点上添加内容，另外一个线程删除了节点。这个时候浏览器应该以哪个线程为准？所以为了避免复杂性，从一诞生，js就是单线程，这已经成为了这门语言的核心特征以后也不会改变。</p>
</div>
<h2 id="浏览器事件循环"><a href="#浏览器事件循环" class="headerlink" title="浏览器事件循环"></a>浏览器事件循环</h2><div class="note primary flat"><p>涉及面试题：异步代码的执行顺序？解释一下什么是Event Loop</p>
</div>
<ul>
<li>首先js是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来确保代码的有序进行。</li>
<li>在执行同步代码的时候，如果遇到了异步事件，js引擎并不会一致等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。</li>
<li>当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行</li>
<li>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行</li>
<li>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。<h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a><code>process.nextTick</code></h2><div class="note primary flat"><p><code>process.nextTick</code>指定的异步任务总是发生于所有异步任务之前。</p>
</div>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;);</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 2 5 4 3 1</span></span><br></pre></td></tr></table></figure>
<h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><ul>
<li><code>process.nextTick</code></li>
<li><code>promise</code></li>
<li><code>Object.observe</code></li>
<li><code>MutationObserver</code><h2 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h2></li>
<li><code>script</code></li>
<li><code>setTimeout</code></li>
<li><code>setInterval</code></li>
<li><code>setImmediate</code></li>
<li><code>I/O</code> 网络请求完成、文件读写完成事件</li>
<li><code>UI rendering</code></li>
<li>用户交互事件（比如鼠标点击、滚动页面、放大缩小等）</li>
</ul>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><ul>
<li>对于在js中的字符串，对象，数组是没有固定大小的，只有当对它们进行动态分配存储的时候，解释器才会分配内存来处理这些数据。当js的解释器消耗完系统中所有可用的内存的时候，就会造成系统崩溃。</li>
<li>内存泄漏，在某些情况下，不再使用到的变量所占用内存没有及时释放，导致程序运行中，内存占用越来越大，极端情况导致系统崩溃，服务器宕机。</li>
<li>js有自己的一套辣鸡回收机制，js 的解释器可以检测到什么时候程序不再使用这个对象（数据），就会把它所占用的内存释放掉。</li>
<li>针对js的来及回收机制有下面两种方法（常用）：标记清除，引用计数。</li>
<li>标记清除。<div class="note primary flat"><p>v8的辣鸡回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另外一个是不死的对象会活得更久。基于这个假说，v8引擎将内存分为了新生代和老生代。</p>
</div></li>
<li>新创建的对象或者只经过一次的辣鸡回收的对象被称为新生代，经历过多次垃圾回收的对象被称为老生代。</li>
<li>新生代被分为from和to两个空间，to一般是闲置的。当from空间满了之后会执行Scavenge算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后继续执行。</li>
</ul>
<h2 id="Scavenge"><a href="#Scavenge" class="headerlink" title="Scavenge"></a>Scavenge</h2><div class="note primary flat"><p>这个算法分三步：</p>
</div>
<ul>
<li>首先检查from空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代，如果不满足条件则移动to空间。</li>
<li>如果对象不存活，则释放对象的空间。</li>
<li>最后将From空间和to空间进行角色交换</li>
</ul>
<h2 id="新生代-gt-老生代"><a href="#新生代-gt-老生代" class="headerlink" title="新生代=&gt;老生代"></a>新生代=&gt;老生代</h2><div class="note primary flat"><p>条件有两个：</p>
</div>
<ul>
<li>第一个是判断对象是否经过一次Scavenge回收，如果经过则将对象从From空间复制到老生代中。若没有经历，则复制到to空间。</li>
<li>第二个是to空间的内存使用占比是否超过限制。当对象从from空间复制到to空间的时候，若to空间的使用超过25%，则将对象直接晋升到老生代。设置25%的原因是因为算法结束之后，两个空间结束后会交换位置，如果to空间的内存太小，会影响后续的内存分配。<div class="note primary flat"><p>老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉没有标记的对象，由于标记清除后会造成很多内存碎片，不便于后面的内存分配，所以了解内存碎片的问题引入了标记压缩法。</p>
</div>
由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。为了解决这个问题v8引入了增量标记法，将一次停顿进行的过程分为多部，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</li>
</ul>
<h2 id="什么时候回收？"><a href="#什么时候回收？" class="headerlink" title="什么时候回收？"></a>什么时候回收？</h2><div class="note primary flat"><p>v8引擎帮我们实现了自动的垃圾回收管理。利用浏览器的渲染的空闲时间进行垃圾回收</p>
</div>
<h2 id="具体的回收机制？"><a href="#具体的回收机制？" class="headerlink" title="具体的回收机制？"></a>具体的回收机制？</h2><div class="note primary flat"><p>栈内存的回收：栈内存调用栈上下文切换后就被回收，比较简单。<br>堆内存的回收：v8的堆内存分为新生代内存和老生代内存，新生代内存是临时分配的内存，存在时间短，老生代存在时间长。<br>新生代的回收机制：新生代内存容量小，64位系统下只有32m。新生代内存分为from和to两个部分。在进行扫描的时候，先扫描from，将非存活对象回收，将存活对象顺序复制到to中，之后调换fromto进行下一次回收<br>老生代的回收机制：</p>
<ul>
<li>晋升：如果新生代的变量经过多次回收依然存在，那么就会被放入老内存中。</li>
<li>标记清除：老生代内存会先遍历所有对象并打上标记，然后对正在使用或被强引用的对象取消标记，回收标记的对象。</li>
<li>整理内存碎片：把对象挪到内存的一端。</li>
</ul>
</div>
<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><h1 id="区别篇"><a href="#区别篇" class="headerlink" title="区别篇"></a>区别篇</h1><h2 id="python和js的区别"><a href="#python和js的区别" class="headerlink" title="python和js的区别"></a>python和js的区别</h2><ul>
<li>python web后端，js前后端</li>
<li>语法差异</li>
<li>数值类型有<code>int float complex</code> js有<code>Number BigInt</code></li>
</ul>
<p>题外 回调地狱？ flatMap？ set和map手写 ？ 串行？</p>
<h1 id="let-const-var"><a href="#let-const-var" class="headerlink" title="let const var"></a>let const var</h1><p>tob toc ？<br>柯里化<br>前端埋点<br>词法作用域<br>console dir<br>v8辣鸡回收</p>
<p>vue：</p>
<ul>
<li>vue2生命周期</li>
<li>ajax放created 和 mouted区别</li>
<li>放created的流程是怎么样的<br>同步执行完created mouted 请求才接收</li>
<li>了解过fetch吗？fetch存在的问题？</li>
<li>vuex的几个模块，actions可以放异步吗<br>vue3：</li>
<li>vue3性能比vue2好的原因<br>vue3的diff使用了静态标记，生成虚拟dom树的时候只对比这些内容<br>对于不参与更新的元素使用了静态提升，只会创建一次，在渲染的时候重新复用。<br>事件监听器缓存：不需要每次都追踪函数的变化，直接缓存函数起来复用。</li>
<li>vue3watch的缺陷</li>
</ul>
<p>css：</p>
<ul>
<li>使用过css变量吗？和less，sass变量有什么区别？<br>兼容性，less和sass转普通的css<br>less，sass可以插入字符串 css不行<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@direction:</span> left;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">	<span class="selector-tag">padding-</span><span class="variable">@&#123;left&#125;</span>: <span class="selector-tag">5xpx</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如何实现一个自适应正方形 讲一下思路<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/ztj771299799/article/details/79806769">https://blog.csdn.net/ztj771299799/article/details/79806769</a></li>
</ul>
<p>浏览器：</p>
<ul>
<li>window.resize的触发间隔是多少？<br>操作系统</li>
<li>进程和线程<br>进程是</li>
<li>并行和并发</li>
</ul>
<p>js：</p>
<ul>
<li>前端埋点有了解吗？优缺点</li>
<li>为什么使用gif进行请求?有什么好处？<br>gif防止跨域，防止页面的阻塞，占用空间小</li>
<li>对闭包就是返回一个函数这句话你是怎么看的？</li>
<li>闭包是怎么放在内存中的</li>
<li>有使用过Symbol和BigInt吗</li>
<li>浅拷贝和赋值的区别。</li>
</ul>
<p>场景：<br>假设现在有一个按钮，要避免多次请求你会怎么做？</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Zlinni</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zlinni.github.io/posts/fee85c52fd07/">https://zlinni.github.io/posts/fee85c52fd07/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zlinni.github.io" target="_blank">Zlinni's Blog For Study</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a class="post-meta__tags" href="/tags/js/">js</a></div><div class="post_share"><div class="social-share" data-image="/./img/js%E7%B3%BB%E5%88%97/js%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F%E5%A0%86%E5%92%8C%E6%A0%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/fa1981f36489/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/./img/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/Algorithm%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前端算法日记</div></div></a></div><div class="next-post pull-right"><a href="/posts/7fc1593f40ed/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/./img/webpack%E7%B3%BB%E5%88%97/webpack5%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Webpack5实战指南</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/139818545f14/" title="手撕万物Javascript篇"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/./img/vue%E7%B3%BB%E5%88%97/%E6%89%8B%E6%92%95%E4%B8%87%E7%89%A9js%E7%AF%87.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-15</div><div class="title">手撕万物Javascript篇</div></div></a></div><div><a href="/posts/df2fc0ed9242/" title="JavaScript(未完结)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/./img/bgc/js.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-30</div><div class="title">JavaScript(未完结)</div></div></a></div><div><a href="/posts/0941e8fc9dd3/" title="Vuejs灵魂之问"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/./img/vue%E7%B3%BB%E5%88%97/Vuejs%E7%81%B5%E9%AD%82%E4%B9%8B%E9%97%AE.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-14</div><div class="title">Vuejs灵魂之问</div></div></a></div><div><a href="/posts/62a0bd444c41/" title="计算机网络不完全指南"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/./img/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-14</div><div class="title">计算机网络不完全指南</div></div></a></div><div><a href="/posts/18a3127ce1f3/" title="HTTP灵魂之问"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/./img/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/HTTP%E7%81%B5%E9%AD%82%E4%B9%8B%E9%97%AE.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-10</div><div class="title">HTTP灵魂之问</div></div></a></div><div><a href="/posts/92dd6276498c/" title="FooTok项目杂谈"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/./img/vue%E7%B3%BB%E5%88%97/footok%E9%A1%B9%E7%9B%AE%E6%9D%82%E8%B0%88.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-24</div><div class="title">FooTok项目杂谈</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/head/boji.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Zlinni</div><div class="author-info__description">就像新年的清晨换上新内裤一样清爽~~</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" href="JavaScript:join_favorite('https://zlinni.github.io/','zlinni'+'\''+'s blog for study');"><i class="fa fa-star"></i><span>收藏本博客</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zlinni" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:984328216@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/959f01bf0881d767a936f6846424fd7.jpg" target="_blank" title="WeChat"><i class="fab fa-weixin"></i></a><a class="social-icon" href="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/f25ad3d4388a03078ea5671f024de65.jpg" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog 如果你有什么问题 请在评论区讨论或私信984328216@qq.com</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">基本数据类型的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">object为什么是引用类型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigInt"><span class="toc-number">1.3.</span> <span class="toc-text">BigInt</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E5%A0%86"><span class="toc-number">2.</span> <span class="toc-text">栈和堆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8"><span class="toc-number">2.1.</span> <span class="toc-text">闭包是怎么存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%A0%88%E5%92%8C%E5%A0%86"><span class="toc-number">2.2.</span> <span class="toc-text">js为什么需要栈和堆</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">检测方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof"><span class="toc-number">3.1.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof"><span class="toc-number">3.2.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constructor-NaN"><span class="toc-number">3.3.</span> <span class="toc-text">constructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-prototype-toString-call"><span class="toc-number">3.4.</span> <span class="toc-text">Object.prototype.toString.call()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text">数据类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%ACBoolean"><span class="toc-number">4.1.</span> <span class="toc-text">转Boolean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">对象转原始类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.3.</span> <span class="toc-text">四则运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.4.</span> <span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.5.</span> <span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="toc-number">4.6.</span> <span class="toc-text">Object的转换规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="toc-number">4.7.</span> <span class="toc-text">&#x3D;&#x3D;的隐式转换规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99-1"><span class="toc-number">4.8.</span> <span class="toc-text">+的隐式转换规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.9.</span> <span class="toc-text">null和undefined的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#This"><span class="toc-number">5.</span> <span class="toc-text">This</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#apply-call-bind-%E5%8E%9F%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">apply&#x2F;call&#x2F;bind 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">判断数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%95%B0%E7%BB%84%E5%80%9F%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">类数组借用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC-%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">6.3.</span> <span class="toc-text">获取数组最大值&#x2F;最小值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAbind%E5%87%BD%E6%95%B0"><span class="toc-number">6.4.</span> <span class="toc-text">实现一个bind函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAcall%E5%87%BD%E6%95%B0"><span class="toc-number">6.5.</span> <span class="toc-text">实现一个call函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAapply%E5%87%BD%E6%95%B0"><span class="toc-number">6.6.</span> <span class="toc-text">实现一个apply函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-number">7.</span> <span class="toc-text">变量提升</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">8.</span> <span class="toc-text">执行上下文</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">9.</span> <span class="toc-text">作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">9.1.</span> <span class="toc-text">全局作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">9.2.</span> <span class="toc-text">函数作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">9.3.</span> <span class="toc-text">块级作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">10.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">10.1.</span> <span class="toc-text">闭包的两个常用的用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">10.2.</span> <span class="toc-text">闭包产生的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="toc-number">10.3.</span> <span class="toc-text">闭包的表现形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">10.4.</span> <span class="toc-text">如何解决循环输出问题？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#New%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">11.</span> <span class="toc-text">New的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%80%83%E7%82%B9"><span class="toc-number">11.1.</span> <span class="toc-text">常见考点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99new%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">11.2.</span> <span class="toc-text">手写new的实现过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">12.</span> <span class="toc-text">原型、原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">12.1.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">js获取原型的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">13.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">13.1.</span> <span class="toc-text">组合继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">13.2.</span> <span class="toc-text">寄生组合继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class%E7%BB%A7%E6%89%BF"><span class="toc-number">13.3.</span> <span class="toc-text">Class继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%BB%A7%E6%89%BF"><span class="toc-number">13.4.</span> <span class="toc-text">其他继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%81%8D%E5%8E%86"><span class="toc-number">14.1.</span> <span class="toc-text">对象遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-number">14.2.</span> <span class="toc-text">编程思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%BD%A2%E5%BC%8F%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">14.3.</span> <span class="toc-text">对象形式的继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">14.4.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">14.5.</span> <span class="toc-text">静态成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E4%B8%8E%E5%85%AC%E6%9C%89"><span class="toc-number">14.6.</span> <span class="toc-text">私有与公有</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">14.7.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">14.8.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QA"><span class="toc-number">14.9.</span> <span class="toc-text">QA</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">15.</span> <span class="toc-text">事件机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">15.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-number">15.2.</span> <span class="toc-text">事件流的三个阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7"><span class="toc-number">15.3.</span> <span class="toc-text">事件捕获</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-number">15.4.</span> <span class="toc-text">事件冒泡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%B5%81%E9%98%BB%E6%AD%A2"><span class="toc-number">15.5.</span> <span class="toc-text">事件流阻止</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%B8%8D%E5%90%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">15.5.1.</span> <span class="toc-text">在不同浏览器的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#preventDefault%E4%B8%8EstopPropagation%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.5.2.</span> <span class="toc-text">preventDefault与stopPropagation的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%B3%A8%E5%86%8C"><span class="toc-number">15.6.</span> <span class="toc-text">事件注册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">15.7.</span> <span class="toc-text">事件委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%85%BC%E5%AE%B9%E5%86%99%E6%B3%95"><span class="toc-number">15.8.</span> <span class="toc-text">事件的兼容写法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">16.</span> <span class="toc-text">模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CommonJS"><span class="toc-number">16.1.</span> <span class="toc-text">CommonJS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AMD"><span class="toc-number">16.2.</span> <span class="toc-text">AMD</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">17.</span> <span class="toc-text">Iterator迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#iterator%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">17.1.</span> <span class="toc-text">iterator的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E6%9C%89iterator%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">17.2.</span> <span class="toc-text">具有iterator接口的数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AF%B9%E8%B1%A1%E6%B2%A1%E6%9C%89iterator%E6%8E%A5%E5%8F%A3"><span class="toc-number">17.3.</span> <span class="toc-text">为什么对象没有iterator接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise"><span class="toc-number">18.</span> <span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#promise%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5"><span class="toc-number">18.1.</span> <span class="toc-text">promise的基本情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#then-catch"><span class="toc-number">18.2.</span> <span class="toc-text">then catch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finally"><span class="toc-number">18.3.</span> <span class="toc-text">finally</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-Promise%EF%BC%88%E5%A4%A7%E5%9D%91%EF%BC%89"><span class="toc-number">18.4.</span> <span class="toc-text">new Promise（大坑）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">18.5.</span> <span class="toc-text">promise的静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#all%E6%96%B9%E6%B3%95"><span class="toc-number">18.5.1.</span> <span class="toc-text">all方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#all%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E4%B8%AA%E6%8A%9B%E5%87%BA%E4%BA%86%E5%BC%82%E5%B8%B8%E4%BC%9A%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E3%80%82"><span class="toc-number">18.5.1.1.</span> <span class="toc-text">all如果有一个抛出了异常会如何处理。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#all%E6%98%AF%E5%B9%B6%E5%8F%91%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%B2%E8%A1%8C%E7%9A%84"><span class="toc-number">18.5.1.2.</span> <span class="toc-text">all是并发的还是串行的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#all%E7%9A%84%E5%B9%B6%E5%8F%91%E9%99%90%E5%88%B6"><span class="toc-number">18.5.1.3.</span> <span class="toc-text">all的并发限制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#allSettled%E6%96%B9%E6%B3%95"><span class="toc-number">18.5.2.</span> <span class="toc-text">allSettled方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#any%E6%96%B9%E6%B3%95-%E8%BF%98%E5%9C%A8%E8%8D%89%E6%A1%88%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8"><span class="toc-number">18.5.3.</span> <span class="toc-text">any方法(还在草案不能使用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#race%E6%96%B9%E6%B3%95"><span class="toc-number">18.5.4.</span> <span class="toc-text">race方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Generator"><span class="toc-number">19.</span> <span class="toc-text">Generator</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0generator"><span class="toc-number">19.1.</span> <span class="toc-text">简单实现generator</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#async-await"><span class="toc-number">20.</span> <span class="toc-text">async&#x2F;await</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">20.1.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">21.</span> <span class="toc-text">事件循环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">21.1.</span> <span class="toc-text">JS为什么是单线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">21.2.</span> <span class="toc-text">浏览器事件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#process-nextTick"><span class="toc-number">21.3.</span> <span class="toc-text">process.nextTick</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">21.4.</span> <span class="toc-text">微任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1"><span class="toc-number">21.5.</span> <span class="toc-text">宏任务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">22.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Scavenge"><span class="toc-number">22.1.</span> <span class="toc-text">Scavenge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3-gt-%E8%80%81%E7%94%9F%E4%BB%A3"><span class="toc-number">22.2.</span> <span class="toc-text">新生代&#x3D;&gt;老生代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">22.3.</span> <span class="toc-text">什么时候回收？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E7%9A%84%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">22.4.</span> <span class="toc-text">具体的回收机制？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">23.</span> <span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E7%AF%87"><span class="toc-number">24.</span> <span class="toc-text">区别篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#python%E5%92%8Cjs%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">24.1.</span> <span class="toc-text">python和js的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#let-const-var"><span class="toc-number">25.</span> <span class="toc-text">let const var</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/139818545f14/" title="手撕万物Javascript篇"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/./img/vue%E7%B3%BB%E5%88%97/%E6%89%8B%E6%92%95%E4%B8%87%E7%89%A9js%E7%AF%87.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="手撕万物Javascript篇"/></a><div class="content"><a class="title" href="/posts/139818545f14/" title="手撕万物Javascript篇">手撕万物Javascript篇</a><time datetime="2022-04-15T06:27:16.000Z" title="发表于 2022-04-15 14:27:16">2022-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/0941e8fc9dd3/" title="Vuejs灵魂之问"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/./img/vue%E7%B3%BB%E5%88%97/Vuejs%E7%81%B5%E9%AD%82%E4%B9%8B%E9%97%AE.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vuejs灵魂之问"/></a><div class="content"><a class="title" href="/posts/0941e8fc9dd3/" title="Vuejs灵魂之问">Vuejs灵魂之问</a><time datetime="2022-04-14T03:04:12.000Z" title="发表于 2022-04-14 11:04:12">2022-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/62a0bd444c41/" title="计算机网络不完全指南"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/./img/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络不完全指南"/></a><div class="content"><a class="title" href="/posts/62a0bd444c41/" title="计算机网络不完全指南">计算机网络不完全指南</a><time datetime="2022-04-14T00:20:38.000Z" title="发表于 2022-04-14 08:20:38">2022-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/18a3127ce1f3/" title="HTTP灵魂之问"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/./img/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/HTTP%E7%81%B5%E9%AD%82%E4%B9%8B%E9%97%AE.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTTP灵魂之问"/></a><div class="content"><a class="title" href="/posts/18a3127ce1f3/" title="HTTP灵魂之问">HTTP灵魂之问</a><time datetime="2022-04-10T01:42:40.000Z" title="发表于 2022-04-10 09:42:40">2022-04-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/92dd6276498c/" title="FooTok项目杂谈"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/./img/vue%E7%B3%BB%E5%88%97/footok%E9%A1%B9%E7%9B%AE%E6%9D%82%E8%B0%88.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="FooTok项目杂谈"/></a><div class="content"><a class="title" href="/posts/92dd6276498c/" title="FooTok项目杂谈">FooTok项目杂谈</a><time datetime="2022-03-24T14:33:23.000Z" title="发表于 2022-03-24 22:33:23">2022-03-24</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Zlinni</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'yPV76XNhFIiEQs8P2sM5otbm-MdYXbMMI',
      appKey: 'BEA2efs1n5lnxkb5cjYQ0xC8',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script data-pjax src="/js/collection.js"></script><script data-pjax src="/js/addele.js"></script><script data-pjax src="/js/eve.js"></script><script data-pjax src="/js/addnodestory.js"></script><script defer src="/live2d-widget/autoload.js"></script><script src="/js/pwanewdir.js"></script><script defer src="https://cdn.jsdelivr.net/gh/graingert/wow@1.3.0/dist/wow.min.js"></script><script defer data-pjax src="/js/fadeIn.js"></script><script defer data-pjax  src="/js/jljy.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/messageboard/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>